<p>正则表达式是C++11时加入标准库👉<a href="https://zh.cppreference.com/w/cpp/regex">正则表达式</a></p>
<h1>匹配规则：</h1>
<table>
<thead>
<tr>
<th>字符匹配规则</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\w</code></td>
<td>匹配任何字母字符</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任何非字母字符</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配任何数字字符</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任何非数字，</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空格</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白，</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>正则表达式量词</th>
<th>指定数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0 或更多</td>
</tr>
<tr>
<td>+</td>
<td>1 或更多</td>
</tr>
<tr>
<td>？</td>
<td>0 或 1</td>
</tr>
<tr>
<td>{n}</td>
<td>正好是n</td>
</tr>
<tr>
<td>{n, m}</td>
<td>介于n和m之间（含）</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少n</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>字符</th>
<th>指定</th>
</tr>
</thead>
<tbody>
<tr>
<td>X|Y</td>
<td>字符X或Y</td>
</tr>
<tr>
<td>\Y</td>
<td>特殊字符Y作为文字（换句话说，转义）</td>
</tr>
<tr>
<td>\n</td>
<td>新一行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>Tab</td>
</tr>
<tr>
<td>\0</td>
<td>Null</td>
</tr>
<tr>
<td>\xYY</td>
<td>YY对应的十六进制字符</td>
</tr>
</tbody>
</table>
<h1>例子</h1>
<p>反转自定义字符：例如，字符类<code>[^aeiou]</code>包括所有非元音字符。
<code>c\w{n, m}t</code>:匹配以<code>c</code>开头，以<code>t</code>结尾，中间匹配<code>n ~ m</code>数量的字母字符；
也可以改为<code>c\w*t</code>为匹配以<code>c</code>开头，以<code>t</code>结尾，中间匹配任意数量的字母字符；
例子：
<code>\w{n}</code>:匹配n个字母字符</p>
<h1>模板函数</h1>
<h2>regex_match</h2>
<p><code>regex_match</code>尝试匹配一个正则表达式到整个字符序列
匹配的函数模版有7个，浓缩下来有两个</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">regex_match</span><span class="hljs-params">(first, last, [results], regex, [flags])</span></span>;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">regex_match</span><span class="hljs-params">(str, [results], regex, [flags])</span></span>;
</code></pre>
<p>参数：
<code>first</code>, <code>last</code>: 应用 regex 到的目标字符范围，以迭代器给定
<code>results</code>: 匹配出来的结果
<code>str</code>: 目标字符串，以空终止 C 风格字符串给出
<code>s</code>: 目标字符串，以 std::basic_string 给出
<code>results</code>: 正则表达式
例子：</p>
<pre class="hljs language-cpp"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 简单正则表达式匹配</span>
    std::string fnames[] = {<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;bar.txt&quot;</span>, <span class="hljs-string">&quot;baz.dat&quot;</span>, <span class="hljs-string">&quot;zoidberg&quot;</span>};
    <span class="hljs-function">std::regex <span class="hljs-title">txt_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;
 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {
        std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">regex_match</span>(fname, txt_regex) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }   
 
    <span class="hljs-comment">// 提取子匹配</span>
    <span class="hljs-function">std::regex <span class="hljs-title">base_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;([a-z]+)\\.txt&quot;</span>)</span></span>;
    std::smatch match_results;
 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {
        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(fname, match_results, base_regex)) {
            <span class="hljs-comment">// 首个 sub_match 是整个字符串；下个</span>
            <span class="hljs-comment">// sub_match 是首个有括号表达式。</span>
            <span class="hljs-keyword">if</span> (match_results.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) {
                std::ssub_match base_sub_match = match_results[<span class="hljs-number">1</span>];
                std::string base = base_sub_match.<span class="hljs-built_in">str</span>();
                std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">&quot; has a base of &quot;</span> &lt;&lt; base &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
            }
        }
    }
 
    <span class="hljs-comment">// 提取几个子匹配</span>
    <span class="hljs-function">std::regex <span class="hljs-title">pieces_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;([a-z]+)\\.([a-z]+)&quot;</span>)</span></span>;
    std::smatch pieces_match_results;
 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {
        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(fname, pieces_match_results, pieces_regex)) {
            std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pieces_match_results.<span class="hljs-built_in">size</span>(); ++i) {
                std::ssub_match sub_match = pieces_match_results[i];
                std::string piece = sub_match.<span class="hljs-built_in">str</span>();
                std::cout &lt;&lt; <span class="hljs-string">&quot;    submatch &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; piece &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
            }   
        }   
    }   
}
</code></pre>
<p>结果：</p>
<pre class="hljs"><code>foo.txt: 1
bar.txt: 1
baz.dat: 0
zoidberg: 0
foo.txt has a base of foo
bar.txt has a base of bar
foo.txt
    submatch 0: foo.txt
    submatch 1: foo
    submatch 2: txt
bar.txt
    submatch 0: bar.txt
    submatch 1: bar
    submatch 2: txt
baz.dat
    submatch 0: baz.dat
    submatch 1: baz
    submatch 2: dat
</code></pre>
<h2>regex_search</h2>
<p>尝试匹配一个正则表达式到字符序列的任何部分
匹配的函数模版有7个，浓缩下来有两个</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">regex_search</span><span class="hljs-params">(first, last, [results], regex, [flags])</span></span>;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">regex_search</span><span class="hljs-params">(str, [results], regex, [flags])</span></span>;
</code></pre>
<p><code>first</code>, <code>last</code>: 标识目标字符序列的范围
<code>str</code>: 指向空终止字符序列的指针
<code>regex</code>: 应当应用到目标字符序列的 std::regex
<code>results</code>: 匹配结果
<code>flags</code>: 掌管搜索行为的 std::regex_constants::match_flag_type</p>
<p>例子：</p>
<pre class="hljs language-cpp"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::string lines[] = {<span class="hljs-string">&quot;Roses are #ff0000&quot;</span>,
                           <span class="hljs-string">&quot;violets are #0000ff&quot;</span>,
                           <span class="hljs-string">&quot;all of my base are belong to you&quot;</span>};
 
    <span class="hljs-function">std::regex <span class="hljs-title">color_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;#([a-f0-9]{2})&quot;</span>
                            <span class="hljs-string">&quot;([a-f0-9]{2})&quot;</span>
                            <span class="hljs-string">&quot;([a-f0-9]{2})&quot;</span>)</span></span>;
 
    <span class="hljs-comment">// 简单匹配</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;line : lines) {
        std::cout &lt;&lt; line &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; std::boolalpha
                  &lt;&lt; std::<span class="hljs-built_in">regex_search</span>(line, color_regex) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }   
    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
 
    <span class="hljs-comment">// 展示每个匹配中有标记子表达式的内容</span>
    std::smatch color_match;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; line : lines) {
        <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">regex_search</span>(line, color_match, color_regex)) {
            std::cout &lt;&lt; <span class="hljs-string">&quot;matches for &#x27;&quot;</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;
            std::cout &lt;&lt; <span class="hljs-string">&quot;Prefix: &#x27;&quot;</span> &lt;&lt; color_match.<span class="hljs-built_in">prefix</span>() &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; color_match.<span class="hljs-built_in">size</span>(); ++i) 
                std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; color_match[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
            std::cout &lt;&lt; <span class="hljs-string">&quot;Suffix: &#x27;&quot;</span> &lt;&lt; color_match.<span class="hljs-built_in">suffix</span>() &lt;&lt; <span class="hljs-string">&quot;\&#x27;\n\n&quot;</span>;
        }
    }
 
    <span class="hljs-comment">// 重复搜索（参阅 std::regex_iterator ）</span>
    <span class="hljs-function">std::string <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-string">R&quot;(
        Speed:	366
        Mass:	35
        Speed:	378
        Mass:	32
        Speed:	400
	Mass:	30)&quot;</span>)</span></span>;
    <span class="hljs-function">std::regex <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-string">R&quot;(Speed:\t\d*)&quot;</span>)</span></span>;
    std::smatch sm;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">regex_search</span>(log, sm, r)) {
        std::cout &lt;&lt; sm.<span class="hljs-built_in">str</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
        log = sm.<span class="hljs-built_in">suffix</span>();
    }
 
    <span class="hljs-comment">// C 风格字符串演示</span>
    std::cmatch cm;
    <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">regex_search</span>(<span class="hljs-string">&quot;this is a test&quot;</span>, cm, std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;test&quot;</span>))) 
        std::cout &lt;&lt; <span class="hljs-string">&quot;\nFound &quot;</span> &lt;&lt; cm[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; at position &quot;</span> &lt;&lt; cm.<span class="hljs-built_in">prefix</span>().<span class="hljs-built_in">length</span>();
}
</code></pre>
<p>结果：</p>
<pre class="hljs"><code>Roses are #ff0000: true
violets are #0000ff: true
all of my base are belong to you: false
 
matches for 'Roses are #ff0000'
Prefix: 'Roses are '
0: #ff0000
1: ff
2: 00
3: 00
Suffix: ''
 
matches for 'violets are #0000ff'
Prefix: 'violets are '
0: #0000ff
1: 00
2: 00
3: ff
Suffix: ''
 
Speed:	366
Speed:	378
Speed:	400
 
Found test at position 10
</code></pre>
<h2>regex_replace</h2>
<p>以格式化的替换文本来替换正则表达式匹配的出现位置
匹配的函数模版有6个，浓缩下来有两个</p>
<pre class="hljs language-cpp"><code><span class="hljs-comment">// 返回输出迭代器 out 在所有插入后的副本</span>
<span class="hljs-function">OutputIt <span class="hljs-title">regex_replace</span><span class="hljs-params">(out, first, last, basic_regex_re, basic_string_fmt, [flags])</span></span>; 

<span class="hljs-comment">// 返回含有输出的字符串 result </span>
<span class="hljs-function">std::basic_string&lt;CharT,STraits,SAlloc&gt;
    <span class="hljs-title">regex_replace</span><span class="hljs-params">(basic_string_s, basic_regex_re, basic_string_fmt, [flags])</span></span>;
</code></pre>
<p>参数：
<code>first</code>, <code>last</code>: 以一对迭代器表示的输入字符序列
<code>basic_string_s</code>: 以 std::basic_string 或字符数组表示的输入字符序列
<code>basic_regex_re</code>: 将与输入序列匹配的 std::basic_regex
<code>flags</code>: std::regex_constants::match_flag_type 类型的匹配标志
<code>basic_string_fmt</code>: 正则表达式替换格式字符串，准确语法依赖于 flags 的值
<code>out</code>: 存储替换结果的输出迭代器</p>
<p>例子：</p>
<pre class="hljs language-cpp"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   std::string text = <span class="hljs-string">&quot;Quick brown fox&quot;</span>;
   <span class="hljs-function">std::regex <span class="hljs-title">vowel_re</span><span class="hljs-params">(<span class="hljs-string">&quot;a|e|i|o|u&quot;</span>)</span></span>;
 
   <span class="hljs-comment">// 写结果到输出迭代器</span>
   std::<span class="hljs-built_in">regex_replace</span>(std::ostreambuf_iterator&lt;<span class="hljs-keyword">char</span>&gt;(std::cout),
                      text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), vowel_re, <span class="hljs-string">&quot;*&quot;</span>);
 
   <span class="hljs-comment">// 构造保有结果的字符串</span>
   std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; std::<span class="hljs-built_in">regex_replace</span>(text, vowel_re, <span class="hljs-string">&quot;[$&amp;]&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
</code></pre>
<p>结果：</p>
<pre class="hljs"><code>Q**ck br*wn f*x
Q[u][i]ck br[o]wn f[o]x
</code></pre>
