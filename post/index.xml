<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Blog</title>
    <link>https://okokfun.github.io/post/</link>
    <description>Recent content in Posts on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 04 Oct 2024 23:32:14 +0800</lastBuildDate><atom:link href="https://okokfun.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第二节 医学影像设备质量控制的检测参数与仪器</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE-%E5%89%AF%E6%9C%AC/</link>
      <pubDate>Fri, 04 Oct 2024 23:32:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE-%E5%89%AF%E6%9C%AC/</guid>
      <description>一、Ⅹ 线机检测参数 二、CR、DR 测定参数 三、DSA 测试参数 四、CT 检测仪器 五、MR 质控检测系统 六、US 检测仪器 七、SPECT、PET 设备检测仪器 八、γ 刀检测参数 </description>
    </item>
    
    <item>
      <title>第三节 SPECT 设备电路与故障检修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82spect%E8%AE%BE%E5%A4%87%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E6%A3%80%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 23:30:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82spect%E8%AE%BE%E5%A4%87%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E6%A3%80%E4%BF%AE/</guid>
      <description>一、工作过程 二、电路分析 三、故障分析与维修 </description>
    </item>
    
    <item>
      <title>第一节 医学影像成像质量控制</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%8A%82%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E6%88%90%E5%83%8F%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 04 Oct 2024 23:25:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%8A%82%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E6%88%90%E5%83%8F%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/</guid>
      <description>一、评价与控制 二、CR 的伪影与质控 三、DR、DSA 质控参数 四、CT 图像处理与质控 五、CT 图像质量评价 六、MR 图像质量控制 七、SPECT 设备的质量控制 </description>
    </item>
    
    <item>
      <title>第一节 核医学成像设备的保养</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%9D%E5%85%BB/</link>
      <pubDate>Fri, 04 Oct 2024 23:25:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%9D%E5%85%BB/</guid>
      <description>一、保养内容 二、保养时间表 三、使用注意事项 </description>
    </item>
    
    <item>
      <title>第二节 核医学成像设备的维修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 23:25:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E6%A0%B8%E5%8C%BB%E5%AD%A6%E6%88%90%E5%83%8F%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、设备故障 二、设备故障对影像的影响 三、故障检修 </description>
    </item>
    
    <item>
      <title>第三节 B 超设备单元电路与故障分析</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82b%E8%B6%85%E8%AE%BE%E5%A4%87%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 04 Oct 2024 23:23:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82b%E8%B6%85%E8%AE%BE%E5%A4%87%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</guid>
      <description>一、B 超设备电路 二、B 超设备故障检修 </description>
    </item>
    
    <item>
      <title>第二节 医用超声设备的维修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 23:00:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、维修方法 二、超声设备维修 三、保养与故障分析 </description>
    </item>
    
    <item>
      <title>第一节 超声设备安装和调试</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82%E8%B6%85%E5%A3%B0%E8%AE%BE%E5%A4%87%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95/</link>
      <pubDate>Fri, 04 Oct 2024 22:59:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8C%BB%E7%94%A8%E8%B6%85%E5%A3%B0%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%AA%E5%99%A8%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82%E8%B6%85%E5%A3%B0%E8%AE%BE%E5%A4%87%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95/</guid>
      <description>一、设备结构组成 二、安装与拆卸 </description>
    </item>
    
    <item>
      <title>第三节 MR 设备单元电路与故障检修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82mr%E8%AE%BE%E5%A4%87%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E6%A3%80%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:54:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82mr%E8%AE%BE%E5%A4%87%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E6%A3%80%E4%BF%AE/</guid>
      <description>一、线圈 二、梯度磁场电源 三、3.0T磁共振设备电路与故障检修 四、激光相机、PACS 系统在 MR 上的设置与调整 </description>
    </item>
    
    <item>
      <title>第二节 MR设备整机故障分析</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82-mr%E8%AE%BE%E5%A4%87%E6%95%B4%E6%9C%BA%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 04 Oct 2024 22:53:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82-mr%E8%AE%BE%E5%A4%87%E6%95%B4%E6%9C%BA%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</guid>
      <description>一、主计算机系统 二、射频子系统 三、梯度子系统 </description>
    </item>
    
    <item>
      <title>第一节 MR 图像伪影与故障</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-mr%E5%9B%BE%E5%83%8F%E4%BC%AA%E5%BD%B1%E4%B8%8E%E6%95%85%E9%9A%9C/</link>
      <pubDate>Fri, 04 Oct 2024 22:48:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E7%AB%A0-mr-%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-mr%E5%9B%BE%E5%83%8F%E4%BC%AA%E5%BD%B1%E4%B8%8E%E6%95%85%E9%9A%9C/</guid>
      <description>一、硬件 二、射频脉冲 三、外磁场与梯度磁场 </description>
    </item>
    
    <item>
      <title>第五节 CT 设备维修实例</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E8%8A%82-ct%E8%AE%BE%E5%A4%87%E7%BB%B4%E4%BF%AE%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Fri, 04 Oct 2024 22:38:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E8%8A%82-ct%E8%AE%BE%E5%A4%87%E7%BB%B4%E4%BF%AE%E5%AE%9E%E4%BE%8B/</guid>
      <description>一、ELSCINT 2000 CT 设备故障检修 二、CT 球管质量不佳现象分析与检修 三、多排螺旋 CT 设备电路故障分析与检修 四、VCT 组成与电路框图分析 </description>
    </item>
    
    <item>
      <title>第三节 CT 设备电路分析</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82ct%E8%AE%BE%E5%A4%87%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 04 Oct 2024 22:34:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82ct%E8%AE%BE%E5%A4%87%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</guid>
      <description>一、CT 设备单元电路 二、单排螺旋 CT 设备电路分析 </description>
    </item>
    
    <item>
      <title>第二节 CT 球管故障判断及原因分析</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82ct%E7%90%83%E7%AE%A1%E6%95%85%E9%9A%9C%E5%88%A4%E6%96%AD%E5%8F%8A%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 04 Oct 2024 22:33:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82ct%E7%90%83%E7%AE%A1%E6%95%85%E9%9A%9C%E5%88%A4%E6%96%AD%E5%8F%8A%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</guid>
      <description>一、灯丝断路 二、管芯真空度下降或管芯玻壳破损 三、旋转阳极不转 四、CT球管过热或油循环停止 五、管套内高压打火 六、CT球管漏油 </description>
    </item>
    
    <item>
      <title>第一节 CT 设备故障分类与检测</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E5%AD%97%E5%8C%96-x-%E7%BA%BF%E6%9C%BA%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:24:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E5%AD%97%E5%8C%96-x-%E7%BA%BF%E6%9C%BA%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、故障分类 二、性能检测 </description>
    </item>
    
    <item>
      <title>第四节 常见的故障与维修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E8%8A%82%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:24:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E7%AB%A0-ct-%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E8%8A%82%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、用软件维修 二、计算机故障检修 三、计算机外围设备故障的维修 四、阵列处理器、图像显示系统故障的维修 五、数据采集系统故障的维修 六、扫描架、床机械运动系统故障的维修 七、滑环故障的维修 八、Ⅹ 线系统故障的维修 九、散热系统故障的维修 十、相机故障的维修 十一、配电箱、操作台故障的维修 </description>
    </item>
    
    <item>
      <title>第三节 数字乳腺 X 线机安装与调试</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%95%B0%E5%AD%97%E4%B9%B3%E8%85%BAx%E7%BA%BF%E6%9C%BA%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95/</link>
      <pubDate>Fri, 04 Oct 2024 22:20:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%95%B0%E5%AD%97%E4%B9%B3%E8%85%BAx%E7%BA%BF%E6%9C%BA%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95/</guid>
      <description>一、维修方法 二、PLAMED 系列乳腺 X 线机故障维修和设备维护 </description>
    </item>
    
    <item>
      <title>第二节 医用数字胃肠 Ⅹ 线机维修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8C%BB%E7%94%A8%E6%95%B0%E5%AD%97%E8%83%83%E8%82%A0%E7%BA%BF%E6%9C%BA%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:18:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8C%BB%E7%94%A8%E6%95%B0%E5%AD%97%E8%83%83%E8%82%A0%E7%BA%BF%E6%9C%BA%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、维修方法 二、NAX 系列数字胃肠 X 线机故障维修和设备维护 三、HX150ET-A 高频发生器维修和维护 四、TH-600 数字系统维修和维护 </description>
    </item>
    
    <item>
      <title>第一节 数字化 X 线机的故障与维修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E5%AD%97%E5%8C%96-x-%E7%BA%BF%E6%9C%BA%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:09:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E5%AD%97-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E5%AD%97%E5%8C%96-x-%E7%BA%BF%E6%9C%BA%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E7%BB%B4%E4%BF%AE/</guid>
      <description>一、维修方法 二、故障产生的原因及故障特征 三、数字化 X 线机的故障分析和维修 </description>
    </item>
    
    <item>
      <title>第八节 X 线机整机故障分析</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AB%E8%8A%82-x%E7%BA%BF%E6%9C%BA%E6%95%B4%E6%9C%BA%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 04 Oct 2024 22:05:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AB%E8%8A%82-x%E7%BA%BF%E6%9C%BA%E6%95%B4%E6%9C%BA%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/</guid>
      <description>一、故障分类与检测方法 二、工频Ⅹ线机单元电路 三、工频Ⅹ线机故障综合分析与检修 四、变频X线机电路组成与故障维修 </description>
    </item>
    
    <item>
      <title>第七节 Ⅹ 线机的维护与检修</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E8%8A%82%E7%BA%BF%E6%9C%BA%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%A3%80%E4%BF%AE/</link>
      <pubDate>Fri, 04 Oct 2024 22:03:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%83%E8%8A%82%E7%BA%BF%E6%9C%BA%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%A3%80%E4%BF%AE/</guid>
      <description>一、维护 二、定期检查 三、检修 四、电路故障的判断及检查程序 </description>
    </item>
    
    <item>
      <title>第六节主要参量测试与调整</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E8%8A%82%E4%B8%BB%E8%A6%81%E5%8F%82%E9%87%8F%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E6%95%B4/</link>
      <pubDate>Fri, 04 Oct 2024 22:03:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%85%AD%E8%8A%82%E4%B8%BB%E8%A6%81%E5%8F%82%E9%87%8F%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E6%95%B4/</guid>
      <description>一、曝光时间 二、管电流 三、管电压 四、Ⅹ线电视系统 </description>
    </item>
    
    <item>
      <title>第四节Ⅹ线电视系统</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E8%8A%82%E7%BA%BF%E7%94%B5%E8%A7%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 04 Oct 2024 21:57:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E5%9B%9B%E8%8A%82%E7%BA%BF%E7%94%B5%E8%A7%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>一、检修条件与注意事项 二、检查故障的基本手段 三、判断故障的基本方法 四、X线电视系统常见故障的检查程序 五、元件的更换 </description>
    </item>
    
    <item>
      <title>第三节 单元电路原理与故障</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%85%E9%9A%9C/</link>
      <pubDate>Fri, 04 Oct 2024 21:49:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%89%E8%8A%82%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%85%E9%9A%9C/</guid>
      <description>一、透视装置与诊视床的工作原理与常见故障 二、适时摄影装置的工作原理与常见故障 三、电源电路的工作原理与常见故障 四、X线管灯丝加热电路的工作原理与常见故障 五、X线管安全保护电路的工作原理与常见故障 </description>
    </item>
    
    <item>
      <title>第二节低压部分</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E4%BD%8E%E5%8E%8B%E9%83%A8%E5%88%86/</link>
      <pubDate>Fri, 04 Oct 2024 21:37:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%8C%E8%8A%82%E4%BD%8E%E5%8E%8B%E9%83%A8%E5%88%86/</guid>
      <description>一、谐振式磁饱和稳压器的工作原理与常见故障 二、空间电荷抵偿变压器的工作原理与常见故障 三、继电器与接触器的工作原理与常见故障 四、各种开关的工作原理与常见故障 五、限时器的工作原理与常见故障 六、延时器的工作原理与常见故障 七、低压电路元件故障及检修 八、稳压器常见故障 九、电源频率变化的影响 十、继电器的常见故障及检修 十一、机械式和电动机式限时器的故障及检修 十二、电子管的故障 十三、电子管限时器的故障及检修 十四、RC电路的故障 十五、灵敏继电器和稳压电容的故障 十六、晶体管的故障 十七、故障检查举例 十八、旋转阳极启动装置的故障及检修 十九、活动滤线器的故障检修 二十、胃肠摄影装置的故障及检修 </description>
    </item>
    
    <item>
      <title>第一节高压部分</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E9%AB%98%E5%8E%8B%E9%83%A8%E5%88%86/</link>
      <pubDate>Fri, 04 Oct 2024 20:54:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E8%8A%82-%E9%AB%98%E5%8E%8B%E9%83%A8%E5%88%86/</guid>
      <description>一、高压变压器的原理与常见故障 二、灯丝变压器的原理与常见故障 三、高压整流元件的工作原理与常见故障 四、高压电缆的工作原理与常见故障 五、高压交换闸的工作原理与常见故障 六、高压电路元件故障及维修 七、高压变压器初级电路的常见故障 八、高压变压器次级及管电流测量电路工作原理与常见故故障 </description>
    </item>
    
    <item>
      <title>第五节Ⅹ线机的通电试验</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E8%8A%82%E7%BA%BF%E6%9C%BA%E7%9A%84%E9%80%9A%E7%94%B5%E8%AF%95%E9%AA%8C/</link>
      <pubDate>Fri, 04 Oct 2024 20:54:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F-x-%E7%BA%BF%E8%AE%BE%E5%A4%87%E7%BB%B4%E6%8A%A4/%E7%AC%AC%E4%BA%94%E8%8A%82%E7%BA%BF%E6%9C%BA%E7%9A%84%E9%80%9A%E7%94%B5%E8%AF%95%E9%AA%8C/</guid>
      <description>一、注意事项 二、电源电路 三、控制电路 四、高压电路 </description>
    </item>
    
    <item>
      <title>绪论 医学影像设备技术的发展</title>
      <link>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Fri, 04 Oct 2024 19:17:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E7%BB%AA%E8%AE%BA/</guid>
      <description>一、Ⅹ线机的发展 迄今,　X 线管(X-ray tube)经历了四次重大发展: ①由早期的充气管到真空管的发展,提高了 X 射线机(以下简称 X 线机)的可控性(1913年); ②从固定阳极发展到旋转阳极,　提高了 X 线管的输出功率和图像质量(1929年); ③高速旋转阳极和复合材料阳极靶面的开发应用,进一步提高了 X 线管的输出功率和连续使用能力(20世纪60年代);　④整管旋转、阳极盘直接油冷却、电子束定位方式,　使 X 线管连续使用能力提高到一个更高水平(2003年)。
X 线机的高压部分早期使用感应线圈供电, 采用裸高压线、裸 X 线管方式, 1910年发展为工频升压真空管高压整流方式。1928年制成高压电缆,X 线机发展到具备防电击、防辐射功能。到20世纪六七十年代,自动控制、程序控制技术应用到 X 线机中,大型 X 线机变得十分复杂, 但总体上仍属于电工元器件产品。1982年, 采用逆变方式的 X 线高压发生装置实用化, 逆变频率不断提高, 加之计算机技术的应用, X 线高压发生系统进入完全电子产品时代, 并进行了由繁到简、脱胎换骨的进化。
1951年, 出现了影像增强器(image intensifier, I.1),此前荧光屏式透视一直是在暗室中进行的, L.I的诞生, 使电视技术被引入 X 线领域,X 线电视系统(X-ray television, X-TV)使医生从暗室检查和辐射现场中解脱出来,使 X 线机发生了一次划时代的革命,是 X 线机发展史上的一个里程碑。1961年,隔室操作多功能检查床出现, 并于20世纪70年代后得到广泛应用, 胃肠透视检查进入遥控时代。由于 I.I 的使用, X-TV 透视已成为基本的检查手段。20世纪60—90年代, 动态器官检查的影像记录手段是心血管专用机的主要记录方式。21 世纪初,随着平板探测器(flat panel detector, FPD)广泛应用于采集动态和静态图像, X-TV 在 X 线领域的应用也将成为历史。</description>
    </item>
    
    <item>
      <title>第1章 血压计</title>
      <link>https://okokfun.github.io/post/%E5%B8%B8%E7%94%A8%E5%8C%BB%E7%96%97%E5%99%A8%E6%A2%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E4%BF%AE/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E8%A1%80%E5%8E%8B%E8%AE%A1/</link>
      <pubDate>Tue, 20 Aug 2024 13:01:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E5%B8%B8%E7%94%A8%E5%8C%BB%E7%96%97%E5%99%A8%E6%A2%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%B4%E4%BF%AE/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E8%A1%80%E5%8E%8B%E8%AE%A1/</guid>
      <description>第一节 概述 血液在血管内流动对血管壁产生的压力,称为血压。血压是人体的重要生命体征之一,　在临床上具有十分重要的意义。
血压计是测量血流压力的器械。以加压空气压迫在局部动脉上,　然后观察施加了多大的压力,　才能够制止局部动脉的波动。因此,　所加的空气压力也就代表了血液流动的压力。目前,　我们所使用的血压计在形式上和结构上类型很多:　血压计有立式的、台式的;　血压表也有将测压表做成类似石英钟大小,　成为落地式、便携式;　电子式血压计都是便携式的。按原理类型分类大体上可分为三种:　即水银柱式血压计、气压表式血压计和电了式血压计。血压计的准确度是非常重要的技术指标。因此,　血压计是国家规定的强制检定器具,　必须定期检定,　在检定血压计准确度时必须使用精密血压计进行校正.
第二节水银柱式血压计 一、水银柱式血压计的构造与原理 (一) 水银柱式血压计的构造 1. 血压计的组成与结构 水银柱式血压计是由测压计、气球、橡胶袋和盒子四个部分组成。测压计包括水银壶、玻璃管和标尺。水银壶与玻璃管连接在一起,　其连接处用软木垫或橡胶垫压紧,　以免漏气和水银外溢。玻璃管的顶端盖金属帽,　帽内装有软木垫、橡胶垫和金属网,　可以使空气自由出入,　水银却不能外溢。
2. 血压计的计量单位 以前生产的血压计,　玻璃管的刻度有 300mmHg(1mmHg=133.322Pa) 和 280mmHg 两种,　其玻璃管刻度最小值相当于 2mmHg 的压力。目前所使用的双刻度血压计,标尺上的刻度数字是两种表示方法:　一侧是以 mmHg 为单位, 最大刻度值为 300mmHg; 一侧是以 kPa 为单位, 最大刻度值为 40kPa</description>
    </item>
    
    <item>
      <title>第31章 PLC</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC31%E7%AB%A0plc/</link>
      <pubDate>Sat, 14 Oct 2023 14:04:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC31%E7%AB%A0plc/</guid>
      <description>31.0 引言 在所有用来控制制造过程的设备中，可编程逻辑控制器（ProgrammableLogic Controller，PLC）是最重要的一种。20世纪60年代初，PLC首次得到应用，主要用于汽车工业。在此之前，设备制造的自动控制是通过装在金属柜中成百上千的继电器实现的。
汽车型号每年都会改变，常常要求调整生产线及其相关的继电器控制系统。因为这些控制系统很复杂，所以需要花很长时间用于调整，接线也经常出错。出于这些原因，控制工程师开发了计算机可编程系统来代替继电器控制系统。
这对很多公司来说是一个很大的挑战。实际上，计算机在此之前已经用于统计工作，而此时用于满足工业需求。这项技术渐渐进步，其用户群也被更广泛拓展。但是，新观念被制造商系统地接受，还是花了整整 10 年时间。
现在，PLC（可编程控制器或者称为可编程逻辑控制器）成为工业中的主要控制设备。50 多家制造商提供了几百种类型的 PLC。
31.1 工业PLC的功能 31.2 控制系统的基本要素 31.3 PLC应用举例 31.4 中央处理器 31.5 编程单元 31.6 I/0模块 31.7 输入模决的结构 31.8 输出模块的结构 31.9 PLC的模决化结构 31.10 远程输入和输出 31.11 传统控制电路和PLC电路 31.12 安全规则 31.13 PLC编程 31.14 编程语言 31.15 PLC在继电器箱中的优点 工业现代化 31.16 PLC的工业应用 31.17 规划变更 31.18 了解PLC 31.19 PLC的连接 31.20 PLC的编程 31.21 透明企业 </description>
    </item>
    
    <item>
      <title>第30章 谐波</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC30%E7%AB%A0%E8%B0%90%E6%B3%A2/</link>
      <pubDate>Sat, 14 Oct 2023 14:03:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC30%E7%AB%A0%E8%B0%90%E6%B3%A2/</guid>
      <description>30.0 引言 工业中的电压和电流常常会波形畸变。关于畸变的讨论我们在第 2 章 2.12 部分已经简要提及。正如前面所述，引起畸变的原因可能是变压器磁心的磁饱和、晶闸管开关的动作，或者是其他非线性负荷。一个畸变波形可能由基波和一个或多个谐波组成。例如，将图 2-23 复制为图 30-1，图中畸变交流电流包含 5 次、7次以及一些更高次的谐波分量电流。
$$ 图30-1 频率为60Hz的畸变电流波形，有效值为 62.5A。电流包含了以下分量：基波（60Hz）：59A；5次谐波：15.6A；7次谐波：10.3A。该波形中还包含一些幅值很小的更高次谐波。 $$
30.1 谐波和相量图 30.2 畸变波形的有效值 30.3 峰值系数和总谐波畸变率THD 30.4 谐波和电路 30.5 基波功率因数和总功率因 30.6 非线性负荷 30.7 谐波的产生 30.8 功率因数校正 30.9 无功功率的产生 谐波的影响 30.10 电容中的谐波电流 30.11 导体中的谐波电流 30.12 线圈中的畸变电压和磁通量 30.13 三相四线配电系统中的谐波电流 30.14 谐波和谐振 30.15 谐波滤波器 30.16 供电网中的谐波 30.17 变压器和K因数 谐波分析 30.18 周期波形的分析步骤 </description>
    </item>
    
    <item>
      <title>第29章 基于固态控制器的输配电技术</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC29%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BA%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%BE%93%E9%85%8D%E7%94%B5%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Sat, 14 Oct 2023 14:02:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC29%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BA%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%BE%93%E9%85%8D%E7%94%B5%E6%8A%80%E6%9C%AF/</guid>
      <description>29.0 引言 随着晶闸管、GTO和其他电力电子开关器件的快速发展，电力公司在输配电过程中控制潮流的方案发生了很大的变化。
除了断路器、调压变压器、静态无功补偿器之外，输配电系统还有大量其他无源器件。另一方面，输配电线路多样性使预测潮流的方向和大小变得更加困难。此外，这些输电系统的复杂性要求留有更多的安全裕量，从而避免设备故障、开关冲击、负荷突然断开等引起系统不稳定问题。
电力公司面临的特殊问题是，电力输送的需求持续增长，而输配电线路架设权却越来越难取得。由于上述问题再加上其他一些原因，电力公司正寻找在不降低可靠性和稳定性的基础上，增加现有线路的输送能力的方法，使线路达到热稳极限并满载送电。
系统不稳定出现得很快，几秒内就可能扩散到整个系统，这是个重要问题。所以，断路器必须及时切断会加剧系统失稳的设备和负荷。
由于现代输电线路可以即刻对任何事故做出反应，并处理潜在危险事态，因此可以认为输电系统是 “主动的”。输电线的快速动作可能要归功于晶闸管和GTO，这些电力电子器件目前可以处理几千安培的电流和几千伏的电压。事实上，第28章中已经谈到，它们已经用于几十万伏的高压直流输电系统。这些开关器件已经应用于串联电容、无功补偿器、谐波滤波器以及超快速开关等设备。
本章将介绍一些最近发展起来、在该领域经过测试的重要固态控制器。首先介绍输电系统的潮流控制器，它属于FACTS（柔性交流输电系统），随后将介绍用于配电的电力电子控制器。加州帕罗奥图的电力研究院（EPRI）与几个合作的设备制造商、电力公司在 FACTS 项目方面业界领先。
输电系统潮流控制器 在输电部分，本书将介绍以下器件：
a. 晶闸管控制的串联电容器（TCSC）
b. 静止同步补偿器（STATCOM）
c. 统一潮流控制器（UPFC）
d. 静态变频器
29.1 TCSC 29.2 游标调节 29.3 静止同步补偿器 29.4 消除谐波 29.5 UPFC 29.6 静态变频器 配电方案定制 29.7 配电系统中的扰动 29.8 为什么采用PWM变换器 29.9 配电系统 29.10 补偿器和电路分析 29.11 并联补偿器：工作原理 29.12 串联补偿器：工作原理 29.13 小结 </description>
    </item>
    
    <item>
      <title>第27章 电力成本</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC27%E7%AB%A0%E7%94%B5%E5%8A%9B%E6%88%90%E6%9C%AC/</link>
      <pubDate>Sat, 14 Oct 2023 13:58:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC27%E7%AB%A0%E7%94%B5%E5%8A%9B%E6%88%90%E6%9C%AC/</guid>
      <description>27.0 引言 1999年，美国的电力企业向工业、商业和居民提供了大约 3130TW·h 的电能（见表27-1）。这意味着电力企业在一天 24 小时内，不间断地向每个男性、女性和儿童提供 1.1kW 的电能服务。电能的生产、传输和分配都涉及巨大的成本，这些成本主要被分为两类—固定成本和运行成本。
用户类型 用户数量 总耗电量 [TW • h] 每月每个用户耗电量 [TW • h] 工业 527 000 1018 161 000 商业 13 964 000 971 5792 民用 109 817 000 1141 866 注：*1999年的统计数据由美国能源信息管理局提供的信息整理而来。预计能源消耗量年增长率为 2%。这样，2005 年的总能源消耗量将达到 3525TW·h。 固定成本 包括针对建筑、大坝、涡轮、发电机、断路器、变压器、输电线路和其他在电力生产、传输和分配中使用的设备的折旧费用。这些投资代表着数千亿美元的巨额成本。
运行成本 包括人员工资、燃料成本、管理和其他日或周费用。
考虑到以上两种成本的相对重要性，电力公司制定了对用户公平的电费体系。电费基于以下准则：电能消费数量 [TW • h]、电能消费的需求 [TW]、负荷的功率因数。
27.1 基于能量的费用 27.2 基于需求的费用 27.3 需求计量 27.4 基于功率因数的电费 27.5 典型电费结构 27.6 需求控制器 27.7 功率因数修正 27.8 测量电能的电能表 27.9 电能表原理 27.10 电能表读数 27.</description>
    </item>
    
    <item>
      <title>第28章 直流输电</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC28%E7%AB%A0%E7%9B%B4%E6%B5%81%E8%BE%93%E7%94%B5/</link>
      <pubDate>Sat, 14 Oct 2023 13:58:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC28%E7%AB%A0%E7%9B%B4%E6%B5%81%E8%BE%93%E7%94%B5/</guid>
      <description>28.0 引言 大功率、高电压电力电子换流器的发展使利用直流进行传输和控制大功率成为可能。直流输电提供了一些独特性质，可与目前交流电网互为补充。本章将讲述北美及世界各地使用的各种直流输电方式。在学习本章之前，读者首先应回顾一下第 21 章中所涉及的电力电子的原理。
28.1 直流输电的特点 28.2 基本的直流输电系统 28.3 电压、电流和功率的关系 28.4 直流线路中的功率波动 28.5 整流和逆变的特点 28.6 功率控制 28.7 电压波动的影响 28.8 双极型输电线路 28.9 潮流反转 28.10 直流输电线路的组成 28.11 电感器与直流侧谐波滤波器（6脉冲换流器） 28.12 换流变压器 28.13 无功电源 28.14 交流侧谐波滤波器 28.15 通信线路 28.16 地线 28.17 单极换流站举例 28.18 晶闸管换流站 28.19 典型装置 轻型直流输电系统 28.20 远距离输电 28.21 静态发电机的构成 28.22 轻型高压直流输电系统概述 28.23 有功功率的控制 28.24 轻型直流输电系统案例 </description>
    </item>
    
    <item>
      <title>第26章 电能分配</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC26%E7%AB%A0%E7%94%B5%E8%83%BD%E5%88%86%E9%85%8D/</link>
      <pubDate>Sat, 14 Oct 2023 13:55:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC26%E7%AB%A0%E7%94%B5%E8%83%BD%E5%88%86%E9%85%8D/</guid>
      <description>26.0 引言 第 25 章中，我们提到一个由高压输电线路组成的电力系统，这些线路将电能输送到一个带变电站的中压（MV级）网络中。在北美，这种中压网络的运行电压通常是 2.4kV 到 69kV。然后，通过这些中压网络向数百万个独立的 120V 至 600V 的低压系统供电。
本章包含以下内容:
变电站、中压配电系统保护、低压配电系统和建筑电气。
变电站 26.1 变电站电力设备 26.2 断路器 26.3 空气开关 26.4 隔离开关 26.5 接地开关 26.6 避雷器 26.7 限流电抗器 26.8 接地变压器 26.9 变电站实例 26.10 中压配电 26.11 低压配电 中压配电系统保护 26.12 保护设备之间的配合 26.13 熔丝断流器 26.14 自动重合开关 26.15 分段隔离开关 低压配电 26.17 低压配电系统 26.18 接地电气安装 26.19 触电 26.20 120V和240V/120V系统的接地 26.21 设备接地 26.22 接地故障断路器 26.23 快速的导体温升: $1^2t$ 因数 26.24 熔丝的作用 26.25 建筑物内的电气安装 26.26 电气安装的主要元件 </description>
    </item>
    
    <item>
      <title>第24章 发电</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC24%E7%AB%A0%E5%8F%91%E7%94%B5/</link>
      <pubDate>Sat, 14 Oct 2023 13:53:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC24%E7%AB%A0%E5%8F%91%E7%94%B5/</guid>
      <description>24.0 引言 前面介绍了电机、变压器和其他一些主要的电力元件，下面看看它们在大型电力系统的应用。电力系统包括发电、输电、配电各环节，开始于电厂，结束于最偏远的乡间夏度假别墅。因此，本章和下面三章内容分别为: 发电、输电、配电和电能成本。
24.1 电力系统的需求 24.2 电厂的选址 24.3 发电厂类型 24.4 有功功率平衡控制 24.5 互联电网的优点 24.6 停电情况 24.7 频率和电子钟 水电厂 24.8 可用的水能 24.9 水电厂类型 24.10 水电站的构成 24.11 抽水蓄能电厂 24.12 火电厂的组成 24.13 汽轮机 24.14 凝汽器 24.15 冷却塔 24.16 给水泵 24.17 汽轮机组的能量流程图 24.18 火电厂和环境 核电厂 24.19 原子核的构成及同位素 24.20 铀的来源 24.21 原子裂变释放的能量 24.22 链式反应 24.23 核反应堆的类型 24.24 轻水反应堆的实例 24.25 重水反应堆的实例 24.26 快中子增殖反应堆的原理 24.27 核聚变 风力发电厂 24.28 风的特性 24.29 风能的利用 24.30 驱动直流发电机的风机 24.31 驱动恒速异步发电机的风机 24.32 驱动变速异步发电机的风机 24.</description>
    </item>
    
    <item>
      <title>第25章 输电</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC25%E7%AB%A0%E8%BE%93%E7%94%B5/</link>
      <pubDate>Sat, 14 Oct 2023 13:53:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC25%E7%AB%A0%E8%BE%93%E7%94%B5/</guid>
      <description>25.0 引言 输电不像发电和用电那样受人关注，因此人们有时会忽视它的存在。但是输电中消耗的人力、物力远大于发电中的损耗。
电能通过架空线或者地下电缆传输。尽管导线很普通，它们的电特性却极大地影响着电能的传输。本章将研究几种类型的输电线: 高压、低压、大功率、小功率、架空线、地下电缆，然后介绍一些电力系统中电压、功率的控制方法。
25.1 配电系统中的主要元件 25.2 输电线类型 25.3 电压标准 25.4 高压输电线路的组成部分 25.5 导线构造 25.6 线路的舞动 25.7 电晕无线电干扰 25.8 污秽 25.9 雷击 25.10 建筑物上的避雷器 25.11 闪电和输电线路 25.12 基准冲击电压绝绿水平（BIL） 25.13 地线 25.14 塔基 25.15 输电线路的基本任务 25.16 等值电路 25.17 典型阻抗值 25.18 简化的等效电路 25.19 输电线路的电压偏移和输电容量 25.20 阻性线路 25.21 感性线路 25.22 带补偿的感性线路 25.23 连接两系统的电感线路 25.24 功率传输小结 25.25 线路电压的选择 25.26 增加电能传输容量的方法 25.27 超高压线路 25.28 电力中心之间的功率交换 25.29 电能交换实例 </description>
    </item>
    
    <item>
      <title>第23章 交流电机的电子控制</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC23%E7%AB%A0%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 14 Oct 2023 13:44:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC23%E7%AB%A0%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/</guid>
      <description>23.0 引言 第22章介绍了能使直流电机高效率运行的电力电子控制系统。4象限控制可以满足精确的高速传动系统的要求。电力电子控制同样适用于交流电机。这样，可使用电力电子装置控制笼型、绕线型感应电机和同步电机。通过改变电压和电流来控制直流电机，而通过改变电压和供电频率来控制交流电机。直流电机有很好的控制性能，但为什么还要使用交流电机？以下是此问题的答案：
交流电机没有换向器和电刷；因此，不需要经常维护。 交流电机比直流电机价格便宜（重量也轻一点）。 在恶劣的环境条件下，交流电机更加耐用，运行得更良好。 交流电机可以在很高的电压下工作，高达 25kV。直流电机只能工作在 1000V 以下。 交流电机的容量可以大得多，可以高达 500 00kW。直流电机则低于 2000kW。 交流电机能够运行在 100 000r/min 的转速下工作，但是大容量直流电机转速一般低于 2000r/min。 本章主要讨论三相电动机及其控制系统。读者首先应复习 21 章、22 章中关于电力驱动的基本原理。此外，为了理解交流电机控制的基本原理，读者应该复习 20.18 和 20.20，这两部分闸述了改变供电电压频率对笼型感应电机运行特性的影响。
23.1 交流驱动装置的类型 23.2 电流源型逆变器供电的同步电机驱动系统 23.3 同步电动机和交交变频器 23.4 交交变频器的电压、频率控制 23.5 交交变频器供电的笼型感应电动机 23.6 笼型异步电动机和调压调速 23.7 笼型异步电动机的软起动 自换流逆变器 23.8 用于笼型电动机的自换流变频器 23.9 电流源型自换流式变频器（方波） 23.10 电压源型自换流式变频器（方波） 23.11 绕线式感应电动机的斩波控制 23.12 绕线式感应电动机转子能量反馈调速 脉宽调制型调速系统 23.13 脉宽调制基本概念 23.14 脉宽调制方式和感应电动机 感应电动机的转矩速度控制 23.15 直流电动机和磁通方向 23.16 转差、磁通方向和转矩 23.17 变速控制（恒转矩模式）特性 23.18 变速控制（恒功率模式）特性 23.19 变速控制（发电机模式）特性 23.20 感应电动机及其等效电路 23.21 实际电动机的等效电路 23.</description>
    </item>
    
    <item>
      <title>第22章 直流电动机的电子控制</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC22%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 14 Oct 2023 13:43:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC22%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/</guid>
      <description>22.0 引言 高速、可靠、价格便宜的功率半导体器件为直流电动机的控制带来了巨大的变化。这一章将研究这类电力电子技术的基本原理。在21章中，已经介绍了整流器和逆变器电路。读者在进一步深入学习本章内容之前，可以先复习21章内容，及　20.16　节和　20.17　节关于电力电子驱动部分的内容。
在讨论各类控制方法的时候，我们只研究功率主电路的运行状态。因此，产生和控制触发脉冲的方法并不涉及。触发电路由复杂电子技术、逻辑电路、集成电路和微处理器等组成。不讨论触发电路，并不会影响到本章重点介绍直流电机调速系统的基本原理。
22.1 一象限速度控制 22.2 二象限控制――励磁反向 22.3 二象限控制――电枢反向 22.4 二象限控制――双变流器 22.5 四象限控制――有环流双变流器系统 22.6 正转矩二象限控制 22.7 四象限驱动 22.8 带续流二极管六脉波变流器 22.9 半桥变流器 22.10 直流拖动 22.11 直流电动机斩波调速 22.12 无刷直流电动机基础 22.13 无换向器电动机 22.14 类似无刷直流电机的同步电动机 22.15 标准同步电动机和无刷直流电动机 22.16 无刷直流电动机的实际应用 </description>
    </item>
    
    <item>
      <title>第21章 电力电子技术基础</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC21%E7%AB%A0%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 Oct 2023 13:41:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC21%E7%AB%A0%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</guid>
      <description>21.0 引言 电子系统及其控制已经在电力技术领域得到广泛应用，因此，学习掌握电力电子技术知识变得十分必要。虽然无法在本章节中涵盖这一学科的全部内容，但是将就大多数电力电子电路的基本运行原理进行简要介绍，其中包括一些日前正受到普遍运用的电路。
只要一提到电力电子器件，首先会想起二极管和晶闸管。它们广泛运用于交直流变换的电力电子系统中。接着会讨论更多现代电力电子器件的应用，如门极关断（GTO）晶闸管、双极结型晶体管（BJT）、金属-氧化物-半导体场效应晶体管（power MOSFET）和绝缘栅双极晶体管（IGBT）。它们在电路中的作用与晶闸管基本上没有区别。在电力电子电路中，这些器件基本上都工作在高速开关状态，大多数电力电子系统能通过电路的开通、关断来进行解释分析。电力电子电路并不简单，但是即使半导体背景知识并不深入的人也能理解其基本特性。
21.1 电位 21.2 基本电气元件的端电压 二极管和二极管电路 21.3 二极管 21.4 二极管的主要参数 21.5 电阻串联型电池充电器 21.6 电感串联型电池充电器 21.7 单相桥式整流电路 21.8 滤波 21.9 三相三脉波二极管整流电路 21.10 三相六脉波整流电路（三相桥式整流电路） 21.11 有效线电流、基波线电流 21.12 畸变系数 21.13 位移因数、总功率因数 21.14 谐波分量与THD 晶闸管和晶闸管电路 21.15 晶闸管 21.16 门极触发原理 21.17 晶闸管的功率增益 21.18 电流中断与强迫换流 21.19 基本晶闸管功率电路 21.20 带无源负载的可控整流电路（电路1） 21.21 带有源负载的可控整流电路（电路2） 21.22 电网换流逆变器（电路3） 21.23 交流静态开关（电路4） 21.24 周波变换器（电路5） 21.25 三相六脉波可控变流器（电路6） 21.26 基本工作原理 21.27 三相六脉波整流器带有源负载 21.28 延迟触发一整流模式 21.29 延迟触发一逆变模式 21.30 触发范围 21.31 变流器等效电路 21.32 三相六脉波变流器中的电流 21.</description>
    </item>
    
    <item>
      <title>第20章 电动机控制基础</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC20%E7%AB%A0%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 Oct 2023 13:40:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC20%E7%AB%A0%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80/</guid>
      <description>20.0 引言 从最广义来说，工业控制包括使用各种方法来控制一个电气系统的运行。应用到机器上，它包括带负载电动机的起动、加速、反转、减速和制动。在本章中我们将学习三相异步电动机的电气控制（而非电子控制）。我们的研究将限制于基本电路，因为实际的工业电路往往太复杂，难以很简洁的加以闸述。然而，这里展示的基本原则能适用于任何系统的控制，无论它看上去有多么复杂。
20.1 控制硬件 20.2 常开和常闭触点 20.3 继电器线圈励电流 20.4 控制图 20.5 起动方法 20.6 手动直接起动器 20.7 起动器 20.8 点动 20.9 反转 20.10 反接制动 20.11 降压起动 20.12 串电阻起动 20.13 自耦变压器起动 20.14 其他起动方式 20.15 主令控制器 20.16 计算机和控制 电气驱动 20.17 电气驱动基础 20.18 典型的转矩速度曲线 20.19 转矩速度曲线的形状 20.20 电流转速曲线 20.21 再生制动 </description>
    </item>
    
    <item>
      <title>第19章 步进电动机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC19%E7%AB%A0%E6%AD%A5%E8%BF%9B%E7%94%B5%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 13:35:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC19%E7%AB%A0%E6%AD%A5%E8%BF%9B%E7%94%B5%E5%8A%A8%E6%9C%BA/</guid>
      <description>19.0 引言 步进电动机是一种特殊的电动机，它通常用于运动和位置都必须准确控制的场合。顾名思义，步进电动机是分步转动的，每一步都对应于提供给其中一个定子绕组的脉冲。根据设计，步进电动机每个脉冲可以前进 90°，45°，18°，或者几分之一度。由于脉冲频率的不同，电动机可以一次一步，很缓慢地前进，也可以以高达 000r/min 的转速逐步转动。
根据定子各绕组接受脉冲的顺序，步进电动机可以顺时针或者逆时针转动。
步进电动机的运动很大程度取决于带动它的驱动电源。电源提供一系列由微处理器依次发出的脉冲。脉冲序列按照顺时针脉冲为（十），逆时针脉冲为（一）方式，进行统计并存储数据。这样，净步数就能时刻确认。因此，我们能准确地得到电动机的旋转数，且精确到一步的大小。这使得步进电动机可以作为一种准确的定位装置应用于机床、X-Y绘图仪、打字机、录音机、电子阀和打印机中。
这一章将讨论较常见的步进电动机的工作原理、它们的特性和局限性，以及有哪些驱动方式。
19.1 基本步进电动机 19.2 惯性的作用 19.3 机械负载的作用 19.4 转矩电流曲线 19.5 起停步频 19.6 转速 19.7 缓冲 19.8 步进电动机的类型 19.9 电动机绕组与驱动方式 19.10 高速运转 19.11 改进时间常数 19.12 双电平驱动 19.13 不稳定和共振 19.14 步进电动机和直线驱动 </description>
    </item>
    
    <item>
      <title>第18章 单相电动机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC18%E7%AB%A0%E5%8D%95%E7%9B%B8%E7%94%B5%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 13:31:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC18%E7%AB%A0%E5%8D%95%E7%9B%B8%E7%94%B5%E5%8A%A8%E6%9C%BA/</guid>
      <description>18.0 引言 单相电动机可在无三相电源的条件下使用，常用于家电产品和电动工具。
市场上有许多种单相电动机，用来满足特定的应用。下面研究单相电动机的几个基类型，特别侧重于广泛使用的分相感应电机
18.1 单相感应电动机的结构 18.2 同步转速 18.3 转矩转速特性 18.4 工作原理 18.5 堵转转矩 18.6 电阻分相式电动机 18.7 电容起动式电动机 18.8 单相感应电动机的效率和功率因数 18.9 单相电动机的振动 18.10 电容运转式电动机 18.11 反转 18.12 罩极电动机 18.13 通用电动机 18.14 磁滞电动机 18.15 同步磁阻电动机 18.16 同步传动 单相电动机的等效电路 18.17 磁动势分布 18.18 单相电动机的旋转磁动势 18.19 单相电动机电路图推导 </description>
    </item>
    
    <item>
      <title>第17章 同步电动机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC17%E7%AB%A0%E5%90%8C%E6%AD%A5%E7%94%B5%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 13:29:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC17%E7%AB%A0%E5%90%8C%E6%AD%A5%E7%94%B5%E5%8A%A8%E6%9C%BA/</guid>
      <description>17.0 引言 上一章介绍的同步发电机除了作发电机运行，还可以作电动机运行。当作电动机运行时（将其连接到三相电源上），就称为同步电动机。顾名思义，同步电动机的转子旋转与它的旋转磁场是同步的，它的转速与电源的频率有关，而与负载和电源电压无关。一般说来电源的频率是固定的，因此同步电机动的转速可以保持恒定不变。但是，同步电动机在实际生活中得到应用，不仅仅因为它转速恒定，更多的是因为它有一些独特的电气性能。在本章我们将学习它的这些性能。
绝大多数同步电动机功率在 150kW～15MW 之间，转速在 150～1800r/min 之间，一般主要应用在重工业中（如图17-1所示）。单相同步电动机是小容量同步电动机的一种，它常用在控制设备和电钟中，这些将在第18章中讨论。
17.1 结构 17.2 同步电动机的起动 17.3 迁入转矩 17.4 同步电动机负载运行 17.5 同步电动机负载运行时的计算 17.6 功率与转矩 17.7 机械角度与电角度 17.8 磁阻转矩 17.9 同步电动机的损耗和效率 17.10 励磁与无功功率 17.11 额定功率因数 17.12 V形曲线 17.13 同步电动机的制动 17.14 同步电动机与感应电动机 17.15 同步调相器 </description>
    </item>
    
    <item>
      <title>第16章 同步发电机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC16%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%8F%91%E7%94%B5%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 13:11:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC16%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%8F%91%E7%94%B5%E6%9C%BA/</guid>
      <description>16.0 引言 目前消耗的电能主要是由三相同步发电机发出的，这些发电机是世界上最大的能源转换装置，他们将机械能转换为电能，其单机容量高达 1500MW。本章将学习这些大型现代发电机的结构和特性。这些分析均是基于 8.6 节的相关基本原理，希望读者在学习本章内容前先对相关材料进行复习。
16.1 商用同步发电机 16.2 极数 16.3 定子的主要特性 16.4 转子的主要特性 16.5 励磁与励磁装置 16.6 无刷励磁 16.7 影响同步发电机大小的因素 16.8 空载磁化曲线 16.9 同步电抗――交流发电机等效电路 16.10 Xs的测量 16.11 阻抗基值与Xs标么值 16.12 短路比 16.13 带载运行时的同步发电机 16.14 调节曲线 16.15 发电机的同步 16.16 无穷大母线上的同步发电机 16.17 无限大母线――励电流变化的影响 16.18 无限大母线——机械转变化的影响 16.19 交流发电机性的物理解释 16.20 发电机输出的有功功率 16.21 有功功率的控制 16.22 瞬时电抗 16.23 两电源间的功率传递 16.24 效率、功率与电机的大小 </description>
    </item>
    
    <item>
      <title>第15章 感应电动机的等效电路</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC15%E7%AB%A0%E6%84%9F%E5%BA%94%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Sat, 14 Oct 2023 13:09:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC15%E7%AB%A0%E6%84%9F%E5%BA%94%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF/</guid>
      <description>15.0 引言 前三章已经介绍了不通过电路图来描述笼型感应电动机和绕线式感应电动机的重要特性。如果要更好地理解电动机，等效电路图还是非常必要的。在这一章里，从基本的原则中推导出等效电路来。然后分析这些小功率和大功率电动机的性质，同时观察它们的一些基本的区别。最后，得出一台异步发电机的等效电路并分析其负载特性。
15.1 绕线式转子感应电动机 15.2 能量关系 15.3 感应电动机的相量图 15.4 最大转矩和速度 15.5 两种实用型电动机的等效电路 15.6 最大转矩的计算 15.7 转速度曲线与其他特性 15.8 异步发电机的性质 15.9 等效电参效的买验测定 </description>
    </item>
    
    <item>
      <title>第14章 三相感应电机的选择和应用</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC14%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sat, 14 Oct 2023 13:05:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC14%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E5%BA%94%E7%94%A8/</guid>
      <description>14.0 引言 三相感应电机可以作为电动机或者发电机运行。
当为一种特定的应用而购买一台三相感应电机时，经常会发现好几种型号都可以满足这个需求。因此，我们必须做出选择，这种选择通常可以简化。因为车床、风扇、泵等设备的制造厂商了解哪种电机最适合驱动负载。然而，了解一些不同种类的市场上用到的电机的基本结构和特性是有用的。
这一章将会介绍一些具体的感应电机应用，例如，异步发电机和变频器等。通过这些设备可以使读者更好的从整体上了解感应式电机。
14.1 感应电动机的标准和分类 14.2 基于环境和冷却方法的分类 14.3 基于电气和机械特性的分类 14.4 电动机转速的选择 14.5 双速电动机 14.6 不同负载下的感应电动机特性 14.7 感应电动机的起动 14.8 感应电动机的反接制动 14.9 能耗制动 14.10 异常情况 14.11 机械过载 14.12 线电压改变 14.13 单相 14.14 频率变化 14.15 感应电动机作为发电机使用 14.16 感应电机的完整转矩速度特性 14.17 绕线式转子感应电动机性 14.18 高惯性负载的起动 14.19 变速驱动 14.20 频率变换器 </description>
    </item>
    
    <item>
      <title>第13章 三相感应电机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC13%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 12:46:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC13%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA/</guid>
      <description>13.0 引言 三相感应电机包含电动机和发电机。
三相感应电动机是应用最为广泛的电动机。它们很简单，可靠，价廉，很容易维护。可以在空载到满载间以恒定速度运行。电动机的速度是随频率而变化的，因此，对这些电动机进行速度控制是困难的。目前变频器被越来越多地应用于感应电动机的速度控制。
在这一章中，将介绍三相感应电动机的基本原理，以及描述它运行的一些基本的方程，然后讨论它的结构以及绕组。
笼型，绕线式，直线感应电动机，从几马力到数千马力，这些电机的基本原理都是一样的。
这一章中还研究三相电动机用作三相感应发电机。
13.1 主要结构 13.2 运行原理 13.3 旋场磁场 13.4 旋转方向 13.5 极数——同步转速 13.6 笼型电动机的起动特性 13.7 转子的升速——转差 13.8 电动机负运行 13.9 转差和转差率 13.10 转子中感应电势和频率 13.11 笼型感应电动机的特性 13.12 感应电动机电流的估算 13.13 有功功率流 13.14 转矩速度曲线 13.15 转子电阻效应 13.16 绕线式转子异步电动机 13.17 三相绕组 13.18 扇形电动机 13.19 直线感应电动机 13.20 行波 13.21 直线感应电动机的特性 13.22 磁悬浮 双馈感应电机 13.23 双馈绕线式电动机（调速） 13.24 双馈绕线式转子电动机（亚同步状态时的功率关系） 13.25 双馈绕线式转子电动机（超同步状态时的功率关系） 13.26 双馈绕线式转子发电机 </description>
    </item>
    
    <item>
      <title>第11章 特殊变压器</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC11%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%8F%98%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Sat, 14 Oct 2023 12:42:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC11%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%8F%98%E5%8E%8B%E5%99%A8/</guid>
      <description>11.0 引言 为了满足一些特殊的工业应用需要，许多变压器必须专门设计。本章将研究这些专用变压器，它们分别应用于配电系统、霓虹灯、实验室、感应炉以及高频电器中。虽然这些变压器各有特点，但都具有第10章所讨论的标准变压器的基本特性。因此，当变压器运行时，以下的近似处理依然成立：
绕组上的感应电势正比于数、频率和磁通。 一次侧的安匝数等于二次侧的安匝数。 输入视在功率等于输出视在功率。 忽略一次侧的励磁电流。 11.1 双电压配电变压器 11.2 自耦变压器 11.3 普通变压器连接成为自耦变压器 11.4 电压互感器 11.5 电流互感器 11.6 电流互感器的二次侧不能开路 11.7 环形电流互感器 11.8 自耦变压器 11.9 高阻抗变压器 11.10 感应加热 11.11 高频变压器 </description>
    </item>
    
    <item>
      <title>第10章 实际变压器</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC10%E7%AB%A0%E5%AE%9E%E9%99%85%E5%8F%98%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Sat, 14 Oct 2023 12:39:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC10%E7%AB%A0%E5%AE%9E%E9%99%85%E5%8F%98%E5%8E%8B%E5%99%A8/</guid>
      <description>10.0 引言 在上一章，我们学习了理想变压器，了解了它的一些基本特性。现实中使用的变压器是非理想的，因此，原来的简单的分析方法必须加以改进。实际变压器的线圈是有电阻的，而且铁心的导磁性也不是无限的。此外，由一次绕组产生的磁通也不是完全交链二次绕组的，故必须要考虑漏磁的影响。最后，应考虑到铁心产生的涡流损耗和磁带损耗将引起变压器的温升。
实际变压器也可以像理想变压器、电阻、阻抗一样，用一个等效电路来描述。这个等效电路由一些基础概念发展而来。这使得我们可以分析计算类似于电压调节率、并联变压器运行规律等特性。变压器应用模型的分析可以用标么值方法。
10.1 具有非理想铁心的理想变压器 10.2 不完全耦合的理想变压器 10.3 一次侧与二次侧的漏电抗 10.4 实际变压器的等效电路 10.5 电力变压器的结构 10.6 标准端部标志 10.7 极性测试 10.8 变压器油头 10.9 变压器额定功率与损耗 10.10 空载磁化曲线 10.11 冷却方法 10.12 等效电路的简化 10.13 电压调整率 10.14 变压器阻抗的测量 10.15 标么值 10.16 变压器阻抗 10.17 典型阻抗标么值 10.18 变压器并联 </description>
    </item>
    
    <item>
      <title>第12章 三相变压器</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC12%E7%AB%A0%E4%B8%89%E7%9B%B8%E5%8F%98%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Sat, 14 Oct 2023 12:39:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC12%E7%AB%A0%E4%B8%89%E7%9B%B8%E5%8F%98%E5%8E%8B%E5%99%A8/</guid>
      <description>12.0 引言 北美的电力分配是通过三相传输线来实现的。为了实现高效和经济的传输，电压必须采用一定的高压，而电压的数值则取决于传输的电量和距离。另一个影响因素则是家用和工业用电的区别。这些都有统一的标准，有 120V/240V 单相系统，以及 600V 三相系统。显然，这就需要三相变压器来实现电压的转换。
三相变压器有两种类型，一种是具有三个一次侧和三个二次侧，分别绕在三个铁心上的。另一种是将三个单相变压器连接起来形成一个三相变压器。
12.1 三相组式变压器的基本性质 12.2 △/△联结 12.3 △/Y联结 12.4 Y/△联结 12.5 Y/Y联结 12.6 开路△联结 12.7 三相变压器 12.8 升压变压器和降压变压器 12.9 相移原理 12.10 三相变两相变压器 12.11 相移变压器 12.12 三相变压器的计算 12.13 三相变压器的极性标记 </description>
    </item>
    
    <item>
      <title>第9章　理想变压器</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC9%E7%AB%A0%E7%90%86%E6%83%B3%E5%8F%98%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Sat, 14 Oct 2023 12:36:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC9%E7%AB%A0%E7%90%86%E6%83%B3%E5%8F%98%E5%8E%8B%E5%99%A8/</guid>
      <description>9.0 引言 变压器可能是今为止用途最广泛的电气设备之一。它可以提高或者降低交流电路中的电压和电流，可以使两个电路相互隔离，并且可以增加或减少电容、电感、电阻的视在值。除此之外，使用变压器可以实现电能的远距离输送，满足工业和生活上的安全用电。
在本章将研究变压器的一些基本特性，这将有助于理解下一章所讲的商用变压器，同时有助于我们理解感应电动机、交流发电机以及同步电动机等的基本运行原理。所有这些器件都是基于电磁场感应规律，因此希望读者能够特别留意本章的内容。
9.1 线圈中的感应电势 9.2 外施电压与感应电势 9.3 基本变压器 9.4 变压器的极性 9.5 同名端的特性 9.6 空载时的理想变压器: 电压比 9.7 带负载的理想变压器: 电流比 9.8 理想变压器的电路模型 9.9 阻抗比 9.10 阻抗变换 </description>
    </item>
    
    <item>
      <title>第7章 有功功率、无功功率和视在功率</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC7%E7%AB%A0%E6%9C%89%E5%8A%9F%E5%8A%9F%E7%8E%87%E6%97%A0%E5%8A%9F%E5%8A%9F%E7%8E%87%E5%92%8C%E8%A7%86%E5%9C%A8%E5%8A%9F%E7%8E%87/</link>
      <pubDate>Sat, 14 Oct 2023 12:29:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC7%E7%AB%A0%E6%9C%89%E5%8A%9F%E5%8A%9F%E7%8E%87%E6%97%A0%E5%8A%9F%E5%8A%9F%E7%8E%87%E5%92%8C%E8%A7%86%E5%9C%A8%E5%8A%9F%E7%8E%87/</guid>
      <description>7.0 引言 有功功率、无功功率和视在功率的概念在电力技术中非常重要。事实上，用功率去理解电能的传输和交流电机的特性比用电压和电流简单得多。因此读者应重点关注这一章。
有功功率、无功功率和视在功率的概念应用于电压、电流呈正弦变化的稳态交流电路中，但不能应用于瞬态电路或直流电路中。
本章先分析交流电路的瞬时功率，然后再对有功功率、无功功率进行定义并区分负载和电源，接着定义视在功率、功率因数、功率三角形，随后利用这些概念来求解交流电路，最后在交流电路中用矢量符号来表示有功功率、无功功率。
7.1 瞬时功率 7.2 有功功率 7.3 无功功率 7.4 无功负载和无功电源的定义 7.5 电容和无功功率 7.6 有功功率和无功功率的区别 7.7 视在功率 7.8 P、Q和S之间的关系 7.9 功率因数 7.10 功率三角形 7.11 电源和负的其他概念 7.12 包含多种负载的系统 7.14 使用功率三角形方法解决交流电路的问题 7.15 功率和矢量标记 7.16 电源和负载的规则 (符号标记) 7.17 源和负载的规则 (双下标标记) </description>
    </item>
    
    <item>
      <title>第6章 电机的效率和散热</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC6%E7%AB%A0%E7%94%B5%E6%9C%BA%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E6%95%A3%E7%83%AD/</link>
      <pubDate>Sat, 14 Oct 2023 12:28:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC6%E7%AB%A0%E7%94%B5%E6%9C%BA%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E6%95%A3%E7%83%AD/</guid>
      <description>6.0 引言 当电机把一种能量转化为另一种能量时，损耗总是存在。损耗发生在电机内部导致温度上升和效率下降。
从损耗来看，电机分成两种类型：有旋转部件的（电动机、发电机等）和没有旋转部件的（变压器、电抗器等）。旋转的电机将产生电气和机械损耗，而静止的电机只产生电气损耗。
这一章将分析直流电机中的损耗，但是这些损耗在运行于交变电流的其他电机中同样存在。研究功率损耗非常重要，因为它给出了如何减小损耗的线索。
这一章还包括温度上升和电气设备的使用寿命等重要的主题。而这两者都和使用的绝缘等级有关，而绝缘等级都是标准化的。
6.1 机械损耗 6.2 电气损耗 6.3 负载作用下的损耗 6.4 效率曲线 6.5 温升 6.6 电气设备的预期寿命 6.7 绝缘体的耐热等级 6.8 最大环境温度和热点温升 6.9 电阻法测温升 6.10 转速和电机尺寸之间的关系 </description>
    </item>
    
    <item>
      <title>第4章 直流发电机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC4%E7%AB%A0%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 12:14:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC4%E7%AB%A0%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA/</guid>
      <description>4.0 引言 我们从学习直流发电机开始来逐渐学习旋转电机。现在的直流发电机并不像它们以前那样普遍了，因为在多数场合，可以通过电子整流器来产生直流。这些整流器无需任何旋转机构便可以把交流电转换为直流。然而，了解直流发电机也是很重要的，它是进一步理解直流电动机运行的基础。事实上，在工业中，许多直流电动机在运行中处于短暂的发电状态。
直流发电机和电动机的构造是相同的，因此，任何发电机可作为电动机，反过来也成立。由于它们相同的构造，发电机和电动机的基本特性也是相同的。因此，任何关于直流发电机的知识也适用于直流电动机。
在本章中，首先学习两极发电机空载运行时的基本原理，介绍电刷位置的重要性，定义什么是所谓的中性点，并说明感应电压是怎么产生的以及什么因素决定它的大小。
接下来学习直流发电机的负载运行，讨论机械转矩、电流的方向以及电枢反应的重要性，并讨论换向极以及极尖饱和的问题。
再往后介绍几种直流发电机的类型和它们的电压调节特性。
本章最后描述直流电机的实际物理结构，包括它的多极设计。
4.1 产生交流电势 4.2 直流发电机 4.3 交流发电机和直流发电机的不同 4.4 改善波形 4.5 感应电势 4.6 中性线 4.7 感应电势的大小 4.8 发电机负载运行: 能量转化过程 4.9 电枢反应 4.10 移动电刷位置以改善换向 4.11 换向极 4.12 他励发电机 4.13 空载下的饱和曲线 4.14 并励发电机 4.15 控制并励发电机的端电压 4.16 等效电路 4.17 他励发电机的负载运行 4.18 并励发电机的负载运行 4.19 复励发电机 4.20 差复励发电机 4.21 负载特性 4.22 发电机的规格 直流发电机的构造 4.23 主磁极 4.24 电枢 4.25 换向器和电刷 4.26 多极发电机的详细分析 4.27 理想换向过程 4.28 实际换向过程 </description>
    </item>
    
    <item>
      <title>第5章 直流电动机</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC5%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sat, 14 Oct 2023 12:14:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC5%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/</guid>
      <description>5.0 引言 我们已经对直流发电机有了很好的理解，接下来开始学习直流电动机。直流电动机把电能转化成机械能，用来驱动起重机、风机、水泵、计时器、冲压机、汽车等。有些设备的转矩-速度曲线是固定的（如水泵或风机），有些则变化很大（如起重机或汽车）。电动机的速度-转矩曲线应该与他所驱动的负载类型相匹配，这样就对应三种基本类型的电动机：
并励电动机 串励电动机 复励电动机 在普通的工业应用中很少采用直流电动机，这是因为所有的电气设施系统只提供交流电。当然对于特殊应用场合，如轧钢厂、矿山、电力机车，使用直流电动机更有优势，因此要将交流电转换成直流电。原因是直流电动机的转矩-转速曲线能在很大范围内可变，且保持高效率。
现在，这种局面有所改变，因为成熟的电力电子技术的使用，使交流电动机用于变速场合成为可能。但直流电动机仍在大量地使用和制造。
5.1 反电动势 5.2 电动机的加速过程 5.3 机械功率和转矩 5.4 旋转速度 5.5 电枢速度控制 5.6 变磁场调速 5.7 并励电动机带负载运行 5.8 串励电动机 5.9 串励电动机的速度控制 5.10 串励电动机的应用 5.11 复励电动机 5.12 改变旋转方向 5.13 并励电动机的起动 5.14 触点式起动器 5.15 电动机制动 5.16 能耗制动 5.17 反接制动 5.18 能耗制动和机械时间常数 5.19 电枢反应 5.20 电枢反应产生的磁通畸变 5.21 换向极 5.22 补偿绕组 5.23 调速基础 5.24 永磁电动机 </description>
    </item>
    
    <item>
      <title>第8章 三相电路</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC8%E7%AB%A0%E4%B8%89%E7%9B%B8%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Sat, 14 Oct 2023 12:14:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC8%E7%AB%A0%E4%B8%89%E7%9B%B8%E7%94%B5%E8%B7%AF/</guid>
      <description>8.0 引言 电能的产生、传输、分配都是以三相电能的形式进行。家用及小型的电器使用单相电能，但三相电能使用更广泛，主要是基于以下几个重要因素：
a. 三相电动机、发电机和变压器更简单、便宜，且效率更高；
b. 在限定的重量和成本之下，三相传输线路能传递更多的能量；
c. 三相传输线路的电压调节能力更强；
因此，三相电能和三相电路的学习对于了解电力技术是绝对有必要的。幸运的是，曾用来解决单相线路的基本电路技术可以被直接用于三相电路。而且，大多数的三相电路可以被简化为基本的单相电路。在这种情况下，假设读者对于之前关于线路和能量的章节非常熟悉。
8.1 多相系统 8.2 单相发电机 8.3 单相发电机输出功率 8.4 二相发电机 8.5 二相发电机的输出功率 8.6 三相发电机 8.7 三相发电机的输出功率 8.8 联结 8.9 电压关系 8.10 △联结 8.11 三相线路的传输功率 8.12 三相电路中的有功、无功和视在功率 8.13 三相电路的计算 8.14 工业负载 8.15 相序 8.16 相序的确定 8.17 交流电路的功率测量 8.18 三相三线制电路的功率测量 8.19 三相四线制电路的功率测量 8.20 无功功率表 8.21 从单相转换成三相 </description>
    </item>
    
    <item>
      <title>第3章 力学和热学的基本知识</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC3%E7%AB%A0%E5%8A%9B%E5%AD%A6%E5%92%8C%E7%83%AD%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 14 Oct 2023 12:10:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC3%E7%AB%A0%E5%8A%9B%E5%AD%A6%E5%92%8C%E7%83%AD%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
      <description>3.0 引言 3.1 力 3.2 转知 3.3 机械功 3.4 功率 3.5 电动机的功率 3.6 能量的转化 3.7 效率 3.8 直线运动的动能 3.9 旋转动能、转动惯量 3.10 转矩、转动惯量对速度的影响 3.11 电动机/负系统的速度 3.12 在机械连接系统中的能量流动 3.13 电动机驱动具有转动惯量的负 3.14 电动机驱动直线运动的负载 3.15 热量和温度 3.16 温度定标 3.17 物体温度升高所需的热量 3.18 热量的传递 3.19 导体传热 3.20 热量的对流传送 3.21 对流的热损耗计算 3.22 热射 3.23 辐射损耗的计算 </description>
    </item>
    
    <item>
      <title>第2章 电学、磁学及电路基本原理</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC2%E7%AB%A0%E7%94%B5%E5%AD%A6%E7%A3%81%E5%AD%A6%E5%8F%8A%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 14 Oct 2023 11:31:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC2%E7%AB%A0%E7%94%B5%E5%AD%A6%E7%A3%81%E5%AD%A6%E5%8F%8A%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description>2.0 引言 本章主要回顾一下电学、磁学以及电路的基本原理。尽管读者具备求解电路等的基础知识，但由于涉及与电力技术有重要关系的知识，因此回顾还是很有必要的。而且，这些基本知识建立了本书所应用的确定电压、电流的理论。这些知识也将会为读者在接触以后章节内容中提供参考。
2.1 电流方向 对于图2-1所示的干电池，它有一个正极（十）和一个负极（一）。这两个极之间的电位差（用伏特表示）是由于负极相对于正极有更多的电子造成的。
如果用导线将这两极连接起来，则电位差将在这个电路中产生电流。该电流是由从负极出发的电子，沿着导线移动，直至到达正极再回到电池的运动造成的（见图2-2）。
在电流的电子移动理论被完全接受以前，17世纪的科学家们武断地认为电流在导体中的流动是由正极向负极的（见图2-3）。这个称为常规电流方向一直沿用到今天，并在电力技术应用中被接受。
在本书中我们使用常规电流方向，但值得注意的是，实际的电子流动方向与常规的电流方向相反。
2.2 电源和负载的区别 在电路中，识别电源和负载有时是很重要的。在定义上，电源提供电能而负载消耗电能。每个有电流流过的电力元件（电动机、电阻、热电偶、电池、电容、发电机等）都可以被归类为电源或负载。到底怎样才能区别它们呢？
为了建立一个一般的准则，我们考虑两个盒子 A 和 B，它们用一对导线相连，导线中的电流不断地变化且不断地改变方向（见图2-4）。假设在导线上的电压降为零。每个盒子 里的装置和元件未知，且都通过某种方式连接到外面的电极　$A_1$、$A_2$　和　$B_1$、$B_2$。在两极之间也存在变化的电压，其大小和方向也都是变化的。在这样高度变化的条件下，如何识别 A 和 B 哪个是电源，哪个是负载呢？
为解决上面的问题，假设有高精密的仪器能测量到两极之间瞬时电压的极性和瞬时的电流的方向。然后利用以下准则:
当电流从电压正极性方向流出时这个装置就是电源。 当电流流进电压正极性方向时这个装置就是负载。 如果电压的瞬时极性和电流的瞬时方向如图2-4所示，利用上述准则可以知道A盒是 电源，B盒是负载。而如果电流改变方向，电压极性不变时，则B盒变成电源，A盒为负载。
以上判断一个装置是否是电源还是负载的方法很简单，但它有着重要的应用，特别是在交流电路中。
有些元件（如电阻）只能作为负载。其他元件（比如光电池）只能作为电源。然而，许多元件既可以作为负载，又可以作为电源。因此当一个电池发出电能时，它作为电源（电流从电压正极流出）；当它被充电时，又变成了负载（电流流进电压正极）。类似地，电动机一般在系统中作为负载，但当条件合适时也能作为电源。同样的事情也能发生在电容上。当电容放电时它作为一个电源，电流从其正极流出；另一方面，当电容充电时，它作为负载，此时电流流人它的正极。
2.3 标志符号 2.4 电压的双下标符号表示 2.5 电压的标志符号 2.6 交流电压图 2.7 正负电流 2.8 正弦电压 2.9 把余弦函数转化为正弦函数 2.10 交流电压的有效值 2.11 相量表示法 2.12 谐波 2.13 电感中的能量 2.14 电容中的能量 2.15 一些有用的公式 2.16 磁场强度H与通密度B 2.17 真空中的 B-H 曲线 2.18 性材料中的 B-H 曲线 2.19 确定相对导率 2.20 法拉第电磁感应定律 2.</description>
    </item>
    
    <item>
      <title>第1章 单位</title>
      <link>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC1%E7%AB%A0%E5%8D%95%E4%BD%8D/</link>
      <pubDate>Sat, 14 Oct 2023 11:14:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC1%E7%AB%A0%E5%8D%95%E4%BD%8D/</guid>
      <description>1.0 引言 单位在日常生活中起着重要作用。实际上，任何看到、感受到的事物，任何买卖的东西都是用单位来衡量和比较的。我们对于这些单位量是那么熟悉，以至于觉得它们很自然，很少会去想它们是怎么得来的，为什么给它们指定这个单位值。
几百年前用36个大麦粒首尾相连排列的长度来定义一英尺，而用国王埃德加的鼻子到他伸展的手端的长度来定义一码。
从那以后，我们在定义出更精确的单位的过程中走了很长的一段路。现在的大部分单位都是基于大自然的物理规律而设定的，由于其有不变性和可重现性的优点。因此，尺和码是用通过光速来计算定义的，时间是通过原子振动的持续时间来定义的。测量标准的提高和科技的进步是息息相关的，它们也是互相依存的。
虽然基本标准各国是统-一的，但单位的日常应用远未统一。例如，在测量长度时有些人使用英尺和码，而有些人使用毫米和米。天文学家运用秒差距，物理学家用埃，另外一些人员仍在使用杆和测链。但是这些长度单位可以达到很高的精确度，因为现在长度的标准是用光速来衡量的。
这些基准使同一个测量单位在不同国家或不同专业得以互相比较。长度、质量、时间等标准单位将当今使用的各种单位联系起来。
1.1单位制 多年来已制定各种单位制以满足商业、工业以及科学的需求。一个单位制可表述为其各单位之间有数值联系，而且常常是整数关系。如在英制中，英寸、英尺、码都是彼此相关的，由12、3、36这几个数联系起来。.
在公制中也存在类似的相关性，只不过那些单位是由10的倍数联系起来的。因此，厘米、米、千米是由100、1000、100 000这几个数联系起来的。所以从米换算到厘米比从码换算到英尺方便，这也是公制的优点之一.
公制在当今被认定为国际单位制，SI 是它的缩写。SI 是在1960年召开的第11届度量衡大会上被正式确定的，那届大会的主题是“国际单位制”。
1.2国际单位制 国际单位制 (SI) 被大多数国家所采用，但它并没有消除其他先前被使用的单位。就像建立了良好的生活习惯一样，那些单位变成我们生活的一部分，不能马上改变它。一夜之间从码到米，以及从盎司到克的转换并不是容易的。这是很自然的，因为长期使用一种单位使我们对事物的质量、规模以及它们怎样与物质世界联系有了自已的认识和理解。
然而，SI 变得越来越重要 (尤其是在电气和机械领域) ，使得我们应该了解单位制基本内容，从而，能用简单的方法从一个单位系统换算到另一个单位系统。在这方面，附录列出的转换图表是非常有用的。
SI具有很多其他单位系统没有的明显的优点:
这是一个十进制系统; 它包含了工业和商业中很多常用的单位，例如伏特、安培、千克以及瓦特; 这是一个连贯系统，在电、机以及热之间有着非常简洁明了的联系; 它可以被科学研究者、技术员、工程师以及外行者使用，能把理论与实践联系起来。 尽管有这些优点，但 SI 并不是万能的。在特殊领域如原子物理学，以及甚至在每天的工作中，其他单位制可能会更方便些。所以我们测量平面角时用度这个单位，尽管在 SI 中角的单位是弧度。而且，我们将继续使用天和小时来计算时间，尽管在 SI 中是用秒计时。
1.3 基本单位和导出单位 国际单位制由7个基本单位组成 (如表1-1所示) 。
$$ 表1-1~~~基本单位 $$
量 单位 符号 长度 米 m 质量 千克 kg 时间 秒 s 电流 安培 A 热力学温度 开尔文 K 发光强度 坎德拉 cd 物质的量 摩尔 mol 从这些基本单位我们可以导出其他一-些诸如面积、功率、力、磁通量等单位。能导出的单位在数量上没有限制，有些单位使用频繁从而给它们取了特殊的名字。因此，对于压强单位用更简单的帕斯卡取代原来的牛顿/平方米。一些有特殊名字的导出单位量列在表1-2中。
$$ 表1-2~~~导出单位 $$</description>
    </item>
    
    <item>
      <title>11.11 控制实验室</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.11%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4/</link>
      <pubDate>Wed, 30 Aug 2023 18:38:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.11%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4/</guid>
      <description>11.11 控制实验室 在附录D，我们提供了 LEGO MINDSTORMS 实验室的案例，包括三个拾取机器人、一个电梯监控系统。作为一个项目，你可以使用本章所讨论的方法针对这些系统设计不同的控制器。你也可以使用 MATLABSISO 设计工具、Simulink（见附录 E）或者本章提供的工具箱来开发你的控制系统。最后，可以参考习题 11-68 的LEGO MINDSTORMS 专题。</description>
    </item>
    
    <item>
      <title>11.10 MATLAB工具和案例研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.10matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:37:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.10matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</guid>
      <description>11.10 MATLAB 工具和案例研究 为了一步步展现本章例子的计算结果和演示图效果，我们使用 MATLABSISO 设计 工具。通过图形用户界面（GUI)，SISO 设计工具创建了一个友好用户环境来减少控制系统设的复杂度。SISO 设计工具要求使用根轨迹、Bode图和极坐标来设计SISO矫正器。SISO 设计工具默认反馈控制控制框图表示如图11-78所示, 反馈控制框图包含反馈增益 H、校正器 C 级联控制对象 G 、预滤波器 F 。</description>
    </item>
    
    <item>
      <title>11.9 局部反馈控制</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.9%E5%B1%80%E9%83%A8%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:37:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.9%E5%B1%80%E9%83%A8%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/</guid>
      <description>前面儿节讨论的控制方法都是在控制系统的主环或前向通道上串联控制器。尽管串联控制器因其实现简单而最为常见，有时根据系统的性质把控制器放在局部反馈环里也是有好处的，如图 11-2b 所示。例如，转速计可与直流电动机直接相连，这不仅是为了显示速度的需要，更是因为通过反馈转速计的输出信号，团环系统的稳定性可以得到改善。电动机速度也可以通过电动机运行方向上的电动势得到。原则上，PID 控制器、相位滞后和相位超前控制器都可以用作局部反馈控制器，只是效果不同而已。在一定条件下，局部控制可以使系统的鲁棒性更好，即对外界扰动或内部参数变化的灵敏度较低。</description>
    </item>
    
    <item>
      <title>11.8 鲁棒控制系统的设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.8%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:37:16 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.8%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.7 前向和前馈控制器</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.7%E5%89%8D%E5%90%91%E5%92%8C%E5%89%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E5%99%A8/</link>
      <pubDate>Wed, 30 Aug 2023 18:36:58 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.7%E5%89%8D%E5%90%91%E5%92%8C%E5%89%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.6 零极点对消设计 陷波滤波器</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.6%E9%9B%B6%E6%9E%81%E7%82%B9%E5%AF%B9%E6%B6%88%E8%AE%BE%E8%AE%A1-%E9%99%B7%E6%B3%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/</link>
      <pubDate>Wed, 30 Aug 2023 18:36:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.6%E9%9B%B6%E6%9E%81%E7%82%B9%E5%AF%B9%E6%B6%88%E8%AE%BE%E8%AE%A1-%E9%99%B7%E6%B3%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.5 相位超前和相位滞后控制器的设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.5%E7%9B%B8%E4%BD%8D%E8%B6%85%E5%89%8D%E5%92%8C%E7%9B%B8%E4%BD%8D%E6%BB%9E%E5%90%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:36:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.5%E7%9B%B8%E4%BD%8D%E8%B6%85%E5%89%8D%E5%92%8C%E7%9B%B8%E4%BD%8D%E6%BB%9E%E5%90%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>在校正控制系统中， PID 控制器及其组成部分 PD 和PI控制器是对控制系统进行微分、积分操作。一般来说，我们可以把控制系统的控制器设计看作滤波器设计问题，这样就会有很多可能的设计方案。从滤波角度来看， PD 控制器可以看作高通滤波器,PI控制器可以看作低通滤波器，而 PID 控制器根据控制器参数值的不同，可以看成带通滤波器或带阻滤波器。在本节中，我们所介绍的高通滤波器可以称为相位超前控制器，因为它给控制系统引入的正向相位超出了一定的频率范围。低通滤波器因为引入了负向相位，因此称为相位滞后控制器。两种控制器所对应的电路如图11-30所示。 $$ 图11-30\ G_c(s)=K_c\frac{S+Z_1}{S+P_1}的运算放大电路 $$ 一个简单的相位超前或相位滞后控制器的传递函数表达式为 $$ G_c(S) = K_c\frac{S+Z_1}{S+P_1} \ (11-69) $$ 如果 $p_1&amp;gt;z_1$，控制器为高通滤波器或相位超前控制器;如果$p_1&amp;gt;z_1$，控制器为低通滤波器或相位滞后控制器。
式(11-69)所示运算放大电路的实现可见第6章的表6-1g,并在图11-30中使用倒置放大器再次重现。该电路的传递函数可以写为 $$ G_c(S) = \frac{E_o(S)}{E_{in}(S)}=\frac{C_1}{C_2}\frac{S+\frac{1}{R_1C_1}}{S+\frac{1}{R_2C_2}} \ (11-70) $$
对比式( 11-69)和式( 11-70)，可得: $$ K_c = C_1/C_2\ (11-71)Z_1 = 1/R_1C_1\ P_1=1/R_2C_2 $$ 令$C=C_1=C_2$，可以将所需设计的参数从4个减少到3个，则式(11-70)可以写为 $$ G_c(S)=\frac{R_2}{R_1}(\frac{1+R_1C_s}{1+R_2C_s})=\frac{1}{a}(\frac{1+aTs}{1+Ts})\(11-72) $$ 其中： $$ a = \frac{R_1}{R_2}\(11-73) $$ $$ T = R_2C\(11-74) $$
11.5.1相位超前控制器的时域分析和设计 在本节中，我们首先考虑式(11-70)和式(11-72)所表示的相位超前控制器($z_1&amp;lt;p_1$或$a&amp;gt;1$)。为了使得加人相位超前控制器后，系统的稳态误差指标不会下降，式(11-72)中的因子 a 应当包含在前向通道增益系数$K$中。因此可以写为 $$ G_c(s) = \frac{1+aTs}{1+Ts}，a&amp;gt;1\(11-75) $$ 式(11-75)的零极点配置图如图11-31所示。根据第7章中的讨论，在前向通道传递函数中加入一对零极点(零点很接近原点)对控制系统会产生影响，若相位超前控制器的参数选择合理，则可以提高闭环系统的稳定性。超前控制器设计从本质上讲就是合理地配置 $G_c(s)$ 的零点，使得控制系统满足实际要求。根轨迹方法可以用来确定参数范围。以下列出的是选择参数a和T的几点指导性原则:</description>
    </item>
    
    <item>
      <title>11.4 PID控制器的设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.4pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:36:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.4pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>从前面的讨论知道， PD 控制器能够增加系统的阻尼但不改变稳态响应。PI控制器可以同时改进系统的相对稳定性和稳态误差，但增加了，上升时间。使用 PID 控制器就是为了利用PI控制器和 PD 控制器各自的优点。下面将要简单介绍一-下设计 PID 控制器的步骤: $$ 图11-27 例11-3-2中具有Pl控制器的控制系统的单位阶跃响应曲线 $$ 1.考虑有这么一个 PID 控制器，它由PI控制器串联上一个 PD 控制器组成。那么该 PID 控制器的传递函数可以写为 $$ G_c(s) =K_P+ K_DS+\frac{K_I}{S}=(K_{P1}+K_{D1}S)(K_{P2}+\frac{K_{I2}}{S})\(11-58) $$ 将 PD 控制器的比例常数设定为Kp=1，因此我们只需要设计 PID 中的3个参数。令式(11-58)左右两边同类项的系数相等，可以得到: $$ (11-59)K_P = K_{P2}+K_{D1}K_{I2}\\ \ (11-60)K_D=K_{D1}K_{P2}\\ \ (11-61)K_I = K_{I2} $$ 2. 考虑只有 PD 部分有效。选择$K_{D1}$的值使得部分期望的相对稳定性可以实现。在时域中，系统的相对稳定性可以表示为最大超调量;在频域中，相对稳定性可以通过相位裕量来描述。 3. 选择参数 $K_{I2}$ 和 $K_{P2}$ 使得系统的相对稳定性完全满足要求。
注意，设定$K_{p1}$=1的步骤和例11-2-1和11-2-2中的 PD 控制器设计是一致的。下面的例子将用于说明如何在时域和频域中设计 PID 控制器。</description>
    </item>
    
    <item>
      <title>11.3 PI控制器的设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.3pi%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:35:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.3pi%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>从11.2节中，我们得知PD控制器可以改进控制系统的阻尼和上升时间，但其代价是更高的带宽和谐振频率，且PD控制不影响稳态误差，除非稳态误差是随时间变化的，而对阶跃输入而言，PD控制下系统的稳态误差通常是不变的。因此，PD控制器在许多情况下不能满足系统的校正要求。 $$ 图11-19具有PI控制器的控制系统控制框图 $$
PID控制器的积分部分产生一个与控制器输人的时间积分成比例的信号。串联一个PI控制器的二阶系统结构控制框图如图11-19所示。PI控制器的传递函数为
$$ G_c(S) = K_P+\frac{K_I}{S}~~~(11-34) $$
$$ 图11-20a两运算放大器电路 $$
使用表6-1中给出的电子元件来实现式( 11-34)的两个运算放大器电路，如图11-20所示。图11-20a中的两运算放大器的传递函数为
$$ G_c(S) = \frac{E_o(S)}{E_{in}(S)}=\frac{R_2}{R_1}+\frac{R_2}{R_1C_2S}~~~(11-35) $$
比较式(11-34)和式(11-35)得:
$$ K_P = \frac{R_2}{R_1}~~~~~K_I = \frac{R_2}{R_1C_2}~~~~(11-36) $$
图11-20b中的三运算放大器的传递函数为
$$ G_c(s) = \frac{E_o(s)}{E_{in}(s)}=\frac{R_2}{R_1}+\frac{1}{R_iC_is}~~~(11-37) $$
因此 PI 控制器的参数与电路元件参数的关系为:
$$ K_P=\frac{R_2}{R_1}~~~~~K_I = \frac{1}{R_iC_i}~~~~(11-38) $$
$$ 图11-20b三运算放大器电路 $$
$$ 图11-20~~~G_c(s)=K_p +\frac{K_I}{s}的PI控制器的运算放大器电路 $$
图11-20b所示电路的优点在于 $K_p$ 和 $K_I$ 的值是相互独立的，但不论是那种电路，$K_I$的值都与电容值成倒数关系，有效的 PI 控制器设计一.般要求有小的 $K_I$ 值，因此必须注意避免出现不符合实际的大电容值。
校正系统的前向通道传递函数为
$$ G_(s) = G_c(s)G_p(s) = \frac{ω^2_n(K_PS+K_I)}{S^2(S+2ξω_n)}~~~(11-39) $$
通过以上分析，PI 控制器的作用如下:
在前向通道传递函数 $s=-K_I/K_p$ 处增加了一个零点。 在前向通道传递函数 $s=0$ 处增加了一个极点，这说明控制系统从I型变为I型。因此，原始系统的稳态误差可以得到改善，即，如果响应的稳态误差为常数，PI 控制会将误差减小到0 (要保证校正系统仍稳定)。 如果参考输入是斜坡函数，前向通道传递函数为式(11-39)的控制系统(系统控制框图见图11-19)会产生零稳态误差。但是，此时系统是三阶的，所以它可能比原始的二阶系统具有更差的 稳定性，甚至如果 $K_p$ 和 $K_I$ 的值选择不当，系统会变得不稳定。</description>
    </item>
    
    <item>
      <title>11.2 PD控制器的设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.2pd%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:35:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.2pd%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>前面讨论的所有控制系统中的控制器都是常数增益为K的放大器，控制器输出的控制信号只与控制器的输人呈简单的系数比例关系，这类控制方式称为比例控制。
从直观上讲，除了比例运算外，我们也应该能够使用输入信号的微分或积分运算,因此，更为一般的连续控制器应包括加法器(加法或减法)、放大器、衰减器、微分器和积分器等元件。设计者的任务就是要确定采用其中的哪些元件，用多大的比例，以及如何把它们连接在一起。例如，在实际应用中最常用的一类控制器就是 PID 控制器，三个字母分别表示比例(Proportional)、积分(Integral)、微分(Derivative)，在 PID 控制器中微分和积分部分都有各自的性能含义。要想应用这些部分，就必须理解它们的基本特性。为此,首先我们考虑 PD 控制。
任意一个二阶反馈控制系统的控制框图如 图11-3 所示，其传递函数为 $$ G_p(s) = \frac{ω^2_n}{s(s+2ξω_n)}~~~~(11-1) $$
$$ 图11-3~~~具有PD控制器的控制系统控制框图 $$
采用比例-微分(PD)控制的串联控制器的传递函数为 $$ G_c(s) = K_p+K_DS~~~(11-2) $$ 因此,系统的控制信号为 $$ u(t) = K_pe(t)+K_D\frac{de(t)}{dt}~~~(11-3) $$
式中，$K_p$ 和 $K_D$ 分别是比例和微分系数。用表6-1中的元件，我们可以得到 PD 控制器的两种电路实现，如图11-4所示。图11-4a所示电路的传递函数为 $$ \frac{E_o(s)}{E_{in}(s)} = \frac{R_2}{R_1}+R_2C_1s~~~(11-4) $$ 比较式（11-2）和式（11-4）可得到: $$ K_p = R_2/R_1~~~~ K_D = R_2C_1~~~(11-5) $$ 图11-4b所示电路的传递函数为 $$ \frac{E_o(s)}{E_{in(s)}} = \frac{R_2}{R_1}+R_dC_ds~~~(11-6) $$ 同样,由式（11-2）和式(11-6)得到: $$ K_p = R_2/R_1~~~~~K_D = R_dC_d~~~~(11-7) $$
$$ 图11-4 ~~~PD控制器的运算放大器电路实现 $$
图11-4a 所示电路的优点是只用了两个运算放大器，但是该电路不允许独立选择 $K_P$ 和$K_D$, 因为它们通常取决于 $R_2$。PD 控制器的一个重要问题是，如果 $K_D$ 的值很大，则需要大的电容器 $C_1$。在 图11-4b 所示的电路中，允许独立控制 $K_P$ 和 $K_D$ 值。可以选择一个较大的 $R_d$ 值来补偿较大的 $K_D$,使得$C_d$，值比较合理。虽然在本书中我们不可能顾及设计控制器传递函数中的所有实际应用问题，但我们会介绍一些非常重要的注意事项。</description>
    </item>
    
    <item>
      <title>11.1 引言</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.1%E5%BC%95%E8%A8%80/</link>
      <pubDate>Wed, 30 Aug 2023 18:35:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.1%E5%BC%95%E8%A8%80/</guid>
      <description>我们将利用在前述章节中介绍的所有基础知识和分析方法来实现控制系统设计这一最终目标。以图11-1所示控制框图表示的受控过程为例，控制系统设计主要涉及以下3个步骤:
确定系统应该做什么以及如何做(设计要求)。 根据控制器或校正器在受控系统中的连接方式,确定其结构配置。 确定控制器的参数,使得系统达到设计目标。我们将在下面几节详细介绍控制系统的设计。 11.1.1 设计要求 正如第7章所讨论的，我们使用设计要求来描述给定输入系统的预期性能。根据不同的应用，设计要求也不尽相同，但通常包括相对稳定性、稳态精度(误差)、瞬态响应和频率响应等特性。在一些特殊的应用中，在系统设计时也会考虑对参数变化的灵敏性,即鲁棒性或抗干扰性。
线性控制系统的设计既可以使用时域方法也可以采用频域方法。例如，稳态精度可以通过阶跃响应、斜坡响应或抛物线响应的方法来实现，而且用时域方法可以使系统更为方便地达到设计要求。对于其他的要求，例如单位阶跃下的最大超调、上升时间和调节时间也都适用于时域设计。而对于增益裕量、相位裕量和谐振峰值 $M$,，这些衡量相对稳定性的频域特性，通常由Bode图、极坐标图、相位-增益图和 Nichols图来表示，再运用图解法进行研究。
对于二阶系统，时域性能指标和频域性能指标之间有明确的对应关系，但对于高阶系统而言，这种时域指标和频域指标之间的关系就难以建立。值得一提的是，对控制系统的分析和设计是一个需要经验性的工作。对于同一个问题，设计者可以从诸多方法中选取合适的一个来进行设计。
因此，设计者可以根据个人喜好在时域方法或频域方法中选择一种最合适的方法来进行控制系统的设计。需要注意的是，在绝大多数情况下，时域指标(例如最大超调、上升时间和调节时间)通常作为系统性能的最终衡量标准。对于一个没有经验的设计者而言，很难理解诸如增益裕量、相位裕量和谐振峰值等频域特性和实际控制系统之间的物理联系。例如，20dB 的增益裕量是否能保证最大超调小于10%?又比如说，人们很容易理解控制系统的最大超调应该小于5%，调节时间应该小于0.01s这类指标，但相位裕量应该为60°、M,应小于1.1这类频域指标与系统性能之间的关系却并不直观。以下几点详细解释了如何选择使用时域或频域特性指标以及选用这些指标的原因。
以往，在设计线性控制系统时，会采用大量的基于频域的图形工具，例如 Bode图、Nyquist图、增益–相位图和Nichols图等。这些图的优点是:它们不是由精确的点绘制而成的，而是用近似的方法画的。根据图表，设计者可以得到控制系统的增益裕量、相位裕量和M,等频域特性，然后再根据频域方法进行设计。这样使得设计高阶控制系统也不会特别困难。某些类型的控制器在频域中有现成的设计方法，从而可以最大限度地避免反复试验。 时域中的设计主要使用诸如上升时间、延迟时间、调节时间和最大超调等性能指标，但这些分析只适用于二阶系统或可以近似成二阶系统的高阶系统。对于一般高于二阶的控制系统,在时域中就很难遵循一般的设计步骤。 随着高性能、易操作的计算机软件（例如MATLAB)的迅速发展和广泛应用，控制系统的设计也发生了巨大的变化。借助MATLAB，设计者可以在几分钟内完成大量的时域性能指标的设计。这种基于手动执行图形设计的便利性大大降低了频域设计以往的优势。
在本章中，我们结合小型 MATLAB工具箱来帮助你理解示例。在本章结尾将介绍MATLAB SISO设计工具，该工具将有助你更好地使用根轨迹和频域方法。
通常来说，选取一组有意义的频域指标使得对应时域性能指标满足要求是很困难的(有经验的设计者除外)。例如，除非我们知道性能指标要求相位裕量为60°所对应的最大超调，否则该频域指标将是无意义的。事实证明，为了控制最大超调，通常必须至少指定相位裕量或M,。最终，建立一组频域特性变成了一个反复试错的过程。然而，频域方法在解决抗噪和系统灵敏度性能的问题上还是很有用的。更重要的是，频域方法为系统设计提供了另外―种选择。因此，为了方便地比较时域设计和频域设计这两种方法的特点,本章将同时介绍这两种设计方法。
11.1.2控制器结构 通常来说，线性受控过程的动态行为可以用图11-1所示控制框图表示。控制系统的设计目标是在一定的时间间隔内通过控制输入信号u(t)使得输出向量y(t)表示的受控变量满足期望要求。 控制系统中的大多数常规设计方法依赖于所谓的固定结构设计: 设计者一开始就决定了整个设计系统的基本结构，以及控制器相对于受控过程的位置。然后设计问题变成控制器元件的设计。由于大多数控制行为涉及对系统性能特征的修正或校正，所以一般使用固定结构的设计也称为校正。 $$ a)串联(级联)校正 $$ $$ b)反馈校正 $$ $$ c)状态反馈校正 $$ $$ d)串联反馈校正(带二阶自由度) $$ $$ e)带有串联校正的前向校正(带二阶自由度) $$ $$ f)前馈矫正(带二阶自由度) $$ 几个常用的带有校正控制器的控制系统结构如图11-2所示。简单描述如下:
串联(级联)校正。图11-2a展示了一种最为常用的系统控制结构:在受控过程中串联一个控制器，这种结构被称为串联或级联校正。 反馈校正。如图11-2b所示，这种将控制器放在负反馈回路中的设计称为反馈校正。 状态反馈校正。系统的状态变量经定常增益得到控制信号，这被称为状态反馈,如图11-2c所示。状态反馈的缺点是，对高阶系统来说，状态变量较多，为了进行状态反馈就需要较多的传感器来检测状态变量，这样在实际应用时造价高且不可行。即使对于低阶系统，并不是所有的变量都可以直接可测，因此可能需要用观测器或估计器根据测得的输出变量来估计状态变量。 串联反馈校正。图11-2d是由一个串联控制器和一个反馈控制器组成的串联反馈校正。 前馈校正。图 11-2e 和 11-2f 所示的都是前馈校正。图10-2e中，前馈控制器 $G_{cf}(s)$ 在前向通道中与由控制器 $G_c(s)$ 和受控过程组成的闭环系统串联在一起。在图11-2f中，前馈控制器 $G_{cf}(s)$ 与前向通道平行，而不在控制系统回路中，这样就不会影响原系统特征方程的特征根。可以选择 $G_{cf}(s)$ 的零极点来增加或抵消系统闭环传递函数的零极点。 图11-2a~c所示的系统中即使有的控制器中有多个可变参数，但每个控制系统中都只有一个控制器，因此都属于一阶自由度校正。用一阶自由度控制器来实现性能指标有一定的局限性。例如，如果系统要满足一定的稳定性，那么对参数变化就要不敏感;或者，如果选择特征方程的特征根来提供一定的相对阻尼，由于闭环传递函数存在零点,系统阶跃响应的最大超调量仍可能过大。图11-2d~f给出了带有二阶自由度的校正设计。
PID控制器是校正设计中一种常用的控制器，在PID控制中，受控信号经过比例控制、积分控制和微分控制。因为这些信号在时域容易实现而且也容易观察，所以一般用时域方法进行设计。除了PID控制器，比较常用的控制器还有超前控制器、滞后控制器、超前–滞后控制器以及陷波控制器。这些控制器都是根据它们各自的频域特性来命名的，因此经常在频域设计中用到这些控制器。但是，尽管有这些设计倾向，从时域和频域两方面来分析设计结果对于所有的控制系统设计都是有益的。因此，本章会广泛使用时域和频域这两种方法。
需要指出的是，绝不仅仅只有这几种校正方法。我们将在本章后几节中详细介绍这些校正设计方法。图11-2表示的系统结构不仅适用于连续时间控制，也适用于控制器是数字的(在这种情况下，控制器必须是数字的)且带有必要接口和信号变换器的离散时间控制。
11.1.3设计的基本原则 当一个控制器结构确定后，设计者还必须选择能够满足设计要求的控制器类型以及元件参数。对于同一个控制系统设计要求，设计者可以设计出各种控制器类型。在工程实际应用中人们一般选择能够满足设计要求的最简单的控制器。大多数情况下，控制器越复杂其造价也就越高，可靠性也就越差，设计难度也更大。选择特定应用的控制器经常是基于设计者的经验和直觉的。这使得控制器设计不仅是一门科学，也是一种艺术。对于新手来说，开始很难选择一个合适的控制。本章会提供指导性的经验，以说明控制系统设计的基本要素。
选择好控制器，下一步就是选择控制器的参数，也就是组成控制器的一个或多个传递函数的系数。基本的方法是用前面章节所讲到的分析方法来确定每个参数对于设计要求和系统特性的影响，并进而确定满足所有设计要求的控制器参数。这种方法虽然简单，但通常情况下控制器参数会互相影响，使得设计要求相互矛盾，造成设计上的重复。例如，选定一个参数以满足最大超调量要求，但选定另外参数满足上升时间时，最大超调特性可能就不再满足了。显然，所要设计的性能指标越多，控制器参数也就越多，设计过程也就越复杂。
无论是在时域还是在频域范围内设计，均需要注意以下几条基本的设计法则。在时域中，设计通常在s平面上，使用根轨迹方法。在频域中，通过设计回路传递函数的增益和相位来达到设计要求。 一般而言，总结时域和频域的特征是很有用的，这样它们可作为设计指导方针:
闭环极点为复共栀极点，系统为欠阻尼系统，单位阶跃响应为阻尼振荡过程;闭环极点都是实数，阶跃响应为过阻尼状态。但即使系统过阻尼，闭环系统的零点也可能导致系统超调。 系统的动态性能基本上由s平面上接近原点的闭环极点决定，闭环极点越靠左，时间响应分量的下降速度越快。 对系统动态性能起主要作用的闭环极点称为主导极点，系统的主导极点在s平面上越靠左,系统的响应就越快,带宽也越大。 在s平面上主导极点越靠左，在实际应用中实现这样的系统的造价就越高，系统的内部信号也越大。就像我们用锤子砸钉子，锤子冲击钉子的速度越快，砸钉子的力量就越大，所要消耗的能量也越大;同样，跑车比一般汽车速度快，它所耗费的油也多。 当控制系统传递函数的一对零极点近似可抵消时，这个极点产生的那部分系统响应会有小的幅值。 控制系统的时域特性和频域特性之间有一定的对应关系:上升时间和带宽是反比关系，增大相位裕量和增益裕量，减小M，值可以改善系统的衰减性。 </description>
    </item>
    
    <item>
      <title>10.16 MATLAB工具和案例研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.16matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:34:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.16matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.15 频域中的灵敏度研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.15%E9%A2%91%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%81%B5%E6%95%8F%E5%BA%A6%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:34:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.15%E9%A2%91%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%81%B5%E6%95%8F%E5%BA%A6%E7%A0%94%E7%A9%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.14 Nichols图应用于非单位反馈系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.14nichols%E5%9B%BE%E5%BA%94%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%8D%95%E4%BD%8D%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 18:33:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.14nichols%E5%9B%BE%E5%BA%94%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%8D%95%E4%BD%8D%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.13 幅值-相位图中的定常 M 曲线: Nichols 图</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.13%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%B8%B8m%E6%9B%B2%E7%BA%BF-nichols%E5%9B%BE/</link>
      <pubDate>Wed, 30 Aug 2023 18:32:54 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.13%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%B8%B8m%E6%9B%B2%E7%BA%BF-nichols%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.12 用幅值-相位图进行稳定性分析</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.12%E7%94%A8%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2023 18:32:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.12%E7%94%A8%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.11 相对稳定性与 Bode 图的幅值曲线的斜率之间的关系</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.11%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8Ebode%E5%9B%BE%E7%9A%84%E5%B9%85%E5%80%BC%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%96%9C%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 30 Aug 2023 18:32:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.11%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8Ebode%E5%9B%BE%E7%9A%84%E5%B9%85%E5%80%BC%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%96%9C%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.10 用 Bode 图进行稳定性分析</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.10%E7%94%A8bode%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2023 18:31:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.10%E7%94%A8bode%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.9 相对稳定性: 增益裕量和相位裕量</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.9%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7-%E5%A2%9E%E7%9B%8A%E8%A3%95%E9%87%8F%E5%92%8C%E7%9B%B8%E4%BD%8D%E8%A3%95%E9%87%8F/</link>
      <pubDate>Wed, 30 Aug 2023 18:31:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.9%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7-%E5%A2%9E%E7%9B%8A%E8%A3%95%E9%87%8F%E5%92%8C%E7%9B%B8%E4%BD%8D%E8%A3%95%E9%87%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.8 增加 L(s) 的极点和零点对 Nyquist 图的形状的影响</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.8%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E5%AF%B9nyquist%E5%9B%BE%E7%9A%84%E5%BD%A2%E7%8A%B6%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Wed, 30 Aug 2023 18:11:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.8%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E5%AF%B9nyquist%E5%9B%BE%E7%9A%84%E5%BD%A2%E7%8A%B6%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.7 示例: 最小相位传递函数的 Nyquist 判据</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.7%E7%A4%BA%E4%BE%8B-%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/</link>
      <pubDate>Wed, 30 Aug 2023 18:11:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.7%E7%A4%BA%E4%BE%8B-%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.6 根轨迹和 Nyquist 图的关系</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.6%E6%A0%B9%E8%BD%A8%E8%BF%B9%E5%92%8Cnyquist%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 30 Aug 2023 18:10:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.6%E6%A0%B9%E8%BD%A8%E8%BF%B9%E5%92%8Cnyquist%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.5 具有最小相位传递函数的系统的 Nyquist 判据</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.5%E5%85%B7%E6%9C%89%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/</link>
      <pubDate>Wed, 30 Aug 2023 18:10:39 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.5%E5%85%B7%E6%9C%89%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.4 Nyquist 稳定性判据: 基本原理</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.4nyquist%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E6%8D%AE-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 30 Aug 2023 18:10:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.4nyquist%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E6%8D%AE-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.3 前向通道传递函数增加极点和零点的影</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.3%E5%89%8D%E5%90%91%E9%80%9A%E9%81%93%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E7%9A%84%E5%BD%B1/</link>
      <pubDate>Wed, 30 Aug 2023 18:09:44 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.3%E5%89%8D%E5%90%91%E9%80%9A%E9%81%93%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E7%9A%84%E5%BD%B1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.2 二阶系统的谐振峰值、谐振频率和带宽</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.2%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%90%E6%8C%AF%E5%B3%B0%E5%80%BC%E8%B0%90%E6%8C%AF%E9%A2%91%E7%8E%87%E5%92%8C%E5%B8%A6%E5%AE%BD/</link>
      <pubDate>Wed, 30 Aug 2023 18:09:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.2%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%90%E6%8C%AF%E5%B3%B0%E5%80%BC%E8%B0%90%E6%8C%AF%E9%A2%91%E7%8E%87%E5%92%8C%E5%B8%A6%E5%AE%BD/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.1 引言</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.1%E5%BC%95%E8%A8%80/</link>
      <pubDate>Wed, 30 Aug 2023 18:09:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.1%E5%BC%95%E8%A8%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.6 MATLAB 工具箱</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.6matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/</link>
      <pubDate>Wed, 30 Aug 2023 18:08:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.6matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.5 根轨迹族: 多参数变化情形</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.5%E6%A0%B9%E8%BD%A8%E8%BF%B9%E6%97%8F-%E5%A4%9A%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E6%83%85%E5%BD%A2/</link>
      <pubDate>Wed, 30 Aug 2023 18:08:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.5%E6%A0%B9%E8%BD%A8%E8%BF%B9%E6%97%8F-%E5%A4%9A%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E6%83%85%E5%BD%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.4 根轨迹设计</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.4%E6%A0%B9%E8%BD%A8%E8%BF%B9%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 30 Aug 2023 18:08:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.4%E6%A0%B9%E8%BD%A8%E8%BF%B9%E8%AE%BE%E8%AE%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.3 根灵敏度</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.3%E6%A0%B9%E7%81%B5%E6%95%8F%E5%BA%A6/</link>
      <pubDate>Wed, 30 Aug 2023 18:08:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.3%E6%A0%B9%E7%81%B5%E6%95%8F%E5%BA%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.2 根轨迹的性质详解</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.2%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 30 Aug 2023 18:07:41 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.2%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.1 根轨迹的基本性质</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.1%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Wed, 30 Aug 2023 18:07:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.1%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.21 案例研究: LEGO MINDSTORMS 机器臂系统的位置控制</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.21%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstorms%E6%9C%BA%E5%99%A8%E8%87%82%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:07:07 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.21%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstorms%E6%9C%BA%E5%99%A8%E8%87%82%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.20 MATLAB 工具箱和案例学习</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.20matlab%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%92%8C%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 30 Aug 2023 18:06:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.20matlab%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%92%8C%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.19 带有积分控制的状态反馈</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.19%E5%B8%A6%E6%9C%89%E7%A7%AF%E5%88%86%E6%8E%A7%E5%88%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88/</link>
      <pubDate>Wed, 30 Aug 2023 18:06:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.19%E5%B8%A6%E6%9C%89%E7%A7%AF%E5%88%86%E6%8E%A7%E5%88%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.18 通过状态反馈进行极点配置</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.18%E9%80%9A%E8%BF%87%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E8%BF%9B%E8%A1%8C%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 30 Aug 2023 18:05:53 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.18%E9%80%9A%E8%BF%87%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E8%BF%9B%E8%A1%8C%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.17 状态反馈控制</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.17%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:05:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.17%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.16 案例研究: 磁球悬浮系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.16%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%A3%81%E7%90%83%E6%82%AC%E6%B5%AE%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 18:05:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.16%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%A3%81%E7%90%83%E6%82%AC%E6%B5%AE%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.15 能控性和能观性的不变性定理</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.15%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7%E5%AE%9A%E7%90%86/</link>
      <pubDate>Wed, 30 Aug 2023 18:04:57 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.15%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7%E5%AE%9A%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.14 能控性、能观性和传递函数之间的关系</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.14%E8%83%BD%E6%8E%A7%E6%80%A7%E8%83%BD%E8%A7%82%E6%80%A7%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 30 Aug 2023 18:04:42 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.14%E8%83%BD%E6%8E%A7%E6%80%A7%E8%83%BD%E8%A7%82%E6%80%A7%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.13 线性系统的能观性</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.13%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E8%A7%82%E6%80%A7/</link>
      <pubDate>Wed, 30 Aug 2023 18:04:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.13%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E8%A7%82%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.12 控制系统的能控性</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.12%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7/</link>
      <pubDate>Wed, 30 Aug 2023 18:04:14 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.12%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.11 传递函数分解</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.11%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%88%86%E8%A7%A3/</link>
      <pubDate>Wed, 30 Aug 2023 18:03:57 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.11%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%88%86%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.10 相似变换</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.10%E7%9B%B8%E4%BC%BC%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Wed, 30 Aug 2023 18:03:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.10%E7%9B%B8%E4%BC%BC%E5%8F%98%E6%8D%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.9 特征方程、特征值和特征向量</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.9%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</link>
      <pubDate>Wed, 30 Aug 2023 18:03:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.9%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.8 状态方程与传递函数之间的关系</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.8%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 30 Aug 2023 18:03:04 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.8%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.7 状态方程与高阶微分方程之间的关系</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.7%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 30 Aug 2023 18:02:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.7%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.6 状态转移方程</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.6%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Wed, 30 Aug 2023 18:02:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.6%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.5 状态转移矩阵</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.5%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Wed, 30 Aug 2023 18:02:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.5%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.4 状态方程的向量-矩阵表示</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.4%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E5%90%91%E9%87%8F-%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Wed, 30 Aug 2023 18:02:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.4%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E5%90%91%E9%87%8F-%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.3 一阶微分系统的状态方程</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.3%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Wed, 30 Aug 2023 18:01:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.3%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.2 控制框图、传递函数和状态控制框图</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.2%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/</link>
      <pubDate>Wed, 30 Aug 2023 18:01:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.2%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.1 状态变量分析</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.1%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2023 18:01:00 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.1%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.10 控制实验室: LEGO MINDSTORMS NXT 电动机介绍————位置控制</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.10%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstorms_nxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E4%BB%8B%E7%BB%8D%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 30 Aug 2023 18:00:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.10%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstorms_nxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E4%BB%8B%E7%BB%8D%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.9 案例研究: 定位控制系统的时域分析</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.9%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2023 18:00:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.9%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.8 传递函数的主导零极点</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E5%AF%BC%E9%9B%B6%E6%9E%81%E7%82%B9/</link>
      <pubDate>Wed, 30 Aug 2023 17:59:44 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E5%AF%BC%E9%9B%B6%E6%9E%81%E7%82%B9/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.7 基础控制系统以及传递函数增加零极点带来的影响</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.7%E5%9F%BA%E7%A1%80%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E9%9B%B6%E6%9E%81%E7%82%B9%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Wed, 30 Aug 2023 17:59:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.7%E5%9F%BA%E7%A1%80%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E9%9B%B6%E6%9E%81%E7%82%B9%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.6 稳态误差</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.6%E7%A8%B3%E6%80%81%E8%AF%AF%E5%B7%AE/</link>
      <pubDate>Wed, 30 Aug 2023 17:59:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.6%E7%A8%B3%E6%80%81%E8%AF%AF%E5%B7%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.5 二阶系统的暂态响应</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.5%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9A%82%E6%80%81%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 30 Aug 2023 17:58:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.5%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9A%82%E6%80%81%E5%93%8D%E5%BA%94/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.4 一阶系统的时间响应</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.4%E4%B8%80%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 30 Aug 2023 17:58:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.4%E4%B8%80%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.3 单位阶跃响应和时域描述</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.3%E5%8D%95%E4%BD%8D%E9%98%B6%E8%B7%83%E5%93%8D%E5%BA%94%E5%92%8C%E6%97%B6%E5%9F%9F%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Wed, 30 Aug 2023 17:58:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.3%E5%8D%95%E4%BD%8D%E9%98%B6%E8%B7%83%E5%93%8D%E5%BA%94%E5%92%8C%E6%97%B6%E5%9F%9F%E6%8F%8F%E8%BF%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.2 评价控制系统时间响应性能的典型测试信号</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.2%E8%AF%84%E4%BB%B7%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B8%E5%9E%8B%E6%B5%8B%E8%AF%95%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Wed, 30 Aug 2023 17:57:44 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.2%E8%AF%84%E4%BB%B7%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B8%E5%9E%8B%E6%B5%8B%E8%AF%95%E4%BF%A1%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.1 连续时间系统的时间响应</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.1%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 30 Aug 2023 17:57:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.1%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.6 虚拟实验室: LEGO MINDSTORMS NXT 电动机入门—————建模和表征</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.6%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E5%92%8C%E8%A1%A8%E5%BE%81/</link>
      <pubDate>Wed, 30 Aug 2023 17:57:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.6%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E5%92%8C%E8%A1%A8%E5%BE%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.5 案例研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.5%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 17:56:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.5%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.4 直流电动机的速度控制及位置控制</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.4%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%8F%8A%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 30 Aug 2023 17:55:55 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.4%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%8F%8A%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.3 控制系统中的直流电动机</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Wed, 30 Aug 2023 17:55:38 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.2 控制系统中的传感器和编码器</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%BC%96%E7%A0%81%E5%99%A8/</link>
      <pubDate>Wed, 30 Aug 2023 17:55:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%BC%96%E7%A0%81%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.1 有源电气元件的建模: 运算放大器</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.1%E6%9C%89%E6%BA%90%E7%94%B5%E6%B0%94%E5%85%83%E4%BB%B6%E7%9A%84%E5%BB%BA%E6%A8%A1-%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Wed, 30 Aug 2023 17:55:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.1%E6%9C%89%E6%BA%90%E7%94%B5%E6%B0%94%E5%85%83%E4%BB%B6%E7%9A%84%E5%BB%BA%E6%A8%A1-%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.4 MATLAB 工具和案例分析</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.4matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2023 17:54:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.4matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.3 Routh-Hurwitz 判据</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.3routh-hurwitz%E5%88%A4%E6%8D%AE/</link>
      <pubDate>Wed, 30 Aug 2023 17:54:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.3routh-hurwitz%E5%88%A4%E6%8D%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.2 稳定性判定方法</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.2%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 30 Aug 2023 17:53:44 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.2%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.1 稳定性介绍</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.1%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 30 Aug 2023 17:53:27 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.1%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BB%8B%E7%BB%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.5 MATLAB 工具箱</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.5matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/</link>
      <pubDate>Wed, 30 Aug 2023 17:53:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.5matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.4 案例研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.4%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 17:52:57 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.4%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.3 状态图</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.3%E7%8A%B6%E6%80%81%E5%9B%BE/</link>
      <pubDate>Wed, 30 Aug 2023 17:52:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.3%E7%8A%B6%E6%80%81%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.2 信号流图</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.2%E4%BF%A1%E5%8F%B7%E6%B5%81%E5%9B%BE/</link>
      <pubDate>Wed, 30 Aug 2023 17:52:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.2%E4%BF%A1%E5%8F%B7%E6%B5%81%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.1 控制框图</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.1%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/</link>
      <pubDate>Wed, 30 Aug 2023 17:52:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.1%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.9 线性化回顾: 状态空间方法</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.9%E7%BA%BF%E6%80%A7%E5%8C%96%E5%9B%9E%E9%A1%BE-%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 30 Aug 2023 17:40:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.9%E7%BA%BF%E6%80%A7%E5%8C%96%E5%9B%9E%E9%A1%BE-%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.8 MATLAB 案例研究</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.8matlab%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 30 Aug 2023 17:40:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.8matlab%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.7 线性齐次状态方程的解</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.7%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/</link>
      <pubDate>Wed, 30 Aug 2023 17:40:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.7%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.6 系统的一阶微分方程: 状态方程</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Wed, 30 Aug 2023 17:39:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.5 线性系统的脉冲响应和传递函数</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.5%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%84%89%E5%86%B2%E5%93%8D%E5%BA%94%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 30 Aug 2023 17:39:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.5%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%84%89%E5%86%B2%E5%93%8D%E5%BA%94%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.4 拉普拉斯变换在线性常微分方程求解中的应用</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.4%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 30 Aug 2023 17:38:56 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.4%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.3 部分分式展开的拉普拉斯逆变换</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.3%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80%E7%9A%84%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%80%86%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Wed, 30 Aug 2023 17:38:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.3%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80%E7%9A%84%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%80%86%E5%8F%98%E6%8D%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.2 拉普拉斯变换</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.2%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Wed, 30 Aug 2023 17:38:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.2%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.1 微分方程介绍</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 30 Aug 2023 17:37:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%BB%8B%E7%BB%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.6 案例研究: LEGO MINDSTORMS NXT 电动机————机械建模</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.6%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%9C%BA%E6%A2%B0%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Wed, 30 Aug 2023 17:35:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.6%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%9C%BA%E6%A2%B0%E5%BB%BA%E6%A8%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.5 类比</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.5%E7%B1%BB%E6%AF%94/</link>
      <pubDate>Wed, 30 Aug 2023 17:33:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.5%E7%B1%BB%E6%AF%94/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.4 非线性系统的线性化</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.4%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96/</link>
      <pubDate>Wed, 30 Aug 2023 17:32:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.4%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.3 简单热系统和简单流体系统的建模</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.3%E7%AE%80%E5%8D%95%E7%83%AD%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%AE%80%E5%8D%95%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Wed, 30 Aug 2023 17:32:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.3%E7%AE%80%E5%8D%95%E7%83%AD%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%AE%80%E5%8D%95%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.2 简单电气系统的建模</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.2%E7%AE%80%E5%8D%95%E7%94%B5%E6%B0%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Wed, 30 Aug 2023 17:31:55 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.2%E7%AE%80%E5%8D%95%E7%94%B5%E6%B0%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.1 简单机械系统的建模</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.1%E7%AE%80%E5%8D%95%E6%9C%BA%E6%A2%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Wed, 30 Aug 2023 17:31:35 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.1%E7%AE%80%E5%8D%95%E6%9C%BA%E6%A2%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1.11 案例研究: 基于 LEGO MINDSTORMS 的智能车辆避障</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.11%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%9F%BA%E4%BA%8Elegomindstorms%E7%9A%84%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BE%86%E9%81%BF%E9%9A%9C/</link>
      <pubDate>Wed, 30 Aug 2023 17:31:07 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.11%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%9F%BA%E4%BA%8Elegomindstorms%E7%9A%84%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BE%86%E9%81%BF%E9%9A%9C/</guid>
      <description>本节的目标是让读者对实际系统的控制器设计过程有更好的理解，我们将以 LEGO MINDSTORMS NXT 可编程机器人系统为例。虽然此处使用的示例在现阶段可能看起来难度过大，但是这个例子可以演示成功地实施控制系统所需要的步骤。读者可以在完成附录D的学习以后再来回顾这个示例。
项目描述
如图1-16所示，系统的设置是一辆用 MATLAB 和 Simulink 控制的 LEGO MINDSTORMS 车。如图1-17和图1-18所示，此 LEGO 车配有超声波传感器、光传感器、指示灯、NXT 电机齿轮箱和NXT模块。编码器(传感器)用于读取电动机齿轮箱的角位置。NXT模块最多可以读取4个传感器的输人并通过 RJ12 电缆控制多达三台电动机。详细介绍请参见第8章。将超声波传感器放置在小车的前侧以检测车身与障碍物之间的距离。将光传感器朝下放置以检测运行表面的颜色，当检测到颜色为白色时表示出发。使用 USB 把系统与主机连接，主机使用蓝牙连接实时记录编码器数据。
○ 此文章待完成</description>
    </item>
    
    <item>
      <title>1.10 离散控制系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.10%E7%A6%BB%E6%95%A3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:30:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.10%E7%A6%BB%E6%95%A3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>区别于连续系统，离散控制系统中一点或多点信号是以脉冲序列或数字编码的形式出现的。通常离散控制系统又分为采样控制系统和数字控制系统。采样控制系统指一大类使用脉冲信号的离散系统。数字控制系统中使用数字计算机或控制器，因此信号是数字编码的，例如二进制码。
一般情况下，采样系统每隔一定的时间获取一次数据或信息。例如，控制系统的误差信号只能由脉冲提供，在两个相邻的脉冲之间的时间间隔里，系统是收不到误差信号的。严格来讲，采样数据系统属于交流系统，因为信号是脉冲调制的。 $$ 图1-14采样控制系统的控制框图 $$ 图1-14说明了一个典型采样系统的运行过程。对系统施加连续输人信号 $r(t)$,误差信号 $e(t)$ 由采样器采样，采样器的输出是脉冲序列。采样器的采样速率可以一致，也可以不一致。在系统中整合采样器有很多好处，其中一个重要的好处在于系统使用的一.些昂贵的设备在一些控制通道上是共享时间的; 另一个好处是脉冲信号不易受噪声影响。
由于数字计算机在尺寸、灵活性方面有很多优势，计算机控制近年来越来越流行。许多航空系统含有数字控制器，这种控制器可以在不超过本书大小的空间里集成成千上万的离散元件。图1-15是导弹制导控制的数字自动飞行系统包含的基本元件。 $$ 图1-15 制导导弹的数字自动飞行系统 $$</description>
    </item>
    
    <item>
      <title>1.9 连续控制系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.9%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:30:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.9%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>连续系统是指各部分信号是连续时间变量t的函数的系统。连续系统中的信号可以进一步分为交流信号和直流信号。与电子工程中的交直流定义不同，交流和直流控制系统在控制系统中具有特殊意义。交流控制系统通常是指系统信号已根据某种调制模式调制过。直流控制系统只是意味着信号没有经过调制，但仍然有符合传统定义的交流信号。图1-12是闭环直流控制系统的原理图，图.上也显示了系统的阶跃响应波形。直流控制系统的典型元件是稳压器、直流放大器、直流电动机和直流转速表等。 $$ 图1-12 典型直流闭环控制系统的原理图 $$ 图1-13是一个典型的交流控制系统原理图，其功能等同于图1-12所示直流系统。这种系统中的信号是经过调制的，也就是说，信息由交流载波信号传输。需要注意的是，交流系统输出的被控变量的性能与直流系统中的相似。调制过的信号由交流电动机的低通特性解调。交流控制系统广泛用于飞行器与导弹控制系统，这类系统中往往有噪声和干扰引起的问题。在交流控制系统中使用400Hz或更高频率的载波信号，可以使系统不易受低频噪声影响。交流控制系统的典型元件是自整角机、交流放大器、交流电动机、陀螺仪和加速度计等。 $$ 图1-13典型交流闭环控制系统的原理图 $$</description>
    </item>
    
    <item>
      <title>1.8 时不变与时变系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.8%E6%97%B6%E4%B8%8D%E5%8F%98%E4%B8%8E%E6%97%B6%E5%8F%98%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:29:41 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.8%E6%97%B6%E4%B8%8D%E5%8F%98%E4%B8%8E%E6%97%B6%E5%8F%98%E7%B3%BB%E7%BB%9F/</guid>
      <description>如果系统参数在系统运行过程中相对于时间是不变的，那么称此系统为时不变系统。实际上，多数物理系统都包含&amp;ndash;些参数随时间波动或变化的部件。比如在电动机刚启动以及温度升高时，电动机的绕线电阻会发生变化。时变系统的另-一个例子是制导导弹控制系统，飞行中导弹的质量会随着其携带的燃料的不断消耗而减少。尽管不具非线性的时变系统仍然是线性系统，但是这类系统的分析和设计往往比线性时不变系统困难得多。</description>
    </item>
    
    <item>
      <title>1.7 线性系统与非线性系统</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.7%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:29:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.7%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/</guid>
      <description>这种分类是根据分析与设计的方法进行的。严格来说，线性系统实际上并不存在，因为实际的物理系统总是具有一定程度的非线性。线性反馈控制系统被作为一种理想化模型而提出。当控制系统内信号的幅值被限制在系统各部件呈现线性特征的范围内时，此系统就可以被认为是线性的。但是当信号幅值超过部件线性运行区域时，根据非线性的程度，系统就可能被认为是非线性的了。例如，控制系统中常用的放大器在输入信号较大时呈现饱和特性;电动机电磁场往往也具有饱和特性。控制系统中其他常见的非线性现象包括: 啮合齿轮之间的齿隙和死区，弹簧的非线性特性，两移动组件之间的非线性摩擦力或力矩等。控制系统中常利用非线性特性来改善系统性能或提供更高效的控制。例如，为了实现最短时间控制，许多导弹和太空船的控制系统里常使用开关型(bang-bang或继电)控制器。其中，典型的例子是装在导弹和飞船侧面的喷管，它们产生反作用力矩提供姿态控制。这些喷管往往以全关或全开的方式工作，它们能在一定时间里喷出固定量的气体来控制弹(船)体姿态。
对于线性系统，有许多解析的和图形的方法可以用于分析与设计。本书的主要内容讲述的是线性系统的分析与设计。至于非线性系统，则往往难以用数学方法处理，也没有适用于各种非线性系统的通用方法。在设计控制器的开始阶段，可以基于线性模型设计不考虑系统的非线性，然后采用计算机仿真，把设计好的控制器用于非线性模型加以评估或重新设计。第8章要介绍的控制实验室主要用于使用逼真的物理部件来模拟实际系统的特征。</description>
    </item>
    
    <item>
      <title>1.6 反馈控制系统的类型</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.6%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 30 Aug 2023 17:29:04 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.6%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>反馈控制系统可以有多种分类方法，如何分类取决于分类的目的。例如，按照分析和设计的方法，反馈控制系统可以分为线性与非线性系统、时变与时不变系统。按照系统中信号的种类，可以分为连续与离散系统、调制与非调制系统。控制系统还常根据系统的主要目的来分类。举例来说，位置控制系统和速度控制系统控制的正是与其名称同名的那些输出变量。在第11章里，控制系统的类型是由开环传递函数确定的。总之，根据系统的一些特征有很多种分类方法。在着手分析和设计系统之前，掌握一些控制系统的常见分类方法是很重要的。</description>
    </item>
    
    <item>
      <title>1.5 反馈的含义及其作用</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.5%E5%8F%8D%E9%A6%88%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Wed, 30 Aug 2023 17:28:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.5%E5%8F%8D%E9%A6%88%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/</guid>
      <description>1.4节中显示的使用反馈的动因显得过于简单了。在那些例子里，反馈用于减少系统输出和参考输人之间的误差，但是反馈在控制系统中的意义远比上述例子所展示的深刻得多。减小系统误差只是反馈对于系统的各种重要作用之一。以下几节介绍反馈对于稳定性、带宽、总增益、阻抗和敏感度等系统品质特性的影响。
要理解反馈对系统的作用，就必须在广义上考察这种现象。如果反馈是为了实现控制而有意识地引入到系统中的，那么反馈的存在性是很容易识别的。但是，对于很多我们认为应该是不存在反馈的物理系统，却可以通过一定的方法观察到其中存在的反馈。一般地，只要系统变量中存在闭合的因果关系序列，系统就存在反馈。按这种观点看，很多通常被认为是无反馈的系统都存在反馈。不过，在控制理论中不管系统是否具有物理反馈，只要能够确定其具有前面提到的反馈，就可以用系统的方法加以研究。
现在来讨论一下反馈对系统各方面性能的影响。由于目前还不具备线性系统理论的数学基础，我们只讨论简单的静态系统。图1-9所示系统具有简单反馈，$r$代表输人信号，$y$代表输出信号，$e$是误差，$b$是反馈信号，参数$G$和$H$可以看作常量增益。由简单的代数运算很容易得到系统的输入输出关系: $$ 图1-9 反馈系统 $$
$$ M = \frac{y}{r}=\frac{G}{1+GH}\(1-1) $$ 根据反馈系统结构的基本关系，我们可以得到反馈的一些重要作用。
1.5.1 反馈对于总增益的影响 由式(1-1) 可以看出，反馈系统的增益中比无反馈系统的增益多了一个因子$1+GH$。图1-9所示的系统包含$负反馈$，因为反馈信号是负的。乘积$GH$自身可能是一个负信号，因此反馈的一般作用是它可以增加或减小增益G。在实际系统里，$G$和$H$是频率的函数，所以$1+GH$的幅值可能在某个频段大于1，而在另一个频段小于1。由此可知，反馈可以在一个频段增加系统增益，而在另一个频段减小系统增益。
1.5.2 反馈对于稳定性的影响 稳定性的概念用于描述系统能否跟随输人命令，也就是一般意义下的可用性。不严格地说，系统输出失去控制时就被称为不稳定。为了研究反馈对于稳定性的影响,我们仍然考虑式(1-1)。若$GH=-1$，则对于任意的有限输入，系统输出均为无穷，系统不稳定。这意味着反馈可以使原来稳定的系统变成不稳定。确实，反馈是一把双刃剑，使用不当也会有害。需要指出的是，这里讨论的只是静态情况，而且一般情况下$GH=-1$并非是使系统不稳定的唯一 条件。有关系统稳定性的内容将在第5章进行详细讨论。
$$ 图1-10具有两个反馈环的反馈系统 $$ 反馈的好处之一在于可以使不稳定的系统变得稳定。假设图1-9所示系统不稳定，因为$GH=-1$ ;如果按照图1-10使用负反馈增益$F$引人另一个反馈环，整个系统的输人输出关系为 $$ \frac{y}{r}=\frac{G}{1+GH+GF}\(1-2) $$ 显然，尽管因为 $GH=-1$而使得反馈系统内环不稳定，但通过适当选择外环反馈增益$F$,仍旧可以使整个系统稳定。实际上，$GH$是频率的函数，闭环系统的稳定性条件依赖于$GH$的幅值和相位。概括来讲，反馈可以改善系统稳定性，也会因为不恰当的使用而损害系统稳定性。
敏感度也是设计控制系统时需要考虑的一个重要因素。由于所有的物理元件都具有随环境和使用时间而改变的性质，所以不能认为控制系统的参数在系统的使用寿命内是一成不变的。例如，电动机的绕线电阻在其运行时会随着温度升高而改变。带有电子元件的控制系统由于系统参数在“预热”的过程中仍在发生变化，在第一次启动时往往不能正常工作，这种现象有时被称为“早困”。大多数复印机在第一次运行的时候有一个“预热”的过程，在这段时间里不做控制操作。
一般而言，一个好的控制系统应该对参数变化不敏感，而对输人指令敏感。我们来看一下参数变化时反馈对敏感度的影响。考虑图1-9所示系统，我们认为 $G$ 是可能变化的增益参数。整个系统的增益 $M$ 对 $G$ 的变化的敏感度定义为 $$ S^M_G = \frac{\partial{M}/M}{\partial{G}/M}=\frac{M变化的百分比}{G变化的百分比}\(1-3) $$ 这里 $\partial{M}$ 表示 $G$ 的增量引起的 $M$ 的增量。使用式( 1-1 )，敏感度方程可以写成 $$ S^M_G = \frac{\partial{M}}{\partial{G}}\frac{G}{M}=\frac{1}{1+GH}\(1-4) $$ 上述关系式表明: 如果 $GH$ 是正常数，可以在系统保持稳定的情况下，通过增加 $GH$ 来减小敏感度函数的幅值。显然在开环系统里，系统增益与 $G$ 的变化是一一对应的(如 $S^M_G=1$ )。如前所述，$GH$ 是频率的函数; $1+GH$ 的幅值在某些频段内可能小于1，因此反馈可能在某些情况下增大系统对参数变化的敏感度。一般地，反馈系统增益对于参数变化的敏感度取决于参数所在的位置。读者可以推导出图1-9的系统对于H的变化的敏感度。</description>
    </item>
    
    <item>
      <title>1.4 闭环控制系统 (反馈控制系统)</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.4%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:28:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.4%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>开环控制系统缺少从输出到输入的反馈，这种反馈可以提供更精确、更具适应性的控制。为了获得更精确的控制，被控信号y经反馈后与参考输人比较，输人与输出的差值经比例放大得到执行信号，并送给系统以纠正误差。具有至少- -条上述反馈路径的系统称为闭环控制系统。 $$ 图1-7闭环怠速控制系统控制框图 $$ 图1-7是一个闭环怠速控制系统框图。参考输入 $\omega_r$,设定为期望的怠速。发动机的怠速对应于参考值$\omega_r$，任意偏差(如转矩 $T_L$)都会被速度变换器和误差传感器检测到。控制器根据偏差产生一个信号来调整节气阀调节角 $\alpha$ 以消除误差。图1-8比较了开环与闭环怠速控制系统的典型响应特性。在图1-8a中加入负载转矩$T_L$后，开环系统的怠速会降低并稳定在-一个较低值上; 在图1-8b中，加 $T_L$ 后闭环系统的速度会迅速恢复到设定值。 $$ a)开环怠速控制系统的典型响应 $$ $$ b)闭环怠速控制系统的典型响应 $$ $$ 图1-8开环与闭环怠速控制系统的典型响应对比 $$</description>
    </item>
    
    <item>
      <title>1.3 开环控制系统 (无反馈系统)</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.3%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E6%97%A0%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 30 Aug 2023 17:27:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.3%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E6%97%A0%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/</guid>
      <description>图1-2所示怠速控制系统并不复杂，它被称为开环控制系统。显然，该系统不能达到令人满意的性能指标。某-一时刻，根据发动机速度设置节气阀调节角 $\alpha$ 初始值后，一旦加上负载转矩 $T_L$，发动机转速不可避免地要降低。要让系统正常工作，唯一的办法是根据负载转矩的变化调节 $\alpha$,从而维持 $\omega$ 在期望的水平上。传统的电动洗衣机也是开环控制系统，因为总的洗涤时间完全是由人的判断和估计决定的。 $$ 图1-6开环控制系统的组成 $$ 开环控制系统通常由两个部分组成: 控制器与被控过程(见图1-6)。参考输入 $r$ 被用于控制器，其输出为激励信号 $u$; 激励信号作用于被控过程上，使被控变量$y$达到预先设定值。比较简单的情况下，根据系统特性，控制器可能是放大器、机械连接或者是其他控制元件;在复杂情况下，控制器可能是计算机，如微处理器等。由于开环控制系统具有简单经济的特点，其常被用于很多不重要的应用中。</description>
    </item>
    
    <item>
      <title>1.2 控制系统应用举例</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</link>
      <pubDate>Wed, 30 Aug 2023 17:24:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</guid>
      <description>1.2控制系统应用举例 随着计算机技术的发展和新材料的开发，控制系统的应用范围获得了极大的扩展。这些材料可用于开发高效的执行器和传感器，从而减少了对能源的浪费和环境的影响。这些先进的执行器和传感器几乎可以被应用到任何系统中，包括生物推进、运动、机器人、材料处理、生物医学、外科和内窥镜、航空、海洋、国防和航天工业。
下面介绍一些我们日常生活中常见的控制系统。
1.2.1　智能交通系统 汽车及其在过去两个世纪的演变可以说是人类最具有变革性的发明。多年来，许多创新使得汽车更快、更安全、更美观。人们总是希望汽车的智能化程度不断提高，而且能够提供最大程度的舒适、安全和低油耗。汽车智能系统包括空调控制系统、巡航控制系统、防死锁刹车系统(ABS)、用于在粗糙地面上减少震动的主动悬挂、高过载弯道平衡气垫、当汽车转向不足或过高时提供偏移控制的动力系统(通过有选择地启动刹车以重新获得车辆控制)、防车轮加速时抓地不牢的牵引系统、控制车辆侧倾的主动转向杆等。以下是几个例子。
线控驱动和驾驶辅助系统
新一代的智能汽车能够了解驾驶环境、定位所在位置、监控汽车健康状态、理解道路标志、监控驾驶员的表现，甚至超越驾驶员以避免事故的发生。要实现上述功能需要对现有控制系统进行大修。线控技术把传统的机械和液压系统替换为电子设备和控制系统，使用机电执行器和人机接口(或者称为触觉系统)，如踏板和转向模拟器。因此，传统的一些汽车元件，如驾驶杆、中间轴、泵、软管、流体、带、冷却器、制动助力器和主汽缸等。触觉界面可以为驾驶员提供足够的透明度，同时保持系统的安全性和稳定性。卸下笨重的机械方向盘和转向系统的其余部分在现代汽车重量的减轻和安全性方面具有明显的优势，并且由于给驾驶员创造了更大的空间而在人体工程学方面也有改善。在这方面，用驾驶员通过触觉控制的触觉装置来替换方向盘是有益的。触觉装置可以让驾驶员产生与机械方向盘相同的感觉，但是由于去除了大体积的机械系统，可以改善成本，提高安全性，同时减少燃料的消耗。
驾驶辅助系统通过感知、检测危险的性质和程度来帮助驾驶员避免或减轻事故。根据威胁的重要性和时间，车载安全系统将会尽早提醒司机即将到来的危险，并积极协助或最终进行干预，以避免事故或减轻其后果。当驾驶员由于疲劳驾驶或者是注意力不集中导致车辆失控时，辅助系统自动替代功能将是系统中的重要组成部分。在这种系统中，被称为先进车辆控制系统的装置对车辆控制进行纵向和横向的监控，并且通过与中央控制单元的交互，在被需要时可以随时对车辆进行控制。该系统可以方便地与传感器网络集成在一-起，监控道路上的各个环节，并准备以安全的方式采取适当的行动。
高级混合动力总成技术的综合应用
混合动力技术可以提高燃油的效率，同时增强驾驶体验。把新能源存储和转换技术与动力总成相结合，是混合动力技术的主要目标。这些技术必须与内燃机平台兼容，并且必须增强而不是危及车辆的功能。应用的示例包括插电式混合动力技术，其单独使用电池供电来增加车辆的巡航距离，并且利用燃料电池、能量收集(例如，通过将悬架中的振动能量或者是制动器中的能量转换为电能)或可持续能源(如太阳能和风力发电)为电池充电。智能的插电式车辆可以作为未来集成智能家居和电网能源系统的一部分，其将利用智能电能计量装置预测峰值能耗小时数，来最大限度地利用电网能源。
高性能实时控制，健康监测和诊断
现代车辆使用越来越多的传感器、执行器和网络嵌入式计算机。随着驱动系统等革 命性功能的引入，现代车辆对高性能计算的需求将会增加。将感官数据处理为适当的控 制、监测以及诊断信息所需要的巨大的计算负担为嵌入式计算技术的设计带来了挑战。 为此，与之对应的挑战是如何利用复杂的计算技术来控制、监控和诊断复杂的汽车系 统，同时满足低功耗和成本效益等要求。
1.2.2　汽车转向控制 其为图1-1所示为控制系统的简单例子，考虑汽车转向系统。被控变量或输出$y$是两个前轮的方向;激励信号或输入$u$为方向盘的方向。转向机构和整车动力系统组成了这样的控制系统或者类似的过程。如果控制汽车的速度是目的，那么施加在加速器上的压力就是激励信号，车辆速度就是被控变量。总体来说，可以认为简化的汽车控制系统有两个输入(方向盘和加速器)和两个输出(方向和速度)。这里的两个控制量和两个输出量是互相独立的，但是有些系统中的控制量之间是相互关联的。具有超过一个输人和一个输出的系统被称为多变量系统。
1.2.3　汽车怠速控制 以汽车发动机的怠速控制为例，这个控制系统的目标是: 在发动机上施加诸如传动、电力辅助转向、空调等负载的情况下，维持发动机以较低的速度空转，以降低损耗。如果没有怠速控制，任何突加于发动机的负载都会造成发动机速度陡降，甚至导致发动机熄火。因此，怠速控制系统的主要目的在于:在发动机上施加负载时，消除或尽量减少转速下降;使发动机怠速稳定在期望值上。图1-2是怠速控制系统框图。这里节气阀调节角 $\alpha$ 和负载转矩 $T_L$，(使用空调、电力辅助、转向或电L力制动产生的转矩)是输人，发动机转速 $\omega$ 是输出，发动机则是被控过程或系统。 $$ 图1-2息速控制系统控制框图 $$
1.2.4　太阳能收集器的太阳跟踪控制 为了发展经济可行的非石油源电能，人们在替代能源的开发方面已经进行了大量的研究，其包括太阳能转换方法和太阳能电池转换技术。大部分此类系统使用了太阳跟踪装置。图1-3展示了一个太阳能收集器阵列，图1-4是一个使用太阳能的高效抽水机的概念图。白天太阳能收集器产生电能把水从地下抽到蓄水池(在附近的山上)，次日清晨，蓄水池的水再被送至灌溉系统。
$$ 图1-3太阳 能收集器阵列 $$ $$ 图1-4使用太阳能的高效抽水机的概念图 $$ 太阳能收集器的一个重要特征是蝶形收集器必须精确地跟踪太阳，因此，蝶形收集器的移动必须由复杂的控制系统控制。图1-5所示控制框图描绘了太阳跟踪系统及其他一些重要部件的常见结构。控制器在清晨发出“开始跟踪”命令并保证收集器始终对着太阳。控制器在白天不断计算两个控制轴(方位角和仰角)的移动速度，并使用这个速度与太阳传感器获得的信息作为输人来启动适当的电动机指令，从而转动收集器。 $$ 图1-5太阳跟踪装置的重要部件 $$</description>
    </item>
    
    <item>
      <title>1.1 控制系统的基本组成部分</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.1%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 30 Aug 2023 17:23:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.1%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
      <description>本章的目的是使读者熟悉以下几方面的内容:
什么是控制系统。 控制系统的重要性。 控制系统的基本组成部分。 控制系统应用例子。 为什么绝大多数控制系统均具有反馈。 控制系统的分类。 在过去的50年里，控制系统在现代文明和技术的发展和进步中发挥着越来越重要的作用。它几乎影响着我们日常活动的方方面面。例如在家中，我们需要控制房间内的温度和湿度以使生活舒适。在工业上，制造过程中的大量产品需要达到一定的指标，这些指标要满足精度和成本利润的要求。一个人要能够完成包括做各种决策在内的各种类型的任务。有些任务通常是-一种程序化的方式，例如捡起物体后从一个地方走到另外一个地方。在某些情况下，一些任务需要按照尽可能好的方式去完成。例如在百米短跑中，运动员希望以尽可能短的时间跑完全程。而对于一名马拉松选手来说，他不仅需要尽可能快地跑完，还需要控制好在这个过程中的能量消耗并设计最好的比赛策略。为了实现这些“目标”，通常需要引人能够执行某种控制策略的控制系统。
控制系统已经大量应用到工业的各个部门，比如产品质量控制、自动装配线、机床控制、空间技术、计算机控制、交通系统、电力系统、机器人、微机电系统( MEMS)、纳米技术等，甚至包括社会与经济系统。具体地说，控制系统的应用领域包括:
过程控制，实现工业环境下的自动化和批量生产。
机床，改善精度并提高生产效率。
机器人系统，实现运动和速度控制。
运输系统，现代汽车和飞机的各种功能涉及控制系统。
微机电系统，微型机电装置，如微型传感器和微型执行器。
芯片实验室，在只有几毫米至几平方厘米大小的芯片上同时进行用于医疗诊断或者是环境监测的几项实验任务。
生物力学和生物医学，人造肌肉、药物输送系统和其他辅助技术。
1.1 控制系统的基本组成部分 控制系统的基本组成部分包括:
控制目标。 控制系统(元件)。 结果或输出。 $$ 图1-1 控制系统的基本组成部分 $$
上述三部分之间的基本关系如图1-1所示，此控制框图提供了一种图形化的方法来描述控制系统的元件如何进行交互。我们稍后将在第4章中进行讨论。在这种情况下，控制目标可由输入(或者称为激励信号 u)和输出(或者称为被控变量 y)确定。一般而言，控制系统的目标在于通过输入，经由控制元件, 以某种预先设定的方式来控制输出。</description>
    </item>
    
    <item>
      <title>自动控制系统目录</title>
      <link>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Tue, 29 Aug 2023 17:08:35 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</guid>
      <description>第1章　绪论 1.1　控制系统的基本组成部分 1.2　控制系统应用举例 1.2.1　智能交通系统 1.2.2　汽车转向控制 1.2.3　汽车怠速控制 1.2.4　太阳能收集器的太阳跟踪控制 1.3　开环控制系统（无反馈系统） 1.4　闭环控制系统（反馈控制系统） 1.5　反馈的含义及其作用 1.5.1　反馈对于总增益的影响 1.5.2　反馈对于稳定性的影响 1.5.3　反馈对于外部干扰或噪声的作用 1.6　反馈控制系统的类型 1.7　线性系统与非线性系统 1.8　时不变与时变系统 1.9　连续控制系统 1.10　离散控制系统 1.11　案例研究：基于LEGOMINDSTORMS 的智能车辆避障 1.12　小结 第2章　动态系统的建模 2.1　简单机械系统的建模 2.1.1　平移运动 2.1.2　旋转运动 2.1.3　平移和旋转运动之间的转换 2.1.4　齿轮系 2.1.5　齿隙和死区（非线性特性） 2.2　简单电气系统的建模 2.2.1　无源电气元件建模 2.2.2　电气网络建模 2.3　简单热系统和简单流体系统的建模 2.3.1　热系统的基本属性 2.3.2　流体系统的基本属性 2.4　非线性系统的线性化 2.5　类比 2.</description>
    </item>
    
    <item>
      <title>12.7 PMOS、NMOS和E2CMOS</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-7pmosnmos%E5%92%8Ce2cmos/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-7pmosnmos%E5%92%8Ce2cmos/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.6 发射极耦合逻辑-ECL电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:24 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.5 CMOS和TTL性能的比较</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.4 TTL在实际使用中的注意事项</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.3 TTL电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-3ttl%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-3ttl%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.2 CMOS电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-2cmos%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:24 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-2cmos%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.1 基本操作特性和参数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.4 数字信号处理基础</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.3 数—模转换方法</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:38 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.2 模—数转换方法</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.1 模拟信号转换为数字信号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.8 磁和光存储</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.7 特殊类型的存储器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.6 存储器扩展</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.5 闪存</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-5%E9%97%AA%E5%AD%98/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-5%E9%97%AA%E5%AD%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.4 可编程ROM[PROM和EPROM]</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/</link>
      <pubDate>Fri, 21 Jul 2023 22:29:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.3 只读存储器-ROM</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/</link>
      <pubDate>Fri, 21 Jul 2023 22:28:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.2 随机存储器-RAM</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/</link>
      <pubDate>Fri, 21 Jul 2023 22:28:08 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.1 半导体存储器基础</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 21 Jul 2023 22:27:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.9 关联标注的逻辑符号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:27:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.8 移位寄存器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.7 移位寄存器计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:39 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.6 双向移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:26 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.5 并行输入/并行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.4 并行输入/串行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:25:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.3 串行输入/并行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:25:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.2 串行输入/串行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.1 基本移位寄存器的功能</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.8 关联标注的逻辑符号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.7 计数器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.6 计数器译码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.5 级联计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.4 同步计数器的设计</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 21 Jul 2023 22:22:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.3 加/减同步计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:58 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.2 同步计数器运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.1 异步计数器运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.6 非稳态多谐振荡器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.5 单稳态触发器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.4 触发器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.3 触发器运算特性</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.2 边沿触发器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:19:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.1 锁存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-1%E9%94%81%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:19:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-1%E9%94%81%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.10 奇偶发生器/校验器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:55 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.9 多路分配器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.8 多路复用器-数据选择器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.7 代码转换器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:58 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.6 编码器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-6%E7%BC%96%E7%A0%81%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-6%E7%BC%96%E7%A0%81%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.5 译码器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-5%E8%AF%91%E7%A0%81%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-5%E8%AF%91%E7%A0%81%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.4 比较器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-4%E6%AF%94%E8%BE%83%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-4%E6%AF%94%E8%BE%83%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.3 异步进位与超前进位加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:16:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.2 并行二进制加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:16:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.1 基本加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:15:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.5 具有脉冲波形输入的逻辑电路运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:15:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.4 使用与非门和或非门的组合逻辑</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.3 与非门和或非门的通用特性</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.2 组合逻辑电路的实现</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.1 基本组合逻辑电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:13:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.10 5变量的卡诺图</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/</link>
      <pubDate>Fri, 14 Jul 2023 19:07:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.9 卡诺图乘积项之和的最小化</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/</link>
      <pubDate>Fri, 14 Jul 2023 19:07:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.8 卡诺图</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.7 布尔表达式和真值表</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.6 布尔表达式的标准形式</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.5 使用布尔代数进行化简</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.4 逻辑电路的布尔分析</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.3 狄摩根定理</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:42 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.2 布尔代数的定律和法则</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.1 布尔运算和表达式</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.7 固定功能逻辑</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/</guid>
      <description>3.7.1 逻辑系列 数字逻辑电路的三个系列是 CMOS(互补金属氧化物半导体)、双极型和 BiCMOS(双CMOS)。这三种电路器件实现内部逻辑功能的类型不同。CMOS 是由场效应管(FET)来实现，双极型(也称为TTL，即晶体管-晶体管逻辑)逻辑使用双极型晶体管来实现，而 BiCMOS 是前面两种的组合。这些逻辑器件系列的基本逻辑功能相同，但是工作参数不同，例如开关速度(传输时间)、功率损耗和抗干扰能力。CMOS 与门和双极型或 BiCMOS 与门的逻辑功能相同。对于所有其他功能的逻辑器件也一样。
CMOS 在这些逻辑系列中，CMOS占有主导地位，双极型显然要被淘汰，BiCMOS 具有的逻辑功能类型也有限。在 CMOS 系列中，按不同的使用电压、功率损耗、开关速度和一些其他参数分为许多种类。表3.14列出了更多的常用 CMOS 逻辑电路,按各种器件的电路运行和优化的直流工作电压进行区分。 $$ 表3.14 ~~~CMOS逻辑器件的种类 $$
名称 描述 $V_{CC}$ AC 高级CMOS 5.0 V ACT 具有双极型兼容输入的高级CMOS 5.0 V AHC 高级高速CMOS 5.0 V AHCT 具有双极型兼容输入的高级高速CMO 5.0 V ALVC 高级低电压CMOS 3.3 V AUC 高级超低电压CMOS 1.8 V AUP 高级超低功耗CMOS 3.3 V AVC 高级甚低电压CMOS 2.5 V CD4000 标准CMOS 5.0 V FCT 快速CMOS技术 5.0 V HC 高速CMOS 5.0 V HCT 具有双极型兼容输入的高速CMOS 5.</description>
    </item>
    
    <item>
      <title>3.6 异或门和同或门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/</guid>
      <description>3.6.1 异或门 异或门(XOR)的标准符号如图3.42所示。异或门只有两个输入。异或门的运算功能为模-2加法(第2章介绍过)。只有当两个输入处于相反的逻辑电平时，异或门的输出才是高电平。根据输入 A 和输入 B 及输出 X，它的运算可以做如下表述:
对于异或门来说，如果输入 A 是低电平而输入 B 是高电平，或者输入 A 是高电平而输入 B 是低电平，那么输出 X 就是高电平; 如果 A 和 B 都是高电平或者都是低电平，那么输出 X 为低电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~(b)具有异或门的矩形轮廓 $$ $$ 图3.42~~~~异或门的标准逻辑符号 $$
◇ 对于异或门来说,相反的两个输入产生高电平输出。 异或门的所有 4 个可能的输入组合及输出结果如图3.43所示。高电平是有效或者是确定电平，只有当两个输入相反时才会输出高电平。异或门的运算总结在表3.11中。 $$ 图3.43~~~异或门的所有输入逻辑电平和相应的输出电平。打开文件F03-43检验异或门操作 $$
$$ 表3.11~~~异或门的真值表 $$
输入A 输入B 输出X 0 0 0 0 1 1 1 0 1 1 1 0 3.6.2 同或门 同或门(XNOR)的标准符号如图3.45所示。和异或门相似，同或门也只有两个输入。同或门符号输出位置上的小圆圈指示它的输出和异或门的输出是相反的。当两个输人逻辑电平相反时，同或门的输出就是低电平。这个运算可以做如下表述(A 和 B 是输入,X 是输出):
对于同或门来说，如果输入 A 是低电平而输入 B 是高电平，或者 A 是高电平，B 是低电平，输出 X 就是低电平;如果输入 A 和输入 B 都是高电平或者都是低电平，输出 X 就是高电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)长方形轮廓 $$ $$ 图3.</description>
    </item>
    
    <item>
      <title>3.5 或非门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-5%E6%88%96%E9%9D%9E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-5%E6%88%96%E9%9D%9E%E9%97%A8/</guid>
      <description>◇ 除了输出反相之外，或非门和或门相同。 术语或非(NOR)是非-或(NOT-OR)的缩写，意指具有反相(反码)输出的或运算。2输入或非门和与之等价的或门后面再加反相器的标准逻辑符号，如图3.34(a)所示。图3.34(b)给出了矩形轮廓符号。
$$ (a)特殊形状，2输入或非门和等价的非-或门~~~~~~~~~~~~~~~~~~(b)矩形轮廓,具有极性指示的2输入或非门 $$ $$ 图3.34~~~标准或非门逻辑符号(ANSI/IEEE标准91-1984) $$
3.5.1 或非门的运算 当任何一个输入为高电平时，或非门就输出一个低电平。只有当所有的输入是低电平时，输出才是高电平。对于 2 输入或非门的情况，如图3.34所示，输人被标为 A 和 B，输出被标记为 X，该运算可以做如下表述:
对于 2 输入或非门，如果输入 A 或 B 为高电平，或者 A 和 B 都是高电平，输出 X 就是低电平; 如果 A 和 B 都是低电平，输出X就是高电平。
这个运算产生和或门相反的输出电平。在或非门中，低电平输出是有效的或者是确定的输出电平，由输出的小圆圈所表示。图3.35说明了2输入或非门的运算，包括所有可能的4种输入组合,而表3.9是2输入或非门的真值表。 $$ 图3.35~~~2输人或非门的操作。打开文件F03-35检验或非门操作 $$
$$ 表3.9~~~2输入或非门的真值表 $$
输入A 输入B 输出X 0 0 1 0 1 0 1 0 0 1 1 0 1=高电平, 0=低电平
3.5.2 波形输入的运算 下面的两个例子给出了具有脉冲波形输人的或非门运算。和其他类型的门一样，只要遵循真值表就可以确定输出波形和输入的正确时间关系。
或非门的非-与等价运算 或非门和与非门相似，但具有其运算的另一个方面，也就是固有的逻辑函数功能。表3.9给出了只有当所有的输入都是低电平时，才会产生高电平输出。从这一点来说，或非门可以用做需要所有的低电平输入来产生高电平输出的与运算。或非门的这个功能称为非-与。这里术语“非”意指低电平输入有效或低电平为确定状态。
对非-与运算的 2 输入或非门来说，如果输入 A 和 B 都是低电平时, 输出 X 就是高电平。</description>
    </item>
    
    <item>
      <title>3.4 与非门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:42 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/</guid>
      <description>◇ 除了输出被反相之外，与非门和与门是一样的。 词汇与非(NAND)是非-与(NOT-AND)的缩写，意思是具有反码(反相)输出的与函数。2输入的与非门的标准逻辑符号和一个与门其后再加一个反相器的电路图等价，如图3.26(a)所示，其中符号=的意思是恒等于。图3.26(b)给出了矩形轮廓符号。
$$ (a)特殊形状，2输入与非门及等价的与门+非门~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)矩形轮廓，具有极性指示 $$
$$ 图3.26~~~标准与非门逻辑符号(ANSI/IEEE标准91-1984) $$
3.4.1与非门的运算 只有所有的输入都是高电平时，与非门才会输出其低电平。当任何一个输入为低电平时，输出就是高电平。2输人与非门的一个具体例子如图3.26所示，其中输人被标为 A 和 B,输出被标为 X,该运算可以进行如下表述:
对于一个2输入与非门，当输入 A 和 B 都是高电平时，输出X就是低电平; 当输入 A 或 B 为低电平，或者 A 和 B 都是低电平时,输出 X 就是高电平。
注意，这个运算和与门输出电平的运算是相反的。在一个与非门中，低电平(0)是有双蚁确定的输出电平，由输出的小圆圈所表示。图3.27说明了 2 输入与非门的所有 4 种可能组合，而表3.7是把 2 输入与非门的所有逻辑运算汇总后的真值表。
$$ 图3.27~~~2输入与非门的运算。打开文件F03-27检验与非门操作 $$
$$ 表3.7~~~2输入与非门的真值表 $$
输入A 输入B 输出X 0 0 0 0 1 0 1 0 0 1 1 1 1=高电平,0=低电平
3.4.2波形输入的运算 现在来看与非门的波形运算。从真值表可以知道，仅当所有的输人为高电平时，输出才是低电平。
与非门的非-或等价运算 与非门运算的内在特性是这样的: 一个或者多个低电平输人产生一个高电平输出。表3.7给出了当任何一个输入 A 和 B 是低电平(0)时，输出就是高电平(1)。从这个观点来看，与非门可用于需要一个或者多个低电平输入并且产生高电平输出的或运算。与非门运算的这个功能称为非-或运算。术语“非”在上下文中意思是当输入为低电平时，输人就被定义为处于有效或者确定状态。</description>
    </item>
    
    <item>
      <title>3.3 或门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-3%E6%88%96%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-3%E6%88%96%E9%97%A8/</guid>
      <description>◇ 或门可以具有多于两个的输入。 或门(OR gate)具有两个或者更多的输入及一个输出，如图3.18所示的标准逻辑符号给出了具有两个输人的或门。或门可以具有多于一个的任意输入。虽然同时给出了特殊形状和矩形轮廓符号，但是本书使用的是特殊形状符号。
$$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)具有OR(≥1)限定符号的矩形轮廓 $$ $$ 图3.18 ~~~或门的标准逻辑符号，图中给出了两个输入的或门(ANSI/IEEE标准91-1984) $$
3.3.1 或门的运算 ◇ 有一个以上的输入是高电平时，或门的输出就是高电平。 当任意一个输人为高电平时，或门的输出就为高电平。当且仅当所有的输入是低电平时，输出才会是低电平。所以，或门用来判断它的输入是否有一个或者多个高电平,有高电平输入时，输出一个高电平以表明条件满足。图3.18中2输人或门的输入被标以A和B，输出则被标以X，或门的运算可以做如下表述:
对于一个 2 输入或门来说，如果输入 A 和输入 B 中有一个是高电平，或者两者都为高电平,输出 X 就为高电平; 仅当 A 和 B 都是低电平时，X 为低电平。
高电平是或门的有效或者肯定输出电位。图3.19给出了2输人或门的所有 4 种可能输人组合的输人和输出结果。
$$ 图3.19 ~~~2输人或门的所有可能逻辑电位。打开文件F03-19检验或门操作 $$
3.3.2 或门真值表 表3.5描述了2输入或门的运算。这个真值表可以扩展到任意个数的输入;但是不管有多少输入，当有一个或者多个输入是高电平时，输出就是高电平。 $$ 表3.5~~~2输入或门的真值表 $$
输入 输入 输出 0 0 0 0 1 1 1 0 1 1 1 1 1=高电平,0=低电平
3.3.3波形输入的运算 现在观察具有波形输入的或门运算，并请记住它的逻辑运算。再有，分析具有脉冲波形的或门运算的关键是涉及的所有波形的时间关系。例如，在图3.20 中，在时间间隔 $t_1$ 期间，A 和 B 都是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_2$ 期间,输入A是低电平0，但是输入 B 是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_3$ 期间,两个输入都是低电平 0,所以输出 X 为低电平 0。在时间间隔 $t_4$ 期间，两个输人都是高电平 1，所以输出 X 为高电平 1。</description>
    </item>
    
    <item>
      <title>3.2 与门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-2%E4%B8%8E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-2%E4%B8%8E%E9%97%A8/</guid>
      <description>名词“门&amp;quot;用以描述运行基本逻辑运算的电路。与门(AND gate)由两个或者更多的输入和一个输出组成，由图3.8中的标准逻辑符号所表示。输入位于左边，而输出位于每个符号的右边。图中给出具有两个输入的与门;但是，与门可以有大于两个的任意输入。虽然给出了特殊形状符号和矩形轮廓符号，但是本书主要使用图3.8(a)中的特殊形状符号。
(a)特殊形状_____________________________(b)具有与(&amp;amp;)限定符号的矩形轮廓
$$ 图3.8~~~与门的标准逻辑符号，给出了两个输入(ANSI/IEEE标准91-1984) $$
3.2.1与门的运算 ◇ 与门可以具有多于两个的输入。 当且仅当与门所有的输人都是高电平时，才会输出高电平。当任何一个输入为低电平时，输出就是低电平。所以，与门的基本用途即判断若干条件是否同时为真，为真时所有的输入是高电平,并且在输出产生高电平以表示所有的条件都为真。图3.8中的2输入与门的输入被标记为 A 和 B，而输出被标记为 X。与门运算可以表述为
对于 2 输入与门，当输入 A 和 B 都是高电平时，输出 X 为高电平;当 A 或 B 是低电平，或者 A 和 B 都是低电平时, X 就是低电平。
图3.9给出了一个 2 输人与门，同时列出了所有 4 种可能的输入组合，以及每个与门相对应的输出。
$$ 图3.92~~~输入与门的所有可能逻辑电平。打开文件 F03-09检验与门操作 $$
3.2.2与门真值表 ◇ 对于一个与门来说，输入都是高电平时才会产生高电平输出 $$ 表3.2 ~~~2输入与门的真值表 $$ 输入 输入 输出 A B X 0 0 0 0 1 0 1 0 0 1 1 1 1 = 高电平,0 = 低电平</description>
    </item>
    
    <item>
      <title>3.1 反相器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/</guid>
      <description>反相器的标准逻辑符号如图3.1所示,(a)图给出了特殊形状符号,(b)图给出了矩形轮廓符号.在这本书中,一般使用特殊形状符号;但是,矩形轮廓符号常常出现在许多工业出版物中,所以也应该熟悉它们.(逻辑门符号依据 ANSI/IEEE 标准 91-1984.)
3.1.1 否定和极性指示 $$ (a)具有否定指示的特殊形状符号~~~~~~~~~~(b)具有极性指示的矩形轮廓符号 $$ 否定指示是一个小圆圈(o),当其出现在任何逻辑元件的输入或者输出位置时,为反相或者为反码,如图3.1(a)的反相器所示.一般情况下,输入位于逻辑符号的左侧而输出位于右侧.当出现在输人位置时,小圆圈就表示 0 电平有效或者是确定的输入状态,而这个输入称为低电平有效输人.当出现在输出位置时,该小圆圈就指明0有效或者是确定的输出状态,而这个输出称为低电平有效输出.当输人或者输出没有小圆圈时,就表示1是有效的或者是确定的状态,而这个输入或输出称为高电平有效.
极性或者电平指示是一个&amp;quot;三角形&amp;quot;(◣),当其出现在任何逻辑元件的输人或者输出位置时,表示反相,如图3.1(b)所示.当其出现在输入位置时,就表示低电平是有效的或者是确定的输人状态.当其出现在输出位置时,就表示低电平是有效的或者是确定的输出状态.
两种指示(小圆圈或三角形)都可以用在特殊形状符号和矩形轮廓符号中.图3.1(a)给出的是本书后面主要使用的反相器.注意反相或极性指示的不同放置并不意味着反相器运算方式的改变.
3.1.2 反相器真值表 当反相器的输入是高电平时，它的输出就是低电平。当反相器的输入是低电平时，它的输出就是高电平。这种运算总结于表3.1中，表中以电平和对应的位值给出了每个可能的输入和与之对应的输出。这样的表称为真值表。 $$ 表3.1~~~反相器真值表 $$
输入 输出 低(0) 高(1) 高(1) 低(0) 3.1.3 反相器运算 图3.2给出了反相器脉冲输入和相应的输出，其中 $t_1$ 和 $t_2$ 指明了在输人和输出波形上相对应的点。
当输入为低电平时，输出就是高电平; 当输入是高电平时,输出就是低电平，因此产生反相的输出脉冲。
$$ 图3.2~~~具有脉冲输入的反相运算。打开文件FO3-02检验反相操作 $$
3.1.4 时序图 ◇ 时序图给出了两个或者更多的波形在时间上的相互关系。 回顾第1章我们知道，基本上时序图是基于时间的、准确显示两个或者更多波形相互之间关系的图形。例如，图3.2中输出脉冲和输人脉冲的时间关系，可以用一个时序图把两个脉冲对准,从而使得这些脉冲边沿的发生以正确的时间关系展现出来。输入脉冲的上升沿和输出脉冲的下降沿在相同的时间出现(理想状态)。类似地,输入脉冲的下降沿和输出脉冲的上升沿在相同的时间出现(理想状态)。这种时序关系如图3.3所示。实际上，从输入的变化到输出的变化有一个非常小的延迟。时序图在说明具有多个脉冲的数字波形之间的时间关系时特别有用。
$$ 图3.3~~~在图3.2条件下的时序图 $$
3.1.5 反相器的逻辑表达式 ◇ 布尔代数使用变量和运算符来描述逻辑电路。 在布尔代数(它是逻辑电路的数学基础并且将在第4章得到全面的介绍)中，变量可以由多个字母表示，但是通常由一个或两个字母表示。接近字母表中开始位置的通常表示输人，而接近结束位置的通常表示输出。变量的反码由字母上方的横杠来表示。变量可取的值是 1 或者 0。如果一个变量是 1，它的反码就是 0，反之亦然。
反相器(非门电路)的运算可以用下面的方式表示: 如果输入变量为 A,输出变量为 X，那么 $$ X=\overline{A} $$ 这个表达式说明输出是输入的反码,所以如果 A=0，那么 X =1; 而如果 A=1，那么 X =0。图3.</description>
    </item>
    
    <item>
      <title>2.12 错误检测码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/</guid>
      <description>2.12.1错误检测的奇偶校验法 ◇ 奇偶校验位给出一个数中1的个数是奇数还是偶数. 许多系统都使用一个奇偶校验位,作为位错误检测的手段.任意的多位数组都包含奇数个 1或偶数个 1.将一个奇偶校验位附加到多位数组中,使得这组数中 1 的个数总是偶数或者总是奇数.一个偶校验位使得 1 的总数为偶数,而奇校验位使得 1 的总数为奇数.
一个给定的系统运行于偶校验或者奇校验,而不是同时运行于两者.例如,如果某系统运行于偶校验,则对于所接收的每一个多位数组都做一个检查,以确保这个多位数组中 1 的总数是偶数.如果有奇数个 1,就有一个错误发生了.
作为对奇偶校验位怎样附加到编码中的一个说明,表2.7列出了每个BCD码的偶校验和奇校验的奇偶校验位.每个BCD码的校验位处于P列上. $$ 表2.7~~带奇偶校验位的 ~BCD ~码 $$ $$偶校验$$
校验位 P BCD 0 0000 1 0001 1 0010 0 0011 1 0100 0 0101 0 0110 1 0111 1 1000 0 1001 $$奇校验$$
校验位 P BCD 1 0000 0 0001 0 0010 1 0011 0 0100 1 0101 1 0110 0 0111 0 1000 1 1001 奇偶校验位可以附加到码的开头或者结尾,这取决于系统的设计.</description>
    </item>
    
    <item>
      <title>2.11 数字编码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</guid>
      <description>2.11.1格雷码 格雷(Gray)码是无权码,并不是算术编码;也就是没有赋予不同位的特足的权.恰雷俏的重要特征是,从一个码字到下一个接续码字仅有一位发生了变化.这个特征在许多应用程序中是非常重要的,例如对于轴位编码器,在两个相邻顺序数之间,错误敏感度随着位数改变数目的增加而增加.
◇ 格雷码的一位改变的特征减小了出错概率. 表2.6列出了十进制数 0~15 所对应的 4 位格雷码,表中给出了二进制数以做参照.和二进制数相似,格雷码可以拥有任意的位数.注意两个相邻的格雷码字之间的一位变化.例如,从十进制数 3 到十进制数 4,格雷码从 0010 变为 0110,而二进制编码从 0011 变为 0100 改变了 3 个位.格雷码中唯一的位改变是从右数的第 3 位,其他位保持不变. $$ 表2.6 ~~~4位格雷码 $$
10进制 2进制 格雷码 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 二进制数到格雷码的转换 二进制数和格雷码之间的转换有时很有用.</description>
    </item>
    
    <item>
      <title>2.10 二—十进制编码-BCD</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/</guid>
      <description>2.10.1 8421 BCD码 ◇ 在 BCD码中,每个十进制数都由 4 位二进制编码表示. 8421 码是 BCD(二-十进制编码)码的一种类型.二-十进制编码的意思是,每一个十进制数,从 0~9,都由 4 位二进制编码表示.名称 8421 表明了 4 个位的二进制权($2^3,~2^2,~2^1,~2^0$).这种编码的主要优点是,8421 编码数和我们熟悉的十进制数之间很容易转换.只要记住 10 个十进制数的二进制组合,如表2.5所示.8421 码是主要的 BCD 码,所以当我们提及 BCD 码时,总是指 8421 码,除非有特殊的说明.
$$ 表2.5~~10进制/BCD转换 $$
10进制 0 1 2 3 4 5 6 7 8 9 BCD 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 无效码 应当认识到,使用4个位可以表示 16 个数(从0000 到1111),但是在 8421 码中,在这 16 个数中只使用了 10 个数.未使用的编码组合为 1010,1011,1100,1101,1110,1111,它们在 8421 BCD 码中是无效的.
为了以 BCD 码表示任意十进制数,只要将每个十进制数位用相应的 4 位编码替代就可以了,如例2.</description>
    </item>
    
    <item>
      <title>2.9 八进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>八进制数字系统由8个数位组成,它们是
$$ 0，~1,~2，~3,~4，~5,~6，~7 $$
要计大于 7 的数，则从另一列重新开始:
$$ 10,~11 ，~12，~13，~14，~15~，16，~17，~20，~21 ,… $$
八进制数字系统的基是 8。 八进制计数和十进制计数比较相似，不同的是没有使用数字 8 和 9。为了区别八进制数和十进制数或者十六进制数，我们使用下标 8 来表示八进制数。例如，八进制 $15_8$ 等于十进制数 $13_{10}$ 和十六进制数D。有时会看到八进制数后面跟随“o”或者“Q”。
2.9.1 八进制数到十进制数的转换 由于八进制数的基是 8,因此每一个相继的数位都是 8 的递增幂，从最右边 $8^0$ 开始, 计算八进制数的相应十进制数的数值，可以通过把每一个数字都乘以其相应的权，并把所得到的积加起来。下面展示了 $2374_8$ 的转换过程。
2.9.2 十进制数到八进制数的转换 把十进制数转换为八进制数的方法，即重复除以 8 的方法，这和十进制数到二进制数或十六进制数的转换方法相似。为了给出这个过程，我们把十进制数 359 转换为八进制数，以 8 为除数的每一次相继相除都会产生一个余数，而这个余数就会成为相应八进制数的数位。所产生的第一个余数是最低有效数(LSD)。 2.9.3 八进制数到二进制数的转换 ◇ 八进制是表示二进制数的简洁方法，但是并没有十六进制数常用。 因为每一个八进制数位都可以由一个 3 位二进制数来表示，所以八进制数转换为二进制数很容易。每一个八进制数位由 3 位二进制数表示，如表2.4所示。 $$ 表2.4 ~~~8进制/2进制转换 $$
8进制 0 1 2 3 4 5 6 7 2进制 000 001 010 011 100 101 110 111 为了把八进制数转换为二进制数，只要用相应的 3 位二进制数替换每个八进制数位就可以了。这个过程如例2.</description>
    </item>
    
    <item>
      <title>2.8 十六进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>◇ 十六进制数字系统由数字 0~9 和字母 A~F 组成.
十六讲制数字系统的基是 16,也就是它由 16 个数字和字母共同组成.大多数的数字系统都能成组处理二进制数,即多个4位的组合,这样使用十六进制非常方便,因为每一个十六进制数位就代表了一个 4 位二进制数(如表2.3所示).
10 个数字和 6 个字母字符构成了十六进制数字系统.使用字母 A,B,C, D,E,F 表示数字,初看起来很奇怪,但是请记住任何一种数字系统都是有序符号的集合而已.如果已经理解这些符号表示哪些数,一旦习惯了它们的使用方式,这些符号本身就不重要了.我们将使用下标 16 来指明十六进制数以避免和十进制数相混淆.有时可能会看到十六进制数后面跟随一个&amp;quot;h &amp;ldquo;.
$$ 表2.3 $$
10进制数 2进制数 16进制数 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 2.</description>
    </item>
    
    <item>
      <title>2.7 带符号数的算术运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</guid>
      <description>2.7.1 加法 加法中的两个数就是加数和被加数,结果是和.当两个带符号二进制数相加时,有以下4种情况.
两个数都是正的. 正数的数值大于负数的数值. 负数的数值大于正数的数值. 两个数都是负的. 这里使用 8 位带符号数,每次给出一种情况作为例子,也给出相应的十进制数作为对照
◇ 两个正数相加产生一个正数.
两个数都是正的:
和是正的,因而是二进制原码(非补码).
◇ 正数和负数相加产生一个正数.
正数的数值大于负数的数值:
最后的进位被舍去.和是正的,因而是二进制原码(非补码).
◇ 一个正数加上一个较大的负数或者两个负数相加时,生成一个补码形式的负数.
负数的数值大于正数的数值:
和是负的,所以是补码形式.
两个数都是负的:
最后的进位被舍去.和是负的,所以是补码形式.
在计算机中,负数是以补码形式保存的,所以正如所见,加法过程是很简单: 将两个数加起来,并舍去最后的任何进位.
溢出条件 当两个数加在一起,而表示和所需的位数超出了这两个数的位数,这时就会发生溢出,并由一个错误符号位指明.溢出仅发生在两个都是正数或者两个都是负数的情况下.如果相加结果得到的符号位和相加的两个数的符号不同,就表明发生了溢出.下面的 8 位数例子将说明这种情况.
在这个例子中,和 183 需要 8 个数值位.由于数中只有 7 个数值位(有一位是符号位),这时进位就会进人符号位,从而产生溢出指示.
一次加两个数 现在让我们看看数字串相加的情况,即一次加两个数.可以这样操作,首先将前两个数相加,然后两数之和加第三个数,然后再在此和的基础上加第四个数,以此类推.这就是计算机中数字串的相加方法.一次加两个数的方法如例2.19所示.
2.7.2 减法 ◇ 减法是将减数符号改变后的加法.
减法是加法的一个特例.例如,从　＋9(被减数)中减去　＋6(减数)就相当于　+9　加上　-6.基本上,减法运算是改变减数的符号然后加上被减数的运算.减法的结果称为差.
正二进制数或者负二进制数的符号通过求此数的补码而改变.
例如,求取正数　00000100 (+4)的补码时,就会得到　11111100,这就是　–4,权和的计算如下: $$ -128~+64~+32~+16~+8~+4=-4 $$ 作为另一个例子,当取负数 11101101 (-19)的补码时,就会得到 00010011,这就是＋19,权和的计算如下: $$ 16~+2~+1~=~19 $$
◇ 当用补码的方法进行二进制减法时,重要的是两个数要有相同的位数.
由于减法仅仅是减数符号改变后的加法,所以该过程有如下的表述方式:
要将两个带符号数相减,取减数的补码然后相加即可.舍去最后的任何进位.
2.7.3 乘法 乘法中的数分别是被乘数,乘数及积.</description>
    </item>
    
    <item>
      <title>2.6 带符号数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:43 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>2.6.1 符号位 二进制符号数的最左边就是符号位,指出这个数是正数还是负数.符号位 0 表示正数,1 表示负数.
2.6.2 符号数值的形式 当以符号数值的形式表示带符号二进制数时,最左边的一位是符号位,其余的都是数值位.数值位对于正数和负数来说都是二进制原码(非补码).例如,十进制数＋25表示为符号数值的形式就是一个 8 位带符号二进制数,使用符号数值的形式为
十进制数-25表示为 $$ 10011001 $$ 注意 ＋25 和 –25 之间的唯一区别是符号位,因为对于正数和负数来说,数值位都是二进制原码.
在符号数值的形式中,负数和其相应的正数具有相同的数值位,但其符号位为 1 而不是 0.
2.6.3 反码形式 以反码形式表示正数的方法和以符号数值形式表示正数的方法是一致的.但是,负数却是其相应正数的反码.例如,使用 8 位数字,十进制数 -25 可以表示为 +25(00011001) 的反码 $$ 11100110 $$ 在反码形式中,负数就是其相应正数的反码.
2.6.4 补码形式 正数的补码形式表示方法和符号数值与反码形式的表示方法是一致的.负数是相应正数的补码.再次使用 8 位数字,把十进制数 -25 表示为 +25(000011001) 的补码.按位取反再加 1,得到 $$ -25 =11100111 $$ 在补码形式中,负数是相应正数的补码.
2.6.5 带符号数的十进制值 符号数值 在符号数值的形式中,正数和负数的十进制值,是由所有数值位为 1 的相应权加起来得到的,不考虑那些为 0 的位.符号通过检查符号位来确定.
反码 在反码形式中,正数的十进制值是由所有为 1 的数值位相应的权加起来得到的,而不要考虑为 0 的位置.负数的十进制值是通过给符号位的权赋以负值,并把所有为 1 的数值位相应的权加起来再加上 1 得到的.</description>
    </item>
    
    <item>
      <title>2.5 二进制数的反码和补码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</guid>
      <description>2.5.1 求二进制数的反码 ◇ 改变数中的每一位以得到反码.
二进制数的反码可以通过把所有的 1 变为 0 及把所有的 0 变为 1 而得到,如下所示:
利用数字电路求二进制数反码的最简单方法是使用并行反相器(&amp;ldquo;非&amp;quot;电路),如图2.1所示,用以变换8位二进制数.
2.5.2 求二进制数的补码 ◇ 反码加 1 就可以得到补码.
二进制数的补码是通过在反码的最低有效位(LSB)上加1而获得的. $$ 补码=反码+1 $$
◇ 改变最低有效1左边的全部位求得补码.
求二进制数补码的另一种替代方法如下所示:
从右边的最低有效位开始,写下它们实际的位,包括第一个 1. 剩下的位求反码. 使用反相器和加法器可以实现二进制负数的补码,如图2.2所示.该图说明了怎样把一个8位数转换为它的补码;首先每一个位取反(取得反码),然后使用加法器电路把反码加1. $$ 图2.2~~~ 获得二进制负数补码的例子 $$ 为了把反码或者补码变回二进制原码(非补码),可以应用和前面描述的一样的过程.为了从反码回到二进制数原码,可以反转所有的位.为了从补码回到二进制数原码,可以先取得补码的反码,然后在最低有效位上加 1.</description>
    </item>
    
    <item>
      <title>2.4 二进制算术</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/</guid>
      <description>2.4.1 二进制加法 ◇ 在二进制中,1+1 = 10,而不是2.
二进制数(位)加法的 4 条基本规则如下:
0+0=0 和为0. 进位是0 0+1=1 和为1. 进位是0 1+0=1 和为1. 进位是0 1+1=10 和为10. 进位是1 注意: 前三条规则产生单个的位,而在第4条规则中,两个1相加生成二进制的2(10).二进制数在相加时,最后一种情况在低位的和为0,而在左边的高位产生了进位1,如下面的加法运算 11+1 所示:
在最右列中,1+1=0,因而在此列的左侧一列,即中间一列产生进位1.在中间一列中,1+1+0=0,因而在此列的左侧一列中产生进位1.在最左列中,1+0+0 =1.
当存在进位1时,就会遇到三个位进行加法的情况(两个数中的位和一个进位).这种情况如下所示: 2.4.2 二进制减法 ◇ 在二进制中,10 - 1 =1,而不是9.
二进制数(位)减法的4条基本规则如下:
0-0=0 1-1=0 1-0=1 10-1=1 0-1 产生借位1 进行减法运算时,有时必须从左边一列中借位.在二进制中,仅当0减去1时才需要借位.在这种情况下﹐从左边一列借来1,被减的列就会出现10,这时必须使用上面列出的4条基本规则中的最后一条.例2.8和例2.9说明了二进制减法,同时也给出了相应的十进制减法.
2.4.3 二进制乘法 ◇ 两位的二进制乘法和十进制数О和1的乘法相同.
位相乘的4条基本规则如下:
0 * 0 = 0 1 * 1 = 0 1 * 0 = 1 10 * 1 = 1 ~~ 0 - 1 产生借位1 二进制乘法和十进制乘法的运算方法是一样的.</description>
    </item>
    
    <item>
      <title>2.3 十进制数到二进制数的转换</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:56 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>2.3.1 权和的方法 ◇ 如果要把一个已知的十进制数转换为二进制数,只要求出二进制数的权,全部权加起来就是十进制数.
想要得到一个给定十进制数的二进制数,只要确定二进制数权的和,它们等于相应的十进制数.记住二进制权的简单方法是最低位为1,也就是$2^0$,任何一个权乘以2,就会得到下一个更高位的权,因此7个二进制权的序列就是64,32,16,8,4,2,l,这和上一节学到的一样.例如,十进制数9就可以由二进制权的和表示如下: $$ 9=8+1或者9=2^3＋2^0 $$ 把1放在适当的权的位置上,即 $2^3$ 和 $2^0$,把0放在 $2^2$ 和 $2^1$ 的位置上,就确定了十进制数9.
2^3 2^2 2^1 2^0 1 0 0 1 十进制数9的二进制数表达
2.3.2 重复除以2的方法 ◇要得到一个给定十进制数的二进制数,可以用2除这个十进制数直至商为0,每次余数的全部便构成了二进制数.
将十进制整数转换为二进制数的系统方法是重复除以2的过程.例如,把十进制数12转换为二进制数,首先12除以2.然后把每次得到的商都除以2,直到商为0.每次相除所得到的余数就构成了二进制数.第一个得到的余数是二进制数中的最低有效位(ISB),最后一个产生的余数是最高有效位(MSB).将十进制数12转换为二进制数的过程由下列步骤给出. 2.3.3 十进制小数转换为二进制数 例2.5和例2.6给出了整数的转换,现在来看小数的转换.记住小数二进制权的一个简单的方法是最高有效权是0.5,也就是$2^{-1}$,任何一个权除以2,就得到次低位的权;因此4个小数的二进制权的序列就是0.5, 0.25, 0.125,0.0625.
权和 权和的方法可以应用于十进制小数,如以下的例子所示: $$ 0.625= 0.5 +0.125 = 2^{-1} + 2^{-3} =0.101 $$
在$2^{-1}$位置上有一个1,在 $2^{-2}$ 位置上有一个0,而在$2^{-3}$位置上有一个1.
重复乘2 正如所见,可以用重复除以 2 的方法把十进制整数转换为二进制数.二进制小数则可以用重复乘2的方法转换得到.例如,把十进制小数 0.3125 转换为二进制数,首先把 0.3125 乘以 2,然后把每次乘积的小数部分乘以 2,直到乘积的小数部分为 0,或者达到了所需要的小数位数. 由相乘产生的进位数字或者进位,就生成了二进制数. 所产生的第一个进位是最高有效位(MSB),最后一个进位是最低有效位(LSB).该过程如下所示: </description>
    </item>
    
    <item>
      <title>2.2 二进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>2.2.1 二进制计数 ◇ 二进制数字系统有两个数字(位).
下面学习二进制系统的计数方法.首先看一下十进制系统的计数方法.在用完数字之前,从О开始,依次计数到9.然后从另一个数位开始(左边),继续从10计数到99.此时已经用完了两位数字的所有组合,所以需要第三个数位,从100计数到999.
二进制数在计数时,也会发生类似的情况,只是这时只有两个数字,称为位(比特).开始计数:0,1.此时,已经使用了两个数字,所以加入另一个数位继续计数:10,11.至此,已经使用了两个数字的所有组合,所以需要第3个数位.使用3个数位,可以继续计数:100,101,110,111.还要继续下去,就需要第4个数位,以此类推.从0到15的二进制计数方法如表2.1所示.注意在每一列中1和0的交替规律.
◇ 二进制数字系统的基为2.
如表2.1所示,从О计数到15需要4个数位.一般来说,对于 n 个数位,可以计数到2^n-1. $$最大十进制数=2^n-1$$ 例如,若有5个数位(n =5),就可以从0计数到31. $$2^5-1= 32-1 = 31$$ 若有6个数位(n =6),就可以从О计数到63. $$2^6-1=64-1 =63$$
◇ 一个数中位的值由它在此数的位置确定.
10进制数字 2进制数字 0 0 0 0 0 1 0 0 0 1 2 0 0 1 0 3 0 0 1 1 4 0 1 0 0 5 0 1 0 1 6 0 1 1 0 7 0 1 1 1 8 1 0 0 0 9 1 0 0 1 10 1 0 1 0 11 1 0 1 1 12 1 1 0 0 13 1 1 0 1 14 1 1 1 0 15 1 1 1 1 2.</description>
    </item>
    
    <item>
      <title>2.1 十进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>十进制数字系统有10个数字.
在十进制数字系统中,10个数字中的每一个数字(从0到9)都表示某个数量.这10个符号(数字)并没有限制仅仅表示10个不同的数字量,因为可以在数字量相应的位置上分别使用这10个不同数字来表示这个数字量的大小.这10个数字的每一个最多可以从0到9表示10个数字.如果想要表示一个比9大的数字量,可以使用两个或者更多的数字位,而每一个数字所处的位置表示了这一位的大小.例如,想要表示23这个数字量,可以使用(根据它们在该数字量中相应的位置)数字2表示20这个数字量,用数字3表示3这个数字量,如下所示. 十进制数字系统的基为10.
十进制数中每一个数字所在的位置表示了这一位的大小,称之为权.整数的权是10的正次幂,从右向左递增,开始于 $10^0$= 1. $$ &amp;hellip;10^5\ 10^4\ 10^3\ 10^2\ 10^1\ 10^0 $$ 对于小数,权是10的负次幂,从左向右递减,开始于$10^{-1}$. $$ 10^2\ 10^1\ 10^0.10^{-1}\ 10^{-2}\ 10^{-3}&amp;hellip;\ \\ \\ 个-小数点 $$
数字的值取决于它在数中的位置.
十进制数的值等于每个数字乘以相应位置上的权之后的和.</description>
    </item>
    
    <item>
      <title>1.3 固定功能的集成电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</guid>
      <description>单片集成电路(IC)是一个完全由单个小型的硅芯片组成的电子电路.组成电路的所有元件-晶体管,二极管,电阻和电容是单个芯片的一部分.固定功能的逻辑和可编程的逻辑是数字集成电路的两大类型.在固定逻辑功能的芯片中,逻辑功能已由开发商写入,不能改变. $$ 图1.15一个固定功能集成芯片封装类型的剖面图(双引线封装),给出了芯片的内部连接输入/输出引脚的封装部分 $$ 图1.15给出了一个固定功能集成芯片封装类型的剖面图,其中露出了封装内部的芯片电路,标出了芯片连接封装引脚用以连接外部的各种电路.
1.3.1 集成电路封装 $$ (a)双引线封装(DIP) $$ 集成电路封装以它们安装在印制电路板(PCB)上的方法来分类,例如对穿孔封装和表面贴装等类型.对穿孔封装类型的引脚通过穿孔插入印制电路板,以便可以和另一边的导体焊接.最为普通的对穿孔封装是双引线封装(DIP),如图1.16( a)所示.
另一种集成电路封装的类型是使用表面贴装技术(SMT).表面贴装相对于对穿孔封装节省空间.通过印制电路板的孔对于表面贴装技术是多余的.表面贴装的引脚直接焊接在印制电路板一面的导体上,留出另一面用于附加的电路.其次,对于有相同引脚数的电路,表面贴装与双引线封装相比尺寸更小,因为表面贴装的引脚分布更紧凑.一个表面贴装的例子就是小轮廓集成电路(SOIC),如图1.16(b)所示.
$$(b)小轮廓集成电路(SOIC)$$ $$图1.16对穿孔和表面贴装芯片的例子.相同引脚数的 DIP比 SOIC的尺寸大, DIP大约为0.785英寸①长 , SOIC大约为0.385英寸长$$
在一种尺寸范围内可用的表面贴装技术的不同类型,取决于引脚数(越复杂的电路和引线配置需要更多的引脚).图1.17给出了几种类型的例子.如图所见,收缩小轮廓封装( SSOP )的引脚形成鸥翼式形状.带引线的塑料芯片载体( PLCC )的引脚在封装下以J形翻转.无引线陶瓷芯片( LCC )具有金属接触面,焊接在它的陶瓷体上.薄型四侧引脚扁平封装( LQFP )也具有鸥翼式形状的引脚.片状刻度封装( CSP )和精密间距球形网格阵列( FBGA )的引脚嵌入在封装的底部相互接触. $$ 图1.17SMT封装配置,(e)和(f)给出的是底视图 $$
1.3.2 引脚编号 所有集成电路的封装都具有一个标准形式的引脚编号.双引线封装(DIP)和收缩小轮廓封装(SSOP)的引脚都具有一定的编号排列方式,如图1.18( a)的16个引脚封装的芯片所示.观察芯片封装的顶部,引脚1有一个标识,可以是一个小圆点,一个缺口或是一个斜角边.小圆点总是紧靠着引脚1.同样,缺口方向朝上,引脚1总是在左上角的位置,如图所示.从引脚1开始,逐步向下引脚编号递增,然后跨越芯片在另一边编号向上递增.最大的引脚编号总是在缺口的右边小圆点对面的位置. $$ 图1.18集成电路封装引脚的标准类型.给出的是顶视图 $$ 带引线的塑料芯片载体(PLCC)封装和无引线陶瓷芯片(LCC)封装在全部的4个边上都具有引脚.引脚1由一个小圆点标记,或由其他的索引标记,它处于一边的中心位置.引脚的编号沿逆时针递增,图中看到的是封装顶部的视图.最大的引脚编号总是处于引脚1的右边.图1.18(b)给出了20个引脚的PLCC封装芯片的引脚分布.</description>
    </item>
    
    <item>
      <title>1.2 二进制数,逻辑电平和数字波形</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/</guid>
      <description>1.2.1 二进制数 二进制系统中的两个数——1和0,称为位(比特,bit),是二进制数(binary digit)的缩写.在数字电路中,使用两个不同的电压电平表示这两个位.一般情况下,高电压用1来表示,低电压用0来表示.这称为正逻辑,本书将都使用正逻辑. $$ 高电压(H)=1低电压(L)=0 $$ 在另一种系统中,1表示低电压,0表示高电压,这称为负逻辑. 一组位(一些1和0的组合)称为码,用来表示数字,字母,符号,指令及任何给定应用中的对象.
1.2.2 逻辑电平 用来表示1和0的电压称为逻辑电平.理想情况下,一个电平表示高电压,另一个电平表示低电压.在实际的数字电路中,这个高电压可以是指定的最小值和最大值之间的任意值.同样,低电压也可以是指定的最小值和最大值之间的任意值.在指定的高电平范围和低电平范围之间是不能有重叠的.
图1.5给出了数字电路中高电平和低电平的通常范围.变量 $V_{H(max)}$ 表示高电平的最大值,变量 $V_{H(min)}$ 表示高电平的最小值.$V_{L(max)}$ 表示低电平的最大值,$V_{L(min)}$ 表示低电平的最小值.在正常的工作情况下,$V_{L(max)}$ 和 $V_{H(min)}$ 之间的电压值是不可以出现的.对于一个给定的电路,在此范围内的电压既可以是高电平,也可以是低电平.例如,在CMOS 数字电路中,高电平值在2~3.3 V,低电平压值在0~0.8 V,也就是说,如果使用2.5 V,电路将把它看成是高电平或二进制1.如果使用0.5 V,那么就是低电平或二进制0.对于这种类型的电路,0.8~2 V的电平值是不可以出现的.
1.2.3 数字波形 数字波形由两种不同的电平值组合而成,它们在高,低电平或状态之间不断地变化.图1.6(a)给出一个正向脉冲,是在电压(或电流)从低电平变到高电平,再从高电平变回到低电平时产生的.图1.6(b)给出一个反向脉冲,是在电压从高电平变到低电平,再从低电平变回到高电平时产生的.数字波形由这一系列的脉冲组成. 脉冲 如图1.6所示,脉冲有两个边沿:在t时刻首先出现的为前沿,在t,时刻随后出现的为后沿.对于一个正向脉冲,前沿是上升沿,后沿是下降沿.图1.6所示的脉冲是理想状态下的脉冲,因为假设上升沿和下降沿的变化是没有时间范围的(瞬间).实际情况是,这些变化是有时间范围的,尽管大多数的数字波形可以假定为理想脉冲.
图1.7给出了一个非理想的脉冲.实际上,所有脉冲或多或少都存在这些非理想的特性.通常,杂散电感和电容效应会产生超调量和振荡.杂散电容和电路电阻会产生下调量,形成时间常数不大的RC电路. $$ 图1.7非理想脉冲的特性 $$
从低电平到高电平所需的时间称为上升时间t,,从高电平到低电平所需的时间称为下降时间t.在实际运用中,通常测量的上升时间是从脉冲幅度(相对于基线的高度)的10%处到脉冲幅度的90%处的时间宽度,测量的下降时间则是从幅度的90%处到幅度的10%处的时间宽度.如图1.7所示,上升时间和下降时间不包括脉冲顶部和底部的10% ,因为这部分区域的波形是非线性的.脉冲的宽度tw就是脉冲的持续时间,通常把上升沿和下降沿幅度50%处的时间间隔定义为脉冲宽度,如图1.7所示.
波形特性 在数字系统里,遇到的大多数波形都是由一系列的脉冲组成的,有时称为脉冲序列,它们可以分为周期的和非周期的.周期波形就是在一个固定的时间间隔里不断重复自身,这个时间间隔称为周期( $T$ ).频率( $f$ )是重复的速率,测量单位是赫兹( $Hz$ ).而一个非周期性脉冲波形则不会在一个固定的时间间隔里重复,它可能由脉冲宽度不确定的脉冲组成,也有可能由时间间隔不确定的脉冲组成,图1.8给出两种波形的例子.
$$ (a)周期(方波) $$ $$ (b)非周期 $$ 脉冲(数字)波形的频率(f)就是其周期(T)的倒数,它们之间的关系如下所示: $$ (1.1) f = \frac{1}{T} $$ $$ (1.2) T = \frac{1}{f} $$ 周期数字波形的一个重要特性就是它的占空比,它是脉冲宽度( $t_w$ )和周期( $T$ )的比值,可以用百分比来表示 $$ (1.</description>
    </item>
    
    <item>
      <title>1.1 数字量与模拟量</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/</link>
      <pubDate>Fri, 14 Jul 2023 18:57:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/</guid>
      <description>模拟量具有连续的数值,数字量具有离散的数值.自然界中大多数可以测量的事物都以模拟量的形式出现.例如,空气温度在一个连续的范围内变化.在给定的一天里,温度不会立即从70°F下上升到71°F;这中间经历无数个温度值.如果绘制一个典型的夏季温度图,将会得到一个平滑和连续的曲线(类似于图1.1的曲线).其他模拟量的例子是时间,压力,距离和声音.
相对于一个连续的温度图,假设每小时测量一次温度.现在有一个24小时内每隔一小时采样测量到的离散温度值,如图1.2所示,这样就可以有效地将模拟量转换成数字量的形式,即用一个个数字码对应于每个采样到的温度值.注意,图1.2本身并不是模拟量的数字表示.
数字量的优点,在电学应用方面,数字量表示法和模拟量表示法相比有一定的优势.其,数字数据和模拟数据相比,前者在处理和传输方面更有效,更可靠.其二,数字数据在需要保存时,更显示了它的优越性.例如,转换成数字形式的音乐,要比相对应的模拟形式更简洁,复制时更精确,更清晰.噪声(不需要的电压波动)几乎不会影响数字数据,但会影响模拟信号.
1.1.1 模拟电子系统 扩音系统用于把声音放大,从而让更多的听众听到,这是模拟电子应用的一个简单例子.图1.3的基本图示给出了自然界中的模拟量,即声波,它由麦克风接收,并将其转换为较弱的模拟电压,称为声频信号.这个电压随着声波的音量大小和频率变化而连续变化,随即加到线性放大器的输入中.放大器的输出,也就是放大的输入电压,随即传人扬声器.扬声器将放大的音频信号再变回声波,而这时的声波音量比话简接收到的原始声波的音量大很多.</description>
    </item>
    
    <item>
      <title>15.5功率控制</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-5%E5%8A%9F%E7%8E%87%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 14 Jul 2023 18:30:27 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-5%E5%8A%9F%E7%8E%87%E6%8E%A7%E5%88%B6/</guid>
      <description>电子电路的一个有用应用是控制负载上的功率。本节将学习在功率控制应用中两种泛使用的器件，晶闸管整流器(SCR)和双向晶闸管(triac)。这些器件属于晶闸管类型的器件，广泛用于电动机工业控制、加热器、相位控制和其他许多应用中。可以认为晶闸管是一种电子开关，能够快速打开和关闭流向负载的大电流。集成电路经常用来确定何时打开和关闭 SCR 或双向晶闸管。
学完本节后，你应该掌握以下内容:
描述如何控制负载上的功率 描述 SCR 和双向晶闸管 解释如何打开和关闭 SCR 解释零电压开关 定义微控制器 15.5.1 晶闸管整流器 $$ a)基本结构~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)电路符号 $$
$$ 图15-40~~~晶闸管整流器(SCR) $$
晶闸管是一种半导体开关，由四层或多层交替的 pnpn 材料组成。有几种不同类型的晶闸管，类型主要取决于层数和每层的特定连接。对于一个四层晶闸管，当从第 1、2 和层进行连接时，就形成一种称为 SCR(晶闸管整流器)的闸二极管形式。这是晶闸管家族中最重要的器件之一，因为它相当于一个能够在需要时打开的二极管。SCR 的基本结构和电路符号如图15-40所示。对于 SCR，三个连接分别为阳极(A)、阴极(K)和栅极(G)。
$$ a)当I_G=0时，必须大于V_{BR(F)}才能进入导通区域~~~~~~~~~~~~b) I_G控制SCR能够导通所需要的V_{BR(F)}值 $$
$$ 图15-41~~~ SCR特性曲线 $$
当栅极电流为 0 时，SCR 的特性曲线如图15-41a所示。特性曲线中有4个区域。反向特性(第三象限中的曲线)与一般二极管相同，包含一个反向阻断区域和一个反向雪崩区域。反向阻断区域等效于一个断开的开关。加到 SCR 上使它能够进入雪崩区域的反向电压一般为几百伏或者更高。SCR 一般不工作在反向雪崩区域。
正向特性(画在第一象限)分成两部分。第一部分是正向阻断区域，其中 SCR 基本截止，阳极和阴极之间阻抗非常高，近似相当于一个断开的开关。第二个区域为正向导通域，其中产生阳极电流，如一般的二极管一样。为了让 SCR 进入这个区域，必须超过正向击穿电压 $V_{BR(F)}$。当 SCR 工作在正向导通区域时，阳极和阴极之间近似为一个闭合的开关。可以看到它与一般二极管特性(见图2-10)具有相似性，除了正向阻断区域之外。
打开SCR 有两种方法让 SCR 进入正向导通区域。在这两种情况下，阳极到阴极必须正向偏置，即阳极相对于阴极必须为正。第一种方法已经提到过，它要求加上一个超过正向击穿电压 $V_{BR(F)}$ 的正向电压。击穿电压触发通常不常用。第二种方法需要在栅极上加上一个正的脉冲电流(触发)。这个脉冲使正向击穿电压减小，如图15-41b所示，并使得 SCR 导通。栅极电流越大， $V_{BR(F)}$ 越小。这是打开 SCR 的一般常用方法。
一旦 SCR 打开，栅极就失去了控制。结果是 SCR 被锁住，只要阳极电流一直维持 SCR 将继续相当于一个闭合的开关。当阳极电流下降到小于一个称为保持电流的值时 SCR 会离开导通区域。保持电流如图15-41所示。</description>
    </item>
    
    <item>
      <title>15.4 应变测量、压力测量和运动测量</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-4%E5%BA%94%E5%8F%98%E6%B5%8B%E9%87%8F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E9%87%8F%E5%92%8C%E8%BF%90%E5%8A%A8%E6%B5%8B%E9%87%8F/</link>
      <pubDate>Fri, 14 Jul 2023 18:30:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-4%E5%BA%94%E5%8F%98%E6%B5%8B%E9%87%8F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E9%87%8F%E5%92%8C%E8%BF%90%E5%8A%A8%E6%B5%8B%E9%87%8F/</guid>
      <description>本节将讨论三种与力相关的参数(应变、压力和运动)的测量方法。许多应用都需要量这三种参数。此外，其他参数(例如液体的流速)也可以间接通过测量应变、压力或者动而得到。
学完本节后，你应该掌握以下内容:
描述应变、压力和运动测量的方法 解释应变计如何工作 讨论应变计电路 解释压力传感器如何工作 讨论压力测量电路 列出几种压力传感器应用 15.4.1 应变计 $$ a)~~~当加上一个力时，发生应变，长度从L变到L+△L $$ $$ b)~~~当平板发生弯曲时，发生应变，上表面扩张，下表面压缩 $$
$$ 图15-29~~~应变例子 $$
应变是由于作用在材料，上面的力量产生的材料变形，或者扩张或者压缩。例如，金属杆或金属棒当加上一个合适的力时，它会稍稍变长，如图15-29a 所示。此外，如果金属盘弯曲，那么上表面会有一个膨胀，称为拉伸应变，下表面会有一个压缩，称为压缩应变，如图15-29b所示。
应变计的原理是: 如果材料的长度增加，它的电阻值增大;如果长度缩短，它的电阻值减小。这可以用下面的式子表示(回顾 DC/AC 电路课程)。 $$ R=\frac{\rho L}{A}~~~(15-3) $$ 这个式子说明:对于一种材料，比如一段线，它的电阻值与电阻率($\rho$)和长度(L)成正比，和横截面积(A)成反比。
$$ a)典型的应变计结构 \\ b)沿着作用力的方向把应变计放置到被测量物体表面。当表面被拉长时，应变计也被拉伸 $$
$$ 图15-30~~~一个简单的应变计和它的放置方式 $$
应变计基本上是一个长而薄的电阻性材料条，它黏合在需要测量应变的物体的表面，比如放在测试的飞机机翼或尾翼上。当一个力作用在物体上引起微微的拉伸时，应变计也按比例拉长，电阻值增大。大多数应变计以类似于图15-30a 所示的形式来实现小区域范围内有足够电阻值的长度。然后如图15-30b所示将它沿着应变线方向放置。
$$ 图15-31~~~应变系数的说明。欧姆表符号并不表示测量△R的实际方法 $$
应变计的应变系数 应变计的一个重要特性是应变系数(GF)，GF定义为沿应变轴方向电阻值的相对变化与长度的相对变化之比。对于金属应变计，GF一般约为2。应变系数的概念在图15-31中说明，并可以用式(15-4)表示，其中R为标称电阻，$△R$ 为由应变引起的电阻变化。长度的相对变化($△L/L$)用应变($\epsilon$)来表示，一般表示为百万分率，称为微应变($μ\epsilon$)。 $$ GF=\frac{△R/R}{△L/L}~~~(15-4) $$
15.4.2 基本的应变计电路 $$ a)恒流电路~~~~~~~~~~~~~~~b)三线电桥电路 $$
$$ 图15-32~~~基本的应变测量电路 $$
因为当应变计感应量发生变化时，其电阻值会发生一个微弱变化，所以它通常用于与 RTD 类似的电路中。基本的差别是应变计测量应变，而不是温度。因此，应变计一般用在电桥电路中，或者用在恒流源驱动的电路中，如图15-32所示。它们的应用方式与 RTD 和热敏电阻相同。1B31 是应变计信号调理器的例子。它的数据手册见网站 www.analog.com。
15.4.3 压力传感器 $$ a)基本的压力计结构~~~~b)当膜片上没有净压力时，应变计电阻为其标称值(侧面图) \\ c)净压力使得膜片扩张，应变计被拉伸，因此电阻增大 $$</description>
    </item>
    
    <item>
      <title>15.3 温度测量</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-3%E6%B8%A9%E5%BA%A6%E6%B5%8B%E9%87%8F/</link>
      <pubDate>Fri, 14 Jul 2023 18:30:08 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-3%E6%B8%A9%E5%BA%A6%E6%B5%8B%E9%87%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>15.2 角度测量</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-2%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/</link>
      <pubDate>Fri, 14 Jul 2023 18:30:00 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-2%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>15.1 RMS-DC转换器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-1rms-dc%E8%BD%AC%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:29:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-1rms-dc%E8%BD%AC%E6%8D%A2%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.7 V/F和F/V转换器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-7v-f%E5%92%8Cf-v%E8%BD%AC%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:29:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-7v-f%E5%92%8Cf-v%E8%BD%AC%E6%8D%A2%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.6 A/D转换方法</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-6a-d%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 14 Jul 2023 18:29:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-6a-d%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.5 A/D转换的基本概念</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-5a-d%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Fri, 14 Jul 2023 18:26:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-5a-d%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.4 D/A转换</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-4d-a%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 14 Jul 2023 18:26:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-4d-a%E8%BD%AC%E6%8D%A2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.3 模拟和数字接口</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-3%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%95%B0%E5%AD%97%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 14 Jul 2023 18:26:07 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-3%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%95%B0%E5%AD%97%E6%8E%A5%E5%8F%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.2 采样保持放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-2%E9%87%87%E6%A0%B7%E4%BF%9D%E6%8C%81%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:55 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-2%E9%87%87%E6%A0%B7%E4%BF%9D%E6%8C%81%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>14.1 模拟开关</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-1%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-1%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.9 光纤</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-9%E5%85%89%E7%BA%A4/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-9%E5%85%89%E7%BA%A4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.8 PLL</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-8pll/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-8pll/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.7 频率调制</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-7%E9%A2%91%E7%8E%87%E8%B0%83%E5%88%B6/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-7%E9%A2%91%E7%8E%87%E8%B0%83%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.6 IF和音频放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-6if%E5%92%8C%E9%9F%B3%E9%A2%91%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-6if%E5%92%8C%E9%9F%B3%E9%A2%91%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.5 AM解调</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-5am%E8%A7%A3%E8%B0%83/</link>
      <pubDate>Fri, 14 Jul 2023 18:25:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-5am%E8%A7%A3%E8%B0%83/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.4 混频器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-4%E6%B7%B7%E9%A2%91%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:24:53 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-4%E6%B7%B7%E9%A2%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.3 幅度调制</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-3%E5%B9%85%E5%BA%A6%E8%B0%83%E5%88%B6/</link>
      <pubDate>Fri, 14 Jul 2023 18:24:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-3%E5%B9%85%E5%BA%A6%E8%B0%83%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.2 线性乘法器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-2%E7%BA%BF%E6%80%A7%E4%B9%98%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:24:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-2%E7%BA%BF%E6%80%A7%E4%B9%98%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>13.1 基本接收机</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-1%E5%9F%BA%E6%9C%AC%E6%8E%A5%E6%94%B6%E6%9C%BA/</link>
      <pubDate>Fri, 14 Jul 2023 18:24:26 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-1%E5%9F%BA%E6%9C%AC%E6%8E%A5%E6%94%B6%E6%9C%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.4 对数和反对数放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-4%E5%AF%B9%E6%95%B0%E5%92%8C%E5%8F%8D%E5%AF%B9%E6%95%B0%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:24:08 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-4%E5%AF%B9%E6%95%B0%E5%92%8C%E5%8F%8D%E5%AF%B9%E6%95%B0%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.3 OTA</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-3ota/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:57 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-3ota/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.2 隔离放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-2%E9%9A%94%E7%A6%BB%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-2%E9%9A%94%E7%A6%BB%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.1 仪表放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-1%E4%BB%AA%E8%A1%A8%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-1%E4%BB%AA%E8%A1%A8%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.6 IC稳压器的应用</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-6ic%E7%A8%B3%E5%8E%8B%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-6ic%E7%A8%B3%E5%8E%8B%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.5 IC稳压器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-5ic%E7%A8%B3%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:13 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-5ic%E7%A8%B3%E5%8E%8B%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.4 基本开关稳压器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-4%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:23:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-4%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.3 基本并联稳压器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-3%E5%9F%BA%E6%9C%AC%E5%B9%B6%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:22:54 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-3%E5%9F%BA%E6%9C%AC%E5%B9%B6%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.2 基本串联稳压器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-2%E5%9F%BA%E6%9C%AC%E4%B8%B2%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:22:44 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-2%E5%9F%BA%E6%9C%AC%E4%B8%B2%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.1 稳压</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-1%E7%A8%B3%E5%8E%8B/</link>
      <pubDate>Fri, 14 Jul 2023 18:22:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-1%E7%A8%B3%E5%8E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.7 555定时器作为单稳态触发器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-7555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:21:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-7555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.6 555定时器作为振荡器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-6555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:21:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-6555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.5 弛豫振荡器原理</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-5%E5%BC%9B%E8%B1%AB%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 14 Jul 2023 18:21:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-5%E5%BC%9B%E8%B1%AB%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.4 具有 LC 反馈电路的振荡器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-4%E5%85%B7%E6%9C%89lc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:21:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-4%E5%85%B7%E6%9C%89lc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.3 具有 RC 反馈电路的正弦波振荡器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-3%E5%85%B7%E6%9C%89rc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:20:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-3%E5%85%B7%E6%9C%89rc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.2 反馈振荡器原理</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-2%E5%8F%8D%E9%A6%88%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 14 Jul 2023 18:20:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-2%E5%8F%8D%E9%A6%88%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/</guid>
      <description>反馈振荡器的工作基于正反馈原理，本节将验证这个概念并观察振荡发生的一般条件。反馈振荡器广泛用于产生正弦波。
学完本节后，你应该掌握以下内容:
解释反馈振荡器的工作原理 解释正反馈 描述振荡的条件 讨论振荡启动的条件 10.2.1 正反馈 $$ 图10-3~~~正反馈产生振荡 $$ 正反馈的特点是将输出信号的同相部分反馈到输入端，用正弦波振荡器来阐述其基本原理，如图10-3所示。你可以看到，同相反馈电压被放大后产生输出电压，依次又产生反馈电压。也就是说，通过建立循环来维持信号本身，产生连续的正弦波输出，这个现象称为振荡。
10.2.2 振荡条件 图10-4阐述了维持振荡的两个条件:
反馈环路上的相移实际上必须为$0°$。 环绕闭环反馈环路(环路增益)的电压增益 $A_{cl}$ 必须等于 1(单位)。环绕闭环反馈环路上的电压增益 $A_{cl}$ 是放大器增益 $A_v$ 和反馈电路衰减 $B$ 的乘积。 $$ 图10-4~~~~振荡条件 $$ $$ A_{cl}=A_vB $$ 如果希望输出正弦波，大于1的环路增益将很快地使得波形的两个峰值处于饱和，产生严重的失真。为了避免这种情况，一旦振荡开始，必须使用一些增益控制以保持增益精确地保持在1。例如，如果反馈网络的衰减是0.01，放大器必须恰好具有100增益来克服衰减同时又不产生严重的失真(0.01×100=1)。大于100的放大器增益将会产生两个波形峰值受限的振荡。 10.2.3 开始条件 到目前为止，你已经看到什么条件可以让振荡器产生连续的正弦波输出现在我们检查当直流电压源闭合时振荡开始的条件。你知道，维持振荡必须满足单位-增益条件，为了启动振荡，环绕正反馈环路上的电压增益必须大于1，使得输出维持在想要的值。然后增益必须下降到1，使得振荡输出保持在希望的电平并能维持振荡。(在下一节会讨论，振荡开始后，有许多方法可以降低增益。)开始和维持振荡的电压增益条件如图10-5阐述。 $$ 图10-5~~~~当振荡在t_0开始时，条件A_{cl}&amp;gt;1产生正弦波输出电压幅度以建立期望的电平。 \\ 然后，A_{cl}减小到1，把输出电压维持在期望的幅度上 $$ 通常会提出这样的问题: 如果振荡器开始时是关闭的，并没有输出电压，反馈信号是如何启动开始建立正反馈过程的? 起初, 在电阻或其它原件中产生的宽带噪声, 或在电源闭合的瞬间，会产生一个小的正反馈电压，反馈电路只允许频率等于所选振荡频率的电压同相地出现在放大器的输入端。初始的反馈电压经过放大，并且不断地加强，从而产生如前所讨论的输出电压。</description>
    </item>
    
    <item>
      <title>10.1 振荡器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-1%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:19:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-1%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description>振荡器是产生周期波形来实现定时、控制或通信功能的电路。在几乎所有的电子系统中都可以找到振荡器，包括模拟和数字系统、大多数的测试仪器，如示波器和函数发生器。
振荡器需要某种正反馈，将部分输出信号反馈到输人，使得输人信号加强，从而维持连续不断的输出信号。尽管外部输入不是严格必需的，但是许多振荡器使用外部信号来控制频率或使它与另一个源同步。可以用以下两种方法之一来设计振荡器产生受控制的振荡信号: 使用反馈振荡器的单位增益方法和使用弛豫振荡器的定时方法。这两种方法都将在本章讨论。
不同类型的振荡器产生不同类型的输出，如正弦波、方波、三角波和锯齿波。本章介绍几种类型的基本振荡电路，它们使用运算放大器和分立晶体管作为增益元件，还会介绍一块称为 555 定时器的非常通用的集成电路。
10.1 振荡器 振荡器是能在其输出端产生周期波形的电路，它仅使用直流电源作为必需的输人。重复的输入信号并不是必需的，但可以用来同步振荡输出。输出电压要么是正弦波，要么是非正弦波，这取决于振荡器的类型。振荡器主要分为反馈振荡器和弛豫振荡器两大类。
学完本节后，你应该掌握以下内容:
描述所有振荡器的基本工作原理 解释振荡器的目的 讨论振荡器两种重要的分类 列出反馈振荡器的基本元件 10.1.1 振荡器的类型 $$ 图10-1~~~~基本振荡器概念给出三种常见类型的输出波形 $$ 本质上，所有振荡器都将来自直流电源的电能转换为周期波形，这些周期波形可以用于各种定时、控制或信号产生应用。一个基本的振荡器如图10-1 所示，振荡器可以根据产生信号所采用的技术进行分类。
反馈振荡器 有一类振荡器是反馈振荡器， 它将输出信号的一部分无净相移地反馈到输入端来加强输出信号。振荡开始后，环路增益保持在 1.0 来维持振荡。反馈振荡器由一个放大器(或者分立晶体管，或者运算放大器)和一个正反馈网络组成，其中放大器提供增益，正反馈网络产生相移并提供衰减，如图10-2所示。
$$ 图10-2~~~~反馈振荡器的基本元件 $$ 弛豫振荡器 振荡器的第二种类型是弛豫振荡器。弛豫振荡器使用一个 RC 定时电路来产生波形，通常是方波或非正弦波。典型地，弛豫振荡器使用施密特触发器或其他器件交替地通过电阻向电容充电和放电来改变状态。弛豫振荡器将在10.5节中讨论。</description>
    </item>
    
    <item>
      <title>9.7 测量滤波器响应</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-7%E6%B5%8B%E9%87%8F%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/</link>
      <pubDate>Fri, 14 Jul 2023 18:19:41 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-7%E6%B5%8B%E9%87%8F%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/</guid>
      <description>本节讨论通过测量确定滤波器响应的两种方法——离散点测量和扫频测量。
学完本节后，你应该掌握以下内容:
讨论测量频率响应的两种方法 解释离散点测量方法 解释扫频测量方法 9.7.1 离散点测量 $$ 图9-26~~~滤波器响应的离散点测试方法(图中的读数是任意的且只用于示意) $$
使用实验室常用仪器，在输入频率的离散值处测量滤波器输出的电压，测量方法如图9-26所示。其一般过程如下:
设置正弦波产生器的幅度为所需的电压电平。
设置正弦波产生器的输出频率远低于待测滤波器的预期截止频率。对低通滤波器，设置频率尽可能地接近 0Hz。对带通滤波器，设置频率远低于预期的下限频率。
在预测步骤，逐渐增加频率产生足够多的数据点以获得精确的响应曲线。
当改变频率时，保持输入电压幅度不变。
在每个频率处，记录下输出电压值。
在记录了足够多的测量点后，画出输出电压-频率曲线图。
如果被测量的频率超出了 DMM 的响应，就必须使用示波器来代替。
9.7.2 扫频测量 与离散点测试方法相比，扫频方法需要更复杂的测试设备，但是这种方法更为有效，能够得到更加精确的响应曲线。使用扫频发生器和频谱分析器的通用测试方法如图9-27a所示，图9-27b给出了如何用示波器替代频谱分析器来进行测试。 $$ 图9-27~~~滤波器响应的扫频测试方法 $$
扫频发生器可以产生恒定幅度的输出信号，这个信号的频率在两个预先设置的范围内线性增加，如图9-27所示。在图9-27a中, 频谱分析仪是一台仪器, 它可以对所需的频率间隔/每格进行校准, 而不是采用常用的时间/每格。因此，当送到滤波器的输人频率扫过预先设置的范围时，在频谱分析仪的屏幕上就会画出其响应曲线。使用示波器来显示响应曲线的测试方法如图9-27b所示。</description>
    </item>
    
    <item>
      <title>9.6 有源带阻滤波器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-6%E6%9C%89%E6%BA%90%E5%B8%A6%E9%98%BB%E6%BB%A4%E6%B3%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:19:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-6%E6%9C%89%E6%BA%90%E5%B8%A6%E9%98%BB%E6%BB%A4%E6%B3%A2%E5%99%A8/</guid>
      <description>带阻滤波器阻止指定频带内的频率通过，允许其他频率通过。带阻滤波器的响应与带通滤波器的响应相反。
学完本节后，你应该掌握以下内容:
理解有源带阻滤波器 识别多重反馈带阻滤波器 解释状态可变带阻滤波器的工作原理 9.6.1 多重反馈带阻滤波器 $$ 图9-23~~~多重反馈带阻滤波器 $$
图9-23是多重反馈带阻滤波器。注意，这种配置与带通滤波器的配置相似，只是去掉了$R_3$，并加人了$R_4$。
9.6.2 状态可变带阻滤波器 将9.5节介绍过的状态可变滤波器的低通响应和高通响应进行求和，就可以产生带阻响应，如图9-24所示。 $$ 图9-24~~~状态可变带阻滤波器 $$</description>
    </item>
    
    <item>
      <title>9.5 有源带通滤波器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-5%E6%9C%89%E6%BA%90%E5%B8%A6%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:19:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-5%E6%9C%89%E6%BA%90%E5%B8%A6%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</guid>
      <description>如前所述，带通滤波器让下限频率和上限频率之间的频率通过，拒绝所有位于通带范围外的频率通过。带通响应可以看作低频响应曲线和高频响应曲线的重叠部分。
学完本节后，你应该掌握以下内容:
理解有源带通滤波器 描述由低通和高通滤波器构成的带通滤波器 确定级联带通滤波器的截止频率和中心频率 确定多重反馈带通滤波器的中心频率、带宽和增益 解释状态可变带通滤波器的工作原理 9.5.1 低通和高通滤波器的级联形成带通响应 实现带通滤波器的一种方法是将一个高通滤波器和一个低通滤波器级联，如图9-17a所示，只要截止频率分得足够开。每个滤波器都是二极点 Sallen-Key 巴特沃斯结构，下降率为一40dB/十倍频程，如图9-17b中的复合响应曲线所示。如图9-17b所示，每个滤波器截止频率的选择使得响应曲线充分重叠，而且，高通滤波器的截止频率必须比低通滤波器的截止频率足够低。 $$ 图9-17~~~通过二极点高通滤波器和二极点低通滤波器级联形成的带通滤波器 \\ (与两个级联滤波器的级联次序无关) $$
带通滤波器的下限频率 $f_{c1}$ 是高通滤波器的截止频率，上限频率是低通滤波器的截止频率 $f_{c2}$ 。理想情况下，如前所述，通带的中心频率 $f_0$ 是 $f_{c1}$ 和 $f_{c2}$ 的几何平均值。下面的公式给出了图9-17中带通滤波器三个频率之间的关系。 $$ f_{c1}=\frac{1}{2\pi \sqrt[]{R_{A1}R_{B1}C_{A1}C_{B1}}} \\ f_{c1}=\frac{1}{2\pi \sqrt[]{R_{A2}R_{B2}C_{A2}C_{B2}}} \\ f_0=\sqrt[]{f_{c1}f_{c2}} $$
当然，如果在实现每个滤波器时使用等值元件，截止频率的公式可以简化为 $f_c = 1/2\pi RC$.
9.5.2 多重反馈带通滤波器 另一种类型的滤波器结构是多重反馈带通滤波器，如图9-18所示。通过 $R_2$ 和 $C_1$ 有两条反馈路径，元件 $R_1$ 和 $C_1$ 提供低通响应，$R_2$ 和 $C_2$ 提供高通响应。最大增益 $A_0$ 在中心频率处产生。Q 值小于 10 的滤波器属于这种类型。从 $C_1$ 反馈路径看，$R_1$和 $R_3$ 并联(将$V_{in}$源用短路替代)，中心频率的表达式可以表示为: $$ f_0=\frac{1}{2\pi \sqrt[]{(R_1||R_3)R_2C_1C_2}} $$ $$ 图9-18~~~多重反馈带通滤波器 $$</description>
    </item>
    
    <item>
      <title>9.4 有源高通滤波器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-4%E6%9C%89%E6%BA%90%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:19:08 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-4%E6%9C%89%E6%BA%90%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</guid>
      <description>在高通滤波器中，RC 网络中的电容与电阻的作用相反。除此之外，高通滤波器的基本参数与低通滤波器相同。
学完本节后，你应该掌握以下内容:
理解有源高通滤波器 识别单极点滤波器并确定它的增益和截止频率 识别二极点 Sallen-Key 滤波器并确定它的增益和截止频率 解释如何通过级联高通滤波器获得更高的下降率 9.4.1 单极点滤波器 图9-13a给出了一个下降率为一20dB/十倍频程的高通有源滤波器。注意，输入电路是一个单极点的高通 RC 网络。负反馈网络与前面讨论的低通滤波器的负反馈网络相同。高通响应曲线如图9-13b所示。 $$ 图9-13~~~单极点有源高通滤波器和响应曲线 $$
理想情况下，高通滤波器让大于 $f_c$ 的所有频率通过而无任何限制，如图9-14a所示，尽管在实际中并不是这种情况。正如你已经学过的，所有运算放大器都固有内部的 RC 网络，限制了运算放大器在高频处的响应。因此，对高通滤波器的响应有上限频率的限制。事实上，这使得它成为一个具有很大带宽的带通滤波器。在大多数应用中，因为内部高频限制比滤波器的 $f_c$ 要大得多，所以这种限制可以忽略。在一些应用中，为了提高它的高频限制频率，采用特殊的电流反馈运算放大器或分立式晶体管用作增益元件,而不是采用标准的运算放大器来实现。 $$ 图9-14~~~高通滤波器响应 $$
9.4.2 Sallen-Key 高通滤波器 图9-15是一个高通二阶Sallen-Key结构的滤波器。元件RA、CA、Rs和CB形成二极点频率选择网络。注意，在频率选择网络中，电阻和电容的位置与它们在低通滤波器结构中的位置相反。与其他滤波器一样，通过恰当地选择反馈电阻 $R_1$ 和 $R_2$ 响应特性可以优化。 $$ 图9-15~~~基本 Sallen-Key二极点高通滤波器 $$
9.4.3 级联高通滤波器 和低通时的配置一样，一阶和二阶高通滤波器可以通过级联形成三极点或者多极点的滤波器，可以产生更快的下降率。图9-16是一个六极点的高通滤波器，它由三级二极点电路组成。通过这种结构可以优化巴特沃斯响应，获得一120dB/十倍频程的下降率。 $$ 图9-16~~~六阶高通滤波器 $$</description>
    </item>
    
    <item>
      <title>9.3 有源低通滤波器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-3%E6%9C%89%E6%BA%90%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:18:56 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-3%E6%9C%89%E6%BA%90%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/</guid>
      <description>与无源滤波器(仅使用 R、L 和 C 元件)相比，使用运算放大器作为有源元件的滤波器具有一些优势。运算放大器提供增益，使得信号穿过滤波器时不会衰减。运算放大器的高输入阻抗防止过度增加电源的负载，并且运算放大器的低输出阻抗防止滤波器被所驱动的负载影响。有源滤波器也很容易在很宽的频率范围内调整而不会改变所期望的响应。
学完本节后，你应该掌握以下内容:
理解有源低通滤波器 识别单阶滤波器并确定它的增益和截止频率 识别二阶 Sallen-Key 滤波器并确定它的增益和截止频率 解释如何通过级联低通滤波器获得较高的下降率 9.3.1 单极点滤波器 图9-9a是一个含有单极点低通 RC 网络的有源滤波器，大于截止频率时它的下降率为一20dB/十倍频程，如图9-9b中的响应曲线所示。一阶滤波器的截止频率为 $f_c=1/2\pi RC$。滤波器中的运算放大器连接成同相放大器，通带内的闭环电压增益由 $R_1$ 和 $R_2$ 决定。 $$ A_{cl(NI)}=\frac{R_1}{R_2}+1 $$ $$ 图9-9~~~单极点有源低通滤波器及其响应曲线 $$
9.3.2 Sallen-Key低通滤波器 $$ 图9-10~~~基本Sallen-Key二阶低通滤波器 $$
Sallen-Key 是最常见的二阶(两极点)滤波器中的一种，它通常也称为 VCVS(电压控制电压源，voltage-controlled voltage source)滤波器。一个低通Sallen-Key滤波器如图9-10所示。注意，其中有两个低通 RC 网络，当大于截止频率时它的下降率为一40dB/十倍频程(假设是巴特沃斯响应特性)。一个 RC 网络由 $R_A$和$C_A$组成，另一个 RC 网络由 $R_B$ 和 $C_B$ 组成。一个独特的特性是电容 $C_A$ 提供反馈，在接近通带边缘附近可以调整响应。二阶 Sallen-Key 滤波器的截止频率为 $$ f_c=\frac{1}{2\pi \sqrt[]{R_AR_BC_AC_B}}~~~(9-6) $$
为了简化，把元件值设置成一样，即 $R_A=R_B=R，C_A=C_B=C$，这样，截止频率的表达式就简化成 $f_c=\frac{1}{2\pi RC}$
与单极点滤波器中一样，二阶 Sallen-Key 滤波器中的运算放大器是同相输人的，由 $R_1/_2R$ 提供负反馈网络。已经学过，阻尼系数是由 $R_1$ 和 $R_2$ 的值决定，可以使滤波器响应要么是巴特沃斯响应，要么是切比雪夫响应或贝赛尔响应。例如，从表9-1中可知，对一个二阶巴特沃斯响应要产生1.</description>
    </item>
    
    <item>
      <title>9.2 滤波器的响应特性</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-2%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 14 Jul 2023 18:18:30 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-2%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7/</guid>
      <description>每种滤波器(低通、高通、带通、带阻)可以通过电路元件值定制而具有巴特沃斯、切比雪夫或贝赛尔特性。每一种特性都是由响应曲线的形状来识别的，每种特性在特定的应用中具有各自的优势。
学完本节后，你应该掌握以下内容:
描述三类基本滤波器响应特性和其他滤波器参数 描述巴特沃斯特性 描述切比雪夫特性 描述贝赛尔特性 定义阻尼系数并讨论它的重要性 计算滤波器的阻尼系数 讨论滤波器的阶数和它对下降率的影响 巴特沃斯、切比雪夫或贝赛尔响应特性可以通过恰当地选择有源滤波器电路的元件值来实现，对低通滤波器响应曲线的三个响应特性的一般比较如图9-5所示。同样可以设计具有其中任何一种特性的高通、带通和带阻滤波器。 $$ 图9-5~~~三类滤波器响应特性的比较图 $$
巴特沃斯特性 巴特沃斯特性在通带内提供非常平坦的幅值响应，并且下降率为一20dB/十倍频程/每极点。相位响应是非线性的，然而，通过滤波器的信号相移(因此有时延)会随着频率而非线性变化。因此，加到具有巴特沃斯响应的滤波器上的脉冲将在输出端引起超调，因为脉冲上升沿和下降沿中的每个频率分量经历了不同的时延。具有巴特沃斯响应的滤波器通常用于当通带内的所有频率必须具有相同的增益时。巴特沃斯响应通常指最平坦响应。
切比雪夫特性 当要求下降率非常快时，具有切比雪夫响应特性的滤波器非常有用，因为切比雪夫滤波器可以提供大于一20dB/十倍频程/每极点的下降率。因为这个下降率比具有巴特沃斯特性响应特性的滤波器的下降率要大，所以对给定的下降率，滤波器可以用较少极点和较简单的电路来实现切比雪夫响应。这种类型的滤波器响应在通带内超调或波动(取决于极点的数量)，产生的线性相移比巴特沃斯产生的少。
贝赛尔特性 贝塞尔响应呈现线性相位特性,意味着相移随着频率线性增加。结果就是当输入是脉冲信号时，输出几乎没有超调。由于这个原因，具有贝塞尔响应的滤波器常用于过滤脉冲波形，而不会产生波形失真。
9.2.1 阻尼系数 如前所述，不论滤波器是低通、高通、带通还是带阻类型，有源滤波器都可以设计为具有巴特沃斯、切比雪夫或贝赛尔响应特性。有源滤波器电路的阻尼系数(DF)决定这个滤波器呈现哪种响应特性。为了解释这个基本概念，图9-6给出了一个广义的有源滤波器。它包含一个放大器、一个负反馈网络和一个滤波器部分。在一个同相放大器中，放大器和反馈网络相连接阻尼系数由负反馈网络决定，并且定义为: $$ 图9-6~~~有源滤波器的一般框图，注意，如同在第6章中的定义，R_1对应R_f，R_2对应于R_i; $$
$$ DF=2-\frac{R_1}{R_2}~~~(9-5) $$
基本上，阻尼系数通过负反馈的作用影响滤波器响应。任何试图增加或减小输出端电压的行为都将被负反馈的相反作用抵消。如果阻尼系数的值准确设置，这使得响应曲线在滤波器的通带内趋于平坦。通过高等数学，可以推导出不同阶数滤波器的阻尼系数(不在本书中介绍)，以获得巴特沃斯特性的最大平坦响应。
产生所需响应特性的阻尼系数值取决于滤波器的阶数(极点的数量)。回顾一下，滤波器的极点数越多，滤波器的下降率越快。例如，为了获得一个二阶巴特沃斯响应，阻尼系数必须为1.414。为了实现这个阻尼系数，反馈电阻率应为: $$ \frac{R_1}{R_2}=2-DF=2-1.414=0.586 $$ 这个比率给出了一个同相滤波器放大器的闭环增益 $A_{cl(NI)}$ 为1.586，推导如 $$ A_{cl(NI)}=\frac{1}{B}=\frac{1}{R_2/(R_1+R_2)}=\frac{R_1+R_2}{R_2}=\frac{R_1}{R_2}+1=0.586+1=1.586 $$
9.2.2 截止频率和下降率 截止频率由 RC 网络中的电阻和电容值决定，如图9-6所示。对一个单极点(一阶)滤波器，如图9-7所示，截止频率为 $$ 图9-7~~~一阶(单极点)低通滤波器 $$
$$ f_c=\frac{1}{2\pi RC} $$ 尽管给出的是低通配置，对一个单极点高通滤波器, $f_c$ 的计算公式是相同的。极点数量决定滤波器的下降率。一个巴特沃斯响应的下降率为一20dB/十倍频程/每极点。所以一个一阶(单极点)滤波器的下降率为一20dB/十倍频程，二阶(二极点)滤波器的下降率为一40dB/十倍频程，三阶(三极点)滤波器的下降率为一60dB/十倍频程，以此类推。
通常，为了获得三阶及以上的滤波器，采用单级或两级滤波器级联组成，如图9-8所示。例如，为了得到三阶滤波器，将一个二阶滤波器和一个一阶滤波器级联起来。为了得到一个四阶滤波器，将两个二阶滤波器级联，等等。在级联结构中，每个滤波器称为一级或一节。 $$ 图9-8~~~通过级联可以增加滤波器阶数 $$
由于巴特沃斯特性的最平坦响应，它使用最为广泛。因此，我们将主要通过巴特沃斯响应来阐述基本滤波器的概念。表9-1列出了1～6阶巴特沃斯滤波器的下降率、阻尼系数和反馈电阻比值。 $$ 表9-1~~~巴特沃斯响应的值 $$ </description>
    </item>
    
    <item>
      <title>9.1 基本滤波器响应</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-1%E5%9F%BA%E6%9C%AC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/</link>
      <pubDate>Fri, 14 Jul 2023 18:18:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-1%E5%9F%BA%E6%9C%AC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/</guid>
      <description>电源滤波器在第⒉章中已经介绍，本章介绍用于信号处理的有源滤波器。滤波器可以让某些特定频率的输入信号达到输出端，让其他频率的输入信号不能通过。这种特性称为选择性。
有源滤波器使用的器件，如带无源 RC 网络、RL 网络或 RLC 网络的晶体管或运算放大器。有源器件提供电压增益，无源网络用于频率选择。一般根据响应，有源滤波器有种基本类型:低通、高通、带通和带阻。本章将学习使用运算放大器和 RC 网络实现的源滤波器。
滤波器通常按照输出电压随输人电压频率变化的方式分类，有源滤波器的种类有低通、高通、带通和带阻。本节将学习各种滤波器的一般响应。
学完本节后,你应该掌握以下内容:
描述基本滤波器的增益-频率响应 解释低通响应 确定低通滤波器的截止频率和带宽 解释高通响应 确定高通滤波器的截止频率 解释带通响应 解释品质因数的重要性 确定带通滤波器的截止频率、带宽、品质因素和阻尼系数 解释带阻响应 9.1.1 低通滤波器响应 滤波器是一个允许某些频率通过，衰减或阻止所有其他频率的电路。一个滤波器的通带是滤波器允许通过的频率区域，在这些区域中信号的损耗最小(通常定义为小于一3dB)。截止频率 $f_c$(通常也称为截断频率)定义为通带的终端，通常指响应自通带下降—3dB(70.7%)。通带后的区域称为过渡区，接着是阻带。过渡区和阻带之间没有精确的分界点。
低通滤波器允许从直流到 $f_c$ 之间的频率通过并大幅衰减所有其他的频率。理想低通滤波器的通带如图9-1a中阴影区域所示，当频率在通带以外时响应降为零。理想的响应有时如同“砖墙”，因为没有任何东西可以穿过墙。理想低通滤波器的带宽等于 $f_c$ 。 $$ BW=f_c~~~(9-1) $$
任何实际的滤波器都不可能实现图9-1a所示的理想响应。实际滤波响应取决于极点的数量，极点是滤波器的一个术语，用于描述滤波器中所包含的旁路电路数量。大多数基本低通滤波器是一个简单的 RC 网络，它仅由一个电阻和一个电容器组成，输出在电容器上产生，如图9-1b所示。这种基本 RC 滤波器具有一个单极点，超过截止频率后增益以一20dB/十倍频程的速度衰减，实际的响应在图9-1a中用加粗的线画出。为了显示曲线增益下降的细节，滤波器的响应曲线画在标准的对数坐标中。注意，增益几乎是常量，直到频率达到截止频率为止。在此之后，增益以固定的下降率迅速下降。
$$ 图9-1~~~低通滤波器响应 $$
基本 RC 滤波器增益以一20dB/十倍频程下降意味着在频率 $10f_c$ 处，输出是输入的一20dB(10%)。这种相当平缓的下降并不是特别好的滤波器特性，因为太多不期望的频率(通带以外的频率)可以通过这个滤波器。
简单低通RC滤波器的截止频率在Xc=R处，其中 $$ f_c=\frac{1}{2\pi RC} $$
回顾一下基本的直流/交流课程，截止频率处的输出是输入的70.7%。这种响应等价于衰减了一3dB。
图9-1c给出了几种理想低通响应曲线，包括基本单极点响应(一20dB/十倍频程)。近似的增益曲线表明，通带内的响应是平坦的直至截止频率，在截止频率后响应以常量速率下降。真实的滤波器在截止频率内没有如此好的平坦响应，但如前所述的那样，在截止频率处有一3dB的衰减。
为了使滤波器有更陡的过渡区(因此可以形成更有效的滤波器)，在基本滤波器上增加电路是很有必要的。由于负载效应，简单地级联理想的RC电路不能使过渡区的响应比一20dB/十倍频程更陡。然而，通过将运算放大器与频率选择反馈网络组合，设计后的滤波器的下降率可以达到一40dB/十倍频程、一60dB/十倍频程甚至更大的下降率。在设计中包含一个或多个运算放大器的滤波器称为有源滤波器。通过特殊的滤波器设计，这些滤波器可以优化下降率或其他属性(如相位响应)。通常，滤波器使用的极点越多，滤波器响应的过渡区将越陡。确切的响应取决于滤波器的类型和极点的数量。
9.1.2 高通滤波器响应 $$ 图9-2~~~高通滤波器响应 $$
高通滤波器极大地衰减或不让低于 $f_c$ 的频率通过，并让所有高于 $f_c$ 的频率通过，如图9-2a所示。再重复一下，在截止频率处的输出为通带的70.7%(或一3dB)。理想的响应由阴影区域标出，可以看出，响应在 $f_c$ 处瞬间下降，当然，这是不可能实现的。理想情况下，高通滤波器的通带是大于截止频率的所有频率。实际电路的高频响应受到运算放大器或构成滤波器的其他元件的限制。
由一个电阻和电容器组成的简单 RC 网络可以构成高通滤波器，输出取自电阻，如图9-2b所示。和低通滤波器的情况一样，基本的RC网络有一20dB/十倍频程的下降，如图9-2a中加粗的线所示。同样，基本高通滤波器的截止频率发生在 $X_C=R$ 处，其中 $$ f_c=\frac{1}{2\pi RC} $$ 图9-2c画出了几种理想的高通响应曲线，包括基本RC网络的单级点响应(一20dB/十倍频程)。如同低通滤波器，近似的增益曲线显示了大于截止频率时啊厘是一卫的，小丁截止频率时响应以恒定速率下降。实际高通滤波器没有如图9-2C 所小的理NB的T炽的且一精确的下降率。采用有源高通滤波器使过渡区的响应陡峭程度大于一20dB/十倍频程是可行的，特定的响应依赖于滤波器的类型和极点的数量。</description>
    </item>
    
    <item>
      <title>8.4 转换器和其他运算放大器电路</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-4%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 18:17:53 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-4%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%94%B5%E8%B7%AF/</guid>
      <description>本节介绍几个运算放大电路，它们代表了运算放大器的基本应用。你将学习恒流源、电流-电压转换器、电压-电流转换器和峰值检波器。当然，这并没有全面覆盖所有可能的运算放大器电路，仅仅是介绍了一些常见的基本使用。
学完本节后,你应该掌握以下内容:
理解一些特殊运算放大器电路的工作原理 识别和解释运算放大器恒流源的工作原理 识别和解释运算放大器电流-电压转换器的工作原理 识别和解释运算放大器电压-电流转换器的工作原理 解释如何将一个运算放大器用作峰值检波器 8.4.1 恒流源 $$ 图8-34~~~基本恒流源 $$
当负载电阻变化时，恒流源提供的负载电流保持恒定。图8-34是一个基本电路，稳压源($V_{in}$)通过输入电阻($R_i$)提供恒定电流($I_i$)。因为运算放大器反相输入端虚地(0V)，所以 $I_i$ 的值由 $V_{IN}$ 和 $R_i$ 决定 $$ I_i=\frac{V_{IN}}{R_i} $$ 现在，因为运算放大器的内部输入电阻非常大(理想情况下是无穷大)，所以实际上所有$I_i$通过反馈支路流过$R_L$。因为$I_i=I_L$，所以 $$ I_L=\frac{V_{IN}}{R_i}~~~(8-8) $$
如果$R_L$变化，只要$V_{IN}$和$R_i$保持不变，$I_L$就保持不变。
8.4.2 电流-电压转换器 电流-电压转换器把变化的输入电流变为成正比的输出电压，基本电路如图8-35a所示。因为几乎所有 $I_i$ 流过反馈路径，所以$R_f$的电压降为 $I_iR_f$。因为 $R_f$ 的左端虚地(0V),所以输出电压就等于 $R_f$ 上的电压，该电压与 $I_i$ 成正比。 $$ V_{OUT}=I_iR_f~~~(8-9) $$ $$ a)基本电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)感光电路，电路输出电压与光强度成正比 $$
$$ 图8-35~~~电流-电压转换器 $$
这个电路的一种特殊应用如图8-35b所示，其中，光敏元件用来探测光强度变化。当光强度发生变化时，流过光敏元件的电流随着发生变化，这是因为元件的电阻发生了改变。输出电压的变化与这个电阻的变化成正比($△V_{OUT}= △I_iR_f$)。
8.4.3 电压-电流转换器 $$ 图8-36~~~电压-电流转换器 $$
基本电压-电流转换器如图8-36所示。这个电路用于输出(负载)电流需要由输入电压控制的应用中。
忽略输入失调电压，运算放大器的反相和同相输入端的电压都是 $V_{IN}$。因此，$R_1$ 上的电压等于 $V_{IN}$。因为反相输入端的电流可以忽略，所以 $R_1$ 上的电流与 $R_L$ 上的电流相等。因此， $$ I_L=\frac{V_{IN}}{R_1}~~~(8-10) $$
8.4.4 峰值检测器 $$ 图8-37~~~基本的峰值检测器 $$</description>
    </item>
    
    <item>
      <title>8.3 积分器和微分器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-3%E7%A7%AF%E5%88%86%E5%99%A8%E5%92%8C%E5%BE%AE%E5%88%86%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:17:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-3%E7%A7%AF%E5%88%86%E5%99%A8%E5%92%8C%E5%BE%AE%E5%88%86%E5%99%A8/</guid>
      <description>运算放大积分器模拟数学积分，数学积分本质上是一个求和过程，积分的值是函数曲线下覆盖的总面积。运算放大微分器模拟数学微分，数学微分是确定函数瞬时变化率的过程。为了展示基本原理，本节学习的积分器和微分器是理想的。为了阻止饱和，实际的积分器常常有一个额外的电阻或其他电路在反馈电容器的并联电路中。为了减小高频噪声实际的微分器可能包含一个串联电阻。
学完本节后,你应该掌握以下内容:
理解积分器和微分器的工作原理 判别积分器 讨论电容器如何充电 确定积分器输出变化率 判别微分器 确定微分器的输出电压 8.3.1 运算放大器积分器 $$ 图8-24~~~理想运放积分器 $$
一个理想积分器如图8-24所示。注意，反馈元件是一个电容器，这个电容器与输电阻构成 RC 电路。
电容器如何充电 为了明白积分器是如何工作的，需要复习一下电容器的充电过程。回顾一下，电容器上的电量 Q 与充电电流($I_C$)和时间($t$)成正比。 $$ Q=I_Ct $$ 同样地，考虑到电压，电容器上的电量为 $$ Q=CV_C $$ 从这两个关系式可以得到，电容器电压可以表示成 $$ V_C=(\frac{I_C}{C})t $$ 这个表达式是一条直线的方程，直线开始于 0 并且斜率为 $I_C/C$。(从线性代数可知，直线的一般表达式为 $y=mx十b$。这里，$y=V_C$，$m=I_C/C$，x=t，并且b=0。)
我们知道，在简单 RC 网络上的电容电压是非线性的，是指数的。这是因为当电容充电时引起电压变化率的连续减小，充电电流是连续下降的。使用具有 RC 网络的运算放大器构成的积分器的关键之处是电容器的充电电流是恒定的，因此产生直线(线性)的电压而不是指数电压。现在我们看看为什么是这样的。
$$ 图8-25~~~积分器中的电流 $$
在图8-25中，运算放大器的反相输人端虚地(0V)，所以 $R_i$ 两端的电压等于$V_{in}$。因此，输入电流为 $$ I_{in}=\frac{V_{in}}{R_i} $$ 电容器电压 因为$I_{in}$是恒定的，所以 $I_C$ 也是恒定的。常量 $I_C$ 线性地向电容器充电，在 C 上产生线性电压。电容器的正极通过运算放大器虚地维持在 0V，电容器的负极电压随着电容器充电从 0 开始线性减小，如图8-26所示。这个电压称为负斜坡，它是恒定正极性输入的结果。
$$ 图8-26~~~由恒定充电电流在C上产生的线性斜坡电压 $$
输出电压 $V_{out}$ 与电容器负极电压相同。当常量正极性输入电压是阶跃形式或脉冲形式时(脉冲在高电平处幅度是常量)，输出斜坡在负方向一直减小，直到运算放大器在最大负电平处饱和为止，如图8-27所示。
$$ 图8-27~~~恒定输入电压在积分器输出端产生斜坡 $$</description>
    </item>
    
    <item>
      <title>8.2 求和放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-2%E6%B1%82%E5%92%8C%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:17:24 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-2%E6%B1%82%E5%92%8C%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>求和放大器是第6章中讨论的反相运算放大器组态的一种变化形式。求和运算放大器有两个或两个以上的输入端，输出电压与输人电压的代数总和的负值成正比。本节学习求和放大器是如何工作的，并了解均值放大器和比例放大器，它们都是基本求和运算放大器的变化形式。
学完本节后，你应该掌握以下内容:
理解多种类型求和放大器的工作原理 描述单位增益求和放大器的工作原理 讨论如何获得大于单位增益的任意增益 描述均值放大器的工作原理 描述比例加法器的工作原理 讨论用作数模转换器的比例加法器 讨论求和放大器在其中起重要作用的模拟系统 8.2.1 单位增益求和放大器 一个两输入的求和放大器如图8-18所示，实际上任意数量的输入都是可以的.
$$ 图8-18~~~两输入反相求和放大器 $$
电路的工作原理和输出表达式的推导如下: 电压 $V_{IN1}$和$V_{IN2}$用于输入端，并产生电流$I_1$和$I_2$，如图8-18所示。从无穷大输入阻抗和虚地的概念可知，运算放大器反相端(一)输入电压接近于 0V，因此输入端没有电流。这意味着输人电流 $I_1$ 和 $I_2$ 在这个求和点处相加，形成总电流，这个电流$I_T$流过$R_f(I_T=I_1＋I_2)$。因为$V_{out}=-I_TR_f$，则 $$ V_{OUT}=-(I_1+I_2)R_f=-(\frac{V_{IN1}}{R_1}+\frac{V_{IN2}}{R_2})R_f $$ 如果三个电阻的电阻值相等($R_1=R_2=R_f=R$)，则
$$ V_{OUT}=-(\frac{V_{IN1}}{R}+\frac{V_{IN2}}{R})R=-(V_{IN1}+V_{IN2}) $$ 从前面的公式可以看出，输出电压的幅值等于两个输入电压幅值的和，但是带有负号。式(8-3)是具有 n 个输入求和放大器的通用表达式，如图8-19所示，其中所有电阻的电阻值相等。 $$ 图8-19~~~具有n个输入的求和放大器 $$
$$ V_{OUT}=-(V_{IN1}+V_{IN2}+&amp;hellip;+V_{INn})~~~(8-3) $$
8.2.2 增益大于单位增益的求和放大器 当 $R_f$ 大于输人电阻时，放大器的增益为 $一R_f/R$，其中，$R$ 是每个输人电阻的电阻值。输出的一般表达式为 $$ V_{OUT}=-\frac{R_f}{R}(V_{IN1}+V_{IN2}+&amp;hellip;+V_{INn})~~~(8-4) $$ 从公式可以看出，输出电压的幅值等于所有输入电压的和乘以一个由 $一R_f/R$ 决定的常量。
8.2.3 均值放大器 求和放大器可以用来对输入电压产生数学平均。只需要把比率 $R_f/R$ 设置为输入个数的倒数即可，即 $R_f/R=1/n$。
可以得到若干数字的平均值，首先把这些数相加，然后除以这些数字的总个数。观察式(8-4)，并稍加思考，就可以看出求和运算放大器可以实现求数学均值的功能。下面的例子对此进行了阐述。
8.2.4 比例加法器 通过简单地调整输入电阻的电阻值，可以给求和运算放大器的各个输人赋予不同的权重系数。输出电压可以表示为 $$ V_{OUT}=-(\frac{R_f}{R_1}V_{IN1}+\frac{R_f}{R_2}V_{IN2}+&amp;hellip;\frac{R_f}{R_n}V_{INn})~~~(8-5) $$ 每个输入的权重系数由 $R_f$ 与这个输入的电阻值比率决定。例如，如果一个输入电压的权重为 1，那么 $R=R_f$。或者，如果权重为0.5，那么 $R=2R_f$。$R$的值越小，权重系数越大，反之亦然。</description>
    </item>
    
    <item>
      <title>8.1 比较器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-1%E6%AF%94%E8%BE%83%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 18:17:13 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-1%E6%AF%94%E8%BE%83%E5%99%A8/</guid>
      <description>在前两章学习了运算放大器的原理、运算和特性。运算放大器的应用范围非常宽广很难在一章或一本书内将这些应用都一一覆盖。因此，本章将通过一些基本的应用来阐述运算放大器的应用多样性，并且帮你建立基本运算放大器电路的基础。
运算放大器经常用作非线性器件来比较两个电压的幅值。在这种应用中，运算放大器用作开环配置，输人的一.端是输入电压，输人的另一端是参考电压。
学完本节后，你应该掌握以下内容:
理解几类基本比较器电路的工作原理 描述过零检测器的工作原理 描述非过零检测器的工作原理 讨论输人噪声是如何影响比较运算的 定义滞回 解释滯回是如何降低噪声影响的 描述施密特触发电路 描述限幅比较器的工作原理 描述窗口比较器的工作原理 讨论比较器在包含模数转换器的系统中的应用 8.1.1 过零检测 运算放大器的一个应用是用作比较器，用来判断输人电压是否超过某个值。图8-1a给出了一个过零检测器。注意，反相(-)输入端接地产生零电平，输人信号电压接到同相(+)输人端。由于很高的开环电压增益，两个输人端之间非常小的电压差使得放大器饱和，从而使得输出电压达到它的极限。
打开配套网站上的文件F08-01。这个仿真演示过零检测器的工作原理。
例如，一个运算放大器的 $A_{ol}= 100 000$。输入端仅 0.25mV 的电压差能够产生 $0.25mV\times 100 000=25V$ 的输出电压，前提是这个输出电压没有超过运算放大器的输出上限。然而，因为绝大多数运算放大器的输出电压的范围在 $\pm 15V$ 甚至更小，所以超过这个极限器件将达到饱和。在许多需要比较的应用场合，常选择专门的运放比较器。为了达到最高的速度，这些集成电路通常未做补偿。在一些不太严格的应用中，一个通用运算放大器就可以很好地用作比较器了。
$$ 图8-1~~~运算放大器用作过零检测器 $$
图8-1b展示了正弦波输入电压接入过零检测器的同相端。如图8-1b所示，当正弦波为负时，输出电压在最大负电平处。当正弦波跨过 0 时，放大器变为相反状态，输出变为最大正电平值。过零检测器可以用于从正弦波产生方波的方波产生电路。
8.1.2 非过零检测 $$ 图8-2~~~非过零检测器 $$
通过在反相端(一)接入一个固定的参考电压，图8-1所示的过零检测器经过改进后可以用于检测正、负电压，如图8-2a所示。一个更为实际的接法如图8-2b所示，使用分压器来设置参考电压: $$ V_{REF}=\frac{R_2}{R_1+R_2}(+V)~~~(8-1) $$ 式中，$＋V$ 是运算放大器电源的正极。图8-2c中的电路使用齐纳二极管来设置参考电压( $V_{REF} = V_Z$)。只要输人电压 $V_{in}$小于$V_{REF}$，输出就保持在最大负电平。当输入电压超过参考电压时，输出变为最大正值，图8-2d是正弦波输入电压时的示意图。
8.1.3 输入噪声对比较器工作的影响 $$ 图8-5~~~叠加噪声的正弦波 $$
在许多应用中，噪声(不期望的起伏不定的电压或电流)可能会出现在输人引线上。噪声电压叠加到输人电压上，如图8-5所示，会使比较器的输出状态无规律地来回切换变化。
$$ 图8-6~~~噪声对比较器电路的影响 $$
为了理解噪声电压的潜在影响，考虑将一个低频正弦电压连接到运放比较器的同相输入端(＋)作为过零检测器，如图8-6a所示。图8-6b给出了叠加噪声的输入正弦波和对应的输出。你可以看到，当正弦波接近0时，由于噪声引起的电压起伏使得总输入多次大于或小于0，因此会产生不稳定的输出电压。
8.1.4 用滞回减小噪声影响 在输人端有噪声的情况下，比较器的开关输出会在正电平和负电平之间产生不稳定的跳变，这是因为输入端引起正负变化的参考电压值是同一个值。当输入电压在参考电压值附近变化时，输入端任何很小的噪声都会使得比较器不停地改变工作状态，这种不稳定的情况就会发生。
为了使得比较器对噪声不那么敏感，可以使用一种包含正反馈的技术，称为滞回。本质上，滞回意味着当输入电压从较低向较高变化时的参考电压要高于当输入电压从较高向较低变化时的参考电压。常见的家用恒温调节器是滞回的一个范例，在一个温度上打开，在另一个温度上关闭。
两个参考电压称为上触发点( upper trigger point，UTP)和下触发点(lower trigger point，LTP)。两电平的滞回是通过正反馈实现的，如图8-7所示。注意，同相(＋)输入端连接到电阻分压器，使得输出电压的一部分反馈到输入端，输入信号连接到反相(一)输入端。</description>
    </item>
    
    <item>
      <title>7.5 运算放大器的补偿</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-5%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E8%A1%A5%E5%81%BF/</link>
      <pubDate>Fri, 14 Jul 2023 18:16:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-5%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E8%A1%A5%E5%81%BF/</guid>
      <description>上一节指出，当运算放大器响应的下降率超过 一20dB/十倍频程，并且运算放大器运行在闭环配置中，增益曲线与开环响应相交于更高的下降率时，就会出现不稳定。正如上节讨论的情况中，闭环电压增益被限制在非常高的值。在许多应用中，较低的闭环增益是很有必要或者非常希望的。为了让运算放大器能够运行在较低的闭环增益处，需要进行相位滞后补偿。本节可作为选学内容。
学完本节后，你应该掌握以下内容:
解释运算放大器相位补偿 描述相位-滞后补偿 解释补偿电路 应用单电容器补偿 应用前馈补偿 7.5.1 相位滞后补偿 正如你所看到的，不稳定的原因是运算放大器内部滞后网络的额外相移。当这些相移等于或超过 180° 时，放大器就会振荡。要么通过补偿的方法来去除开环下降率大于 一20dB/十倍频程的部分，要么通过补偿将 一20dB/十倍频程下降的线段延伸到更低的增益处。这些概念在图7-15中进行了阐述。 $$ 图7-15~~~用伯德图说明对典型运算放大器开环增益进行相位补偿的效果 $$
7.5.2 $$ a)电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) 理想输出电压20dB/十倍频程 $$
$$ 图7-16~~~基本补偿网络的作用 $$
对集成电路运算放大器进行补偿有两种基本的方法: 内部的和外部的。两种方法都需要加入 RC 网络。基本补偿操作如下所述: 首先考虑 RC 网络，如图7-16a 所示。补偿电容的电抗 $X_{C_c}$ 在低频处非常大，输出电压几乎等于输人电压。当频率达到其截止频率时，$f_c= 1/[2\pi(R_1 + R_2)C_c]$, 输出电压按 一20dB/十倍频程下降，这个下降率会一直持续到 $X_{C_c}≈0$。在 $X_{C_c}≈0$ 时，输出电压大小由 $R_1$ 和 $R_2$ 决定，如图7-16b所示。这是运算放大器相位补偿中使用的原则。
$$ 图7-17~~~带补偿的运算放大器 $$
为了看清补偿网络如何改变运算放大器的开环响应，参照图7-17。此图是一个二级的运算放大器，每一级和紧跟着的滞后网络都用灰色阴影块表示，补偿网络连接到第一级电路的输出端 A 点处。
把补偿网络截止频率的值设置为小于内部滞后网络的主(最小的)截止频率，这就使得在补偿网络的截止频率处开始以一20dB/十倍频程下降。补偿网络的下降从截止频率开始一直持续到主滞后网络的截止频率处，到该点后，补偿网络的响应呈平稳状态,由主滞后网络的一20dB/十倍频程来接管继续下降，最终的结果是开环响应向左平移，因此压缩了带宽，如图7-18a所示。补偿网络的响应曲线与总开环响应曲线之间的正确关系如图7-18b所示。
$$ 图7-18~~~~补偿运算放大器频率响应的例子 $$
7.5.3 补偿范围 $$ a)部分补偿~~~~~~~~~~~~~~~~~~~~~b)全补偿 $$
$$ 图7-21~~~补偿范围 $$
较大的补偿电容会使得开环响应从较低的频率就开始下降，因此会将 一20dB/十倍频程的下降延伸到较低的增益值，如图7-21a所示。通过足够大的补偿电容可以使得运算放大器无条件地稳定，如图7-21b所示，这里的 一20dB/十倍频程线段一直延伸到单位增益一般这种内部的补偿是由制造商在生产时就实现的，一个内部的、全补偿的运算放大器可以用于任意值的闭环增益并保持稳定。741就是内部全补偿的一种器件。
内部全补偿放大器的缺点是牺牲了带宽，因而降低了转换速率。所以，许多集成运算放大器会提供外部补偿。图7-22给出了 LM101A 运算放大器的典型封装图，带有外补偿的引脚，通过这些引脚可以用小电容提供外部补偿。通过提供外部连接，对特定的应用只需要提供正好够用的补偿，从而避免了性能上不必要的损失。</description>
    </item>
    
    <item>
      <title>7.4 正反馈和稳定性</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-4%E6%AD%A3%E5%8F%8D%E9%A6%88%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/</link>
      <pubDate>Fri, 14 Jul 2023 18:16:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-4%E6%AD%A3%E5%8F%8D%E9%A6%88%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/</guid>
      <description>使用运算放大器时，稳定性是需要考虑的。稳定运行是指运算放大器在任何情况下都不会振荡。不稳定会产生振荡，当输人端没有信号时，由于输人端的噪声和瞬态电压，输出端会有不期望的电压波动。本节可以作为选读内容。
学完本节后，你应该掌握以下内容:
讨论正反馈和运算放大器的稳定性 定义正反馈 定义环路增益 定义相位裕量并讨论它的重要性 判定运算放大器是否稳定 总结稳定性判据 7.4.1 正反馈 为了理解稳定性，必须先检查不稳定性及其原因。大家知道，通过负反馈，反馈到放大器输人端的信号与输人信号相抵，因此减去反馈信号可以有效地减小电压增益。只要反馈是负的，放大器就是稳定的。
当从输出端反馈到输人端的信号的相位与输入信号的相位一致时，正反馈条件就成立了，放大器就会发生振荡。也就是说，当通过运算放大器和反馈网络的总相移是 360°(这也等价于无相移(0°))时，正反馈就会发生。
7.4.2 环路增益 要产生不稳定: (a)必须有正反馈，(b)闭环放大器的环路增益必须大于1。闭环放大器的环路增益定义为运算放大器的开环增益乘以反馈网络的衰减因子。 $$ 环路增益=A_{ol}B~~~(7-7) $$
7.4.3 相位裕量 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c) $$
$$ 图7-10~~~反馈环相移 $$
注意，对图7-10中的每个放大器配置，反馈环连接到反相输入端。由于反相，在输人端和输出端之间存在着固有的 180° 相移。此外，放大器中的 RC 滞后网络(图7-10中没画出来)会产生附加的相移($φ_{tot}$)，因此反馈环的总相移为 $180°+φ_{tot}$。
相位裕量$φ_{pm}$ 是使得反馈环的总相移为 360°(360° 等价于 0°)时的额外相移。 $$ 180°+φ_{tot}+φ_{pm}=360° \\ φ_{pm}=180°-|φ_{tot}|~~~(7-8) $$ 如果相位裕量是正的，则总相移小于 360°，放大器是稳定的。如果相位裕度是 0 或负的，则反馈信号是以输人信号同相反馈的，放大器有潜在的不稳定。从式(7-8)可以看出，当总的滞后网络相移($φ_{tot}$)等于或超过 180° 时，相位裕量是 0° 或负值，存在不稳定状态，这将会引起放大器振荡。
7.4.4 稳定性分析 因为大多数运算放大器实际使用的配置是大于1的环路增益($A_{ol}B&amp;gt;1$)，所以稳定性判断准则基于内部滞后网络的相角。如前所述，运算放大器由多级电路组成，每级有一个截止频率。对补偿运算放大器，只有一个截止频率占主导地位，反馈的稳定性不是一个问题。稳定性问题一般表现为不期望的震荡，对运算放大器，在接近单位-增益频率处的反馈是稳定的。
$$ 图7-11~~~一个三级运算放大器响应的伯德图 $$
为了阐述反馈稳定性的概念，我们以非补偿三级运算放大器为例子，其开环响应如图7-11中的伯德图所示。在这种情况下，有三个不同的截止频率，它们分别对应于三个内部RC滞后网络。在第一个截止频率 $f_{c1}$ 处，增益开始以一20dB/十倍频程下降。当达到第二个截止频率 $f_{c2}$ 处，增益以一40dB/十倍频程开始下降。当达到第三个截止频率 $f_{c3}$ 处，增益以一60dB/十倍频程开始下降。
为了分析非补偿闭环放大器的稳定性，需要确定相位裕量。对闭环增益的一个给定值，如果是正相位裕量表明放大器是稳定的。为了给出不稳定性的条件，下面将给出三种情况。
$$ 图7-12~~~闭环增益和开环增益在-20dB/十倍频程线段上相交的情况(稳定工作) $$
情况1 如图7-12所示，闭环增益和开环增益响应在-20dB/十倍频程线段上相交。中频闭环增益为 106dB，闭环截止频率为5kHz。如果我们假设放大器不会在它的中频范围以外工作，106dB 放大器的最大相移发生在中频范围的最高处(这种情况时是5kHz)。在这个频率处由三个滞后网络产生的总相移为: $$ φ_{tot}=-arctan(\frac{f}{f_{c1}})-arctan(\frac{f}{f_{c2}})-arctan(\frac{f}{f_{c3}}) $$ 式中，$f=5kHz$，$f_{c1}=1kHz$，$f_{c2}= 10kHz$, $f_{c3}= 100kHz$。因此， $$ φ_{tot}=-arctan(\frac{5kHz}{1kHz})-arctan(\frac{5kHz}{10kHz})-arctan(\frac{5kHz}{100kHz}) \\ =-78.</description>
    </item>
    
    <item>
      <title>7.3 运算放大器闭环响应</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-3%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E9%97%AD%E7%8E%AF%E5%93%8D%E5%BA%94/</link>
      <pubDate>Fri, 14 Jul 2023 18:16:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-3%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E9%97%AD%E7%8E%AF%E5%93%8D%E5%BA%94/</guid>
      <description>为了能够精确地控制增益和带宽，运算放大器通常用于带有负反馈的闭环配置中。本节你将看到反馈是如何影响运算放大器的增益和频率的。
学完本节后，你应该掌握以下内容:
理解运算放大器的闭环响应 确定闭环增益 解释负反馈对带宽的影响 解释增益-带宽积 回顾一下第6章讲过负反馈会减小中频增益，前面讨论过的三种结构的闭环增益表达式如下。对同相放大器， $$ A_{cl(NI)}=\frac{R_f}{R_i}+1 $$ 对电压跟随器， $$ A_{cl(VF)}\approx 1 $$ 对反相放大器， $$ A_{cl(I)}\approx -\frac{R_f}{R_i} $$
7.3.1 负反馈对带宽的影响 我们已经学习了负反馈是如何影响增益的，现在将学习负反馈如何影响放大器的带宽。一个闭环运算放大器的截止频率为 $$ f_{c(cl)}=f_{c(ol)}(1+BA_{ol(mid)})~~~(7-4) $$ 从表达式可以看出，由于因子 $1+BA_{ol(mid)}$，闭环截止频率 $f_{c(cl)}$ 要大于开环截止频率$f_{c(ol)}$。B 是反馈衰减因子，等于 $R_i/(R_i+R_f)$。式(7-4) 的详细推导过程见附录。
因为 $f_{c(cl)}$ 等于闭环放大器的带宽，所以带宽同样随着相同的倍数增加。 $$ BW_{cl}=BW_{ol}(1+BA_{ol(mid)})~~~(7-5) $$
$$ 图7-8~~~闭环增益和开环增益的比较 $$ 图7-8用图形方式说明了补偿运算放大器闭环响应的概念。当负反馈减小运算放大器的开环增益时，带宽会增加。在两个增益曲线交叉点上方的增益，闭环增益与开环增益是彼此独立的。对闭环响应，交叉点处的频率是截止频率 $f_{c(cl)}$。注意，超过闭环截止频率后，闭环增益和开环增益具有相同的下降率。
7.3.2 增益-带宽积 由于增益和带宽的乘积是常量，闭环增益的增加会引起带宽的下降，反之亦然。只要下降率是固定的 一20dB/十倍频程，这就成立。如果 $A_{cl}$ 表示任意闭环配置中的增益， $f_{c(cl)}$ 表示闭环截止频率(等于带宽)，于是 $$ A_{cl}f_{c(cl)}=A_{ol}f_{c(ol)} $$ 增益-带宽积始终等于运算放大器开环增益为 1 时的频率(单位增益带宽)。 $$ A_{cl}f_{c(cl)}=单位-增益带宽~~~(7-6) $$</description>
    </item>
    
    <item>
      <title>7.2 运算放大器开环响应</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-2%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%BC%80%E7%8E%AF%E5%93%8D%E5%BA%94/</link>
      <pubDate>Fri, 14 Jul 2023 18:16:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-2%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%BC%80%E7%8E%AF%E5%93%8D%E5%BA%94/</guid>
      <description>本节学习开环频率响应和开环相位响应，开环响应的运算放大器没有外部反馈。频率响应表明电压增益是如何随频率而变化的，相位响应表明输人信号和输出信号之间的相移是如何随频率而变化。与晶体管的β参数类似，同一型号的各个器件之间开环增益的值差别很大。
学完本节后，你应该掌握以下内容:
理解运算放大器的开环响应 讨论内部电路级联数如何影响整体响应 讨论截止频率和下降率 确定总的相位响应 7.2.1 频率响应 在7.1节中，大于截止频率时，假设运算放大器的下降率是常量，即 一20dB/十倍频程。对大多数运算放大器来说，这是成立的。从$f_c$ 到单位增益，下降率为一20dB/十倍频程的运算放大器称为补偿运算放大器(compensated op-amp)。一个补偿运算放大器有一个 RC 网络，用来确定它的频率特性。因此，补偿运算放大器的下降率与基本 RC 网络相同。
对一些运算放大器电路，情况就更为复杂了。频率响应可能由内部许多级的电路决定，每级电路都具有自己的截止频率。因此，总的响应受到多个级联电路影响，它是各个级联电路响应的合成。具有多个截止频率的运算放大器称为非补偿运算放大器。
非补偿运算放大器需要特别注意反馈网络以避免振荡。例如，图7-7a所示的一个三级运算放大器，每级的频率响应如图7-7b所示。我们都知道，dB 增益是相加的，于是运算放大器总的频率响应如图7-7c所示。因为总的下降率是相加的，所以每到一个截止频率总下降率就增加 一20dB/十倍频程(一6dB/八倍频程)。
7.2.2 相移响应 在多级放大电路中，每级电路对总的相移都会有贡献。正如你看到的一样，每个 RC 滞后网络产生的相移最高可达 一90°。 因为一个运算放大器的每级电路包含一个 RC 滞后网络，所以例如一个三级运算放大器的相移滞后最大可达 一270°。同样地，当频率小于截止频率时，每级电路的相移滞后小于 一45°。当频率等于截止频率时，每级电路的相移滞后等于 一45°。当频率大于截止频率时，每级电路的相移滞后大于 一45°。将运算放大器每级电路的相移滞后加起来就可得到总的相移滞后，一个三级运算放大器的相移滞后如下: $$ φ_{tot}=-arctan(\frac{f}{f_{c1}})-arctan(\frac{f}{f_{c2}})-arctan(\frac{f}{f_{c3}}) $$</description>
    </item>
    
    <item>
      <title>7.1 基本概念</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Fri, 14 Jul 2023 18:16:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>本章学习运算放大器的频率响应、带宽、相移和其他一些与频率相关的参数。进一步研究负反馈的作用，了解稳定性的要求和如何补偿运算放大电路以确保稳定工作。
第6章学习了如何确定基本配置的运算放大器的闭环电压增益，以及开环电压增益和闭环电压增益之间的区别。因为这两种不同类型的电压增益很重要，所以本节将它们的定义再次列出。
学完本节后，你应该掌握以下内容:
讨论运算放大器响应的基本领域 解释开环增益 解释闭环增益 讨论增益的频率依赖性 解释开环带宽 解释单位增益带宽 确定相移 7.1.1 开环增益 $$ a)开环~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)闭环 $$
$$ 图7-1~~~开环和闭环运算放大器的配置 $$
运算放大器的开环增益($A_{ol}$)是器件内部的电压增益，等于输出电压和输人电压的比,如图7-1a所示。注意，因为图7-1中没有外部元件，所以开环增益完全由内部设计决定。不同运算放大器的开环电压增益变化非常大。表6-1列出了一些有代表性的运算放大器的开环增益。数据手册中的开环增益通常是指大信号电压增益。
7.1.2 闭环增益 运算放大器的闭环增益($A_{cl}$)是运算放大器具有外部反馈时的电压增益。放大器配置由运算放大器和外部负反馈网络组成，外部负反馈网络把输出端连接到反相输人端(一)。闭环增益由外部元件值决定，反相放大器的配置如图7-1b所示。闭环增益可以由外部元件值精确控制。
可编程增益放大器 可编程增益放大器(programmable gain amplifier, PGA)是一种可通过数字输人选择增益的运算放大器。可编程增益放大器常用于数据采集系统，在数据采集系统中，有各种不同信号电平的输入。典型地，一个给定的信道是由来自计算机或控制器的数字信号选定的，并且 PGA 将会有 2 ~ 10 个甚至更多的输人。根据 PGA 的型号和它的配置方式，每个信道可以将它的增益设置成能使其传感器输人得到优化，或者可以通过数字化编程来选择预定的增益。例如，PGA116 具有 10 个模拟输人，每个输人可以有 8 个任意选定的二进制增益(1~128)。PGA116 和类似型号 PGA117 有一个内置的多路复用器(通道选择电路)和其他功能，包括内部校准能力。
7.1.3 增益的频率依赖性 第 6 章中所有的增益表达式适用于中频增益，并且认为是与频率无关的。运算放大器的中频开环增益可以从 0 频(dc，直流)延伸到截止频率，在截止频率处的增益比中频增益小 3dB。这里的区别是运算放大器是直流放大器(在电路各级之间没有耦合电容)，因此没有低频端的截止频率。这就意味着中频增益向下延伸至 0 频(dc)，直流电压也可以与中频信号一样得以放大。
$$ 图7-2~~~一个典型运算放大器的开环电压增益与频率的理想曲线，频率标尺是对数 $$
图7-2 是一个运算放大器的开环响应曲线(伯德图)。大多数运算放大器的数据手册给出了这种类型的曲线或者规定了中频开环增益。注意，这个曲线每十倍频程减小 20dB(每八倍频程减小 6dB)。中频增益是20 0000，即 106dB，截止频率约为 10Hz。
7.1.4 3dB开环带宽 交流放大器的带宽是指增益比中频增益小 3dB 时两点之间的频率范围。一般地，带宽等于上限频率($f_{cu}$)减去下限频率($f_{cl}$)。 $$ BW=f_{cu}-f_{cl} $$ 因为运算放大器的 $f_{cl}$ 是0，所以带宽就简单地等于，上限频率。 $$ BW=f_{cu}~~~(7-1) $$</description>
    </item>
    
    <item>
      <title>6.6 运放阻抗和噪声</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-6%E8%BF%90%E6%94%BE%E9%98%BB%E6%8A%97%E5%92%8C%E5%99%AA%E5%A3%B0/</link>
      <pubDate>Fri, 14 Jul 2023 18:15:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-6%E8%BF%90%E6%94%BE%E9%98%BB%E6%8A%97%E5%92%8C%E5%99%AA%E5%A3%B0/</guid>
      <description>本节将会介绍负反馈连接如何影响运放的输入与输出阻抗。我们将会对反相放大器和同相放大器都进行讨论。
学完本节后，你应该掌握以下内容:
描述三种运放组态的阻抗 求同相放大器的输入和输出阻抗 求电压跟随器的输入和输出阻抗 求反相放大器的输入和输出阻抗 6.6.1 同相放大器的输入阻抗 已经知道: 负反馈使得反馈电压 $V_f$ 几乎等于输入电压 $V_{in}$. 输入电压与反馈电压的差值 $V_{diff}$ 接近于零，在理想情况下可假设它为零。此假设表明运放的输入信号电流也为零。因为输人阻抗为输入电压与输入电流的比值，所以同相放大器的输入阻抗为: $$ Z_{in}=\frac{V_{in}}{I_{in}}\approx \frac{V_{in}}{0} =无穷大(oo) $$ 在很多实际电路中，此假设有利于获得对运放工作原理的基本认识。更准确的分析需要考虑输入信号电流不为零的事实。
$$ 图6-27~~~同相放大器 $$ 利用图6-27，计算此运放电路的精确输入阻抗。在此分析中，假设两个输人端之间存在一个小的差分电压 $V_{diff}$，如图6-27所示。这意味着你不能假设运放的输入阻抗为无穷大，或者输入电流为零。输入电压可表示为 $$ V_{in}=V_{diff}+V_f $$ 用 $BV_{out}$代替$V_f$，有 $$ V_{in}=V_{diff}+BV_{out} $$ 因为 $V_{out} ≈ V_{ol}V_{diff}$($A_{ol}$为运放的开环增益)，所以 $$ V_{in}=V_{diff}+V_{ol}BV_{diff}=(1+A_{ol}B)V_{diff} $$ 因为 $V_{diff}=I_{in}Z_{in}$, 所以 $$ V_{in}=(1+A_{ol}B)I_{in}Z_{in} $$ 式中，$Z_{in}$是运放的开环输人阻抗(无反馈连接时)。 $$ \frac{V_{in}}{I_{in}}=(1+A_{ol}B)Z_{in} $$
$V_{in}/I_{in}$为此闭环同相放大器的总输入阻抗。
$$ Z_{in(NI)}=(1+A_{ol}B)Z_{in}~~~(6-9) $$
此式表明: 带有负反馈的这个运放电路的输人阻抗远大于运放自身的内部输人阻抗(无反馈)。
6.6.2 同相放大器的输出阻抗 除输人阻抗之外，负反馈也能改进运放的输出阻抗。无反馈放大器的输出阻抗非常小。加人反馈后，输出阻抗会变得更小。在很多应用中，假设带反馈的输出阻抗为零，这可以非常好地满足精度要求，即 $$ Z_{out(NI)}\approx 0 $$ $$ 图6-28~~~带反馈的同相放大器 $$
利用图6-28，可以精确分析带反馈的输出阻抗。对输出电路应用基尔霍夫定律，
$$ V_{out}=V_{ol}V_{diff}-Z_{out}I_{out} $$</description>
    </item>
    
    <item>
      <title>6.5 负反馈运放组态</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-5%E8%B4%9F%E5%8F%8D%E9%A6%88%E8%BF%90%E6%94%BE%E7%BB%84%E6%80%81/</link>
      <pubDate>Fri, 14 Jul 2023 18:15:27 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-5%E8%B4%9F%E5%8F%8D%E9%A6%88%E8%BF%90%E6%94%BE%E7%BB%84%E6%80%81/</guid>
      <description>本节将讨论三种利用负反馈稳定增益并增强频率响应的运放连接方式。如前所述，运放的极高开环增益会造成不稳定的情况，因为输入端的小噪声信号能被放大到使运放超出线性区工作。也可能发生不希望的振荡。此外，不同运放器件的开环增益参数可能会相差很大。负反馈将输出的一部分以与输入信号反相的方式返回输入端，能有效减小增益。闭环增益通常远小于开环增益，并与它无关。 学完本节后，你应该掌握以下内容:
分析三种运放电路组态
认识同相放大器组态
确定同相放大器的电压增益
认识电压跟随器
认识反相放大器组态
确定反相放大器的电压增益
6.5.1 闭环电压增益 $A_{cl}$ 闭环电压增益是带有负反馈的运放的电压增益。放大器电路包括运放和一个外部反馈网络，它将输出与反相输人端相连。那么闭环电压增益由反馈网络的元器件值决定，并能由它们精确控制。
6.5.2 同相放大器 图6-20所示是运放的一种闭环连接，称为同相放大器。输入信号加到同相(＋)输入端。输出的一部分通过反馈网络加到反相(一)输人端。这构成了负反馈。反馈系数B是返回反相输入端的输出电压的比例，它决定了放大器的增益，正如你将要看到的。反馈电压 $V_f$，可以写为
$$ V_f = BV_{out} $$
$$ 图6-20~~~同相放大器 $$
运放输入端之间的差分电压 $V_{diff}$ 如图6-21所示，可表示成 $$ V_{diff} = V_{in} - V_f $$
$$ 图6-21~~~差分输入V_{in}-V_f $$
因为负反馈和高开环增益 $A_{ol}$,输入差分电压非常小。所以，有 $$ V_{in} ≈ V_f $$
代入可得： $$ V_{in} ≈ BV_{out} $$ 重整理得： $$ \frac{V_{out}}{V_{in}} ≈ \frac{1}{B} $$ 反馈系数由分压网络中的 $R_i$ 与 $R_f$ 决定。对反馈网络使用分压定律，可以从输出电压 $V_{out}$ 中计算得到返回到输入端的部分电压。 $$ V_{in} ≈ BV_{out} ≈ (\frac{R_i}{R_i + R_f})V_{out} $$ 重整理得： $$ \frac{V_{out}}{V_{in}} = (\frac{R_i + R_f}{R_i}) $$ 可表示成： $$ A_{cl(NI)} = \frac{R_f}{R_i} + 1~~~(式子6-6) $$</description>
    </item>
    
    <item>
      <title>6.4 负反馈</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-4%E8%B4%9F%E5%8F%8D%E9%A6%88/</link>
      <pubDate>Fri, 14 Jul 2023 18:15:17 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-4%E8%B4%9F%E5%8F%8D%E9%A6%88/</guid>
      <description>负反馈是电子学尤其是运放应用中最有用的概念之一。负反馈是将输出电压中的一部分以与输人信号反相(或者减去)的方式返回到输入端的过程。
负反馈如图6-18所示。反相(一)输入使得反馈信号与输入信号有180°的相位差。运放具有极高的增益，将加到同相与反相输入端的信号的差值放大。所有运放只需要这两个信号之间有非常微小的区别，就能产生所需的输出。当使用负反馈时，同相输入与反相输入端几乎相同。这一概念可以帮助你理解运放电路中会产生什么样的信号。 现在来讨论负反馈是如何工作的，以及理解为何当使用负反馈时，为什么同相和反相输人端的信号几乎相同。假设在同相输入端加入1.0V的输入信号，运放的开环增益为100 000。运放对同相输入信号做出响应，使输出趋于饱和。同时，输出的一部分通过反馈通路返回到反相输人端。但是，如果反馈信号达到1.0V，运放将无信号可放大!因此，`反馈信号只是试图(但永远不会成功)与输入信号匹配``,增益由反馈的量所控制。当你对带有负反馈的运放电路进行故障检测时，请记住虽然这两个信号在示波器上看起来是相同的，但其实还是有细微区别。
现在假设由于某些原因使运放内部增益减小。这会使得输出信号减小一些，通过反馈通路返回到反相输人端的信号也减小。这意味着两个信号之间的差值变大，因此输出增大，补偿了之前的增益减小。输出端的信号变化很小，几乎测量不出来。这说明运放不论发生何种变化，都会很快通过负反馈得到补偿，从而产生稳定的、可预测的输出。
6.4.1 为什么使用负反馈 如你所见，一个典型运放的内部开环增益非常高(通常大于100 000)。因此，两个输人电压之间的极小差别就能使运放进入饱和输出状态。实际上，甚至是输入失调电压也能使运放饱和。例如，假设 $V_{in}$=1mV，$A_{ol}$=100 000，那么
$$ V_{in}A_{ol} = (1 mV) \times 100~000 = 100V $$
由于运放的输出不可能达到 100V，因此其进入饱和状态，输出被限制在它的最大输出电平，图6-19给出了输入电压分别为正(+)负(-) lmV 的情况。
$$ 图6-19~~~~没有负反馈时，两个输人电压之间的极小差别即可使运放达到输出极限，变成非线性 $$
没有负反馈时，两个输人电压之间的极小差别即可使运放达到输出极限，变成非线性
以这种方式工作的运放用途非常有限，通常只限于比较器应用(将在第8章中学习)。利用负反馈，总闭环电压增益($A_{cl}$) 可以减小并且可以控制，使得运放能作为线性放大器工作。除了提供可控、稳定的电压增益之外，负反馈也能实现对输人和输出阻抗、运放带宽的控制。表6-2总结了负反馈对运放性能的一般影响。 $$ 表6-2总结了负反馈对运放性能的一般影响 $$
电压增益 输入阻抗 输出阻抗 带宽 无负反馈 对线性放大器而言，$A_{ol}$太高 非常高(参见表6-1) 非常低 非常窄(因为增益太高) 有负反馈 通过负反馈网络使 $A_{cl}$达到期望值 利用不同种类的电路，能增加或减小到期望值 能减小到期望值 明显变宽 </description>
    </item>
    
    <item>
      <title>6.3 运放数据手册中的参数</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-3%E8%BF%90%E6%94%BE%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 17:41:00 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-3%E8%BF%90%E6%94%BE%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/</guid>
      <description>6.3.1输入失调电压 理想运放具有零输入零输出的特性。但是，在实际运放中，当没有加上差分输人电压时，输出端也会产生一个小直流电压 $V_{OUT(error)}$。其主要产生原因为运放差分输人级的基极-发射极电压存在轻微失配，如图6-11a 所示。 差分输入级的输出电压可表示为 $$ V_{OUT(error)}= I_{C2}R_C-I_{C1}R_C $$ $Q_1$ 与 $Q_2$ 基极-发射极电压的微小差别会导致集电极电流上的微小差别。这使得 $V_{OS}$ 不为零，这是一个误差电压。（集电极电阻相等。)
在运放数据手册中，输入失调电压($V_{OS}$)是两个输人端之间所需的差分直流电压，它使得差分输出为 0V。$V_{OS}$ 如图6-11b所示。输入失调电压的典型值为 2mV 范围之内或更小。理想情况下为 0V。 b)输入失调电压为能消除输出误差电压（使得 $V_{OUT}=0$）所需的输入端的电压差值
6.3.2输入失调电压温漂 输入失调电压温漂是与 $V_{OS}$ 相关的参数，表示温度每变化一度，对应输入失调电压的变化值。其典型值为 5～50μV/℃。通常，运放的输入失调电压越高，温漂越大。
6.3.3输入偏置电流 如你所见，双极型差分放大器的输人端为晶体管的基极，因此输入电流为基极电流。
输入偏置电流为放大器能在第一级正常工作时，输入端所需的直流电流。根据定义，输入偏置电流为两个输入电流的平均值，并计算如下: $$ I_{BIAS} = \frac{I_1+I_2}{2}$$ 输入偏置电流的概念如图6-12所示。 6.3.4 输入阻抗 定义运放输入阻抗的两种基本方式为差分模式与共模模式。差分输入阻抗为反相输入端和同相输入端之间的总电阻，如图6-13a所示。在给定差分输人电压变化下，确定对应的偏置电流变化，可得到差分输人阻抗。共模输入阻抗为每个输入端与地之间的阻抗。其可通过在给定共模输入电压变化下，确定对应的偏置电流变化来得到，如图6-13b所示。 6.3.5输入失调电流 理想情况下，两个输入偏置电流相等，差值为零。但是，在实际运放中，偏置电流完全相等。
输入失调电流 $I_{OS}$ 是输入偏置电流的差，用绝对值表示。 $$ I_{OS}=| I_1-I_2 | $$ 失调电流的实际幅度通常至少比偏置电流小一个数量级(十倍)。多数情况下，失调电流可以忽略。但是，对于高增益、高输入阻抗放大器而言，$I_{OS}$ 应尽可能小，因为即使电流差别很小，通过大输入电阻，也会产生较大的失调电压，如图6-14所示。 输入失调电流导致的失调电压为 $$ V_{OS}=|I_1-I_2| R_{in} = I_{OS}R_{in} $$ Ios导致的误差被运放增益Av放大，因此输出为 $$ V_{OUT(error)}= A_vI_{OS}R_{in} $$ 失调电流会随温度变化，进而影响误差电压。失调电流的温度系数通常在0.5nA/℃范围之内
6.3.6 输出阻抗 输出阻抗为从运放输出端看进去的电阻，如图6-15所示。 6.3.7 共模输入电压范围 所有运放都有正常工作的电压范围的限制。共模输入电压范围是在不会造成削波失真或其他输出失真的情况下，能够加入到两个输人端的输入电压范围。计多运放在直流电压为$\pm$15V的情况下，共模输人电压范围不超过$\pm$10V。但也有运放的输出能达到与电源电压一样大(这称为轨到轨(rail-to-rail))。</description>
    </item>
    
    <item>
      <title>6.2 差分放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-2%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:40:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-2%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>运放通常至少包含一个差分放大器级。因为差分放大器(差放)是运放的输人级，所以它是运放内部操作的基础。因此，有必要了解差分放大器。
学完本节后，你应该掌握以下内容:
讨论差分放大器及其工作原理 解释单端输入工作原理 解释差分输入工作原理 解释共模工作原理 定义共模抑制比 讨论差分放大器在运放中的使用 $$ a)电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)框图符号 $$
$$ 图6-4~~~~基本的差分放大器 $$
基本差分放大器(差放)的电路及其符号如图6-4所示。运放中的差放级提供了高电压增益和共模抑制(本节稍后给出定义)。
6.2.1 基本工作原理 下列讨论与 图6-5 相关，包括差分放大器工作原理的基本直流分析。
首先，当两个输人端都接地(0V)时，发射极电压为 $一0.7V$，如图6-5a 所示。假设晶体管 $Q_1$ 和 $Q_2$ 通过制造中的精密过程控制已达到一致匹配，这样当无输入信号时，两者的发射极直流电流也相等。因此， $$ I_{E1}= I_{E2} $$ 因为两个发射极电流在 $R_E$ 处汇合，所以 $$ I_{E1}= I_{E2}= \frac{I_{R_E}}{2} $$ 式中， $$ I_{R_E}= \frac{V_E-V_{EE}}{R_E} $$ 基于$I_C \approx I_E$的近似，可以得到 $$ I_{C1}=I_{C2} \approx \frac{I_{R_E}}{2} $$ 由于两集电极电流和两集电极电阻相等(当输入电压为零时)，有 $$ V_{C1}=V_{C2}=V_{CC}-I_{C1}R_{C2} $$ 此情况如图6-5a所示。
$$ 图6-5~~~~差分放大器的基本工作原理(地为0V)，其中给出了电流和电压的相对变化 $$ 其次，输人端 2 保持接地，向输入端 1 施加正偏置电压，如图6-5b所示。$Q_1$ 基极的正电压使 $I_{C1}$ 增大，并使发射极电压增加到 $$ V_E=V_B-0.7V $$ 这使得 $Q_2$ 的正向偏置($V_{BE}$)减小，因为 $Q_2$ 基极保持在0V(地)，这使得 $I_{C2}$ 减小，如图6-5b所示。整个结果是 $I_{C1}$ 增大使得 $V_{C1}$ 减小，$I_{C2}$ 减小使得 $V_{C2}$ 增大，如图6-5b所示。</description>
    </item>
    
    <item>
      <title>6.1 运算放大器介绍</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-1%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 14 Jul 2023 17:40:35 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-1%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>目前为止，已经学习了很多重要的电子器件。这些器件(例如二极管和晶体管)都是自独立封装的器件，在电路中与其他器件相互连接，以形成完整的功能单元。这样的器件为分立元器件。
现在将会学习更多的模拟(线性)集成电路，这些电路由很多晶体管、二极管、电阻和电容组成，在一块半导体材料微芯片上制造，并单独封装在一个壳中，形成一个功能电路。第5章已经介绍了一种专用集成电路(IC)，此电路专用于音频放大。
本章将介绍一种通用 IC，即运算放大器(运放)，它是最广泛使用的线性集成电路。虽然运放由很多电阻、电容和晶体管组成，但可以把它看成单一器件。这意味着你更关心从外部来看而不是从内部的元器件级角度来看它能够做什么。
6.1 运算放大器介绍 早期的运算放大器(运放)主要用于完成数学运算，例如加法、减法、积分和差分，因此称为运算放大器。这些早期器件用真空管制造，工作在高电压下。现在的运放是线性集成电路，使用较低的电源电压，并且可靠、便宜。
学完本节后，你应该掌握以下内容:
描述基本的运放及其特性 认识运放符号 识别运放封装上的端子 描述理想运放 描述实际运放 6.1.1 符号及端子 $$ a)符号~~~~~~~~~~~~~~~~~~~~b)标有直流电源接口的符号 $$ $$ c)~~~~典型封装。在双列直插(DIP)封装和表面贴装技术(SMT)上由缺口或圆点指示的是引脚1 $$
$$ 图6-1~~~~运放符号与封装 $$
标准运算放大器(运放)电路符号如图6-1a所示。它有两个输人端————反相(一)输入端和同相(＋)输人端，以及一个输出端。典型的运放需要两个直流电压供电以正常工作，其中一个为正，另一个为负，如图6-1b所示。为简单起见，在电路符号中通常会忽略直流电压端子，但应理解实际上它们存在。几种典型运放 IC 封装如图6-1c所示。
6.1.2 理想运放 为了说明运放究竟是什么，首先考虑其理想特性。当然，实际运放达不到这些理想标准，但从理想角度看，对器件的理解与分析更加简单。
首先，理想运放具有无穷大的电压增益与无穷大的输入阻抗(开路)，因此不会对驱动源产生负载效应。此外，运放具有零输出阻抗。这些特性如图6-2所示。两个输人端之间的电压 $V_{in}$ 为输入电压，输出电压为 $A_vV_{in}$，如内部电压源符号所示。无穷大输入阻抗的概念是很多运放电路的非常重要的分析工具，这将在6.5节中讨论。
6.1.3 实际运放 虽然现代集成电路(IC)运放在许多情况下可以使参数值接近理想值因而被当成理想运放，但没有实际运放能达到理想状态。所有器件都有其限制，运放也不例外。运放既具有电压限制也具有电流限制。例如，输出电压峰峰值通常被限制为略小于两个电源电压的差值。输出电流也被内部约束所限制，例如功率消耗和器件额定值等。
实际运放的特性有高电压增益、高输入阻抗、低输出阻抗和宽带宽。其中一些特性如图6-3所示。 $$ 图6-2~~~~理想运放表示 $$
$$ 图6-3~~~~实际运放表示 $$</description>
    </item>
    
    <item>
      <title>5.8 IC功率放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-8ic%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:40:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-8ic%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>集成电路(IC)是在单个硅片上由许多互联的电路元器件(电阻、二极管、晶体管)组成的具有一定功能的电路。对于模拟电子来说，第6章介绍的运算放大器是最常见的 IC。本节将会介绍为负载提供功率而专门设计的 IC 电路，还会介绍两种专用 IC 音频放大器:美国国家半导体公司的 LM384 和飞思卡尔半导体公司的 MC34119。
学完本节后，你应该掌握以下内容:
给出IC功率放大器的主要特性并描述它的应用 描述集成电路功率放大器的主要指标 说明如何将LM384音频功率放大器配置成一个基本的放大器 解释为什么LM384可以用作对讲系统的放大器 最初，小型集成电路功率放大器是为音频应用而设计，它们将扬声器直接连接到输出。随着应用的扩大，设备种类也不断扩大。今天已有许多专门用于功率放大器的 IC 放大器。与小的分立功率放大器相比，它们具有更高的可靠性和更低的价格。
IC 功率放大器应用广泛，从小型消费类产品到电源、工业电动机控制和稳压设计。大多数都包含A或者AB类功率放大器级和相关的驱动级以及通常会包括一定的电压增益。
虽然有些 IC 电路能给负载提供 100W 甚至更大功率，但功率 IC 的典型输出功率为几瓦。任何功率放大器的最大输出功率都取决于合适的散热。制造商的数据手册中会提供 IC 功率放大器所要求的散热信息。</description>
    </item>
    
    <item>
      <title>5.7 C类和D类功率放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-7c%E7%B1%BB%E5%92%8Cd%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:40:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-7c%E7%B1%BB%E5%92%8Cd%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>本章将要讨论的最后两类放大器在很多方面性能会有很大差别，但是它们都有很高的效率。C 类放大器主要应用于射频电路，比如 FM 发射器。它们一般都是围绕 BJT 和 JEFT 来搭建。D 类放大器是非线性开关放大器，主要利用 MOSFET 来搭建电路。在过去某一段时间，D 类放大器主要用于开关应用，例如电机控制。但是现在市场上已经出现了各种高质量的 D 类音频放大器。我们将首先介绍 C 类放大器。
学完本节后，你应该掌握以下内容:
解释 C 类和 D 类放大器的工作原理 解释基本的 C 类工作原理 描述 C 类偏置 解释 C 类放大器的调谐工作原理 求 C 类放大器的最大功率输出 讨论 D 类放大器的工作原理 解释脉冲宽度调制(PWM) 讨论 D 类放大器中的谐波和频谱 解释 D 类放大器中低通滤波器的作用 5.7.1 C类放大器的基本工作原理 $$ 图5-40~~~~基本的C类放大器工作原理(同相) $$
$$ 图5-41~~~~基本C类放大器工作原理 $$
C 类放大器工作原理的基本概念如图5-40所示。图5-4la给出了一个具有电阻性负载的共发射极C类放大器。C类放大器一般和谐振电路负载一起工作，因此使用的电阻性负载只为了来说明概念。利用负的 $V_{BB}$ 电源使放大器偏置在截止电压以下。交流源电压的峰值略大于 $|V_{BB}|+V_{BE}$，这样只有在每个周期接近正峰值的那一小段时间内，基极电压会超过发射结的势垒电势，如图5-41b所示。在这个短暂的间隔内，晶体管导通。当使用整个交流负载线时，如 图5-41c 所示，理想的最大集电极电流为 $I_{c(sat)}$，理想的最小集电极电压为 $V_{ce(sat)}$.
5.7.2功耗 $$ a）集电极电流脉冲~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）理想C类放大器的波形 $$
$$ 图5-42~~~~C类放大器的波形 $$
C 类放大器中晶体管的功耗很低，因为在整个输人周期中，晶体管只在一个很小的时间段内导通。图5-42a 给出了集电极电流脉冲。两个脉冲之间的时间为交流输入电压的周期(T)。在晶体管导通期间，集电极电流和集电极电压如 图5-42b 所示。为了避免复杂的数学运算，假设了理想的脉冲近似。通过这个简化，如果输出在整个负载线上波动，那么在晶体管导通期间，最大电流幅值为 $I_{c(sat)}$，最小电压幅值为 $V_{ce(sat)}$。因此，导通期间的功耗为</description>
    </item>
    
    <item>
      <title>5.6 B类功率放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-6b%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:39:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-6b%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>当放大器的偏置使其在输入信号的半个周期内处于线性工作区域，而在另外半个周期内处于截止状态时，该放大器就属于B类放大器。相比于A类放大器，B类放大器的优势是它的效率更高。在给定大小的输入功率下，B类放大器能获得更多的输出功率。一般来说，B类放大器至少需要两个有源器件，它们交替来放大输人波形中正的部分和负的部分。这种方式称为推挽。
学完本节后，你应该掌握以下内容:
计算 B 类放大器的交流和直流参数，包括双极型和 FET 型放大器 描述推挽放大器的两种组态 描述交越失真以及如何克服交越失真 解释 AB 类放大器与 B 类放大器的区别 描述如何避免双极型 AB 类放大器中的温度问题 讨论 MOSFET B 类放大器的特性 B 类工作指当 Q 点位于截止区时，导致输出电流只在输入信号的半个周期内变化。在线性放大器中，需要两个器件来完成整个周期工作; 一个放大正半周，而另一个放大负周期。就像你将会看到的，这种工作方式对于功率放大器来说有极大的优点，因为它极大地提高了效率。正是由于这个原因，它们广泛地用于功率放大器。
5.6.1 点位于截止区 $$ 图5-27~~~共集电极B类放大器 $$ B类放大器偏置在截止区，因此 $I_{CQ}=0，V_{CEQ}=V_{CE(cutoff)}$。这样，当没有信号时, 就没有直流电流或者功率损耗。当某信号驱动B类放大器进入导通后，它运行在线性区域。图5-27利用射极跟随器来说明这个情况。
5.6.2 推挽工作 可以看到图5-27中的电路只在正半周期导通。为了放大整个周期信号，必须增加第二个 B 类放大器，并使它在负半周期工作。将两个 B 类放大器组合在一起工作称为推挽工作。
有两种使用推挽放大器来复制完整信号的常见方法。第一种方法使用变压器耦合。第二种使用两个互补对称的晶体管﹔可以是一对匹配的 $npn/pnp$ BJT或者一对匹配的 n 沟道/p沟道 FET。
$$ 图5-28~~~变压器耦合的推挽放大器。Q_1在正半周导通， \\ Q_2在负半周导通。输出变压器将这两个信号整合起来 $$ 变压器耦合 变压器耦合如图5-28所示。输入端变压器的二次绕组是中间抽头的，中间抽头接地，因此二次侧两端的信号互为反相。这样输入端变压器将输入信号转变成两路反相的输出信号后传输给晶体管。注意,两个晶体管都是 npn 型。因为信号的反相，所以 $Q_1$ 将在正周期部分导通，而 $Q_2$ 将在负周期部分导通。输出变压器在两个方向上都允许电流流过，因此它可以将晶体管的两个输出信号整合起来，即使一个晶体管始终处于截止状态。正电源信号连接到输出变压器的中间抽头。
$$ a）正半周期~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）负半周期 $$
$$ 图5-29~~~B类推挽工作方式 $$
互补对称晶体管 图5-29给出了一个最常用的推挽B类功率放大器，它使用两个射极跟随器，以及两个正负电源供电。这是互补放大器，因为一个射极跟随器使用 npn 晶体管，而另一个使用 pnp，分别在输入信号的两个半周期内交替导通。注意，没有直流偏置电压($V_B=0$)。因此，只有信号电压才能驱动晶体管进入导通状态。$Q_1$ 在输入的正半周导通，$Q_2$ 在输入的负半周导通。</description>
    </item>
    
    <item>
      <title>5.5 A类功率放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-5a%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:39:41 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-5a%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>当放大器所加的偏置始终使它工作在线性区，即输出信号是输入信号的放大复制时，它就是 A 类放大器。前面章节的讨论和式子都适用于 A 类工作状态。功率放大器是指将功率传送给负载的放大器。这意味着必须考虑到这些元件的散热能力。
学完本节后，你应该掌握以下内容:
计算 A 类功率放大器关键的交流和直流参数，并讨论交流负载线的工作 解释为什么对于 A 类放大器来说 Q 点位于中心很重要 确定多级放大器的电压增益和功率增益 确定 A 类放大器的效率 在小信号放大器中，交流信号只在交流负载线的极小范围内移动。当输出信号比较大并且接近交流负载线的上下限时，它就是一个大信号类型的放大器。只在所有时候内以大器都工作在线性区，就认为大信号和小信号放大器都是A类放大器。A 类功率放大器是指提供功率(而不是电压)给负载的大信号放大器。根据经验，如果需要考虑元件的散热问题(&amp;gt;1/4W)，那么这个放大器就可能是一个功率放大器。
5.5.1 散热 功率晶体管(和其他功率器件)必须驱散内部产生的过量热量。对于双极型功率晶体管，集电极是最关键的部位，所以晶体管外壳始终与集电极相连。所有功率晶体管的外壳都在管子和散热槽之间设计有一个较大的接触面积。晶体管产生的热流过外壳到达散热槽，然后散发到周围的空气中。散热槽的尺寸、鳍板的数量、材料的种类等都会有所不同，尺寸取决于散热要求和晶体管工作环境的最高温度。在大功率(几百瓦)应用场合，还需要冷却扇。
5.5.2中心Q点 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$
$$ 图5-22~~~当Q点位于交流负载线的中心时A类放大器有最大输出 $$ 3.4节曾提到，直流负载线和交流负载线在 Q 点相交。当 Q 点位于交流负载线的中点时，就能得到 A 类信号的最大值。查看图5-22a中给定放大器的负载线图，就能理解这个概念。该图给出了交流负载线，其中 Q 点位于其中心。集电极电流可以从 Q 点值 $I_{CQ}$ 向上最大变化到饱和值 $I_{c(sat)}$，向下最小变化到截止值 0。同样，集电极-发射极电压可以从其 Q 点值 $V_{CEQ}$ 增大到最大截止值 $V_{ce(cutoff)}$，减小到最小饱和值(近似为 0)。这个工作过程如图5-22b所示。集电极电流的峰值等于 $I_{CQ}$，相应的集电极-发射极电压的峰值等于 $V_{CEQ}$。这个信号就是 A 类放大器中可以获得的最大信号。实际上，输出不能完全达到饱和和截止，所以实际最大值要小一些。
$$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$
$$ 图5-23~~~Q点靠近截止区 $$ 如果 Q 点不在交流负载线的中心，输出信号就会受到限制。图5-23给出了Q点从中心移向截止时负载线的情况。本例中，输出范围受截止的限制。集电极电流只能在向下到接近于 0 和大于 $I_{CQ}$ 向上等量的范围内摆动，集电极-发射极电压只能在向上到截止值和小于 $V_{CEQ}$ 向下等量范围内摆动变化，如图5-23a所示。如果放大器工作范围超过此区域，则就会在截止处被“削顶”，如图5-23b所示。</description>
    </item>
    
    <item>
      <title>5.4 直接耦合放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-4%E7%9B%B4%E6%8E%A5%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:39:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-4%E7%9B%B4%E6%8E%A5%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>另一种耦合信号的重要方式是直接耦合。采用直接耦合，级间没有耦合电容和变压器。根据输人和输出信号的耦合方式，某些放大器可以放大低至直流的任何频率的信亏。本节将介绍直接耦合放大器，然后加入负反馈来稳定偏置和增益。直接耦合也将应用在功率放大器中，这在5.5节中讨论。
学完本节后，你应该掌握以下内容:
确定直接耦合放大器基本的直流和交流参数，并描述负反馈如何稳定放大器的增益 描述直接耦合级如何得到偏置 计算直接耦合放大器的直流和交流参数 解释负反馈如何稳定偏置和增益 $$ 图5-17~~~无反馈的直接耦合放大器 $$ 图5-17是一个直接耦合放大器。信号从 $Q_1$ 的集电极直接耦合到 $Q_2$ 的基极。由于是直接耦合， $Q_2$ 的基极电流是由 $Q_1$ 提供，因此对于 $Q_2$ 不需要任何偏置电阻，以及级间不需要耦合电容。虽然级间是直接耦合，但在这个放大电路中，为了避免外部信号源和负载干扰直流电压，有必要在输入、输出端对交流信号进行耦合(通过电容)。
$Q_2$ 的偏置通过 $Q_1$ 的集电极电阻 $R_{C1}$ 来提供。由于 $Q_1$ 是分压式偏置，所以与 $\beta$ 无关，但 $Q_2$ 采用的是基极偏置，这种偏置方法在线性放大器中使用不太理想，因为会随 $\beta$ 参数变化。另外，温度变化会引起电路的漂移。虽然这款放大器所用的元件少于电容耦合放大器，但存在的缺点比优点多。不过，只要对它做些简单的改动——加人负反馈就能解决随 $\beta$ 变化和漂移的问题。
5.4.1负反馈增强偏置稳定性 $$ 图5-18~~~一个带负反馈的直接耦合放大器，能够稳定偏置 $$
图5-18所示的电路是将图5-17中的放大器减少元件数量后修改得到的放大器，它能够大大改善偏置稳定性。为了避免对偏置电压造成干扰，输入和输出信号采用电容耦合。因为电路中有两个晶体管，所以红色显示的反馈网络利用了相对于单个晶体管产生的额外增益，使电路相对于 $\beta$ 的变化和温度的变化非常稳定。这和3.2节集电极负反馈偏置中的负反馈是类似的。
下面来看图5-17中的反馈如何工作。从 $Q_2$ 开始，注意， $Q_2$ 的基极通过 $R_{C1}$ 正向偏置，从而产生 $Q_2$ 的集电极电流 $I_{C(Q2)}$。该电流会使 $Q_2$ 的发射极电压升高，从而使 $Q_1$ 导通。随着 $Q_1$ 导通程度越来越深， $Q_1$ 集电极电压下降，使 $Q_2$ 的偏置减少。 $Q_2$ 偏置减少的结果是将该偏置稳定在由专门设计的值确定的稳定点。
通过对由$V_{CC}、R_{C1}、V_{BE(Q2)}、R_F、V_{BE(Q1))}$和 $R_{E1}$ 组成的回路应用基尔霍夫电压定理(KVL)求得 $Q_1$ 的集电极电流，约为: $$ I_{C(Q1)}=\frac{V_{CC}-2V_{BE}}{R_{C1}+\frac{R_F}{\beta}+R_{E1}} $$ 设计电路使得 $R_{C1}$ 远大于 $R_F/\beta$ 或 $R_{E1}$。这样，$I_{C(Q1)}$ 几乎完全与 $\beta$ 无关，在 $Q_1$ 集电极上产生一个稳定的电压，以及在 $Q_2$ 产生一个稳定的基极电压。因此，与基极偏置相关的 $\beta$ 依赖性不再是一个问题。</description>
    </item>
    
    <item>
      <title>5.3 变压器耦合放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-3%E5%8F%98%E5%8E%8B%E5%99%A8%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:39:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-3%E5%8F%98%E5%8E%8B%E5%99%A8%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>变压器可以用来将信号从一级耦合到另一极。虽然主要用于高频设计中，但它也可用于低频功率放大器中。当信号频率位于RF范围内(&amp;gt;100kHz)时，放大器的各级之间常用调谐变压器来进行耦合，该变压器形成一个谐振电路。在本节中，将会看到变压器耦 合放大器的例子，包括低频和高频调谐放大器。
学完本节后，你应该掌握以下内容:
描述变压器耦合放大器、调谐放大器和混频器的特性 描述变压器耦合放大器一般如何工作 确定变压器耦合放大器的交流和直流负载 线解释如何利用混频器将高频转换成低频 给出在高频应用中使用IF放大器的优势 5.3.1 低频应用 大多数放大器要求直流信号应该与交流信号隔离。5.1节已经提及电容具有隔直流通交流的作用。变压器也具有隔直流(没有提供直接的通路)通交流的性能。 此外，变压器提供了电路中阻抗匹配的方法。在基本直流/交流课程中已经知道从变压器一次侧来看，二次侧的负载会被变压器改变。降压变压器会使负载在一次侧看起来变得更大，可以表示为:
$$ R&amp;rsquo;_L~~(a) $$
$$ (a)=(\frac{N_{pri}}{M_{sec}})^2R_L~~~(5-4) $$ 式中，(a)是一次侧等效电阻，$N_{pri}/N_{sec}$是一次绕组对二次绕组的匝数比，$R_L$为二次侧的负载电阻。
变压器可以用在输人端、输出端，或者各级之间来耦合电路中各部分之间的交流信号。在功率变压器中，通过阻抗匹配可以进行最大功率传输(将在5.4节中讨论)。变压器也能用来进行信号源和传输线之间的阻抗匹配。线匹配变压器主要用于低阻抗电路($&amp;lt;200\Omega$)。对于电压放大器，变压器也可以用来实现升压以传输给下一级(但功率永远不会变化)。
$$ 图5-11~~~一个变压器耦合的基本放大器，给出了输人变压器、耦合变压器和输出变压器 $$ 图5-11给出了一个变压器耦合的两级放大器。小的低频变压器偶尔也会用在某些传声器或其他传感器中来将信号耦合到放大器。
虽然变压器耦合比 RC 耦合具有更高的效率，但由于存在两个缺点，变压器耦合不能广泛应用于低频电路。首先，与电容相比，变压器价格比较昂贵，并且比较笨重;其次，由于绕组电抗的作用而使其高频响应变差。由于上述原因，低频变压器耦合并不常用，但在某些 A 类功率放大器中会有使用。
5.3.2高频应用 在高频段，变压器会比较小，并且也相对便宜。对于在一定带宽范围内耦合信号而言具有重要的优势。正如在上一节中所看到的，在高频段，变压器初级可以接上一个并联电容来形成一个高 Q 值的谐振电路。接有合适电容的二次绕组也经常连接成一个谐振电路。
从基本交流和直流知识已经知道，并联谐振电路是一个LC电路，它在谐振频率处有最大的阻抗。谐振频率处的高阻抗意味着放大器增益在谐振频率附近可以非常高，而直流时增益却很低。这就形成了一个增益可高达1000(甚至更高)的窄带(典型为10kHz)放大器。此外，放大器可以选择只放大包含有用信号的非常窄范围内的频率信号，而不放大其他频率的信号。
在信号处理中，通常要通过将 RF 和振荡器混合来将无线频率转换成较低的频率。得到的这个新低频称为中频(IF)。调谐变压器耦合在RF和IF放大器中都很重要。
使用 IF 的主要优点是它是一个固定频率，并且对于任何给定的RF信号(在设计范围内)，调谐电路无需改变。这可以通过让振荡器跟踪RF信号来完成。因为IF固定，所以用固定的调谐电路来进行放大就很简单，无须用户进行任何调整。这一思想首先由MajorEdwin Armstrong在第一次世界大战期间提出，并在大多数的通信设备中使用，此外也用于频谱分析仪，它是高频测试设备的重要部分。
$$ 图5-13~~~一个调谐放大器，包括一个RF放大器和一个混频器 $$ 图5-13是一个两级调谐放大器的例子，它在第一级的输人端和第二级的输出端都使用谐振电路。两级之间采用变压器耦合。与此类似的电路是大多数通信设备的组成部分，由一个RF放大器和一个混频器组成。RF放大器用于调谐并放大来自信号站的高频信号。混频器是非线性电路，它将信号与振荡器产生的正弦波混合在一起。
振荡器的频率设置与 RF 之间有一个固定差值。当 RF 与振荡器信号中在非线性电路中混合时，会产生两个新频率: 两个输入信号的和以及两个输人信号的差。第二个谐振电路调谐到差值频率，同时对其他频率进行抑制。这个差值频率就是IF信号，会在IF放大器中进一步放大。IF 放大器的优点在于它是专门用来处理单一频率的放大器。
进一步来看图5-13中的电路。第一个调谐电路包括变压器 $T_1$ 的一次侧，它与 $C_1$ 构成谐振回路来接收信号。非谐振频率的信号被谐振回路抑制。注意，$Q_1$ 的偏置方式是分压式偏置，它没有集电极电阻，而是信号将变压器 $T_2$ 的一次侧看成负载。这一级的增益由集电极电路的电阻除以由 $R_3$和 $r&amp;rsquo;_e$ 组成的发射极电阻确定。
RF 信号通过变压器 $T_2$ 送到 $Q_2$ 的栅极，并与来自振荡器(图5-13中未给出)的信号进行混合。注意， $Q_2$ 对 RF 信号来说是 CS 放大器，但对振荡信号来说是CG放大器。 $Q_2$ 输出端的谐振电路调谐到设定的差值频率，因此 $Q_2$ 的输出是中频(IF)，被送到下一级作进一步放大。为了产生中频，$Q_2$ 必须在非线性放大状态下工作。FET 可以很好地实现这个功能。经常利用两级 MOSFET 将混频器和 RF 放大器结合在一起，如前所述。</description>
    </item>
    
    <item>
      <title>5.2 RF放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-2rf%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:38:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-2rf%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>一般来说，射频(RF)是指用来进行无线传输的频率，范围包括从大约10kHz的实际低频到 300GHz 以上。在 100kHz 以上，放大器经常在输人端、输出端或负载端采用调谐电路，因此很多人喜欢将工作在 100kHz 以上的放大器称作RF放大器。在高频，放大器只用来为那些在一定频段内的频率提供增益。本节将给出高频放大器的一些实际考虑因素。下一节将会介绍高频信号如何通过变压器从一级耦合到另一级。
学完本节后，你应该掌握以下内容:
描述高频放大器的特性并给出实现高频电路时的实际考虑因素 解释当在高频工作时传输线的需求 在给定每单位长度电感和电容的情况下，求电缆的特性阻抗 解释终止电缆的正确方法以避免反射 描述 RF 放大器重要的交流参数 解释中和的意思 解释 AGC 如何工作 5.2.1传输线 当高频信号或者快速上升的数字信号从某一点传输到另一点时，传输线将会产生很多不利的影响，比如信号的衰减、高频响应的下降和噪声的增加。对于几英寸长的信号路径来说，当信号频率在大约100MHz以上或数字信号的上升时间小于约4ns时，这些影响将尤为重要。
考虑由两条电线组成传输线，用它来将一个高频信号从一个点发送到另一个点。电线会有一个电感L，它沿着电线方向为串联形式，同时也会有一个电容C，它在两个传导线之间以并联方式存在。(两个导体用一个绝缘体来分隔形成一个电容。)在高频时，串联的电感上升，而并联的电容下降。电线上的电感和电容不是集中在某一点的，它是分布在整个导线上。
$$ a）一小段传输线的等效电路~~~~~~~~~~~~~~b）三段等效传输线串联 $$
$$ 图5-6~~~高频传输线的等效电路 $$ 图5-6a描述了一小段传输线的等效电路，其中电感和电容画成了分立元件，但是要知道的是，电感和电容是平均分布在整个导线上的。电感被分成了 4 个小电感，每个小电感的电感值是 $L/4$。电容值为C。此外还存在电阻值，但是在高频时，电阻对阻抗产生较小的贡献，因此可以忽略。
为了帮助理解传输线，对一小段等效电路进行扩展，扩展到由一系列小段分立电感和电容连接在一起的情况，如图5-6b所示。如果加长等效电路，会发现一个很有趣的现象;当段数大于10后，再继续增加段数，传输线的阻抗几乎不变。也就是说，阻抗不取决于传输线的长度。这个固定的阻抗值称为传输线的特征阻抗。在高频时，传输线的特征阻抗可表示为: $$ Z_0=\sqrt[]{\frac{L}{C}}~~~(5-1) $$ 式中，$Z_0$ 为传输线的特征阻抗，单位为欧姆(Ω); L为单位长度的电感值。单位为亨利(H); C为单位长度的电容值。单位为法拉(F)。
注意，L和C必须是相同长度的数值。由于公式取的是比值，因此使用多少长度没有关系，只要电感和电容使用的长度一样就可以。电缆的阻抗是几何尺寸和用来构造电缆的介质类型的函数。对于高频应用来讲，有各种不同类型的电缆。它们应该都有较大的带宽和一个与长度无关的固定阻抗。
一类常见的高频传输线是同轴电缆。同轴电缆由一根轴芯和包围在轴芯外面的导体屏蔽层组成。在高频时，这个屏蔽层可以起到屏蔽的作用，可以用来屏蔽轴芯内的信号向外辐射而导致信号的衰减，同时也可以防止外部的信号对轴芯内的信号造成干扰。不同的同轴电缆有不同的特性，比如功率、高频特性和特征阻抗等。
在给定系统中，安装所要求的电缆类型非常重要。比如，视频系统标准中使用 75 欧姆的同轴电缆。不同的电缆有不一样的特征阻抗，对于同轴电缆来说，典型范围为 50~100Ω，对于并联导体可以达到几百欧姆。
由于它的带宽比较宽，因此同轴电缆用于很多通信系统中，其中许多不同的声音频道可以放在相同的电缆上。频分滤波器允许在同一时刻进行双向传输。
5.2.2终止传输线 在高频下，即使一小段传输线相对于信号波长来说也可能是很长的。当来自信号源的信号(入射波)到达传输线终端时，它会被反射回到信号源(反射波)。入射波和反射波沿着线长互相作用，在线上形成驻波。驻波是由人射波和反射波相互作用形成的稳态波。
驻波会对电视信号产生诸如叠影之类的不期望影响而且会增加噪声。为了防止驻波需要在终端加上一个和传输线特征阻抗相同的电阻负载。当传输线以该方式终止时，整个传输线对于信号源而言呈现电阻特性。当传输线正确终止时，所有信号功率都消耗在终端的负载电阻上。不正确的终止可能会产生反射以及导致错误的信号电平。
5.2.3 高频考虑 电感效应 在高频(大约10MHz以上)时，传输线不再是一条简单的导电通路，而成为一个有效的电感。这是由于趋肤效应造成的，趋肤效应会导致电流移动到导体的外表面。这种电感通常不是我们所需要的，因为它会增加传输线的电抗并增加电路中的噪声. 为了避免电感的不利影响，高频电路中的电线应该尽可能的短.
电容效应 在高频的时候，由于电容效应不断增加，晶体管放大器可能会越来越无效。所有有源器件在它们的各极之间都有内部电容。这些内部电容对于高频模拟信号而言相当于低阻抗通路，因此降低了这些器件的有效性。在数字电路中，内部电容限制了脉冲从一个电平变化到另一个电平的速度。因此专门设计了高频晶体管来减小内部电容。
电容的不利影响会被反相放大器(如共源或共射放大器)放大，因为它会形成一种称为米勒效应的正反馈。因此在高频电路中要尽量减小电容值，这可以通过让传输线尽可能短以及避免使用高增益的反相放大器来实现。
电容的另外一个影响是在高频放大器中产生不期望的振荡。振荡可以通过中和的办法来消除，这在后面将会详细讲述。
5.2.4 调谐放大器 带谐振电路的放大器在通信系统中很常见，因为通信系统采用很高的频率。大于 100kHz 的频率通常称为射频或RF。工作在这些频段的放大器被称为射频(RF)放大器对于低频放大器求直流偏置状态的方法同样适用于射频放大器，但对于交流分析需要做些修正。低频放大器是非谐振的，它们用来放大较宽频率范围的信号。
调谐放大器则不同，它们用来放大特定的频段，并消除频段之外的信号。它们使用并联 LC 谐振电路作为负载，在谐振频率时，它对交流信号呈现较高的阻抗，因此产生较高的增益。谐振电路的中心频率(假设 Q 很大)可利用基本的谐振频率方程计算得到。 $$ f_r=\frac{1}{2\pi \sqrt[]{LC}}~~~(5-2) $$</description>
    </item>
    
    <item>
      <title>5.1 电容耦合放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-1%E7%94%B5%E5%AE%B9%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:38:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-1%E7%94%B5%E5%AE%B9%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>前面两章介绍了单级放大器，其主要功能是放大信号电压。你应该已经熟悉了 BJT 与 FET 的偏置和交流参数。
当必须放大一个非常小的信号(如来自天线的信号)时，Q 点上的变化也会相对较小。用于放大这些信号的放大器称为小信号放大器。它们也可能专门用于高频情况。通常来讲，包含额外的增益级会非常有用，特别是在高频通信系统中，其中感兴趣的频率被限制在一定的带宽范围之内。
本章将学习各种不同类型的多级放大器，特别强调高频时的一些考虑，包括噪声、布线，以及消除不必要的振荡。然后将重点转向功率传输的重要要求。对于这些应用，需要功率放大器。最后将介绍集成电路(IC)功率放大器。
5.1电容耦合放大器 两个或多个晶体管可以连接在一起组成一个放大器，该放大器称为多级放大器。1.4节已经介绍了一个简化的放大器模型。现在可以将该简化模型应用到实际放大器电路中来确定它们的整体性能。本节将学习电容耦合放大器，也称为 RC(阻容)耦合放大器。电容耦合是将交流信号传输到后一级最常使用的方法。
学完本节后，你应该掌握以下内容:
确定电容耦合多级放大器的交流参数 计算两级电容耦合放大器的总增益、输入电阻和输出电阻 讨论多级放大器中如何减小振荡和噪声问题 两个或多个晶体管可以连接在一起来提高放大器的性能。放大信号的每个晶体管都称为一级。一般来讲，放大器的第一级必须有非常高的输入电阻来避免对信号源产生的负载作用。另外，第一级需要设计成低噪声工作，因为这些微弱信号电压很容易会被噪声所淹没。后续级的目的是在不产生失真的前提下来增加信号的幅度。
$$ \beta_{DC}=\beta_{ac}=150，对于Q_1和Q_2 \\ 图5-1~~~一个两级CE放大器 $$
提高放大器增益最简单的方法可以是两级通过电容耦合在一起，如图5-1所示。在本例中，两级都是相同的 CE 放大器，第一级的输出连接到第二级的输入端。由于电容具有隔直流的作用，因此电容耦合会阻止其中一级的直流偏置影响另一级的直流偏置。虽然直流通路为开路，但是耦合电容可以让交流信号顺利地传输到下一级。
该电路的分析首先需要分析直流工作状态，如3.2节所述。利用分压原理来计算每级的基极电压。
$$ V_B\approx (\frac{R_2}{R_1+R_2})V_{CC}=(\frac{10K\Omega}{47K\Omega+10K\Omega})10V=1.7V $$
该估计值会略高于实际值，因为没有考虑分压器的负载。减去发射结二极管两端的0.7V电压后，可得到发射极电压为1.0V，因此计算得到发射极电流为:
$$ I_E=\frac{V_E}{R_E}=\frac{1.0V}{1.0K\Omega}=1.0mA $$
发射极电流也约等于集电极电流。
5.1.1负载效应 $$ a）单级放大器模型~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）图5-1中一级放大器的值 $$
从1.4节已经知道放大器可以用框图来表示，框图中只包含重要的参数。交流模型仅仅是一个受控电压源与一个电阻串联(戴维南电路)。为了计算放大器的总增益，图5-2中的每个晶体管级都可以用类似的方式建立模型。只需要知道三个参数: 空载时的电压增益($A_{v(NL)}$)、总输入电阻($R_{in(tot)}$)、输出电阻($R_{out}$)。可以看到空载输出电压等于输入电压乘以空载增益。
首先求一级的空载增益。因为两级相同，所以两级的空载增益也相同。第二级的输入电阻相当于第一级的负载。因此，第一级的负载增益可以通过假设其负载电阻等于第二级的输入电阻 $R_{in(tot)}$ 来计算得到。这会降低第一级的增益，但可以与空载增益计算分开来考虑。该概念的说明会让我们更清楚地认识到基本放大器模型可以简化总增益的计算。
已经知道 CE 放大器的空载增益是集电极交流电阻和发射极交流电阻的比值，空载增益与 $r&amp;rsquo;_e$ 有关，而这个参数又与 $I_E$ 有关，所以应作近似处理。
因为要计算空载增益，交流集电极电阻 $R_e$与实际的集电极电阻 $R_C$ 相同，为 4.7kΩ;
交流发射极电阻约为:
$$ r&amp;rsquo;_e\approx \frac{25mV}{I_E}=\frac{25mV}{1.0mA}=25\Omega $$
空载增益 $A_{v(NL)}$ 约为:
$$ A_{v(NL)}=-\frac{R_C}{R_e}=-\frac{R_C}{r&amp;rsquo;_e}=-\frac{4.7k\Omega}{25\Omega}=-188 $$
CE放大器的输人电阻在3.4节中已经讨论过，采用分压式偏置和没有扩量程电阻的放大器的输入电阻表达式为:
$$ R_{in(tot)}=R_1||R_2(\beta_{ac} r&amp;rsquo;_e) $$</description>
    </item>
    
    <item>
      <title>4.7 MOSFET开关电路</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-7mosfet%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 17:38:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-7mosfet%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF/</guid>
      <description>虽然 BJT 和 JFET 都能用于开关电路，但 MOSFET 是目前大多数开关应用的首选器件。 MOSFET 具有很低的导通电阻，非常高的断开电阻，很快的切换时间，因此它是极好的开关器件。有两种基本类型的 MOSFET 开关电路:模拟和数字。本节将介绍数字和模拟 MOSFET 开关电路。
学完本节后，你应该掌握以下内容:
描述如何将 MOSFET 用于模拟和数字开关电路中 解释如何让 MOSFET 像开关一样工作 描述 MOSFET 模拟开关 讨论模拟开关应用 描述开关电容电路 描述 MOSFET 如何在数字开关电路中应用 讨论互补 MOS(CMOS) 逻辑 解释几种 CMOS数字门的工作原理 讨论几种功率 MOSFET 结构 4.7.1 MOSFET 开关工作原理 $$ 图4-52~~~在负载线上的开关工作 $$ 通常将 E-MOSFET 用于开关应用，因为其具有阈值特性，$V_{GS(th)}$。当栅源电压小于阈值时，MOSFET 处于关闭状态。当栅源电压大于阈值时， MOSFET 导通。当 $V_{GS}$ 在 $V_{GS(th)}$ 与 $V_{GS(on)}$ 之间变化时， MOSFET 就以开关方式工作，如图4-52所示。在关闭状态， $V_{GS}$ &amp;lt; $V_{GS(th)}$ ，器件工作在负载线的下端，相当于一个打开的开关(非常高的 $R_{DS}$)。当$V_{GS}$ 足够大于 $V_{GS(th)}$ 时，器件工作在负载线上端的可变电阻区，相当于一个闭合的开关(非常低的 $R_{DS}$）。 $$ a) ~n沟道MOSFET和等效开关~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) ~p沟道MOSFET和等效开关 $$</description>
    </item>
    
    <item>
      <title>4.6 FET线性放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-6fet%E7%BA%BF%E6%80%A7%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:38:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-6fet%E7%BA%BF%E6%80%A7%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>虽然 MOSFET 主要用于开关电路，但 JFET 和MOSFET 都能在类似于之前学习的 BJT 的CE、CC 和CB 放大器的三种电路组态中用作线性放大器。FET 组态有共源(CS)、共漏(CD)和共栅(CG)。CS 与 CD 放大器具有高输人阻抗和低噪声的特性，是第一级放大器的最佳选择。共栅放大器的应用不多，因此本书只对其进行简要介绍。
学完本节后，你应该掌握以下内容:
描述FET线性放大器的工作原理 描述三种 FET 线性放大器的组态:共源(CS)、共漏(CD)和共栅(CG) 在给定跨导的情况下计算任何 FET 放大器的增益 解释为什么具有电流源偏置的 CD 放大器比单级 CD 放大器更好 4.6.1 FET的跨导: FET的传输特性，即跨导曲线，如图4-9a所示。FET 和 BJT 有本质区别，因为 FET 是电压控制器件。输出的漏极电流由输入的栅极电压控制。跨导为交流参数，定义为:
$$ g_m=\frac{I_d}{V_{gs}} $$
考虑到上式是输出电流($I_d$)除以输人电压($V_{gs}$)，因此跨导本质上是 FET 自身的增益。但和 $\beta_{ac}$ 是纯数字不同，跨导有单位，为西门子(电阻的倒数)。许多数据手册会继续沿用旧单位姆欧(mho，将ohm反向拼写)。如图4-37a所示，一个特定 FET 的跨导可以直接测量得到。可以看到跨导是传输曲线的斜率，它不是一个常数，但取决于漏极电流。
图4-37b给出了 BJT 输入的类似情况。基极电压加在发射结 pn 结上，它会看到一个取决于发射极直流电流的交流电阻。这个小的交流电阻对 BJT 放大器的增益发挥着重要影响，如3.4节所述。
$g_m$ 的倒数与 BJT 的$r&amp;rsquo;_e$。类似。大多数 FET 的交流模型都将 $g_m$ 作为一个重要参数。但是，要从 BJT 放大器转变到FET 放大器，定义一个表示 FET 交流源电阻的参数还是很有用的.
$$ r&amp;rsquo;_s=\frac{1}{g_m} $$
$$ a) n沟道FET传输曲线~~~~~~~~~~~~b) BJT传输曲线 $$</description>
    </item>
    
    <item>
      <title>4.5 MOSFET偏置</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-5mosfet%E5%81%8F%E7%BD%AE/</link>
      <pubDate>Fri, 14 Jul 2023 17:38:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-5mosfet%E5%81%8F%E7%BD%AE/</guid>
      <description>如同 BJT 和 JFET，偏置电路确定合适的直流工作条件，为交流信号提供一个稳定的工作点。MOSFET 的偏置电路与之前介绍的 BJT 和 JFET 的偏置电路类似。特定的偏置电路取决于是否使用一个或者两个电源，以及 MOSFET 的类型(耗尽型或者增强型)。
学完本节后，你应该掌握以下内容:
讨论和分析 MOSFET 偏置电路 解释为什么 D-MOSFET 比其他任何类型的晶体管有更多的偏置选择 解释 0 偏置 讨论 E-MOSFET 的三种偏置方法 4.5.1 D-MOSFET偏置 D-MOSFET 在正或负的 $V_{GS}$ 下都能工作。当 $V_{GS}$ 为负时，器件工作在耗尽模式; 当 $V_{GS}$ 为正时，器件工作在增强模式。D-MOSFET 的优点是在这两种模式下都能工作，也是唯一一种具有此特性的晶体管。
$$ 图4-31~~~~D-MOSFET的零偏置 $$ 零偏置 最基本的偏置方式是使 $V_{GS} =0V$，这样栅极上的交流信号使得栅源电压在该偏置点附近上下变化。图4-31 给出了这种偏置电路。因为该电路非常简单高效，所以它是最常用的 D-MOSFET 偏置方式。工作点设置在耗尽工作和增强工作之间。由于 $V_{GS} =0V$,因此 $I_D=I_{DSS}$，如图 4-31 所示。漏源电压可表示为: $$ V_{DS}=V_{DD}-I_{DSS}R_D $$ $$ a)~包含自给偏置的分压器 ~b）源极偏置~c)电流源偏置 $$
$$ 图4-33~~~~D-MOSFET的其他偏置电路 $$ 其他偏置方式 D-MOSFET 能工作在耗尽或增强模式。因为这种多功能性，所以之前学习的 BJT 和 JFET 的任何偏置电路都能用于D-MOSFET。图4-33 给出了三种常见的偏置方法，但实际中可能还有其他偏置方法。
图4-33a 中的偏置电路使用之前介绍的 JFET 的分压式偏置和自给偏置的组合。栅极电压可通过分压公式计算得到，这对所有 FET 器件都是准确的，因为可以忽略负载效应。栅极电压与 JFET 给出的相同(见式(4-5)): $$ V_G=(\frac{R_2}{R_1+R_2})V_{DD} $$ 组成分压电路的电阻通常非常大(在兆欧级)，因为栅极的高输人电阻。其他电极的电压取决于特定的器件参数。</description>
    </item>
    
    <item>
      <title>4.4 MOSFET 特性</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-4mosfet%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 14 Jul 2023 17:37:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-4mosfet%E7%89%B9%E6%80%A7/</guid>
      <description>金属-氧化物半导体场效应管( MOSFET )是另一种重要的场效应管。MOSFET 和 JFET 的区别在于它没有 pn 结结构，而是 MOSFET 的栅极与沟道之间用非常薄的二氧化硅(SiO$_2$)层来相互绝缘。MOSFET 的两种基本类型为: 耗尽型(D)和增强型(E)。这两者中，E-MOSFET 使用更为广泛。由于现在栅极材料用多晶硅取代金属，因此有时也称 MOSFET 为 IGFET(绝缘栅 FET)。
学完本节后，你应该掌握以下内容:
解释 MOSFET 的工作原理 描述 MOSFET 在构造上的不同 画出 n 沟道和 p 沟道 D-MOSFET 和 E-MOSFET 的符号 解释 MOSFET 在耗尽模式和增强模式下如何工作 解释 MOSFET 的漏极特性曲线 描述 MOSFET 的跨导曲线，并解释它与漏极特性曲线的关系 讨论 MOSFET 器件的特定处理预防措施 4.4.1 D-MOSFET $$ a）n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ b) p沟道 $$ $$ 图4-22~~~~~~~~D-MOSFET的基本结构 $$ 耗尽型 MOSFET (D-MOSFET )是 MOSFET 的一种，其基本结构如图4-22所示。漏区和源区扩散到衬底材料中，然后通过靠近绝缘栅的窄沟道相连。图4-22给出了 n 沟道和 p 沟道 D-MOSFET，但是，p 沟道 D-MOSFET 并不广泛使用。这两种类型器件的工作原理相同，除了 p 沟道的电压极性与 n 沟道的相反。为了简单起见，本节只讨论n沟道器件。</description>
    </item>
    
    <item>
      <title>4.3 JFET偏置</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-3jfet%E5%81%8F%E7%BD%AE/</link>
      <pubDate>Fri, 14 Jul 2023 17:37:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-3jfet%E5%81%8F%E7%BD%AE/</guid>
      <description>利用前几节学习的 JFET 的相关特性，现在我们将会看到如何对 JFET 进行直流偏置。偏置的目的是选择合适的栅源电压来获得期望的漏源电流。由于栅极反向偏置，因此 BJT 的偏置方式并不适用于 JFET。
学完本节后，你应该掌握以下内容:
描述 JFET 的三种偏置方法并解释它们的工作原理 利用`跨导曲线来选择自给偏置电阻的合理值`` 解释分压式偏置或电流源偏置如何产生更稳定的 Q 点 4.3.1JFET的自给偏置 FET 的偏置相对简单。接下来以 n 沟道 JFET 为例。记住，p 沟道 JFET 只需要改变极性。对于 n 沟道 JFET，建立反向偏置需要负的 $V_{GS}$。这可以利用如图4-11所示的自给偏置电路来实现。注意，通过电阻 $R_G$ 接地，将栅极偏置在 0V。虽然反向泄漏电流 $I_{GSS}$ 在 $R_G$ 两端产生一个非常小的电压，但在大多数情况下都可忽略它。可以假设 $R_G$ 上面没有电流流过，两端也没有压降。 $R_G$ 的作用是使得栅极电压稳定在 0V，且不影响之后施加的任何交流信号。由于栅极电流可以忽略， $R_G$ 可以非常大(通常取 1.0M$\Omega$ 甚至更大)，从而对低频交流信号会呈现非常高的输入电阻。
$$ 图4-11~~~ n沟道JFET的自给偏置 $$ 如果栅极电压为 0，如何获取所需的栅源结的反向偏置? 答案是使源极相对于栅极为正，以达到需要的反向偏置。对于图4-11中的 n 沟道 JFET 而言，$I_D$ 在 $R_S$ 两端产生一个压降(极性如图4-11所示)，使得源极相对于栅极为正。因为 $V_G=0V，V_S=I_DR_S$，所以栅源电压为: $$ V_{GS}=V_G-V_S-I_DR_S $$ 因此有: $$ V_{GS}=-I_DR_S $$ 该结果表明栅源电压为负，得到了所需的反向偏置。在本分析过程中，以 n 沟道 JFET 为例来说明。同样 p 沟道 JFET 也需要反向偏置，但所有电压的极性都和 n 沟道 JFET 中的相反。</description>
    </item>
    
    <item>
      <title>4.2 JFET特性</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-2jfet%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 14 Jul 2023 17:37:26 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-2jfet%E7%89%B9%E6%80%A7/</guid>
      <description>本节将介绍 JFET 是如何作为电压控制、恒流器件工作的，也将讨论漏极特性曲线和跨导曲线，以及 JFET 的截止、夹断与 JFET 的输入电阻和电容等内容。
学完本节后，你应该掌握以下内容:
描述结型场效应管(JFET)的结构和工作原理 画出 n 沟道或 p 沟道 JFET 的符号 解释 JFET 的漏极特性曲线，包括可变电阻区和恒流区 解释参数 $g_m、I_{DSS} 、I_{GSS} 、C_{iss} 、V_{GS(off)}和 V_P$ 描述 JFET 的跨导曲线并且解释它与漏极特性曲线的关系 4.2.1 JFET 工作原理 $$ a) n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)p沟道 $$
$$ 图4-2~~~~~两种JFET的基本结构 $$ 图4-2a给出了 n 沟道结型场效应管(JFET)的基本结构。电线连接到 n 沟道的两端，在图4-2中漏极位于上端，源极位于下端。沟道是一个导体: 对 n 沟道 JFET 而言,电子是载流子;对 p 沟道 JFET 而言，空穴是载流子。在没有外加电压的情况下，沟道在两个方向都能导通电流。
在 n 沟道器件中，将 p 型材料掺杂到 n 沟道中来形成 pn 结，并连接到栅极。图 4-2a 显示的是将 p 型材料掺杂进两个区域，这两个区域一般由制造商在内部进行连接形成单个栅极。(一种专用JFET，也称为双栅 JFET，有独立的电极连接到两个区域。)在结构图中，为了简单起见，两个 p 型区域之间的连接被省略掉，只给出到其中一个区域的连接。图4-2b给出了力沟道 JFET。
如前所述，JFET 中的沟道是栅极和源极之间的一个窄导电通路。沟道的宽度, 也就是沟道的导电能力，是由栅极电压控制的。当没有栅极电压时，沟道能通过最大的电流。当栅极施加反向偏置时，沟道宽度变窄，导电能力下降。</description>
    </item>
    
    <item>
      <title>4.1 FET的结构</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-1fet%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 14 Jul 2023 17:37:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-1fet%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>目标 描述场效应管(FET)的基本分类 描述结型场效应管(JFET)的结构和工作原理 描述JFET的三种偏置方法以及它们的工作原理 解释金属-氧化物半导体场效应管(MOSFET)的工作原理 讨论和分析MOSFET偏置电路 描述FET线性放大器的工作原理 讨论MOSFET模拟和数字开关电路 本章介绍场效应管(FET)，一种与双极结型晶体管(BJT)工作原理完全不一样的晶体管。虽然FET的发明要比 BJT 早数十年，但直到20世纪60年代，FET 才实现了商业生产。在某些应用中，FET 优于 BJT。在其他领域，一般混合采用两种晶体管，以获得性能最优的电路。FET主要分为两类，一类称为结型场效应管(JFET)，另一类称为金属-氧化物半导体FET(MOSFET)。尽管 MOSFET 是实际中更为常用的器件，但是 JFET 的结构更加简单，和 MOSFET 也有很多相同的基本特性，因此本书还是首先讨论 JFET 的相关内容。
在本章中，JFET 和 MOSFET 在不同的小系统中给出。每个小系统都说明了利用这些晶体管独有特性的例子。此外，每个系统例子说明了场效应管的不同应用，包括线性放大器和开关电路。本章最后介绍一个利用 MOSFET 开关电路的太阳能跟踪系统。
4.1FET的结构 已经知道双极结型晶体管(BJT)是一种电流控制器件，即基极电流控制集电极电流。场效应管(FET)是电压控制器件，其中栅极电压来控制流经器件的电流。BJT 和 FET 均可作为放大器使用，也都可用于开关电路。
学完本节后，你应该掌握以下内容:
描述场效应管(FET)的基本分类 讨论 FET 和 BJT 的主要差别 4.1.1 FET系列 场效应管(FET)是以与 BJT 的原理工作完全不同的一类半导体。在 FET 中，在称为源极(Source)和漏极(Drain)的两个电极之间由一条窄导电沟道相连。该沟道要么由 n 型材料，要么由 p 型材料制成。正如名字中的“场效应”指出的那样，沟道的导通由一个电场控制，该电场由施加在第三个电极即栅极(Gate)上的电压形成。在结型场效应管(或JFET)中，栅极和沟道之间形成了一个 pn 结。另一种场效应管称为金属-氧化物半导体场效应管(MOSFET)，它利用绝缘的栅极来控制沟道的导通(绝缘栅和 MOSFET 指同一种器件)。绝缘层是一层很薄(&amp;lt;lμm)的玻璃(通常是 $SiO_2$)。图4-1是 FET 系列的一个概览，展示了目前各种种类的场效应管。本章将讨论这些所有种类的场效应管。 $$ 图4-1~~~~场效应管的分类 $$ 事实上，FET 的有关构想要远远早于 BJT。早在1925年，J.E. Lilienfeld就申请了 FET 的专利(在1930年生效)，但直到20世纪60年代，FET 才得到商业化应用。今天，MOSFET用在大部分的数字集成电路中，因为 MOSFET 与 BJT 相比有几个巨大优势，特别是在制造大规模集成电路的时候。MOSFET 之所以成为数字电路中采用的主要晶体管，主要有以下原因。它们可以制造在比 BJT 更小的面积上，并且，它们非常容易制造在集成电路上。此外，它们还可以得到不含电阻和二极管的更简单电路。所有微处理器和计算机内存都采用 FET 技术。4.</description>
    </item>
    
    <item>
      <title>3.7 开关型双极型晶体管</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-7%E5%BC%80%E5%85%B3%E5%9E%8B%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/</link>
      <pubDate>Fri, 14 Jul 2023 17:36:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-7%E5%BC%80%E5%85%B3%E5%9E%8B%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/</guid>
      <description>之前的章节讨论了晶体管作为线性放大器的应用，其另一个主要应用是在数字系统中作为开关。最初数字电路的大规模应用是在电话系统中。现在，计算机成为使用集成电路(IC)的开关电路的最重要应用领域。当需要提供比从 IC 上能够获得的更高的电流或者需要在不同的电压下工作时，会使用分立晶体管开关电路。
学完本节后，你应该掌握以下内容:
解释怎样将晶体管用作开关 计算晶体管开关的饱和电流 解释一个具有迟滞的晶体管开关电路如何改变状态 $$ a)截止&amp;mdash;-打开的开关 $$ $$ b)饱和——闭合的开关 $$ $$ 图3-45~~~~晶体管的理想开关特性 $$ 图3-45说明了晶体管用作开关的基本工作原理。开关是具有打开或关闭两种状态的设备。在图3-45a中，晶体管处于截止状态，因为发射结没有正向偏置。在该状态下，集电极和发射极之间理想情况下为开路，可以用一个打开的开关来等效。在3-45b中，晶体管处于饱和状态，因为发射结正向偏置，并且基极电流大到足以使集电极电流达到其饱和值。在该状态下，集电极和发射极之间理想情况下为短路，可以等效为闭合的开关。实际上，当处于饱和状态时，晶体管上一般会有一个几十分之一伏大小的压降。
3.7.1截止状态 如前所述，当发射结没有正向偏置时，晶体管处于截止状态。忽略泄漏电流，总电流为零，$V_{CE}$等于 $V_{CC}$. $$ V_{CE(cutoff)}=V_{CC} $$
3.7.2饱和状态 当发射结正向偏置且有足够的基极电流来产生最大集电极电流时，晶体管处于饱和状态。因为 $V_{CE}$ 在饱和状态下非常小，所以整个电源电压都作用在集电极电阻上。集电极电流近似为 $$ I_{C(sat)}\approx \frac{V_{CC}}{R_C} $$ 能够产生饱和的最小基极电流为 $$ I_{B(min)}\approx \frac{I_{C(sat)}}{\beta_{DC}} $$ $I_B$ 应该远大于 $I_{B(min)}$ 才能使晶体管较好地保持在饱和状态，而且满足不同晶体管的不同 $\beta$ 值。
3.7.3单晶体管开关电路的改进 $$ 图3-47~~~具有陡门限的两晶体管开关电路 $$ 图3-45所示的基本开关电路通过门限电压控制其工作状态从开到关或从关到开变化。遗憾的是，该门限并不是一个绝对点﹐因为晶体管能够在截止和饱和之间的状态工作,这种状态在开关电路中是不希望出现的。加入第二个晶体管可以显著改善开关动作，提供一个更陡的门限电压。该电路如图 3-47 所示，其中用发光二极管(LED)作为输出显示，这样就可以观察开关行为了。该电路工作状况如下。当 $V_{IN}$ 很小时，因为电路并不能提供足够的基极电流，所以 $Q_1$ 截止。 $Q_2$ 处于饱和状态，因为它能够通过 $R_2$ 获得足够的基极电流，并且LED会发光。随着 $Q_1$ 基极电压增大， $Q_1$ 开始导通。当 $Q_1$ 接近饱和时， $Q_2$ 基极电压突然下降，导致它迅速从饱和状态切换到截止状态。 $Q_2$ 的输出电压降低，LED灭掉。
$$ 图3-48~~~迟滞导致电路在C点和E点发生变换，在其他各点不发生变换 $$ 基本切换电路的另一个改进是增加迟滞。对开关电路而言,迟滞意味着有两个门限电压值,这取决于输出电压是高还是低。图3-48说明了这种情况。当输入电压增大时，它必须跨过上门限值才能使开关发生切换动作。它不会在 A 点或 B 点发生切换，因为下门限不起作用。当信号在 C 点跨过上门限时，输出发生切换，门限也瞬间变为小的阈值。输出并没有在 D 点切换回来，而是必须跨过 E 点的下门限才能返回最初的状态。再一次，因为门限值切换到上门限值，所以在 F 点并不会发生开关动作。开关电路中迟滞的主要优点在于其抗噪能力。从本例中可以看出，尽管输入噪声很强，但是输出仅改变了两次。</description>
    </item>
    
    <item>
      <title>3.6 共基极放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-6%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:36:07 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-6%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>第三种基本的放大器组态为共基极(CB)放大器。CB 放大器能够提供高电压增益，但输入电阻较小。由于这个原因，其应用并不像其他两种那样广泛，但会在某些高频应用和称为差分放大器的电路中使用，该差分放大器将在第6章中讨论。
学完本节后，你应该掌握以下内容:
理解和分析 CB 放大器的工作原理 画出 CB 放大器的交流等效电路 计算 CB 放大器的电压增益、输入电阻和输出电阻 $$ a）典型的CB放大器 $$ $$ b)交流等效电路 $$ $$ 图3-42 ~~~~CB 放大器及其交流等效电路 $$ 图3-42a为分压式偏置的典型共基极(CB)放大器。由于存在 $C_3$，所以基极为信号地(交流地)，输入信号加在发射极。输出通过 $C_2$ 从集电极耦合到负载电阻。图3-42b给出了其交流等效电路。电容和直流电源用短路代替，这使得偏置电阻在等效电路中也被短路。该电路与共发射极电路的基本差别在于信号如何加入放大器中。
3.6.1电压增益 如同 CE 与 CC 放大器，CB 放大器的电压增益也为 $V_{out}/V_{in}$。对于 CB 放大器而言，$V_{out}$ 为集电极交流电压 $V_c$，$V_{in}$ 为发射极交流电压 $V_e$。记住这点，就可以得到电压增益为: $$ V_v=\frac{V_c}{V_e}=\frac{I_c(R_C||R_L)}{I_e(r&amp;rsquo;_e||R_E)} $$ 集电极交流电流和发射极交流电流几乎相同，因此二者可以互相抵消。因为 $R_E&amp;raquo;r&amp;rsquo;_e$，所以可以将 $r&amp;rsquo;_e||R_E$ 近似为 $r&amp;rsquo;_e$。此外，$R_C||R_L$ 表示集电极交流电阻 $R_c$。因此，电压增益仍然是电阻之比。
$$ A_v =\frac{R_C||R_L}{r&amp;rsquo;_e||R_E} $$ 或者为 $$ A_v\approx \frac{R_c}{r&amp;rsquo;_e} $$ 该式说明电压增益近似等于集电极交流电阻和发射极内部交流电阻的比值。在本例中，发射极电阻仅由 $r&amp;rsquo;_e$ 组成。更普通的情况是在发射极电路中增加扩量程电阻，下面将会介绍。
存在扩量程电阻的电压增益 图3-42中的基本 CB 放大器的一个问题是它会使较大的信号产生失真，因为输入端只有一个电阻 $r&amp;rsquo;_e$ 少它在一定程度上与信号幅度相关。一个较大的信号会引起 $r&amp;rsquo;e$ 的变化，从而改变增益。图3-43所示为基本放大器的改进,其中给出了针对小信号晶体管的一些典型值。通过增加具有较小值的扩量程电阻 $R{E1}$,并将其与 $r&amp;rsquo;_e$ 串联来进行改进。如同在CE放大器中，额外增加的固定电阻会产生更高的增益稳定性并增大输入电阻，但是以降低增益为代价。对 CB 放大器来说，它也可以显著改善其线性性质，因为扩量程电阻是与信号幅度无关的定值。</description>
    </item>
    
    <item>
      <title>3.5 共集电极放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-5%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:35:56 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-5%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>共集电极(CC)放大器通常也称为射极跟随器，是三种基本放大器组态中的第二种。输入加在基极，而输出端为发射极。CC放大器提供电流增益，电压增益近似等于1。由于其输入电阻较高，因此常常用作缓冲器或驱动器。
学完本节后，你应该掌握以下内容:
理解和分析CC放大器的工作原理 画出CC放大器的交流等效电路 解释为什么CC放大器的电压增益近似等于1 计算CC放大器的电流增益、输入电阻和输出电阻 解释为什么达林顿管有非常高的 $\beta$ 值 $$ a）典型的CC放大器或射极跟随器 $$ $$ b)交流等效电路 $$ $$ 图3-37~~~ CC放大器及其交流等效电路 $$ 图3-37a给出一个分压式偏置的共集电极(CC)电路。集电极直接接在直流电源上，它是一个交流地。注意，输入加在基极，输出从发射极取出。输出信号与输入信号相位相同。从输入耦合电容往基极看，交流等效电路包含偏置电阻和发射极电路中的电阻，如图3-37b所示。
3.5.1电压增益 将并联发射极和负载电阻合并为一个等效电阻($R_E||R_L$)可以简化图3-37b中的交流电路，如图3-38所示。该电路图用来分析CC极放大器的电压增益。 $$ 图3-38 ~~~ CC放大器的交流输入等效电路 $$ 如同所有线性放大器一样，CC 放大器的电压增益为 $A_v=V_{out}/V_{in}$。分析该增益时，偏置电阻并没有包含在其中，因为它们不会直接影响输入信号(但是它们会对电源产生负载效应)。注意，图3-38中输入电压作用在 r&amp;rsquo;$_e$ 和 $R_E||R_L$ 的串联电路上，而输出电压只作用在 $R_E||R_L$ 两端。只要 r&amp;rsquo;$_e$ 与 $R_E||R_L$ 相比非常小，就可以忽略 r&amp;rsquo;$_e$ 两端很小的电压降。这意味着输入电压和输出电压几乎相同。因此有: $$ A_v\approx1~~~(3-12) $$ 因为 r&amp;rsquo;$_e$ 两端有一个小的压降，所以实际增益要稍小于1。在实际电路中，这点差别并不重要。如果你用示波器查看一个 CC 放大器的输入和输出端，可以看到几乎一样的信号。因为发射极输出电压跟随输入电压变化，所以 CC 放大器通常也称为射极跟随器。共集电极放大器不会进行信号反相。
你可能想知道，如果 CC 放大器具有单位电压增益，那么它的价值何在?答案在于它有电流增益。当需要驱动低阻抗负载(如扬声器)时，就要用到 CC 放大器。为了求得电流增益，首先需要分析输入和输出交流电阻。
3.5.2输入电阻 射极跟随器的特点是有很高的输入电阻，这使其成为非常有用的电路。由于输人电阻很高，当一个电路驱动另一个电路的时候，射极跟随器可以用作缓冲器来减小负载效应。从基极看进去，输人电阻的推导与 CE 放大器的推导相同。从电源看过去，CC 放大器与具有分压式偏置的 CE 放大器有相同的并联通路，如图3-38的等效电路所示。但是，在本例中，发射极电路没有旁路电容。总的输人电阻公式与 CE 相似但有一个不同的发射极交流电阻( $R_E||R_L$ )。 $$ R_{in(tot)}=R_1||R_2[\beta(r&amp;rsquo;_e+R_E||R_L)]~~~~(3-13) $$</description>
    </item>
    
    <item>
      <title>3.4 共发射极放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-4%E5%85%B1%E5%8F%91%E5%B0%84%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 17:35:43 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-4%E5%85%B1%E5%8F%91%E5%B0%84%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>共发射极(CE)是BJT放大器的一种组态，其中发射极是输入信号和输出信号的公共端。本节将介绍特定的CE放大器，并用它来说明一些交流参数。
学完本节后，你应该掌握以下内容:
理解和分析共发射极放大器的工作原理 画出 CE 放大器的交流等效电路 计算 CE 放大器的电压增益、输人电阻和输出电阻 讨论交流负载线和直流负载线的区别 画出 CE 放大器的交流负载线，并求 Q 点 $$ a)电路图 $$ 共发射极(CE)放大器是 BJT 放大器中使用最广泛的类型，它的发射极作为输人和输出信号的参考端。图3-30a给出了一个 CE 放大器，它能够在负载电阻上产生一个放大和反相的输出信号。输人信号 $V_{in}$ 通过电容 $C_1$ 耦合到基极，并导致基极电流在其直流偏置值.上下波动。该基极电流的波动相应地产生了集电极电流的波动。由于晶体管的电流增益，集电极电流的变化量要远大于基极电流的变化量。这就产生了在集电极电压上一个更大的变化量，并且与基极信号电压反相。集电极电压的这个变化量又被电容耦合到负载上，产生输出电压 $V_{out}$。
$$ b)直流负载线 $$ $$ 图3-30 基本的共发射极放大器 $$ 现在来仔细研究图3-30a中的放大器，并检查它的直流和交流参数。直流参数已经在例3-5(图3-20)中算出，这里简要回顾一下方法。注意，初始的 470$\Omega$ 发射极电阻现在包含两个串联电阻 $R_{E1}$ 和 $R_{E2}$，其和为 470$\Omega$。这对直流电流和电压没有影响，但由于旁路电容 $C_2$ 的存在，发射极电路的交流电阻值会不同。
这里存在分压式偏置，因此首先利用分压原理计算直流基极电压。由于发射结二极管压降，发射极电压为基极电压减去 0.7V。接下来，对发射极电阻利用欧姆定律计算出发射极电流。计算得到发射极电流为3.34mA，近似等于集电极电流; 因此，$R_C$ 两端的电压降也可以通过欧姆定律计算得到。从例3-5得到的结果可以知道 $V_C$ 为8 .98V，$V_{CE}$为 7.41V。我们知道 $I_C$ 和 $V_{CE}$ 确定了电路的 Q 点。由于这些 $I_C$ 值和 $V_{CE}$ 值是 Q 点处的值，因此它们有专门的标记: 分别为 $I_{CQ}$ 和 $V_{CEQ}$。
刚刚复习过的参数图能够帮你直观了解这些直流参数。可以通过计算电路的饱和电流和集电极-发射极截止电压来确定负载线。我们知道饱和电流是集电极-发射极电压近似为零时的电流。因此有: $$ I_{C(sat)}=\frac{V_{CC}}{R_C+R_{E1}+R_{E2}}=\frac{18V}{2.</description>
    </item>
    
    <item>
      <title>3.3 数据手册中的参数及交流分析</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-3%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E4%BA%A4%E6%B5%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 14 Jul 2023 17:35:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-3%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E4%BA%A4%E6%B5%81%E5%88%86%E6%9E%90/</guid>
      <description>模拟电子的主干是线性放大器，一种能够从较小信号的副本产生较大信号的电路。上一节介绍了如何利用偏置为晶体管的工作提供必要的直流条件。本节将介绍影响交流信号的因素。
学完本节后，你应该掌握以下内容:
讨论晶体管参数并利用这些参数对晶体管电路进行分析 比较直流量和交流量的标注 讨论厂商数据手册中给出的BJT主要特性 解释耦合电容和旁路电容的作用 解释放大器如何产生电压增益 3.3.1直流和交流量 在本章第一部分中，利用直流量来建立晶体管的工作状态。这些直流电压和电流量用标准的斜体大写字母加上正体大写字母下标来表示，如$V_E、I_E、I_C$和$V_{CE}$。小写斜体下标用来表示交流量方均根值、峰值、峰峰电压和电流，如$V_e、I_e、I_c$和$V_{ce}$。瞬态量用斜体小写字母以及斜体小写下标标注，如$v_e、 i_e、i_c$和$v_{ce}$。
除了电流和电压以外，从交流角度和直流角度来比较，电阻往往具有不同的值(参考1.1节中直流电阻值与交流电阻值的对比)。小写斜体下标用来标识交流电阻值。例如 $R_C$ 代表直流集电极电阻，而 $R_c$ 表示交流集电极电阻。在讨论放大器时可以看到进行这种区分的必要性。内部电阻是晶体管等效电路的一部分，并经常写成小写斜体字母(有时还加一个撇)和下标。例如， $r&amp;rsquo;e$代表内部交流发射极电阻，而 $R{in(tot)}$ 代表放大电路作为信号源负载呈现的总交流电阻值。
对直流和交流电路不同的一个参数是 $\beta$。电路中的直流 $\beta(\beta_{DC})$ 如前定义为集电极电流 $I_C$ 和基极电流 $I_B$ 的比值。交流 $\beta(\beta_{ac})$ 定义为集电极电流的小变化量除以相应的基极电流变化量。用 ac 表示这一变化量，同时它也是集电极电流 $Ⅰ_c$ 和基极电流 $Ⅰ_b$ 的比值(注意，用小写斜体下标)。在厂商的数据手册中 $\beta_{DC}$ 通常写作 $h_{fe}$。公式表示为: $$ \beta_{ac}=\frac{I_c}{I_b}~~~(3-8) $$
对于给定的晶体管，$\beta_{ac}$ 和 $\beta_{DC}$ 的值通常差别很小，并且这种差别是由于特性曲线上微小的非线性而引起的。对大多数设计而言，这些差别并不重要，但是在阅读数据手册时需要理解。
3.3.3 交流和直流等效电路 在3.2节中，你已经解决了设置晶体管正常工作所必需的直流偏置条件。分析或检测任何晶体管放大器故障的第一.步是求直流工作状态。在确定直流电压正确后，下一步就是检查交流信号。交流等效电路与直流电路有很大差别。例如，电容能够阻碍直流通过，因此，它在直流电路中相当于开路;但对于大多数交流信号而言相当于短路。出于这个原因，需要区别对待直流和交流等效电路。
回忆直流/交流电路课程，运用叠加原理可求得线性电路中在单个电压或电流源单独作用下任何地方的电压和电流，可以通过将其他所有电源置 0 来达到这个目标。为了计算交流参数，可以用短路来替换直流电源将它设为 0，然后计算交流参数，就如同只有交流源单独作用。用短路替换电源是指 $V_{CC}$ 实际上对于交流信号而言相当于地电势，这称为交流地。该接地点概念指的是交流信号地而不是直流地，这是个全新的概念。只要记住交流地是交流信号的公共参考点。
3.3.4 耦合电容和旁路电容 图3-29所示为一个基本的 BJT 放大器。该电路与图3-19中的电路的差别在于加人了一个交流信号源、三个电容和一个负载电阻。另外，发射极电阻一分为二。
交流信号通过电容( $C_1$ 和 $C_3$ )进出放大器，这些电容称为耦合电容。如前所述，电容对交流信号而言相当于短路，而对直流信号来说相当于开路。这意味着耦合电容能够通过交流信号，同时阻碍直流电压。输人耦合电容 $C_1$ 将交流信号从信号源输人到基极，同时将信号源与直流偏置电压进行隔离。输出耦合电容 $C_3$ 将信号输出到负载，同时将负载与电源电压进行隔离。注意，这些耦合电容串联连接在信号通路上。
电容 $C_2$ 则不同，它与其中的一个发射极电阻并联。这使得交流信号从发射极电阻的旁路通过，因此称为旁路电容。旁路电容的作用是增大放大器增益，其原因稍后会讲述。因为旁路电容为交流短路，所以电容的两端都为交流接地。无论电容的哪一端接地，另一端对交流信号而言也为接地端。检测故障时一定要记住这一条，你不应该在旁路电容的任意端查找交流信号。如果你能找到，那么该电容可能是开路的。</description>
    </item>
    
    <item>
      <title>3.2 BJT偏置电路</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-2bjt%E5%81%8F%E7%BD%AE%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 17:35:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-2bjt%E5%81%8F%E7%BD%AE%E7%94%B5%E8%B7%AF/</guid>
      <description>本节将给出BJT的偏置方法。偏置是为了使晶体管正确工作而加的合适的直流电压。这可以通过一些基本电路来实现。偏置电路的选择很大程度上取决于应用。本节将介绍4种偏置方法，以及它们的优缺点。
学完本节后，你应该掌握以下内容:
解释4种BJT偏置电路的工作原理 描述基极偏置电路 描述集电极反馈偏置电路 描述分压式偏置电路 描述发射极偏置电路 对于线性放大器，信号必定在正负两个方向上摆动，而晶体管工作电流只能在一个方向上摆动。为了使晶体管放大交流信号，该交流信号必须叠加在设置工作点的直流电平上。偏置电路将直流电平设置为该工作点，这样就允许交流信号在正负两个方向上变化，而不会使晶体管进人饱和与截止状态。
3.2.1基极偏置 $$ a )npn偏置电路 $$ $$ b)负电源供电的pnp偏置电路 $$ $$ c）正电源供电的pnp偏置电路 $$ $$ 图3-14基极偏置电路 $$ 最简单的偏置电路是基极偏置。对于 npn 晶体管，如图3-14a所示，在基极和电压源之间连接一个电阻($R_B$)。注意，这与图3-9a中所介绍的用来生成特性曲线的电路本质上相同。唯一的区别是基极和集电极电源被合并成单个电源(称为 $V_{CC}$)。尽管这种偏置方法很简单，但对于线性放大器而言，这不是一种好方法，下面讨论原因。
pnp晶体管可以使用负电源来实现偏置，如图3-14b所示﹔或者如图3-14c所示，在发射极上加上一个正电源来实现偏置。这两种偏置方法都通过发射结为基极电流提供回路。反过来，该基极电流产生大小为基极电流βpc倍的集电极电流(假定线性工作)。因此，在线性工作条件下，集电极电流为: $$ I_C=\beta_{DC}I_B $$ 流过基极电阻 $R_B$ 的电流为基极电流 $I_B$。根据欧姆定律，替换 $I_B$。并得到 $$ I_C=\beta_{DC}(\frac{V_{R_B}}{R_B})\
I_C=\beta_{DC}(\frac{V_{CC}-V_{BE}}{R_B})~~~~~(3-3) $$ 只要晶体管不处于饱和状态，在给定基极偏置下，该式就给出了集电极电流。由于该式在没有发射极电阻的情况下推导得到，因此只能应用于此种偏置组态。
如前所述，晶体管有不同的电流增益。相同类型的典型晶体管的 $\beta_{DC}$ 值可以有3倍的差距。此外，电流增益还受到温度影响，随着温度升高，基极-发射极电压减小， $\beta_{DC}$ 的值增大。因此，在基极偏置的相似电路中，集电极电流可能相差很大。不能期望依赖于特定 $\beta_{DC}$ 的电路工作在恒定状态。出于这个原因，基极偏置很少用在线性电路中。
因为只使用单一电阻来进行偏置，故基极偏置在开关应用中是很好的选择，此时晶体管始终工作在饱和或者截止状态。对开关放大器，式(3-3)并不成立。
3.2.2集电极反馈偏置 $$ 图3-16集电极反馈偏置 $$ 对于 npn 型晶体管的另一种偏置组态为图3-16所示的集电极反馈偏置电路。(pnp 型晶体管工作原理完全相同，除了负电源电压供电以外。)基极电阻 $R_B$ 连接在集电极，而不是像在之前讨论的基极偏置电路中那样连接在 $V_{CC}$。比起基极偏置情况，该基极电阻的值更小，因为集电极电压比一般工作情况下的 $V_{CC}$ 要小。
集电极反馈用到了电子学中很重要的一个概念——负反馈来获得稳定性。负反馈将部分输出返回到输入来抵消可能出现的变化。负反馈连接提供了相对稳定的 Q 点。
下面来看一下负反馈是如何起作用的。在图3-16中，集电极电压为发射结提供偏置。负反馈产生补偿效果来保持 Q 点稳定。假设 $\beta_{DC}$ 由于温度增加而增加，这导致 $I_C$ 增大，反过来，$R_C$ 上的电压降就加大。随着 $R_C$ 两端的电压降增大，$V_C$ 减少，这反过来也意味着它将提供更少的偏置电流。这种补偿行为正是负反馈产生的作用。关于负反馈的其他应用接下来会一一介绍。</description>
    </item>
    
    <item>
      <title>3.1 BJT的结构</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-1bjt%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 14 Jul 2023 17:35:07 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-1bjt%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>双极结型晶体管(BJT)和场效应管(FET)是两种基本类型的晶体管。本章将介绍第一种类型——双极结型晶体管。本章首先讨论直流工作原理以及偏置电路，然后将会介绍各种偏置电路如何工作以及基本类型的分立放大器如何在线性和开关应用中进行工作，也将学习如何阅读厂商的数据手册。
双极结型晶体管(BJT)的基本结构决定了它的工作特性。本节将介绍半导体材料如何形成BJT，以及标准晶体管符号，也将讲述通过对基本晶体管电路应用负载线来设置合适的直流电流和电压。
学完本节后，你应该掌握以下内容:
描述BT的基本构造和工作原理 区分 npn 和 pnp晶体管 定义 BJT 电流以及解释它们之间的关系 解释 BJT 的特性曲线 解释如何构造晶体管电路的直流负载线 定义截止和饱和 BJT包括 三个掺杂 半导体区域: 发射区、基区和集电区。(这三个区域被两个 pn 结分隔开。图3-1所示为两种不同类型的双极型晶体管。第一种类型由被一个薄的 $p$ 区分隔开的两个 $n$ 区组成( $npn$ )，第二种类型由被一个薄的 $n$ 区分隔开的两个 $p$ 区组成( $pnp$ )。这两种类型都广泛使用，但是，因为 $npn$ 型更加普遍，所以接下来将多以这种类型为例进行讨论。 $$ a)基本的外延平面结构 $$ $$ b)npn $$ $$ c)pnp $$ $$ 图3-1双极结型晶体管结构 $$ 连接基区和发射区的pn结称为发射结，连接基区和集电区的pn结称为集电结，如图3-1b所示。这些 $pn$ 结类似于第 ⒉章讨论的二极管结，因此也经常称为发射结二极管和集电结二极管。从每个区都引出一个电极，分别将从发射区、基区和集电区引出的电极标为E、B和C。尽管发射区和集电区由同种类型的材料制成，但它们的掺杂浓度和其他特性不尽相同。
图3-2给出了 npn 和 pnp 两种 BJT 的电路符号(可以看到npn晶体管上的箭头并不指向里)。术语 双极 指在晶体管结构中空穴和电子都是载流子。
$$ 图3-2BJT的标准符号 $$
3.1.1晶体管工作原理 $$ 图3-3BJT的正向-反向偏置 $$ 为了使晶体管正常工作，两个 pn 结必须由外部提供直流偏压来设置合适的工作状态。图3-3给出了 npn 型和 pnp 型两种晶体管的合适偏置。在两种情况下，发射结(BE)为正向偏置而集电结(BC)为反向偏置，这称为正向-反向偏置。通常 npn 型和 pnp 型晶体管都使用正向-反向偏置，但偏置电压的极性和电流方向在两种类型中是相反的。 $$ 图3-4~~BJT工作原理，其中给出了电子流 $$ 为了说明晶体管如何工作，首先来了解一下当晶体管为正向-反向偏置时，在 npn 晶体管内部发生了什么( pnp 晶体管具有相同的情况，只要将极性进行反置)。基极到发射极的正向偏置使 BE 耗尽区变窄，而基极到集电极的反向偏置使 BC 耗尽区变宽，如图3-4所示。重掺杂的 n 型发射区充满了自由电子,这些电子能够很容易地越过正向偏置的BE结而扩散进入 p 型基区,就像正向偏置二极管中的情况一样。</description>
    </item>
    
    <item>
      <title>2.8 特殊用途二极管</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-8%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E4%BA%8C%E6%9E%81%E7%AE%A1/</link>
      <pubDate>Fri, 14 Jul 2023 15:06:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-8%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E4%BA%8C%E6%9E%81%E7%AE%A1/</guid>
      <description>前面关于二极管的讨论主要集中在利用二极管单向导电性的应用上。有些二极管是为其他一些应用而设计的。本节将学习许多特殊用途的二极管，如齐纳二极管、变容二极管、光敏二极管和发光二极管。
学完本节后,你应该掌握以下内容:
阐述四种特殊用途二极管的特性 描述齐纳二极管的特性曲线 说明齐纳二极管在一个基本的稳压器中是如何起作用的 解释变容二极管是如何成为可变电容器的 讨论发光二极管(LED)和光敏二极管的基本原理 2.8.1齐纳二极管 图2-44给出了齐纳二极管的图示符号。齐纳二极管是一个硅的 $pn$ 结器件，与整流二极管不同的地方在于它的反向击穿区的设计。市场上常见的齐纳二极管的反向击穿电压在1.8～200V之间。在制造时是通过精细地控制掺杂浓度来设置其击穿电压的。从2.4节讨论的二极管特性曲线可知，当二极管反向击穿时，即使电流在急剧变化，但电压仍几乎保持常量。图2-45再次显示了二极管的伏安特性曲线。
齐纳二极管最重要的应用是用作参考电压和小电流应用时的稳压器。作为稳压器时，齐纳二极管存在着局限:它没有集成电路稳压器(在2.6节中讨论)那么高的波动抑制能力，并且也不能应付大负载电流的变化。通过把齐纳二极管和晶体管或运算放大器相结合，就能构造出性能更好的稳压器。
图2-46给出了齐纳二极管反向特性曲线部分。注意，随着反向电压($V_R$)的增加，反向电流($I_R$)始终保持非常小，直到曲线到达拐点处。在这一点,开始出现击穿效应;随着反向电流的快速增大，内部的齐纳交流电阻开始减小。通常这个电阻在参数表中表示为阻抗$Z_Z$。在拐点的底部，齐纳击穿电压($V_Z$)基本保持不变，尽管齐纳击穿电压会随着$I_Z$的增大而稍微增大。特性曲线的恒定电压区表明齐纳二极管的稳压能力。
要使齐纳二极管工作在稳压状态，必须不能低于其反向电流$I_{ZK}$。从图2-46中的曲线可以看到，当反向电流减小到低于拐点处时，电压将急剧减小，稳压功能也就失去了。同样，也存在最大电流$I_{ZM}$，超过这个电流值二极管可能会损坏。因而，基本情况上，当通过齐纳二极管中的反向电流在$I_{ZK} $~$ I_{ZM}$范围内变化时,其端电压几乎保持恒定。数据手册中的额定齐纳电压$V_{ZT}$是指反向电流处于$I_{ZT}$(称为齐纳测试电流)时所对应的电压值。
齐纳等效电路 图2-47a给出了齐纳二极管反向击穿时的理想近似。它被简化成了一个电池，其电压值就是额定齐纳电压。图2-47b表示齐纳二极管的实际等效电路，其中包含齐纳阻抗($Z_Z$)。因为实际的电压曲线并不是理想垂直的，所以齐纳电流的变化($△I_Z$)会引起齐纳电压有微小的变化($△V_Z$)，如图2-47c所示。
$$ a)理想模型 $$ $$ b)实际模型 $$ $$ c)特性曲线 $$ $$ 图2-47齐纳二极管等效电路和Z_Z的图示化特性曲线 $$ 根据欧姆定理，$△V_Z$ 和 $△I_Z$ 的比等于齐纳阻抗，公式如下: $$ Z_Z = \frac{△V_Z}{△I_Z}~~~~~~(式子2-5) $$ 通常，$Z_Z$ 指定为在齐纳测试电流 $I_Z$ 处的值。大多数情况下，在齐纳电流值的整个线性范围内，可以假定 $Z_Z$ 是个常量。
齐纳稳压器 如前所述，齐纳二极管在一些简单的应用中可以作为稳压器。图2-48图示了一个齐纳二极管是如何把变化的直流输人电压稳定在一个恒定值上的。前面学过，这个过程称为线路调整率(见2.6节)。 $$ a）在输入电压增大时,输出电压几乎保持恒定(I_{ZK} &amp;lt; I_Z &amp;lt; I_{ZM}) $$ $$ b)在输入电压减小时，输出电压几乎保持恒定(I_{ZK} &amp;lt; I_Z &amp;lt; I_{ZM}) $$ $$ 2-48 输入电压改变时的齐纳稳压 $$
当输入电压变化时(在满足条件的范围内)，齐纳二极管的输出端电压几乎保持恒定。然而，随着 $V_{IN}$ 变化，$I_Z$ 将相应地变化。因此在满足$V_{IN}&amp;gt;V_Z$的条件下，齐纳二极管能起稳压作用的前提就是输人电压变化引起的二极管电流Iz须在最小和最大电流值($I_{ZK}$和$I_{ZM}$)之间。$R$是串联限流电阻。数字万用表(DMM)上的显示条会显示出相应的值和变化趋势。除了数字读数外，许多数字万用表还有模拟显示。
2.8.2变容二极管 因为结电容会随着反向偏置电压的大小而发生变化，变容二极管故又称为可变电容二极管。变容器是专门为利用可变电容特性而设计的。可以通过改变反向电压来改变电容。这些器件主要用于通信系统中的电子调谐电路。 变容器本质上是一个反向偏置的pn结，它利用耗尽层固有的电容特性。由于反向偏置时所产生的耗尽层不导电，因此它充当了电容器中的电介质。而 $p$ 区和 $n$ 区是导电的，充当了电容器的极板，如图2-51所示。 $$ 图2-51反向偏置时变容二极管用作变容器 $$ 回想一下，电容是由极板面积( A )、介电常数( $\epsilon$ )和电解质厚度( $d$ )决定的，公式如下: $$ C=\frac{A\epsilon}{d} $$ 当反向偏置电压增大时，耗尽层变宽，等效于增加了电解质的厚度，所以减小了电容。当反向偏置电压减小，耗尽层变窄，所以增大了电容。图2-52a和 b 反映了这种作用。通常的电容-电压曲线如图2-52c所示。</description>
    </item>
    
    <item>
      <title>2.7 二极管限幅电路和钳位电路</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-7%E4%BA%8C%E6%9E%81%E7%AE%A1%E9%99%90%E5%B9%85%E7%94%B5%E8%B7%AF%E5%92%8C%E9%92%B3%E4%BD%8D%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 15:06:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-7%E4%BA%8C%E6%9E%81%E7%AE%A1%E9%99%90%E5%B9%85%E7%94%B5%E8%B7%AF%E5%92%8C%E9%92%B3%E4%BD%8D%E7%94%B5%E8%B7%AF/</guid>
      <description>有时用称为限幅器或削波器的二极管电路来对信号电压高于或低于某值的部分进行限幅。另一种称为钳位器的二极管电路常用来将直流电平还原成电信号。
学完本节后，你应该掌握以下内容:
分析二极管限幅器和钳位器的工作原理 解释二极管限幅器是如何工作的，对给定电路决定其限幅电平 解释二极管钳位电路是如何工作的 举出二极管限幅和钳位电路的应用例子 2.7.1二极管限幅器 $$ a)正半周期的限幅;二极管在正半周期导通 $$ $$ b)负半周期的限幅;二极管在负半周期导通 $$ $$ 图2-30二极管限幅电路(削波电路) $$ 图2-30a给出了称作限幅器(也称作削波器)的二极管电路，它用来限制或削掉输人信号的正部分。当信号变为正的时候，二极管正向偏置。因为阴极接地(OV)，所以阳极不能超过 0.7V(假设是硅二极管)。因此，当输入电压超过该值时，$A$ 点的值就被钳位在 +0.7V。
当输入低于 0.7V 时，二级管反向偏置，可以看作开路。输出电压的波形与输入电压的负半部分一样，但是幅值由 $R_1$ 和 $R_L$ 构成的分压器决定，如下: $$ V_{out} = (\frac{R_L}{R_1+R_L})V_{in} $$ 如果 $R_1$ 远小于 $R_L$ ，则 $V_{out}$ $\approx$ $V_{in}$。
把二极管反转，如图2-30b所示，则输入的负半部分被钳位在接近 0 电位。当输人为负时二极管正向偏置，A点处的电压恒定在 -0.7V，即二极管的压降。当输人大于 -0.7V时，二极管不再正向偏置; $R_L$ 的端电压与输入成正比。
$$ 图2-31对输入计算机的信号进行限幅 $$ 限幅器的应用 图2-31给出了一个限幅器的应用。假设你想使用电源线将计算机操作与交流线路同步。如图2-31所示，一个半波整流器连接到变压器的 6.3V 输出端，整流器的峰值信号大约为 9V，对计算机输入来说太大了。计算机和其他逻辑电路在设计时均不能超过规定电压的最大值(典型值＋5.0V)，这样不会有严重损坏计算机的风险。图2-31所示的限幅器防止输入到计算机的信号超过 4.7V。
限幅电平的调节 为了调节对信号电压进行限幅的电平大小，可以将一个偏置电压与二极管串联，如图2-34所示。在二极管变为正向偏置和导通前，A点电压应等于 $V_{BIAS}+0.7V$。一旦二极管开始导通，A点电压就限幅在 $V_{BIAS}+0.7V$，于是所有高于这个值的输人电压都将被限幅，如图2-34所示。 $$ 图2-34带正偏置的正限幅器 $$ $$ 图2-35有可变正向偏置的正限幅器 $$ 如果偏置电压增大或减小，则限幅电平会相应地进行变化，如图2-35所示。如果偏置电压的极性反向，如图2-36所示，高于 $-V_{BB}+0.7V$ 的电压被限幅，输出波形如图2-35所示。只有当A点电压小于 $-V_{BB}+0.7V$ 时，二极管才反向偏置。 $$ 图2-36带负偏置的正限幅器，注意，波形的正侧被限幅在 -V_{BIAS}＋0.</description>
    </item>
    
    <item>
      <title>2.6 整流滤波器和IC稳压器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-6%E6%95%B4%E6%B5%81%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%92%8Cic%E7%A8%B3%E5%8E%8B%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 15:05:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-6%E6%95%B4%E6%B5%81%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%92%8Cic%E7%A8%B3%E5%8E%8B%E5%99%A8/</guid>
      <description>电源滤波器大大地减小了整流器输出电压的波动，形成了幅度接近恒定的直流电压。滤波的原因是电子电路需要恒定的直流电压源和直流电流源来提供电功率与偏置，使得电路能正常工作。通常使用大电容器来进行滤波，为了改善滤波效果，电容(输入滤波器)后紧跟着稳压器。如今由于集成电路(IC)的发展，有了便宜而有效的稳压器。本节介绍集成稳压器，更详细的内容将会在第11章中介绍。
学完本节后，你应该掌握以下内容:
描述整流滤波器和集成稳压器的工作原理 给出IC稳压器的例子，并知道它们是如何连接到整流器的输出端 对一个给定纹波抑制和输人纹波的 IC 稳压器，能计算其输出的纹波 对一个给定的有负载或无负载的电压，计算其负载变动范围 对给定的输人电压变化所引起的输出电压的变化，计算其线性调整率 在大多数电源供电的应用中，标准的 60Hz 交流线性电压源都应转换成幅度接近恒定，值的直流电压。半波整流器的 60Hz 脉动直流输出或全波桥式整流器的 120Hz 脉动输出应该经过滤波来减小较大的电压变化。滤波可以通过一一个电容器、一个电感器或者它们的组合来完成。迄今为止，电容输人滤波器是最便宜并且广泛应用的类型。
2.6.1电容输入滤波器 图2-24给出了一个带有电容输人滤波器的半波整流器。我们将用半波整流器来阐述滤波的原理，然后推广到全波整流器。 $$ a)当电源刚开启时，电容开始充电(二极管正向偏置) $$ b) 在正周期的峰值电压过后，电容通过R_L开始放电，此时二极管处于反向偏置。放电过程占据的时间段在输入电压中用灰色实线标出
c) 电容又开始充电，达到了输入电压的峰值，此时二极管又处于正向偏置状态。充电过程持续时间段在输入电压中用灰色实线标出。注意，在第二个充电周期电容电压在超过它原来的电压前，二极管一直反向偏置
$$ 图2-24具有电容输人滤波器的半波整流器工作原理 $$
在输入正向的前四分之一周期，二极管正向偏置，在二极管到达输人峰值后开始下降前的这段时间，允许电容进行充电，如图2-24a所示。当输入下降到低于其峰值时，如图2-24b所示，电容继续充电，二极管开始反向偏置。在这个周期的剩下部分到下一个周期的开始，电容只能通过负载电阻以一定的速率放电，放电速度取决 $RC$ 时间常数。时间常数越大，电容放电速率就越小。
在下一个周期到达峰值前，如图2-24c所示，当输入电压超过电容器电压大约一个二极管管压降时，二极管又重新正向偏置。
纹波电压 正如你看到的一样，电容在一个周期的开始快速地充电，在正峰值以后通过 $R_L$ 慢慢地放电(当二极管反向偏置时)。由于充电和放电会引起电容电压的变化，这种变化会形成纹波电压。纹波电压越小，滤波效果越好。
对给定的输人频率，全波整流器的输出频率是半波整流器输出频率的两倍。所以，对全波整流器进行滤波更容易，因为两个峰值之间的间隔时间更短。当进行滤波时，对于相同的负载电阻和滤波电容器，全波整流电压的纹波要小于半波整流电压。因为两个全波脉冲间的间隔越短，电容放电越少，所以电压纹波也越小，如图2-25所示。 $$ 图2-25当电路的滤波电容器和正弦波输人相同时，半波和全波整流器输出的纹波电压的比较 $$
$$ 图2-26电容输人滤波器中的浪涌电流沿着灰色的路径流动 $$ 电容输入滤波器的浪涌电流 当电源刚开始接通时，滤波电容器是未充电的。当开关合上的瞬间，电压像短路一样直接加到整流器和未充电的电容器上。图2-26a中用桥式电路来阐述这种情况。初始浪涌电流(有时称作浪涌电流)通过正向偏置的二极管产生。最坏的情况发生在二二次电压达到峰值时开关闭合，会产生最大的浪涌电流。
浪涌电流很可能损坏二极管，因此通常会连接一个浪涌限制电阻器$R_{surge}$, 如图2-26b所示。为了避免在电阻器上产生很大的压降，电阻器的值必须要小。同样，二极管必须具有正向额定电流从而使它能够承受瞬间的浪涌电流。
2.6.2 IC稳压器 当滤波器可以将电源的纹波降低到很小时，最有效的滤波器是将电容输人滤波器和 IC稳压器组合起来运用。通常，IC(集成电路)是在一个小的硅芯片，上构建的功能完整的电路。IC稳压器是一块连接到整流器输出端的IC，即使输入、负载电流或温度发生变化，它也能始终保持输出电压(或电流)的恒定。电容滤波器使得稳压器的输人纹波降低到了一个合适的值。一个大电容和一个IC稳压器的组合价格不贵，但能有助于产生一个很好的小电源。
最流行的IC稳压器具有三个端一输人端、 输出端和参考端(或调节端)。电容器首先对稳压器的输人进行滤波，使纹波减小到 $&amp;lt;$ 10%,然后稳压器可以将纹波减少到可以忽略的水平。此外，大多数稳压器具有内部参考电压、短路保护和热切断电路。它们可以用在各种正、负极性输出的电压中，并且可以用最少的外部元件设计成可变输出。典型地，IC稳压器可以提供具有很强纹波抑制能力的1至数安培电流的输出。超过5A负载电流的IC稳压器也可用。
$$ 图2-27三端稳压器 $$ 为了稳定输出电压而设计的三端稳压器只需要连接外部电容器就可以完成对电源的稳压调整，如图2-27所示。滤波是通过在输人电压和地之间的大容量电容器来完成的。有时，为了防止振荡，当滤波电容器与IC稳压器并不是很靠近的时候，再并联-一个较小的输人电容器，这个电容器需要靠近IC稳压器。最后，为了改善暂态响应，将一个输出电容器(典型值为0.1 ~ lμF)并联在其输出端。
$$ 图2-28 基本的十5.0V电源 $$ 固定三端稳压器的例子有 78XX 和 79XX 系列稳压器，这些系列具有各种输出电压并且能够提供达到1A的负载电流(散热充分)。型号的最后两个数字表示输出电压，因此，7812具有 +12V 的输出。相同稳压器的负输出电压版本记为79XX系列，因此 7912 具有 -12V 的输出。这些稳压电路的输出电压在正常值的 1.</description>
    </item>
    
    <item>
      <title>2.5 整流器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-5%E6%95%B4%E6%B5%81%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 15:05:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-5%E6%95%B4%E6%B5%81%E5%99%A8/</guid>
      <description>由于二极管在一个方向上允许电流通过，而在另一个方向上阻止电流通过，因此二极管通常用在电路(整流器)中，把交流电压转换成直流电压。由交流电压源变成直流电压源中都需要整流器，从最简单的电子系统到最复杂的电子系统，电源是它们基本的部分。本节将学习三种基本的整流器——半波整流器、中间抽头全波整流器、全波桥式整流器。
2.5.1半波整流器 整流器是一个可以把交流转换成脉动直流的电子电路。图2-15阐述了半波整流过程。如图2-15a所示，在一个半波整流器中，一个交流源与一个二极管和一个负载电阻串联。 $$ a)半波整流器 $$ 当正弦波输入电压为正时，二极管是正向偏置的，流过的电流送到负载电阻上，如图2-15b所示。输出电压等于峰值电压减去管压降。 $$ b)当输入电压处于正半周期时，二极管导通 $$ $$ V_{p(out)}=V_{p(in)}-0.7V (式子2-1) $$ $$ c)当输入电压处于负半周期时，二极管截止;所以，输出电压为0 $$ 电流在负载两端产生电压,这个电压与输入电压的正半周期具有相同的形状。当输入电压进入负半周期时变为负值,二极管反向偏置。因为电路中没有电流,所以负载电阻两端的电压为0，如图2-15c所示。最终结果是仅在交流输入电压的正半周期，负载电阻的电压是输入电压减去二极管管压降，使输出成为一个脉动直流电压，如图2-15d所示。注意,在负半周期，二极管需要承受住电源的负峰值电压而不被击穿。
$$ d)三个输入周期的半波输出电压 $$
$$ 图2-15半波整流 器的工作原理，二极管是理想二极管 $$ 在二极管电路中，当所加电压的峰值远远大于势垒电势时,通常可忽略二极管的管压降。这相当于使用二极管的理想模型。
2.5.2全波整流器 全波整流器和半波整流器的区别就是: 全波整流器在整个输入周期允许单向电流流过负载，而半波整流器只在半个周期内允许电流流过负载。全波整流后的结果是一个按照输入电压半个周期的节拍重复输出的直流电压，如图2-18所示。 $$ 图2-18全波整流器 $$
中间抽头全波整流器 中间抽头(CT)全波整流器使用两个二极管连接到一个中间抽头变压器的二次侧，如图2-19所示。输人信号通过变压器耦合到二次侧，整个二次电压的一半出现在中间抽头和每个二次绕组端之间。 $$ 图2-19中 间抽头(CT)全波整流器 $$ 对输人电压的正半周期，二次电压的极性如图2-20a所示。在这种情况下，上面的二极管$D_1$ 正向偏置，下面的二极管 $D_2$ 反向偏置。电流流过的路径是经过 $D_1$ 和负载电阻，在图2-20a中用灰色线标出。 $$ a)在正半周期，D_1正向偏置，D_22反向偏置 $$ 对输入电压的负半周期，次级电压的极性如图2-20b所示。在这种情况下，二极管 $D_1$ 反向偏置，二极管 $D_2$ 正向偏置。电流流过的路径是经过 $D_2$ 和负载电阻，在图2-20b中用灰色线标出。 $$ b)在负半周期，D_2正向偏置，D_1反向偏置 $$ $$ 图2-20二次侧中的导通路径用灰色标出 $$
因为在输人周期的正半周部分和负半周部分，流过负载的电流具有相同的方向，所以在负载两端产生的输出电压是全波整流直流电压。
匝数比对全波输出电压的影响 如果变压器的匝数比是1,整流输出电压的峰值等于一次输人电压峰值的一半减去二极管压降。这是因为在二次绕组端的一半处输出的电压是输人电压的一半。 为了使峰值输出电压等于峰值输入电压(减去势垒电势)，应该使用匝数比为2(1 : 2)的升压变压器。在这种情况下，因为整个二次电压是一-次电压的2倍，所以二次电压在一半处输出的电压等于输人电压。 $$ V_{out} = \frac{V_{sec}}{2}-0.7V $$ 峰值反向电压(PIV) 全波整流器中的每个二极管都交替地处于正向偏置和反向偏置状态。每个二极管需要承受的最大反向电压是整个二次电压的峰值( $V_{sec}$ )。中间抽头全波整流器中每个二极管的峰值反向电压是 $$ PIV=V_{p(out)} $$</description>
    </item>
    
    <item>
      <title>2.4 二极管特性</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-4%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 14 Jul 2023 15:05:04 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-4%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%89%B9%E6%80%A7/</guid>
      <description>2.4.1二级管管符号 通用二极管的标准电路符号： 二极管的两极是 A 和 K ，A 是阳极，K 是阴极。箭头符号总是指向阴极。
$$ a)二极管符号 $$
$$ b)正向偏置 $$ $$ c)反向偏置 $$
$$ 图2-8二极管电路符号和偏置电路。 V_{BB} 是偏置电池电压，V_B是势垒电压。电阻将正向电流限制在一个安全值 $$ 图2-8a给出了通用二极管的标准电路符号。如图2-8a所示，二极管的两极是A和K,A是阳极，K是阴极。箭头符号总是指向阴极。
图2-8b给出了正向偏置二极管通过一个电流限制电阻连接到电源时的情况。二极管的阳极相对于阴极电位是正的，使得二极管导通，如电流表指示的那样。记住，当二极管正向偏置时，势垒电压 $V_B$ 一直存在于阳极和阴极之间，如图2-8b所示。电阻两端的电压$V_R$等于 $V_{BB}$ 减去$V_B$
二极管的反向偏置如图2-8c所示。二极管的阳极相对于阴极电位是负的，二极管不导通，如电流表所指示那样。偏置电压$V_{BB}$全部加在二极管上。因为没有电压降在电阻上，所以电路中没有电流。注意，偏置电压$V_{BB}$与势垒电压$V_B$不相等。
图2-9给出了一些典型的二极管封装。字母A表示阳极;K表示阴极。
2.4.2二极管特性曲线 $$ 图2-10是二极管的伏安特性曲线 $$ $$ 正向偏置的 V-I 特性曲线 $$ $$ 反向偏置的 V-I 特性曲线 $$ 图2-10是二极管的伏安特性曲线。图2-10的右上部分表示二极管正向偏置时的情况。如图2-10所示，当正向偏置电压($V_F$)低于势垒电势时，没有正向电流($I_F$)。当正向偏置电压接近势垒电势的值时(通常硅是0.7V,锗是0.3V)，流过二极管的电流开始增大。一旦正向偏置电压大于势垒电势，正向电流随着偏置电压增大而急剧增大，必须靠限流电阻来限制电流。正向偏置二极管的端电压几乎等于势垒电势的值，但是会随着正向电流的增大而略微增大。对正向偏置的二二极管，通常将势垒电势就作为二极管的管压降。
图2-10的左下部分表示二极管反向偏置时的情况。当反向偏置电压小于击穿电压时，随着反向偏置电压朝着左边增大，电流的值接近于零。当二极管被反向击穿时，二极管中会有较大的反向电流产生，如果不对这个反向电流进行限制，二极管将会被损坏。日通常，大多数整流二极管的击穿电压都大于50V，普通二极管的大多数应用都不会运行在反向击穿区域内。
在示波器上显示二极管的伏安特性曲线 按照图 2-11所示的电路连接方法，可以在示波器上显示二极管的正向特性曲线。信号是峰峰值为5V的三角波信号，用来产生一系列过零电压。这使得二极管在正向偏置和反向偏置之间交替。通道1探测二极管上的管压降，通道2显示与电流成正比的信号。示波器处于 X-Y 模式。信号发生器的公共端绝对不能与示波器共地。通道2需要反转来显示正确方向的信号。 2.4.3用欧姆计或万用表测试二极管 2.4.4二极管的模型 理想模型:
模拟二极管原理最简单的方法就是把二极管看成一个开关。理想情况下，当二极管正向偏置时，相当于开关闭合﹔当二极管反向偏置时，相当于开关断开，特性曲线如图2-12所示。注意，在理想情况下，正向管压降和反向电流始终零。当然，`这是二极管的理想模型，忽略了势垒电势、内部阻抗和其他的一些影响``,然而，在大多数情况下，这种模型已足够精确，尤其是当偏置电压是势垒电势的十倍或者更高倍时。
偏移模型:
精度更高一点的模型是偏移模型。偏移模型考虑了二极管的势垒电势。在这个模型中，正向偏置的二极管等效于一个闭合的开关串联一个小“电池”，这个电池的电压值等于势垒电势 $V_B$ 的值(硅是0.7V)，如图2-13a所示。等效电池的正极向着电源的阳极。记住，势垒电势并不是一个电压源，不能用电压表去测量﹔当二极管正向偏置时，等效电池仅仅具有偏移电源的效果，因为二极管的正向偏置电压 $V_{BB}$ 只有克服了势垒电势的作用才能使二极管导电。和理想模型一样，二极管反向偏置时等效于一-个断开的开关，如图2-13b所示，因为势垒电势并不影响反向偏置的情况。偏移模型的特性曲线如图2-13c所示。在本书中，如不特别说明，都使用偏移模型进行分析。
偏移-电阻模型:
图2-14a给出了正向偏置二极管的等效电路，它由势垒电势和一-个较小的正向电阻构成。正向电阻实际上是一个交流电阻(见1.1节)。正向电阻的值是变化的(取决于在哪点测试)，但是在这个模型中用直线来近似表示。 偏移-电阻模型图2-14a给出了正向偏置二极管的等效电路，它由势垒电势和一-个较小的正向电阻构成.正向电阻实际上是一个交流电阻(见1.1节)。正向电阻的值是变化的(取决于在哪点测试)，但是在这个模型中用直线来近似表示.
在偏移-电阻模型中，反向偏置情况用一个非常大的并联电阻来表示，结果就是产生的反向电流非常小。图2-14b表示很大的反向电阻作用在反向偏置模型中，特性曲线如图2-14c所示。还有其他的一些较小的影响(如结电容)并没有包括在此模型中，对于这些影响，在计算机建模时通常会考虑。</description>
    </item>
    
    <item>
      <title>2.3 半导体二极管的偏置</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-3%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%81%8F%E7%BD%AE/</link>
      <pubDate>Fri, 14 Jul 2023 15:04:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-3%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%81%8F%E7%BD%AE/</guid>
      <description>一个pn结就构成一只半导体二极管。平衡时pn结中没有电流。半导体二极管的主要用处是它能够根据偏置使得电流只朝着一个方向流动。pn结有两种偏置条件——正向偏置和反向偏置。这两种偏置都需要在pn结上外接合适方向的直流电压。
2.3.1 正向偏置 在电子学中，术语偏置是指给半导体器件外加固定直流电压的工作条件。正向偏置是允许电流流过pn结的条件。 图2-6给出了半导体二极管正向偏置时直流电源的极性。电源的负极连接到n区（阴极端），电源的正极连接到p区（阳极端）。当半导体二极管正向偏置时，二极管的阳极电位比其阴极电位高。
正向偏置时是这样工作的：当一个直流电源正向偏置二极管时，由于静电排斥，电源负极推动n区的导带电子向结处运动。同样地，电源正极推动力p区的空穴向结处运动。当外部偏置电压足够可以克服势垒电压时，电子就会有足够的能量进入耗尽区，并穿过pn结进入p区。进入p区的电子会和p区的空穴复合。当电子离开n区时，更多的电子流从电源负极进入n区。因此，通过导带电子（多数载流子）向结的定向移动产生流向n区的电流。当导带电子进入p区并和p区的空穴复合后，这些导带电子就成为价电子。然后，这些价电子向着正阳极连接方向不断地从一个空穴跳到另一个空六。这些价电子的定向移动本质上形成空穴朝着相反方向的定向移动。因此，通过空穴（多数载流子）朝着结方向的定向运动在p区产生电流。
2.3.2 反向偏置 反向偏置是阻止电流流过pn结的偏置条件。图2-7a给出了反向偏置一个半导体二极管所需的直流电源极性。注意，电源负极连接p区，电源正极连接n区。当半导体二极管反向偏置时，二极管的阳极电位比其阴极电位低。 反向偏置时是这样工作的：由于相反的电荷相互吸引，电源负极吸引p区的空穴离开pn结，同时电源正极吸引电子离开pn结。由于电子和空穴离开pn结，耗尽区的宽度变得越来越大；在n区产生越来越多的正离子，在p区产生越来越多的负离子。直到势垒电压等于外部偏置电压时，耗尽层的宽度不再增加，当二极管反向偏置时，耗尽区实际上相当于位于正离子层和负离子层之间的绝缘体。
峰值反向电压(PIV) 当一个二极管反向偏置时，它必须承受住加在两端之上的最大反向电压，否则二极管会被击穿，二极管的这个最大额定电压称为峰值反向电压(PIV)，所需要的PIV值取决于应用场合；在大多数使用普通二极管的情况下，PIV应该高于反向偏置电压.
反向击穿 当外部反向偏置电压增大到足够大时，会发生雪击穿。雪崩击穿是这样产生的：假设少数导带电子从外部电源获得足够大的能量，从而加速它向二极管正极快速运动。在它的运动过程中，它碰撞一个原子并给予这个原子足够的能量使得一个价电子进人导带。这时，就有两个导带电子。每个导带电子又去碰撞原子，使得又有两个价电子被撞入导带。这时，就有4个导带电子。接着，这4个导带电子又撞击4个价电子使它们进入导带。导带电子这种快速的倍增称为雪崩效应，雪崩效应使得反向电流急剧增大。
因为大多数二极管电路并不是为工作在反向击穿条件下而设计的，所以这些二极管工作在反向击穿条件下时可能会损坏。反向击穿也可以不损坏二极管，但是必须限制流过二极管 的电流大小，防止温度过高而损害二极管。有一种类型的二极管，即稳压二极管，就是专门 为工作在反向击穿而设计的，稳压二极管同样需要进行限流（稳压管在2.8节中讨论）。</description>
    </item>
    
    <item>
      <title>2.2 pn结</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-2pn%E7%BB%93/</link>
      <pubDate>Fri, 14 Jul 2023 15:03:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-2pn%E7%BB%93/</guid>
      <description>本征半导体硅(纯度99.999999999%)和锗的导电性能不好，通过加入杂质可以改善其导电性能。
在纯净的硅中加入5价杂质，形成n(negative)型半导体。
在纯净的硅中加入3价杂质，形成p(positive)型半导体。
将两种材料合在一起，则在它们交界处就会形成pn结。
2.2.1 掺杂 掺杂可以增加载流子(电子和空穴)的数量，低电阻率和导电性能。
加入5价电子元素材料，形成n型半导体。在n型半导体材料中，自由电子称为多数载流子；空穴为少数载流子
加入3价电子元素材料，形成p型半导体。在p型半导体材料中，空穴称为多数载流子；自由电子为少数载流子
2.2.2 pn结 在一块本征硅上参杂，使得硅的一半形成n型半导体，另一半形成p型半导体，则在交界处会形成pn结。在n区有很多自由电子（多数载流子）和少量由热激发产生的空穴（少数载流子）。在p区有很多空穴（多数载流子）和少量由热激发产生的自由电子（少数载流子）。pn结形成了基本的二极管，它是所有固态半导体器件的工作基础。二极管是一种只允许电流朝一个方向流动的器件。
耗尽区当pn结形成之后，在结附近的一些导带电子漂移到区并且和区的空穴复合，如图2-5a所示。每个电子穿过结并且和空穴复合后，在n区靠近结处会留下带一个净正电荷的五价原子。同样，当电子和p区的一个空穴复合，一个3价原子会带一个净负电荷。因此，结的n区会有正离子，区会有负离子。正负离子出现在结的相对一侧，在耗尽区处产生势垒电压（V）。势垒电压的大小受温度影响。在室温下，一般硅大约为0.7V，锗为0.3V。因为二极管很少使用，所以在实际应用中势电压为0.7V，本书内容也假设势电压为0.7V。
为了扩散到p区，n区的导带电子必须克服所有正离子的吸力和负离子的力。在离子层形成后，结两边的区域中自由电子和空穴的数量会急剧减少，这个区域称为耗尽区，如图2-5b所示。电荷穿过交界处的任何运动都需要克服势垒电压。</description>
    </item>
    
    <item>
      <title>2.1 半导体原子结构</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 14 Jul 2023 15:01:04 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>2.1.1 原子的电子层和轨道： 每个原子的电子不是混乱的堆杂在一起的，而是分层的，每层有其合适的电子数运动，离原子核越近能量越低，活跃度越低。 The Maximum Number of Electrons in Each Shell 每个壳层中的最大电子数 $$ N_e = 2n^2 $$
2.1.2 价电子、传导电子、离子 离原子核越远越活跃，越近舒服越强。最外层的电子称为价电子,能量最强，束缚最小。
传导电子：价电子又被称为自由电子，获得足够的能量可以脱离原子核的束缚电子。
离子：自由电子附身于中性原子上，此原子被称为负离子。
2.1.3 金属键 原子的原子核和内层电子占据固定的晶格位置。外层价电子受到晶体原子束缚非常小并且可以自由移动，这些带有负电的大量电子和正离子一起形成金属键。 价带：价电子的离散能级模糊成一个带，这个带被测称为价带。
导带：价带的下一个能级(通常被占用)也被模糊成一个能带，被称为导带。
2.1.4 共价键 在钻石中相邻碳原子组成4个键，效果是每个原子周边的8个价电子形成一个化学稳定状态。共用价电子产生很强的共价键。使原子紧密的结合在一起。
共用电子是不可移动的。所以价带和导带之间存在很大的能带间隔。
2.1.5 电子电流和空穴电流 $$ 图2-3本征硅中由热激发产生的电子电流 $$
当价带电子获得足够的能量时会进入导带，会在价带留下一个空穴。这些空穴和和进入的导带的电子行成电子-空穴对。
导带电子失去能量并且跌落到价带的空穴时，这种现象称为复合。 电子电流：在半导体材料中，自由电子的移动是电流的一种。
空穴电流：在晶体结构中从一个位置移动到另一个位置，，这个电流称为空穴电流。</description>
    </item>
    
    <item>
      <title>1.4 放大器</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-4%E6%94%BE%E5%A4%A7%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 14:58:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-4%E6%94%BE%E5%A4%A7%E5%99%A8/</guid>
      <description>信号在之前，大多数都需要放大。放大器简单地增加了信号的幅度(电压、电流)。
1.4.1 线性放大器 线性放大器对输入信号进行幅度上的放大。
理想放大器指对信号的放大不产生噪声和失真，随着时间变化而变化，并且对输入的精确再现。
主要用于放大电压和功率。
电压放大器：$V_{out}$(t)正比于$V_{in}$(t),其比值为电压增益，公式： $$ A_v = \frac{V_{out}}{V_{in}} $$
$A_{v}$=电压增益；$V_{out}$=输出信号电压；$V_{in}$=输入信号电压
理想的放大器的传输曲线应该是一条固定斜率无限延伸的直线，但实际没有这样的器件，在$V_{in}$达到一定的时会达到饱和(斜率不变)，最后$V_{in}$怎么变大$V_{out}$都不会变，在达到$V_{out}$ = $V_{max}$ 时曲线会平行于$X$轴。在达到$V_{out}$ = $V_{max}$之前，饱和之后存在一段非线性曲线。
1.4.2 非线性放大器 放大曲线也可能不是直线，而是曲线。
有两类放大器：波形整形和开关。
波形整形放大器：用于改变波形的形状。
开关放大器：从其他波形产生一个矩形输出。
功率增益$V_p$,信号的输出·比上输入功率。用电压或电流的有效值来求功率。公式： $$ A_p = \frac{P_{out}}{P_{in}} $$ $A_p$=功率增益，$P_{out}$=输出功率， $P_{in}$=输入功率 $$ A_p = \frac{I_{out}V_{out}}{I_{in}V_{in}} $$
$$ A_p = (\frac{V^2_{out}/R_L}{V^2_{in}/R_{in}}) $$
1.4.3 放大器模型 放大器是负载用来放大信号幅度的器件。可以认为放大器是源和负载之间的一个接口。
1.4.4 级联 多个放大器可以结合成一个更大放大能力的放大器的。
1.4.5 对数 对数就是幂，方程： $$ y = b^x $$ y值取决于底为b的幂指数，而幂x则是y的对数值。
有两个常用的对数底：10和e
log以底为10的对数
ln以底为e的对数
以10为底的对数用来描述分贝，对于以10位底，有： $$ y = 10^x $$ 得 $$ x = log_{10}y $$ 把10省掉，简写成$log$。</description>
    </item>
    
    <item>
      <title>1.3 信号源</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-3%E4%BF%A1%E5%8F%B7%E6%BA%90/</link>
      <pubDate>Fri, 14 Jul 2023 14:58:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-3%E4%BF%A1%E5%8F%B7%E6%BA%90/</guid>
      <description>戴维南定理：可以用一个电压源串联一个电阻代替一个复杂的线性电路，这个电路可以看成一个二端口。
诺顿定理：可以用一个电流源并联一个电阻代替一个二端口线性电路。
1.3.1 独立源 理想的独立电压源产生的$\color{#376956}{电压}$与$\color{#871F78}{负载电流}$无关。
理想的独立电流源产生的$\color{#871F78}{电流}$与$\color{#376956}{负载电压}$无关。
理想的独立信号源的值是固定的，与电路中的所有其他参数都无关。虽然无法实现个真正理想的信号源，但是在某些情况下(例如稳压电源)，它可以很接近理想情况。实际中的信号源可以看成一个理想的源与一个电阻(对交流源而言也可以是其他的无源器件)的组合。
1.3.2 戴维南定理 它的适用前提是线性元件。
1.3.3 诺顿定理 诺顿电流的幅度等于负载短路后流经端口的电流。
1.3.4 负载线 戴维南的电流-电压特性曲线是负载线。
短路和开路的特性曲线
在一个线性曲线，接在输出端口的任何负载都满足此特性曲线，
1.3.5 传感器 传感器是一种将物理量(例如位置、压力或温度)从一种形式转换成另一种形式。</description>
    </item>
    
    <item>
      <title>1.2 模拟信号</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-2%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 14 Jul 2023 14:57:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-2%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/</guid>
      <description>是指任何携带信息的物理量，力、热、声、光、电等。
1.2.1 模拟信号和数字信号 信号分为：离散信号和连续信号。离散信号可以只有几个值，连续信号可以无限细分下去。 离散和连续指信号的幅度，也可以指时间。
采样和量化：
​	采样：将模拟波形在时间域上进行切分，每个切片大小大致等于原来波形的值，会丢失一些信息。
​	量化：给每个时间片分配一个数字，量化后的数字可以交给计算机或其它素质电路处理 1.2.2 周期信号 重复的波形称为周期性的，此周期信号有变化。
周期(period, $T$)表示一个周期信号完成一个循环所需要的时间。周期(cycle)是指在波形呈现出另一个完全相同的图案之前波形的完整序列值。可以是在逐次循环的波形上任意两个相应点来测出周期。
向量：既有大小又有方向的量。
频率和周期：
频率：每1s内完成的完整周期的个数，单位Hz
周期：一个循环所经历的时间，单位s，所以周期的倒数就是频率，频率的倒数是周期
$$ T = \frac{1}{f} $$
和 $$ f = \frac{1}{T} $$ 正弦曲线的瞬时值： $$ v(t) = V_Psin(wt + ⌀) $$ $V_p$
正弦曲线的平均值： $$ V_{avg} = \frac{2V_P}{π} $$ 化简得： $$ V_{avg} = 0.637V_P $$ 电流平均值： $$ I_{avg} = 0.637I_p $$ 正弦曲线的有效值： $$ P = IV $$ 计算与直流电压电流产生相同的热效应时的交流电压、电流，通过积分可以求出等效的热量，称为方均根电压(rms)或者电流。
方均根电压和峰值电压的关系： $$ V_{rms} = 0.707V_p $$ 方均根电流与有效电流的关系是： $$ I_{rms} = 0.</description>
    </item>
    
    <item>
      <title>模拟电子技术基础</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 12 Jul 2023 20:53:37 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</guid>
      <description>出版者的话 译者序 前言 第1章 基本模拟概念 ##### 1.1 模拟电子学 ##### 1.2 模拟信号 ##### 1.3 信号源 ##### 1.4 放大器 ##### 1.5 故障检测
第2章 二极管及其应用 ##### 2.1 半导体原子结构 ##### 2.2 pn结 ##### 2.3 半导体二极管的偏置 ##### 2.4 二极管特性 ##### 2.5 整流器 ##### 2.6 整流滤波器和IC稳压器 ##### 2.7 二极管限幅电路和钳位电路 ##### 2.8 特殊用途二极管 ##### 2.9 二极管数据手册 ##### 2.10 故障检测
第3章 BJT ##### 3.1 BJT的结构 ##### 3.2 BJT偏置电路 ##### 3.3 数据手册中的参数及交流分析 ##### 3.4 共发射极放大器 ##### 3.5 共集电极放大器 ##### 3.</description>
    </item>
    
    <item>
      <title>1.1 模拟电子学</title>
      <link>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-1%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E5%AD%A6/</link>
      <pubDate>Wed, 12 Jul 2023 22:05:41 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-1%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E5%AD%A6/</guid>
      <description>1.1 模拟电子学 模拟信号: 我们测量到的自然现象的特性(比如,压力，流速和温度)都来源于模拟信号
信号可分为有 二进制数字 表示的数字信号和有 连续变化量 表示的模拟信号
模拟电子学包括所有其他(非数字)信号，它包括信号处理功能，比如放大,微分和集成等。
1.1.1 线型方程 线型方程式:
$$ y = mx + b $$
式中，y是因变量，x自变量，m是斜率，b是y轴上的截距。 欧姆定理：
$$ I = \frac{V}{R} $$
电流(I)是因变量，自变量是电压(V),斜率是电阻的倒数(1/R), 也就是电导(G).欧姆定律可变化为：
$$ I = GV $$
特性曲线是能够反应一个器件两个变化特性之间关系的图
线性分量：在欧姆定理给定的形式中电流的增加正比于所施加电压的变化
1.1.2 交流电阻 在模拟电子学中，很多器件的特性曲线中电流和电压不成正比。这些器件是非线性器件，但由于这些器件采用了连续的输入信号，它依然在模拟电子学的研究范围内。
交流电阻：将电压的一个微小变化量除以相应的电流变化量(即∆U/∆I)的比值定义为模拟器件的交流电阻(r)，又被称为动态小信号电阻或体电阻。 $$ r_{ac} = \frac{∆U}{∆I} $$ 1.1.3 传统的电流与电子流动 电流是电荷的流动速率。
电流的流向：从电源正极流出，负极流入。
电子的流向：从负极流出，正极流入。</description>
    </item>
    
    <item>
      <title>数字电子技术</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 12 Jul 2023 21:20:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</guid>
      <description>第1章 基本概念 1.1 数字量与模拟量 1.2 二进制数、逻辑电平和数字波形 1.3 固定功能的集成电路 关键词 判断题 自测题 习题 答案
第2章 数字系统、运算和编码 2.1 十进制数 2.2 二进制数 2.3 十进制数到二进制数的转换 2.4 二进制算术 2.5 二进制数的反码和补码 2.6 带符号数 2.7 带符号数的算术运算 2.8 十六进制数 2.9 八进制数 2.10 二—十进制编码(BCD) 2.11 数字编码 2.12 错误检测码 关键词 判断题 自测题 习题 答案
第3章 逻辑门 3.1 反相器 3.2 与门 3.3 或门 3.4 与非门 3.5 或非门 3.6 异或门和同或门 3.7 固定功能逻辑 关键词 判断题 自测题 习题 答案
第4章 布尔代数和逻辑化简 4.1 布尔运算和表达式 4.</description>
    </item>
    
    <item>
      <title>适用于Keil的插件合集</title>
      <link>https://okokfun.github.io/post/keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 11 Jul 2023 13:55:45 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</guid>
      <description>文件下载链接 https://github.com/txt1994/keil_plugs 本人收集的Keil插件，当然也可用于其他软件
1.AStyle 下载链接:
https://sourceforge.net/projects/astyle/files 1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令： -n !E --style=google -s4 对多个文件格式化，但需要在同一个文件夹，命令：
-n &amp;#34;$E*.c&amp;#34; &amp;#34;$E*.h&amp;#34; --style=google -p -s4 -S -f -xW -w -xw -R 2.FileComments 2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令： !E 3.DateTime 3.1 DateTime可以识别当前日期和时间，用的不多，命令： 当前日期：
!E ~E ^E 当前时间：
!E ~E ^E T 4.FunctionComment 4.1 FunctionComment可以提供函数快速添加注释，命令： !E ~E 把这些插件添加到keil中，打开keil，依次点击Tools-&amp;gt;Customize Tools Menu,此时页面是这样的： 把上述的插件添加进去，Command是插件路径，Arguments是使用插件时的参数，可以根据需要自行定制
添加插件的快捷键：点击keil页面的小扳手，找到Shortcut Keys,把下拉框拉到刚才添加的插件处，右边是添加快键键的地方，添加后可以使用了</description>
    </item>
    
    <item>
      <title>第三部分-新的标准库组件</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 19 Mar 2022 00:01:15 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/</guid>
      <description>第三部分 新的标准库组件 本部分介绍了 C++17 的新库组件。
15 std::optional&amp;lt;&amp;gt; 在编程中，我们经常遇到可能返回/传递/使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布尔成员/标志，表明一个值是否存在。 std::optional&amp;lt;&amp;gt; 以类型安全的方式提供此类对象。
可选对象仅具有包含对象的内部存储器以及布尔标志。因此，大小通常比包含的对象大一个字节。对于某些包含的类型，甚至可能根本没有大小开销，前提是可以将附加信息放置在包含的对象中。没有分配堆内存。对象使用与包含类型相同的对齐方式。
但是，可选对象不仅仅是将布尔标志的功能添加到值成员的结构。例如，如果没有值，则不会为包含的类型调用构造函数（因此，您可以为对象提供没有的默认状态）。
与 std::variant&amp;lt;&amp;gt; 和 std::any 一样，结果对象具有值语义。也就是说，复制被实现为深度复制，创建一个独立的对象，带有标志和包含的值（如果有的话）在它自己的内存中。复制没有包含值的 std::optional&amp;lt;&amp;gt; 很便宜；复制带有包含值的 std::optional&amp;lt;&amp;gt; 与复制包含的类型/值一样便宜/昂贵。支持移动语义。
15.1 使用 std::optional&amp;lt;&amp;gt; std::optional&amp;lt;&amp;gt;模型是一个任意类型的可忽略的实例。这个实例可能是一个成员，一个参数，或者一个返回值。你也可以说，std::optional&amp;lt;&amp;gt;是一个容纳零或一个元素的容器。
15.1.1 可选的返回值 以下程序演示了 std::optional&amp;lt;&amp;gt; 用作返回值的能力： lib/optional.cpp
#include &amp;lt;optional&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; // 如果可能，将字符串转换为 int: std::optional&amp;lt;int&amp;gt; asInt(const std::string&amp;amp; s) { try { return std::stoi(s); } catch (...) { return std::nullopt; } } int main() { for (auto s : {&amp;#34;42&amp;#34;, &amp;#34; 077&amp;#34;, &amp;#34;hello&amp;#34;, &amp;#34;0x33&amp;#34;} ) { // 如果可能，尝试将 s 转换为 int 并打印结果: std::optional&amp;lt;int&amp;gt; oi = asInt(s); if (oi) { std::cout &amp;lt;&amp;lt; &amp;#34;convert &amp;#39;&amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#34;&amp;#39; to int: &amp;#34; &amp;lt;&amp;lt; *oi &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } else { std::cout &amp;lt;&amp;lt; &amp;#34;can&amp;#39;t convert &amp;#39;&amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#34;&amp;#39; to int\n&amp;#34;; } } } 在程序中 asInt() 是将传递的字符串转换为整数的函数。 但是，这可能不会成功。 出于这个原因，使用了 std::optional&amp;lt;&amp;gt; 以便我们可以返回&amp;quot;no int&amp;quot;并避免为其定义一个特殊的 int 值或向调用者抛出异常。 因此，我们要么返回调用 stoi() 的结果，它用一个 int 初始化返回值，要么我们返回 std::nullopt，表明我们没有一个 int 值。 我们可以实现如下相同的行为：</description>
    </item>
    
    <item>
      <title>第五部分-专业工具</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/</link>
      <pubDate>Sat, 19 Mar 2022 00:01:15 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/</guid>
      <description>第五部分 专业工具 这部分介绍了普通应用程序程序员通常不必知道的新语言和库特性。 它可能涵盖基础库、特定模式或特殊环境中的程序员的工具。
27 多态的内存资源 (PMR) 自C++98以来，标准库就支持配置类分配其内部（堆）内存的方式的能力。由于这个原因，标准库中几乎所有分配内存的类型都有一个分配器参数。因此，你可以配置容器、字符串和其他类型分配其内部内存的方式，如果它们需要比堆栈上分配的空间更多的话。 分配这种内存的默认方式是从堆中分配。但是有不同的理由来修改这个默认行为：
你可以使用你自己的方式分配内存，以减少系统调用的数量。 你可以确保分配的内存位于彼此的旁边，以从CPU缓存中获益。 你可以把容器和它们的元素放在可供多进程使用的共享内存中。 你甚至可以重定向这些堆内存调用，以使用早期在堆栈上分配的内存。因此，可以有性能和功能方面的原因。 然而，在C++17之前，使用分配器（右）在很多方面都是既棘手又笨拙的（由于一些缺陷，太过复杂，以及与后向兼容的修改）。 现在，C++17为预定义和用户定义的内存分配方式提供了一个相当容易使用的方法，它可以用于标准类型和用户定义的类型。 基于这个原因，本章将讨论：
使用标准库提供的标准内存资源 定义自定义内存资源 为自定义类型提供内存资源支持 如果没有Pablo Halpern、Arthur O&amp;rsquo;Dwyer、David Sankel和Jonathan Wakely的大力帮助，本章就不可能完成。一些视频解释了这里提供的功能：
分配器：Pablo Halpern 的好零件 C++17 的 std::pmr 有代价 David Sankel 分配器是 Arthur O&amp;rsquo;Dwyer 的堆句柄 27.1 使用标准内存资源 本节介绍了标准内存资源以及如何使用它们。
27.1.1 激励性的例子 让我们首先比较一下没有和有标准内存资源的内存消耗。
为容器和字符串分配内存 假设在你的程序中，你有一个由一些字符串组成的向量，你用相当长的方式初始化这些字符串字符串：
pmr/pmr0.cpp #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;#34;../lang/tracknew.hpp&amp;#34; int main() { TrackNew::reset(); std::vector&amp;lt;std::string&amp;gt; coll; for (int i=0; i &amp;lt; 1000; ++i) { coll.emplace_back(&amp;#34;just a non-SSO string&amp;#34;); } TrackNew::status(); } 注意，我们使用一个类来跟踪内存分配的数量，该类跟踪所有用以下循环执行的::new调用：</description>
    </item>
    
    <item>
      <title>第四部分-标准库扩展和修改</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sat, 19 Mar 2022 00:01:15 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/</guid>
      <description>第四部分 标准库扩展和修改 这一部分介绍了用C++17对现有库组件的扩展和修改。
21类型特征扩展 关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。
21.1 类型特征的Suffix _v 从C++17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是
std::is_const&amp;lt;T&amp;gt;::value 你现在可以写:
std::is_const_v&amp;lt;T&amp;gt; // since C++17 这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:
namespace std { template&amp;lt;typename T&amp;gt; constexpr bool is_const_v = is_const&amp;lt;T&amp;gt;::value; } 通常，这有助于制定布尔条件，你可以在运行时使用:
if (std::is_signed_v&amp;lt;char&amp;gt;) { ... } 但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:
if constexpr (std::is_signed_v&amp;lt;char&amp;gt;) { ... } 或在实例化模板时:
// C&amp;lt;T&amp;gt;类的主要模板 template&amp;lt;typename T, bool = std::is_pointer_v&amp;lt;T&amp;gt;&amp;gt; class C { ... }; // 指针类型的部分特殊化。 template&amp;lt;typename T&amp;gt; class C&amp;lt;T, true&amp;gt; { ... }; 在这里，以C类为例，它为指针类型提供了一个特殊的实现。 但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&amp;lt;&amp;gt;。它产生的是一个原始数组的维度大小:
int a[5][7]; std::cout &amp;lt;&amp;lt; std::extent_v&amp;lt;decltype(a)&amp;gt; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // prints 5 std::cout &amp;lt;&amp;lt; std::extent_v&amp;lt;decltype(a),1&amp;gt; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // prints 7 21.</description>
    </item>
    
    <item>
      <title>第二部分-模板特性</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sat, 19 Mar 2022 00:01:14 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/</guid>
      <description>第二部分: 模板特性 9 类模板参数推导 C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：
std::complex&amp;lt;double&amp;gt; c{5.1,3.3}; 也不能忽略第二次的std::mutex：
std::mutex mx; std::lock_guard&amp;lt;std::mutex&amp;gt; lg(mx); C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。
比如：
你可以这样声明： std::complex c{5.1,3.3}; // 好的：推断出 std::complex&amp;lt;double&amp;gt; 你可以这样实现： std::mutex mx; std::lock_guard lg{mx}; // OK: 推断出 std::lock_guard&amp;lt;std_mutex&amp;gt; 你甚至可以让容器推导其元素的类型： std::vector v1 {1, 2, 3} // OK: 推断出 std::vector&amp;lt;int&amp;gt; std::vector v2 {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;}; // OK: 推断出 std::vector&amp;lt;const char*&amp;gt; 9.1 类模板参数推导的使用 只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：
std::complex c1{1.1, 2.2}; // 推断出 std::complex&amp;lt;double&amp;gt; std::complex c2(2.2, 3.3); // 推断出 std::complex&amp;lt;double&amp;gt; std::complex c3 = 3.3; // 推断出 std::complex&amp;lt;double&amp;gt; std::complex c4 = {4.</description>
    </item>
    
    <item>
      <title>QT文档翻译</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Wed, 23 Feb 2022 23:08:02 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</guid>
      <description>此文档来自于👉 QtDocumentCN/QtDocumentCN: Qt中文文档翻译 (github.com)
并由本人补充了一些文档</description>
    </item>
    
    <item>
      <title>左值和右值</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Sun, 20 Feb 2022 16:30:47 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</guid>
      <description>左值有地址和值，可以出现在赋值运算符左边或者右边。
右值只有值，只能出现在赋值运算符右边。
右值只有值，没有地址， 右值是一个优化技巧（C++)，因为右值往往是临时变量的。
左值代表另一个值，右值是值本身。</description>
    </item>
    
    <item>
      <title>并发_并行_同步_异步</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Sun, 20 Feb 2022 16:23:26 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/</guid>
      <description> 并发：
​	计算机可以同时执行多个任务；单核处理器可以通过分配时间片的方式 单线程 并行：
针对多核处理器，不用用过分配时间片方式执行任务，少了线程的上下文切换 同步：
上一个任务执行完毕后才可以进行下一个任务，所以没有并发和并行概念 多线程同步（资源争抢） 异步：
不同任务不会相互等待，执行任务A时也可以在执行任务B，当任务A没有算出结果时，不会呆呆的等A，而是会去执行B，也有可能也同时执行C，D&amp;hellip;，等未来的某个时间A的结果返回也没问题。
同步里面没有并行和异步的概念，异步是一种任务执行序列，其应用可以在多线程并行、单线程并发 多线程的应用场景下，如果有资源竞争的情况，适合使用异步（单线程） </description>
    </item>
    
    <item>
      <title>Visual_Studio_2022_PRE添加OpenCV库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022-pre%E6%B7%BB%E5%8A%A0opencv%E5%BA%93/</link>
      <pubDate>Sat, 19 Feb 2022 23:13:27 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022-pre%E6%B7%BB%E5%8A%A0opencv%E5%BA%93/</guid>
      <description>此篇是VS添加OpenCV库教程
1. 创建一个新工程 2. 创建完工程后切到属性管理器 3. 添加新项目属性列表 然后切到Debug | x64添加新项目属性列表(P) 然后双击新建的文件。
4. 添加库头文件路径和库文件路径 添加库头文件路径 添加库文件路径
5. 填写要使用的库文件名 这里使用debug版
End.</description>
    </item>
    
    <item>
      <title>cmake编译opencv及Clion使用</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8Aclion%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 15 Feb 2022 19:21:35 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8Aclion%E4%BD%BF%E7%94%A8/</guid>
      <description> 采用了linux下编译OpenCV, Visual Studio 2022, QT6.2.3都不成功。
最终采用在win下编译OpenCV + Clion成功，此文记录踩下的坑。
1. 下载OpenCV源码 源码地址👇
Github:
https://github.com/opencv/opencv/archive/4.5.5.zip
2. 编译OpenCV源码 解压文件夹 解压win下exe文件解压后由两个文件夹，source为源码目录 build为已经建好的库文件目录
CMake-gui工具构建
source code选择带有源码的目录，binaries选择一个新创建一个mingw-build目录，然后点击Configure，弹出的窗口选择MinGW Makefiles,第一次可能会失败，失败后再点击Configure，还不行的百度吧。 配置成功后点击Generate cd到mingw-bulid目录执行mingw32-make -j8,根据自己机器性能设置线程数，这里设置8个线程，编译时间较久，等待完成。 然后执行mingw32-make install生成库，在mingw-build生成install保存了生成库库文件和头文件。 3. 后续配置 把C:\\Users\\用户名\\Downloads\\opencv\\mingw-build\\install\\x64\\mingw\\bin路径添加到win的环境变量
👇此为一个CMakeLists.txt
cmake_minimum_required(VERSION 3.19) project(opencv_learn) set(CMAKE_CXX_STANDARD 20) include_directories($ENV{CMAKE_INCLUDE_PATH}) set(OpenCV_DIR C:\\Users\\用户名\\Downloads\\opencv\\mingw-build\\install\\x64\\mingw\\bin) #需要的openCV库 FIND_PACKAGE(OpenCV REQUIRED) #显示OpenCV的版本号 MESSAGE(&amp;#34;OpenCV version : ${OpenCV_VERSION}&amp;#34;) MESSAGE(&amp;#34;OpenCV include : ${OpenCV_INCLUDE_DIRS}&amp;#34;) MESSAGE(&amp;#34;OpenCV libs11 : ${OpenCV_LIBS}&amp;#34;) MESSAGE(&amp;#34;OpenCV DIR : ${OpenCV_DIR}&amp;#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) MESSAGE(&amp;#34;OpenCV libs : ${OpenCV_LIBS}&amp;#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) set(SOURCE main.cpp) # 将源代码添加到此项目的可执行文件。 add_executable (${PROJECT_NAME} ${SOURCE}) TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS}) </description>
    </item>
    
    <item>
      <title>C&#43;&#43;计时器</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c&#43;&#43;%E8%AE%A1%E6%97%B6%E5%99%A8/</link>
      <pubDate>Thu, 10 Feb 2022 17:01:05 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c&#43;&#43;%E8%AE%A1%E6%97%B6%E5%99%A8/</guid>
      <description>此文来自于👉由UP主神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译 【63】【Cherno C++】【中字】C++的计时_哔哩哔哩_bilibili ，并由我整理。
C++计时器
std::chrono::high_resolution_clock高分辨率时钟在不同标准库有所区别，尽量不要使用。
对时长度量使用 steady_clock 对壁钟时间使用 system_clock 。 基础计时器
#include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; #include &amp;lt;thread&amp;gt; int main(void) { auto start = std::chrono::steady_clock::now(); std::this_thread::sleep_for(std::chrono::seconds(1)); auto end = std::chrono::steady_clock::now(); std::chrono::duration&amp;lt;float&amp;gt; time = end - start; std::cout &amp;lt;&amp;lt; time.count() &amp;lt;&amp;lt; &amp;#34;s \n&amp;#34;; std::cin.get(); } 计算打印hello用时
struct Timer { std::chrono::time_point&amp;lt;std::chrono::steady_clock&amp;gt; start, end; std::chrono::duration&amp;lt;float&amp;gt; duration; Timer() { start = std::chrono::steady_clock::now(); } ~Timer() { end = std::chrono::steady_clock::now(); duration = end - start; float ms = duration.</description>
    </item>
    
    <item>
      <title>让字符串及字符操作更加快速</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/</link>
      <pubDate>Mon, 07 Feb 2022 17:25:55 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/</guid>
      <description>视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【80】【Cherno C++】【中字】如何让C++字符串更快_哔哩哔哩_bilibili 并由我整理。
此本不会讲解为什么std::string会很慢和其背后的细节，只有些例子。
std::string的主要问题之一是 字符串格式化及字符串操作 时需要分配内存
bad例子：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; static uint32_t s_AllocCount = 0; // 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符 void* operator new(size_t size) { s_AllocCount++; std::cout &amp;lt;&amp;lt; &amp;#34;allocating: &amp;#34; &amp;lt;&amp;lt; size &amp;lt;&amp;lt; &amp;#34; bytes\n&amp;#34;; return malloc(size); } void PrintName(const std::string&amp;amp; name) { std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } int main(void) { std::string name = &amp;#34;Yan Chernikov&amp;#34;; std::string firstname = name.substr(0, 3); std::string lasttname = name.</description>
    </item>
    
    <item>
      <title>让C&#43;&#43;程序更快的运行</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Sun, 06 Feb 2022 21:27:50 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</guid>
      <description>视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【79】【Cherno C++】【中字】如何让C++运行得更快_哔哩哔哩_bilibili 并由我整理。
通过编码方式利用多核或多处理器 ,利用这些线程，不只是让你的程序顺序执行一条条指令，而是把一些东西，推迟到不同的线程，甚至不是推迟，二十把东西分派到不同的线程，让计算机更快地处理这些东西。
每一个资源，每一个纹理模型，他们通常独立于彼此，意味着这是良好的多线程候选场景。
static std::mutex s_MeshesMutex; static void LoadMesh(std::vector&amp;lt;Ref&amp;lt;Mesh&amp;gt;&amp;gt;* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard&amp;lt;std::mutex&amp;gt; lock(s_MeshesMutex); meshes.push_back(mesh); } void EditLayer::LoadMeshes() { std::ifstream stream(&amp;#34;src/Models.txt&amp;#34;); std::string line; std::vector&amp;lt;std::string&amp;gt; meshFilepaths; while (std::getline(stream, line)) meshFilepaths.push_back(line); #define ASYNC 1 #id ASYNC for (const auto&amp;amp; file : meshFilepaths) // std::launch::async告知std库创建一个线程处理。 // 我们需要保留std::async的返回值，如果不保留的话，因为它会被C++标准库摧毁，在摧毁时，标准库需要确保过程实际已被完成，这基本不是并行了，所以需要创建一个std::future的向量。 m_Futures.push_back(std::async(std::launch::async, LoadMesh, &amp;amp;m_Meshes, file)); #else for (const auto&amp;amp; file : meshFilepaths) m_Meshes.push_back(Mesh::Load(file)); } std::vector&amp;lt;std::future&amp;lt;void&amp;gt; m_Meshes; 通过把任务分派的不同的线程，资源加载速度由6.</description>
    </item>
    
    <item>
      <title>qt添加第三方库方法</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 03 Feb 2022 14:14:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/</guid>
      <description> qt添加第三方库方法
添加库 选择项目名右击
选择添加库
选择外部库，下一步 库文件填写库文件路径和库名字，包含路径是库头文件路径，平台选择一个或全部选择，链接选择动态，点击下一步 汇总将会显示添加到.pro文件中，在项目中可以添加头文件使用此库了 </description>
    </item>
    
    <item>
      <title>qt中ui简单介绍</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 02 Feb 2022 20:07:01 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>qt ui区别：
无ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include &amp;lt;QMainWindow&amp;gt; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); }; #endif // MAINWINDOW_H 有ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include &amp;lt;QMainWindow&amp;gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE // 这个MainWindow和下边的MainWindow没有关系，在不同命名空间内。 class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private: Ui::MainWindow *ui;// ui的指针 }; #endif // MAINWINDOW_H 无ui的mainWindow.cpp #include &amp;#34;mainwindow.h&amp;#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {} MainWindow::~MainWindow() {} 有ui的mainWindow.</description>
    </item>
    
    <item>
      <title>Qt概述</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 01 Feb 2022 17:40:05 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/qt%E6%A6%82%E8%BF%B0/</guid>
      <description>1. Qt概述 1.1 什么是Qt Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。
1.2 Qt的发展史 1991年 Qt最早由奇趣科技开发
1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础
2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言
2012年 Qt又被Digia公司收购
2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。
截至2022年1月31日Qt最新版本为 6.2.3
1.3 支持的平台 Windows – XP、Vista、Win7、Win8、Win2008、Win10、Win11
Uinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD/OS、和其他很多X11平台
Macintosh – Mac OS X
Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE
1.4 Qt版本 Qt按照不同的版本发行，分为商业版和开源版
商业版 为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。
开源的LGPL版本： 为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。
1.5 Qt的下载与安装 下载地址： 现在QT有两种安装方式
在线安装：使用qt的安装器
https://download.qt.io/archive/online_installers/4.2/ 不同系统下载对应安装器,然后安装
离线安装
qt最后的一个离线安装版本是5.14.2,超过此版本是在线安装版，不提供整合二进制版本。
Linux Host 下载链接👉Qt 5.14.2 for Linux 64-bit ( 1.2G )
OS X Host 下载链接👉Qt 5.</description>
    </item>
    
    <item>
      <title>设计模式准则</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/</link>
      <pubDate>Mon, 31 Jan 2022 18:56:20 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/</guid>
      <description>最终目的：高内聚，低耦合 1. 开放封闭原则 (OCP,Open For Extension, Closed For Modification Principle) 😎类的改动是通过增加代码进行的，而不是修改源代码。
2. 单一职责原则 (SRP,Single Responsibility Principle) 类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。
3. 依赖倒置原则 (DIP,Dependence Inversion Principle) 😎依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。
4. 接口隔离原则 (ISP,Interface Segegation Principle) 不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。
5. 里氏替换原则 (LSP, Liskov Substitution Principle) 任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。
6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle) 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。 如果使用对象组合，就降低了这种依赖关系。
7. 迪米特法则(LOD,Law of Demeter) 😎一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。(黑盒原理)</description>
    </item>
    
    <item>
      <title>for和while的几种用法</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 30 Jan 2022 21:10:45 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/</guid>
      <description>三段式for循环 // 变量声明在for里面，自增在里面 for (int i = 0; i &amp;lt; 10; ++i) { //... } // 变量声明在外面,自增在里面 int i = 0; for (; i &amp;lt; 10; ) { //... ++i; } bool condition = true; int i = 0; for (; condition; ) { //... ++i; if (!(i &amp;lt; 5)) condition = false; } 无限循环版本
bool condition = true; int i = 0; for (; ; ) { //... ++i; if (!</description>
    </item>
    
    <item>
      <title>Visual-Studio-2022基本设置</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 30 Jan 2022 19:14:50 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</guid>
      <description>用微软家的Visual Studio 2022创建项目，为了避免文件混乱，可以采用下边的设置方法,当然也可以使用默认的设置。
点击解决方案下的项目名，例如sendbox👇
在弹出的对话窗中点击属性👇
然后在弹出的对话框中👇，选择所有配置,平台选择所有平台
上图有一个错误去掉bin前面的\.
配置属性-&amp;gt;常规，
在常规属性-&amp;gt;输出目录填写$(SolutionDir)bin\$(Platform)\$(Configuration)\
在常规属性-&amp;gt;中间目录填写$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\
其中Platform根据平台选择不同而不同，比如选择x64,那么Platform就是Win64，还有Win32
设置完点击项目，选择清理，然后重新生成
编译器语言标准
配置属性-&amp;gt;常规-&amp;gt;C++语言标准
配置属性-&amp;gt;常规-&amp;gt;C语言标准
End.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;单一变量存放多种类型的数据</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 29 Jan 2022 22:33:43 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description> 此文来源于👉 【77】【Cherno C++】【中字】单一变量存放多种类型的数据_哔哩哔哩_bilibili
用来处理可能存在也可能不存在的数据，也可能是与我们预期不同的类型。当然也不一定，而是让我们存储不同的数据。 std::variant的作用是让我们不用担心处理的确切类型，指定一个std::variant的东西，然后列出他可能的数据类型。 例子：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;variant&amp;gt; int main(void) { std::variant&amp;lt;std::string, int&amp;gt; data; data = &amp;#34;Cherno&amp;#34;; std::cout &amp;lt;&amp;lt; std::get&amp;lt;std::string&amp;gt;(data) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; data = 2;// data被重新赋值为2 std::cout &amp;lt;&amp;lt; std::get&amp;lt;int&amp;gt;(data) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; data.index();// index函数会告诉你类型的索引， 此时会打印1。 if (auto value = std::get_if&amp;lt;int&amp;gt;(&amp;amp;data)) { std::string&amp;amp;v = *value; } else { //... } /* std::cout &amp;lt;&amp;lt; std::get&amp;lt;std::string&amp;gt;(data) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 错误的访问方法，在data被置为int后依旧按照std::string访问，会抛出一个 bad variant access异常 */ std::cin.get(); return 0; } </description>
    </item>
    
    <item>
      <title>C&#43;&#43;数据存在或不存在处理方法</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 29 Jan 2022 21:22:58 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>此文来源于👉 【76】【Cherno C++】【中字】如何处理OPTIONAL数据_哔哩哔哩_bilibili
有一个返回的函数， 比如正在读取一个文件，但是如果这个文件不能被读取，会发生什么，虽然读取失败，但我们仍然需要从函数中返回一些东西，返回一个空字符串没有意义。
如果文件是空的，应有办法看到数据存在或不存在，而std::optional可以给我们一些帮助，此特性在C++17加入。
非std::optional版本
例子：
#incldue &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; std::string ReadStringFromFile(const std::&amp;amp;string filepath, bool&amp;amp; outSuccess) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); outSuccess = true; return result; } outSuccess = false; return {}; } int main(void) { bool fileOpenedSuccessfully; std::string data = ReadStringFromFile(&amp;#34;data.txt&amp;#34;, fileOpenedSuccessfully); if (fileOpenedSuccessfully) { //... } else { //... } return 0; } std::optional版本
#include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;optional&amp;gt; std::optional&amp;lt;std::string&amp;gt; ReadStringFromFile(const std::string&amp;amp; filepath) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;元组与对组</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/</link>
      <pubDate>Sat, 29 Jan 2022 17:41:10 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/</guid>
      <description>来自于👉 tuple - C++ Reference (cplusplus.com) 并整理
一个元组std::tuple是一个能够容纳 元素集合 的对象。每个元素都可以是 不同的类型。
std::make_pair()可以构建一个配对对象，其第一个元素设置为x，第二个元素设置为y，并返回。
std::tie可以绑定std::tuple&amp;lt;T,T,T,...&amp;gt;的实例，并分别给这些元素起别名
std::tuple 所在头文件 &amp;lt;tuple&amp;gt;
例子：
// tuple example #include &amp;lt;iostream&amp;gt; // std::cout #include &amp;lt;tuple&amp;gt; // std::tuple, std::get, std::tie, std::ignore int main () { std::tuple&amp;lt;int,char&amp;gt; foo (10,&amp;#39;x&amp;#39;); auto bar = std::make_tuple (&amp;#34;test&amp;#34;, 3.1, 14, &amp;#39;y&amp;#39;); std::cout &amp;lt;&amp;lt; &amp;#34;bar has &amp;#34;&amp;lt;&amp;lt;std::tuple_size&amp;lt;decltype(bar)&amp;gt;::value &amp;lt;&amp;lt; elements&amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; std::tuple_element&amp;lt;0,decltype(bar)&amp;gt;::type first = std::get&amp;lt;0&amp;gt;(bar); std::cout &amp;lt;&amp;lt; &amp;#34;bar contains: &amp;#34; &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; std::get&amp;lt;2&amp;gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&amp;lt;3&amp;gt;(bar); std::get&amp;lt;0&amp;gt;(foo) = std::get&amp;lt;2&amp;gt;(bar); std::get&amp;lt;1&amp;gt;(foo) = mychar; std::cout &amp;lt;&amp;lt; &amp;#34;foo contains: &amp;#34;; std::cout &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(foo) &amp;lt;&amp;lt; &amp;#39; &amp;#39;; std::cout &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(foo) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } 答案：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;结构化绑定</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Sat, 29 Jan 2022 17:40:33 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</guid>
      <description> 此文总结与👉 神经元猫的个人空间_哔哩哔哩_bilibili 的 【75】【Cherno C++】【中字】C++的结构化绑定_哔哩哔哩_bilibili
在如何处理C++多返回值得问题，返回的数据可以是结构体实例，也可以是元组或对组 从C++17引入的结构化绑定可以改善此项，
以前忒麻烦的版本
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;tuple&amp;gt; std::tuple&amp;lt;std::string, int&amp;gt; CreatPerson() { return { &amp;#34;Cherno&amp;#34;, 24 }; } int main(void) { auto person = CreatPerson(); std::string&amp;amp;name = std::get&amp;lt;0&amp;gt;(person); int age = std::get&amp;lt;1&amp;gt;(person); std::string name; int age; std::tie(name, age) = CreatPerson(); return 0; } 从C++17引入了结构化绑定解决了上诉问题
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;tuple&amp;gt; std::tuple&amp;lt;std::string, int&amp;gt; CreatPerson() { return { &amp;#34;Cherno&amp;#34;, 24 }; } int main(void) { auto[name, age] = CreatPerson(); // 简单，美观 std::cout &amp;lt;&amp;lt; name; return 0; } </description>
    </item>
    
    <item>
      <title>获取C&#43;&#43;中数据的类型的方法</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E8%8E%B7%E5%8F%96c-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 28 Jan 2022 17:51:19 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E8%8E%B7%E5%8F%96c-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>此文来自于👉 C++ / typeinfo — DevDocs ，并整理
判断数据是哪种数据类型 头文件&amp;lt;typeinfo&amp;gt;
std::type_info::name() 例子：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;typeinfo&amp;gt; struct Base { virtual ~Base() = default; }; struct Derived : Base {}; int main() { Base b1; Derived d1; const Base *pb = &amp;amp;b1; std::cout &amp;lt;&amp;lt; typeid(*pb).name() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; pb = &amp;amp;d1; std::cout &amp;lt;&amp;lt; typeid(*pb).name() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; int i; int * pi; std::cout &amp;lt;&amp;lt; &amp;#34;int is: &amp;#34; &amp;lt;&amp;lt; typeid(int).name() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; std::cout &amp;lt;&amp;lt; &amp;#34; i is: &amp;#34; &amp;lt;&amp;lt; typeid(i).</description>
    </item>
    
    <item>
      <title>本人使用的hexo插件列表</title>
      <link>https://okokfun.github.io/post/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 28 Jan 2022 14:14:03 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/</guid>
      <description>文章emoji支持
npm install hexo-filter-github-emojis --save 文章加密访问插件
npm install hexo-blog-encrypt --save 使用方法
将 &amp;ldquo;password&amp;rdquo; 字段添加到您文章信息头就像这样. --- title: Hello World tags: - 作为日记加密 date: 2016-03-30 21:12:21 password: mikemessi abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. --- password下边几行可加可不加。
编辑_config.yml 加入下列几行
# Security encrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码, 请点击本文字. tags: - {name: tagName, password: 密码A} - {name: tagName, password: 密码B} wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;新特性</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 24 Jan 2022 17:02:47 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>1. Variadic Templates 数量不定的模板参数
...代表任意个数据
void print(){} template &amp;lt;typename T, typename... Types&amp;gt; void print(const T&amp;amp; firstArg, const Types&amp;amp;...args) { std::cout &amp;lt;&amp;lt; firstArg &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; print(args...); } void print(const T&amp;amp; firstArg, const Types&amp;amp;...args){}中...代表任意个数据，Types任意类型的数据,
表示接受任意个任意类型的数据
例子：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;bitset&amp;gt; void print() {} template &amp;lt;typename T, typename... Types&amp;gt; void print(const T &amp;amp;firstArg, const Types &amp;amp;...args) { std::cout &amp;lt;&amp;lt; firstArg &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, &amp;#34;hello&amp;#34;, std::bitset&amp;lt;16&amp;gt;(377), 42); return 0; } 结果：</description>
    </item>
    
    <item>
      <title>QT_UI组件库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/qt-ui%E7%BB%84%E4%BB%B6%E5%BA%93/</link>
      <pubDate>Mon, 24 Jan 2022 14:33:42 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/qt-ui%E7%BB%84%E4%BB%B6%E5%BA%93/</guid>
      <description>QT组件库第1-31 QT组件库第32-56 Layouts 布局组件库 1号 Vertical Layout 垂直布局
2号 Horizontal Layout 水平布局
3号 Grid Layout 网格布局
4号 Form Layout 表单布局
Spacers 空间间隔组(弹簧) 5号 Horizontal Spacer 水平间隔
6号 Vertical Spacer 垂直间隔
Buttons 按钮 7号 Push Button 8号 Tool Button 9号 Radio Button 10号 Check Box 11号 Command Link Button 12号 Dialog Button Box Item Views (Model-Based) 清单视图组 13号 List View 清单视图
14号 Tree View 树视图
15号 Table View 表视图
16号 Column View 列视图</description>
    </item>
    
    <item>
      <title>Me</title>
      <link>https://okokfun.github.io/post/me/</link>
      <pubDate>Mon, 24 Jan 2022 13:37:38 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/me/</guid>
      <description>安乐死是对人最后的仁慈，让人可以有尊严和最后无痛苦的离开这个世界，当然前提是有病痛且无法医治，比如物理学家霍金的 肌萎缩性脊髓侧索硬化症（ALS）。</description>
    </item>
    
    <item>
      <title>模板</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sun, 23 Jan 2022 19:49:07 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E6%A8%A1%E6%9D%BF/</guid>
      <description>本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用
1 模板 1.1 模板的概念 模板就是建立通用的模具，大大提高复用性
模板的特点：
模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板
C++提供两种模板机制:函数模板和类模板
1.2.1 函数模板语法 函数模板作用：
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。
语法：
template&amp;lt;typename T&amp;gt; 函数声明或定义 解释：
template &amp;mdash; 声明创建模板
typename &amp;mdash; 表面其后面的符号是一种数据类型，可以用class代替
T &amp;mdash; 通用的数据类型，名称可以替换，通常为大写字母
示例：
//交换整型函数 void swapInt(int&amp;amp; a, int&amp;amp; b) { int temp = a; a = b; b = temp; } //交换浮点型函数 void swapDouble(double&amp;amp; a, double&amp;amp; b) { double temp = a; a = b; b = temp; } //利用模板提供通用的交换函数 template&amp;lt;typename T&amp;gt; void mySwap(T&amp;amp; a, T&amp;amp; b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&amp;lt;int&amp;gt;(a, b); cout &amp;lt;&amp;lt; &amp;#34;a = &amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;b = &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; } int main() { test01(); system(&amp;#34;pause&amp;#34;); return 0; } 总结：</description>
    </item>
    
    <item>
      <title>github资源资源下载加速</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</link>
      <pubDate>Wed, 19 Jan 2022 23:46:32 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</guid>
      <description> 由于大家都知道原因，国内使用github下载源码和Releases文件时都慢如龟速 下边根据我所使用的方法介绍几种方法
1. 通过命令行克隆源码 通过添加.cnpmjs.org 在
git clone https://github.com/MistEO/MeoAssistantArknights.git 的.com后边添加.cnpmjs.org
git clone https://github.com.cnpmjs.org/MistEO/MeoAssistantArknights.git 通过替换为hub.fastgit.org 喜欢的话请他喝杯茶捐赠相关 | FastGit UK Document
在
git clone https://github.com/MistEO/MeoAssistantArknights.git 中把github.com替换为hub.fastgit.org
git clone https://hub.fastgit.org/MistEO/MeoAssistantArknights.git 2. 通过浏览器下载资源 下载例如源码zip包，releases文件。
下载源码zip包 把
https://github.com/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 中的github.com替换为download.fastgit.org
https://download.fastgit.org/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 下载二进制releases文件 此为个人项目喜欢的话请他喝杯茶GitHub Proxy 代理加速 (ghproxy.com)
通过添加https://ghproxy.com/ 把
https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip 在https://github添加https://ghproxy.com/
https://ghproxy.com/https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip </description>
    </item>
    
    <item>
      <title>容器适配器</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Wed, 19 Jan 2022 16:53:19 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>容器适配器提供顺序容器的不同接口
std::stack 定义于头文件 &amp;lt;stack&amp;gt; std::stack 类是容器适配器，它给予程序员栈的功能——特别是 FILO （先进后出）数据结构。
该类模板表现为底层容器的包装器——只提供特定函数集合。栈从被称作栈顶的容器尾部推弹元素。
元素访问 top 访问栈顶元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向栈顶插入元素 (公开成员函数) emplace(C++11) 在顶部原位构造元素 (公开成员函数) pop 删除栈顶元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::queue 适配一个容器以提供队列（FIFO 数据结构） 定义于头文件 &amp;lt;queue&amp;gt;
std::queue 类是容器适配器，它给予程序员队列的功能——尤其是 FIFO （先进先出）数据结构。
类模板表现为底层容器的包装器——只提供特定的函数集合。 queue 在底层容器尾端推入元素，从首端弹出元素。
元素访问 front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向队列尾部插入元素 (公开成员函数) emplace(C++11) 在尾部原位构造元素 (公开成员函数) pop 删除首个元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::priority_queue 定义于头文件 &amp;lt;queue&amp;gt; priority_queue 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与释出。</description>
    </item>
    
    <item>
      <title>关联容器</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 19 Jan 2022 16:53:07 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
      <description>此文整理与👉容器库 - cppreference.com
关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。
std::set 定义于头文件 &amp;lt;set&amp;gt;
std::set 是关联容器，含有 Key 类型对象的已排序集并去重。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。
返回指向 set 首元素的迭代器。
若 set 为空，则返回的迭代器将等于 end() 。
返回值
指向首元素的迭代器。
复杂度 常数。
std::set&amp;lt;&amp;gt;::begin,std::set&amp;lt;&amp;gt;::cbegin #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; int main() { std::set&amp;lt;int&amp;gt; set = { 3, 1, 4, 1, 5, 9, 2, 6, 5 }; std::for_each(set.cbegin(), set.cend(), [](int x) { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;; }); std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } std::set&amp;lt;Key,Compare,Allocator&amp;gt;::empty 检查容器是否无元素</description>
    </item>
    
    <item>
      <title>顺序容器</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 19 Jan 2022 16:52:52 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>顺序容器实现能按顺序访问的数据结构。
std::array 静态的连续数组
定义于头文件 &amp;lt;array&amp;gt;
std::array 是封装 固定大小数组 的容器。 隐式定义的成员函数 (构造函数)(隐式声明) 遵循聚合初始化的规则初始化 array （注意默认初始化可以导致非类的 T 的不确定值） (公开成员函数) (析构函数)(隐式声明) 销毁 array 的每个元素 (公开成员函数) operator=(隐式声明) 以来自另一 array 的每个元素重写 array 的对应元素 (公开成员函数) 元素访问 at(C++11) 访问指定的元素，同时进行越界检查 (公开成员函数) [operator](C++11) 访问指定的元素 (公开成员函数) front(C++11) 访问第一个元素 (公开成员函数) back(C++11) 访问最后一个元素 (公开成员函数) data(C++11) 直接访问底层数组 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty(C++11) 检查容器是否为空 (公开成员函数) size(C++11) 返回容纳的元素数 (公开成员函数) max_size(C++11) 返回可容纳的最大元素数 (公开成员函数) 操作 fill(C++11) 以指定值填充容器 (公开成员函数) swap(C++11) 交换内容 std::vector 定义于头文件 &amp;lt;vector&amp;gt;</description>
    </item>
    
    <item>
      <title>日期和时间工具</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 18 Jan 2022 19:17:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/</guid>
      <description>此文来源于👉日期和时间工具 - cppreference.com
日期和时间工具 std::chrono 库 时钟 时长 时间点 时钟 system_clock(C++11) 来自系统范畴实时时钟的挂钟时间 (类) steady_clock(C++11) 决不会调整的单调时钟 (类) high_resolution_clock(C++11) 拥有可用的最短嘀嗒周期的时钟 (类) is_clockis_clock_v(C++20) 确定类型是否为时钟 (Clock) (类模板) (变量模板) utc_clock(C++20) 协调世界时 (UTC) 的时钟 (Clock) (类) tai_clock(C++20) 国际原子时 (TAI) 的时钟 (Clock) (类) gps_clock(C++20) GPS 时间的时钟 (Clock) (类) file_clock(C++20) 用于文件时间的时钟 (Clock) (typedef) local_t(C++20) 表示本地时间的伪时钟 时间点 时间点是从特定时钟的纪元开始经过的时间时长。
定义于头文件 &amp;lt;chrono&amp;gt; 定义于命名空间 std::chrono time_point(C++11) 时间中的点 (类模板) clock_time_conversion(C++20) 定义如何转换一个时钟的时间点为另一个的特性类 (类模板) clock_cast(C++20) 转换一个时钟的时间点为另一个 (函数模板) 时长 时长由时间跨度组成，定义为某时间单位的某个计次数。例如，“ 42 秒”可表示为由 42 个 1 秒时间点位的计次所组成的时长。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;无序容器</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 18 Jan 2022 16:54:33 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>此文来自👉容器库 - cppreference.com
容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作
无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。
1. std::unordered_set 唯一键的集合，按照键生成散列
unordered_set 是含有 Key 类型唯一对象集合的关联容器。搜索、插入和移除拥有平均常数时间复杂度。
在内部，元素并 不以任何特别顺序排序，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。
不可修改容器元素（即使通过非 const 迭代器），因为修改可能 更改元素的哈希，并破坏容器。
例子 #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; int main() { // 创建三个 string 的 unordered_set（映射到 string ） std::unordered_set&amp;lt;std::string&amp;gt; u = { &amp;#34;RED&amp;#34;, &amp;#34;GREEN&amp;#34;, &amp;#34;BLUE&amp;#34; }; // 迭代并打印 unordered_set 的关键和值 for (const auto &amp;amp;n : u) { std::cout &amp;lt;&amp;lt; &amp;#34;Key:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } // // 添加新入口到 unordered_set // &amp;#34;BLACK&amp;#34;; // &amp;#34;WHITE&amp;#34;; u.</description>
    </item>
    
    <item>
      <title>动态内存管理</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 18 Jan 2022 13:20:39 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>此文取自于👉动态内存管理 - cppreference.com
std::unique_ptr 拥有独有对象所有权语义的智能指针
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;functional&amp;gt; struct B { virtual void bar() { std::cout &amp;lt;&amp;lt; &amp;#34;B::bar\n&amp;#34;; } virtual ~B() = default; }; struct D : B{ D() { std::cout &amp;lt;&amp;lt; &amp;#34;D::D\n&amp;#34;; } ~D() { std::cout &amp;lt;&amp;lt; &amp;#34;D::~D\n&amp;#34;; } void bar() override { std::cout &amp;lt;&amp;lt; &amp;#34;D::bar\n&amp;#34;; } }; // 消费 unique_ptr 的函数能以值或以右值引用接收它 std::unique_ptr&amp;lt;D&amp;gt; pass_through(std::unique_ptr&amp;lt;D&amp;gt; p) { p-&amp;gt;bar(); return p; } void close_file(std::FILE* fp) { std::fclose(fp); } int main() { std::cout &amp;lt;&amp;lt; &amp;#34;unique ownership semantics demo\n&amp;#34;; { auto p = std::make_unique&amp;lt;D&amp;gt;(); // p 是占有 D 的 unique_ptr auto q = pass_through(std::move(p)); assert(!</description>
    </item>
    
    <item>
      <title>C&#43;&#43;文件系统库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/</link>
      <pubDate>Sun, 16 Jan 2022 15:16:11 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/</guid>
      <description> 此文来源于👉文件系统库 - cppreference.com，并整理。
库范畴定义 文件：持有数据的文件系统对象，能被写入或读取，或二者皆可。文件拥有名称及属性，属性之一是文件类型： 目录：表现为目录条目的容器的文件，目录条目标识其他文件（其中一些可以是另外的嵌套的目录）。讨论到具体文件时，包含该文件目录条目的目录是其父目录。父目录能以相对路径名 &amp;ldquo;..&amp;rdquo; 表示。 硬链接：关联一个名字到一个既存文件的目录条目。若支持多重硬链接，则文件在最后一个到它的硬链接被移除后才被移除。 符号链接：关联一个名词到一个路径的目录条目，路径可以存在亦可不存在。 常规文件：不是其他文件类型的文件。 文件名：命名一个文件的字符串。容许字符、大小写区别、最大长度以及被禁止名称是实现定义的。名称 &amp;ldquo;.&amp;rdquo; （点）与 &amp;ldquo;..&amp;rdquo; （双点）在库层次拥有特殊含义。 路径：标识一个文件的元素序列。它以可选的 根名 （例如 Windows 上的 &amp;ldquo;C:&amp;rdquo; 或 &amp;ldquo;//server&amp;rdquo; ）开始，后随可选的 根目录 （例如 Unix 上的 &amp;ldquo;/&amp;rdquo; ），后随零或更多个文件名（除了最后一个都必须是目录或到目录的链接）的序列。表示路径的字符串（路径名）的原生格式（如哪些字符被用作分隔符）与字符编码是实现定义的，库提供路径的可移植表示。 绝对路径：无歧义地标识一个文件位置的路径。 规范路径：不包含符号链接、 &amp;ldquo;.&amp;rdquo; 或 &amp;ldquo;..&amp;rdquo; 元素的绝对路径。 相对路径：标识相对于文件系统中某位置的文件位置的路径。特殊路径名 &amp;ldquo;.&amp;rdquo; （点，“当前目录”）和 &amp;ldquo;..&amp;rdquo; （双点、“父目录”）是相对路径。 类 定义于头文件 &amp;lt;filesystem&amp;gt; 定义于命名空间 std::filesystem path(C++17) 表示路径 (类) filesystem_error(C++17) 文件系统错误时抛出的异常 (类) directory_entry(C++17) 目录条目 (类) directory_iterator(C++17) 指向目录内容的迭代器 (类) recursive_directory_iterator(C++17) 指向一个目录及其子目录的内容的迭代器 (类) file_status(C++17) 表示文件类型及权限 (类) space_info(C++17) 关于文件系统上空闲及可用空间的信息 (类) file_type(C++17) 文件的类型 (枚举) perms(C++17) 标识文件系统权限 (枚举) perm_options(C++17) 指定权限操作的语义 (枚举) copy_options(C++17) 指定复制操作的语义 (枚举) directory_options(C++17) 用于迭代目录内容的选项 (枚举) file_time_type(C++17) 表示文件时间值 (typedef) 非成员函数 定义于头文件 &amp;lt;filesystem&amp;gt; 定义于命名空间 std::filesystem absolute(C++17) 组成一个绝对路径 (函数) canonicalweakly_canonical(C++17) 组成一个规范路径 (函数) relativeproximate(C++17) 组成一个相对路径 (函数) copy(C++17) 复制文件或目录 (函数) copy_file(C++17) 复制文件内容 (函数) copy_symlink(C++17) 复制一个符号链接 (函数) create_directory create_directories(C++17)(C++17) 创建新目录 (函数) create_hard_link(C++17) 创建一个硬链接 (函数) create_symlink create_directory_symlink(C++17)(C++17) 创建一个符号链接 (函数) current_path(C++17) 返回或设置当前工作目录 (函数) exists(C++17) 检查路径是否指代既存的文件系统对象 (函数) equivalent(C++17) 检查两个路径是否指代同一文件系统对象 (函数) file_size(C++17) 返回文件的大小 (函数) hard_link_count(C++17) 返回指代特定文件的硬链接数 (函数) last_write_time(C++17) 获取或设置最近一次数据修改的时间 (函数) permissions(C++17) 修改文件访问权限 (函数) read_symlink(C++17) 获得符号链接的目标 (函数) remove remove_all(C++17)(C++17) 移除一个文件或空目录 移除一个文件或递归地移除一个目录及其所有内容 (函数) rename(C++17) 移动或重命名一个文件或目录 (函数) resize_file(C++17) 以截断或填充零更改一个常规文件的大小 (函数) space(C++17) 确定文件系统上的可用空闲空间 (函数) status symlink_status(C++17)(C++17) 确定文件属性 确定文件属性，检查符号链接目标 (函数) temp_directory_path(C++17) 返回一个适用于临时文件的目录 (函数) 文件类型 is_block_file(C++17) 检查给定的路径是否表示块设备 (函数) is_character_file(C++17) 检查给定的路径是否表示字符设备 (函数) is_directory(C++17) 检查给定的路径是否表示一个目录 (函数) is_empty(C++17) 检查给定的路径是否表示一个空文件或空目录 (函数) is_fifo(C++17) 检查给定的路径是否表示一个命名管道 (函数) is_other(C++17) 检查参数是否表示一个其他文件 (函数) is_regular_file(C++17) 检查参数是否表示一个常规文件 (函数) is_socket(C++17) 检查参数是否表示一个具名 IPC 套接字 (函数) is_symlink(C++17) 检查参数是否表示一个符号链接 (函数) status_known(C++17) 检查参数是否表示一个符号链接 (函数) </description>
    </item>
    
    <item>
      <title>C&#43;&#43;正则表达式</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 16 Jan 2022 14:45:25 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>此文章来源于👉正则表达式库 - cppreference.com,并整理
正则表达式库提供表示正则表达式的类，正则表达式是一种用于在字符串中匹配模式的微型语言。
定义于头文件 #include &amp;lt;iostream&amp;gt; #include &amp;lt;iterator&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;regex&amp;gt; int main() { std::string s = &amp;#34;Some people, when confronted with a problem, think &amp;#34; &amp;#34;\&amp;#34;I know, I&amp;#39;ll use regular expressions.\&amp;#34; &amp;#34; &amp;#34;Now they have two problems.&amp;#34;; std::regex self_regex(&amp;#34;REGULAR EXPRESSIONS&amp;#34;, std::regex_constants::ECMAScript | std::regex_constants::icase); if (std::regex_search(s, self_regex)) { std::cout &amp;lt;&amp;lt; &amp;#34;Text contains the phrase &amp;#39;regular expressions&amp;#39;\n&amp;#34;; } std::regex word_regex(&amp;#34;(\\w+)&amp;#34;); auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex); auto words_end = std::sregex_iterator(); std::cout &amp;lt;&amp;lt; &amp;#34;Found &amp;#34; &amp;lt;&amp;lt; std::distance(words_begin, words_end) &amp;lt;&amp;lt; &amp;#34; words\n&amp;#34;; const int N = 6; std::cout &amp;lt;&amp;lt; &amp;#34;Words longer than &amp;#34; &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &amp;#34; characters:\n&amp;#34;; for (std::sregex_iterator i = words_begin; i !</description>
    </item>
    
    <item>
      <title>线程支持库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/</link>
      <pubDate>Sat, 15 Jan 2022 17:13:05 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/</guid>
      <description>此文来自于👉线程支持库 - cppreference.com
线程支持库 thread(C++11) std::thread 类与支持函数 stop_token(C++20) std::jthread 的停止记号 mutex(C++11) 互斥元件 shared_mutex(C++14) 共享互斥元件 future(C++11) 异步计算元件 condition_variable(C++11) 线程等待条件 semaphore(C++20) 信号量 latch(C++20) 闩 barrier(C++20) 屏障 #include &amp;lt;thread&amp;gt; std::thread thread类 表示单个执行线程。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; int main() { std::thread th1; } std:🧵:id thread::id类 是轻量的可频繁复制类，它作为 std::thread 对象的唯一标识符工作。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; typedef unsigned long long ULL; std::string getThreadIdOfString(const std:🧵:id &amp;amp; id) { std::stringstream sin; sin &amp;lt;&amp;lt; id; return sin.str(); } ULL getThreadIdOfULL(const std:🧵:id &amp;amp; id) { return std::stoull(getThreadIdOfString(id)); } int main() { std:🧵:id id = std::this_thread::get_id(); std::cout &amp;lt;&amp;lt; &amp;#34;cout ----- id : &amp;#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;getThreadIdOfString ----- id : &amp;#34; &amp;lt;&amp;lt; getThreadIdOfString(id) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;getThreadIdOfULL ----- id : &amp;#34; &amp;lt;&amp;lt; getThreadIdOfULL(id) &amp;lt;&amp;lt; std::endl; return 0; } std:🧵:hardware_concurrency() 返回处理器支持的并发线程数。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;关键词</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c&#43;&#43;%E5%85%B3%E9%94%AE%E8%AF%8D/</link>
      <pubDate>Sat, 15 Jan 2022 15:31:05 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c&#43;&#43;%E5%85%B3%E9%94%AE%E8%AF%8D/</guid>
      <description> 此文章来自👉C++ 参考手册
C++关键词： alignas (C++11 起) default(1) register(C++17弃用)(2) alignof (C++11 起) delete(1) reinterpret_cast and do requires (C++20 起) and_eq double return asm dynamic_cast short atomic_cancel (TM TS) else signed atomic_commit (TM TS) enum sizeof(1) atomic_noexcept (TM TS) explicit static auto(1) export(1)(3) static_assert (C++11 起) bitand extern(1) static_cast bitor false struct(1) bool float switch break for synchronized (TM TS) case friend template catch goto this char if thread_local (C++11 起) char8_t (C++20 起) inline(1) throw(C++17中移除) char16_t (C++11 起) int true char32_t (C++11 起) long try class(1) mutable(1) typedef compl namespace typeid concept (C++20 起) new typename const noexcept (C++11 起) union consteval (C++20 起) not unsigned constexpr (C++11 起) not_eq using(1) constinit (C++20 起) nullptr (C++11 起) virtual const_cast operator void continue or volatile co_await (C++20 起) or_eq wchar_t co_return (C++20 起) private while co_yield (C++20 起) protected xor decltype (C++11 起) public xor_eq reflexpr (反射 TS) override (C++11) final (C++11) import (C++20) module (C++20) transaction_safe (TM TS) transaction_safe_dynamic (TM TS) </description>
    </item>
    
    <item>
      <title>cpr请求库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/</link>
      <pubDate>Thu, 13 Jan 2022 20:43:31 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/</guid>
      <description>本文介绍的HTTP库👉libcpr/cpr: C++ Requests: Curl for People, a spiritual port of Python Requests. (github.com)
HttpServer Url Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/hello.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/basic.json&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/error.html&amp;#34;}; Url url{&amp;#34;http://bad_host/&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/basic_cookies.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/empty_cookies.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/check_cookies.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/v1_cookies.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/check_v1_cookies.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/basic_auth.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/bearer_token.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/digest_auth.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/header_reflect.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/temporary_redirect.html&amp;#34;}; Url url{server-&amp;gt;GetBaseUrl() + &amp;#34;/permanent_redirect.</description>
    </item>
    
    <item>
      <title>Socket_Cpp库的使用</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 13 Jan 2022 20:28:16 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
此库是一个简单的TCP库👉sockpp
TCP TCP Clien IPV4:tcp_clien sockpp::socket_initializer sockpp环境初始化 sockpp::tcp_connector conn({host, port}) // 初始化一个连接器，并尝试连接到{host, port} !conn.read_timeout(seconds(5)) // 读超时 conn.address() // 连接成功打印地址 conn.connect(sockpp::inet_address(&amp;#34;localhost&amp;#34;, port)) // 链接{localhost, port} sockpp::inet_address(host, port) // 返回一个默认的端口号和地址 conn.clone() // clone一个sockpp::tcp_socket conn.last_error_str() // 返回根据平台各自的错误字符串 conn.last_error() conn.write(s) // 通过coon把字符串s写过去 conn.write_n(buf, n) // 从buf中取n个字节的数据并通过tcp写过去 conn.read(buf, sizeof(buf))) // 读sizeof(buf)个字节到buf中，并返回读到的字节数 conn.read_n() // conn.address() // 服务器的地址 conn.peer_address() conn.shutdown(SHUT_WR) 例子- 单线程
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;#34;sockpp/tcp_connector.h&amp;#34; #include &amp;#34;sockpp/version.h&amp;#34; using namespace std; using namespace std::chrono; int main(int argc, char* argv[]) { cout &amp;lt;&amp;lt; &amp;#34;Sample TCP echo client for &amp;#39;sockpp&amp;#39; &amp;#34; &amp;lt;&amp;lt; sockpp::SOCKPP_VERSION &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; endl; string host = (argc &amp;gt; 1) ?</description>
    </item>
    
    <item>
      <title>Oracle数据库介绍</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 09 Jan 2022 16:51:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>数据库介绍 什么是数据库?
​	数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.
​	举个例子来说明这个问题：每个人都有很多亲戚和朋友，为了保持与他们的联系，
​	我们常常用一个笔记本将他们的姓名、地址、电话等信息都记录下来，
​	这样要査谁的电话或地址就很方便了。
​	这个“通讯录”就是一个最简单的“数据库”，每个人的姓名、地址、电话等信息就是这个数据库中的“数据”。
​	我们可以在笔记本这个“数据库”中添加新朋友的个人信息，也可以由于某个朋友的电话变动而修改他的电话号码这个“数据”。
​	不过说到底，我们使用笔记本这个“数据库”还是为了能随时査到某位亲戚或朋友的地址、邮编或电话号码这些“数据”。
数据库是干什么用的?
存储和管理数据,便于程序开发.
oracle简介:
Oracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。
Oracle公司成立与1977年，总部位于美国加州；
Oracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。
Oracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。
2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。
2008年1月16日 sun公司收购了mysql 。
2009年4月20日 oracle收购了sun 。
常见的数据库有哪些？
oracle公司的oracle数据库
IBM公司的DB2数据库
Informix公司的Informix数据库
sysbase公司的sysbase数据库
Microsoft公司的SQL Server
oracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）
MongoDB数据库
Mariadb数据库 (由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发,MariaDB名称来自Michael Widenius的女儿Maria的名字)
SQLite (设计目标是嵌入式)
1 Oracle的体系结构 Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。
1.1 表空间和数据文件 逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。
物理概念：数据文件，在磁盘上（/home/oracle_11/app/oradata/orcl目录中的.DBF文件）；
​ 一个表空间包含一个或者多个数据文件。
1.2 段、区、块 段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。</description>
    </item>
    
    <item>
      <title>nginx安装</title>
      <link>https://okokfun.github.io/post/nginx%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Jan 2022 16:07:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/nginx%E5%AE%89%E8%A3%85/</guid>
      <description>1. 一些基本概念 ###1.1 Nginx初步认识
Nginx介绍
engine x
俄罗斯
开源的框架
c语言
Tengine - 淘宝基于nginx修改的
Nginx能干什么?
作为web服务器 解析http协议 反向代理服务器 了解反向代理的概念 邮件服务器 解析邮件相关的协议: pop3/smtp/imap Nginx的优势?
更快
高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求 高扩展
低耦合设计的模块组成,丰富的第三方模块支持 高可靠
经过大批网站检验 www.sina.com.cn www.xunlei.com www.163.com 每个worker进程相对独立, 出错之后可以快速开启新的worker worker进程的个数是可以控制的 在后台干活的进程 低内存消耗
一般情况下,10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗 2.5M内存 单机支持10万以上的并发连接
取决于内存,10万远未封顶 热部署
master和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件 最自由的BSD许可协议
BSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布 淘宝: tengine 1.2 正向/反向代理 正向代理
正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。
正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径, 比如:
学校的局域网
单位局域网访问外部资源
正向代理服务器是为用户服务的
反向代理
反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。
客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的
请求直接发给反向代理服务器
反向代理服务器将请求转发给后边的web服务器
web服务器 N 台 反向代理服务器转发请求会轮询进行 web服务器收到请求进行处理, 得到结果</description>
    </item>
    
    <item>
      <title>MySQL数据库API库</title>
      <link>https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93api%E5%BA%93/</link>
      <pubDate>Wed, 05 Jan 2022 20:21:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93api%E5%BA%93/</guid>
      <description>MySQL数据库API库 访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。
可使用mysql -V 命令查看当前系统内所使用的mysql数据库版本信息。数据库版本为5.6.20版。因此，我们可从帮助手册refman-5.6-en.a4.pdf入手，了解学习MySQL C API使用的一般信息。
从API手册23.8中可获取信息，MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数-I、-L、-l。
从手册中可获知，函数库名为mysqlclient。
因此我们使用命令:
find / -name libmysqlclient* 查找该库的路径。得到 /usr/lib64/mysql/libmysqlclient.a。 nm /usr/lib64/mysql/libmysqlclient.a命令可查看库内包含的函数。
编写hello应用链接函数库 编写一个hello.c应用程序，链接使用该库。
用到头文件 &amp;lt;mysql.h&amp;gt; 可使用locate mysql.h查看其目录位置/usr/include/mysql/mysql.h。
编译引用了库的应用程序。
gcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient 参见帮助手册refman-5.6-en.a4.pdf：23.8.4.3小节。
MySQL API常用函数 总体印象 使用MySQL库API函数的一般步骤：
a. 初始化. MYSQL *mysql_init(MYSQL *mysql);
b. 错误处理	unsigned int mysql_errno(MYSQL *mysql);char *mysql_error(MYSQL *mysql);
c. 建立连接.	MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);</description>
    </item>
    
    <item>
      <title>Mysql数据库</title>
      <link>https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Wed, 05 Jan 2022 12:57:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>1 MySQL基础知识 瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。
MySQL是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低、MySQL软件采用了双授权政策，分为社区版和企业版。
1.1 MySQL版本及下载 MySQL数据库版本相对比较繁杂。常见的有：Community社区版、Enterprise企业版。
MySQL Community Server 版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。
MySQL Enterprise Edition 企业版收费的，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。
其中Community Server 可以直接从mysql 的官网下载。但Enterprice Edition只能从Oracle edelivery上下载，而Edelivery有时会屏蔽中国IP。
MySQL各版本区别参见：
http://www.admin10000.com/Document/62.html
下载mysql时注意区分版本细节及所应用的系统平台：linux(32/64) 、win(32/64)
举例：
win版本：
mysql-installer-community-8.0.26.0.msi版本
​ GA 是指软件的通用版本，一般指正式发布的版本 (Generally Available (GA) Release)
​ mysql-essential-5.1.60-win32.msi精简版，如果只需要mysql服务，就选择此版本。
​ mysql-5.1.60-win32.msi 是完 是整版，包含安装程序和配置向导，有MySQL文档。
mysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导
​ mysql-5.1.60.zip 是用于windows的Mysql源码压缩包
linux版本
​ 在http://www.mysql.com/downloads/网站上下载不了
​ 在 www.oracle.com/downloads 找mysql 注册用户, 选择操作系统平台和mysql版本 进行下载
官方文档上有关MySQL安装，介绍了3种类型及其对应安装方式来安装MySQL数据库：
Linux supports a number of different solutions for installing MySQL. The recommended method is to use one of the distributions from Oracle.</description>
    </item>
    
    <item>
      <title>Json的使用</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/json%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 04 Jan 2022 17:38:16 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/json%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>百度百科 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
本文采用
MistEO哥哥写的项目。
他写两个很棒的项目
Json:MistEO/meojson: A fast and easy-to-use JSON parser/generator for C++ (github.com)
明日方舟助手：MistEO/MeoAssistantArknights: 明日方舟助手，自动刷图、智能基建换班，全日常一键长草！ (github.com)
他的博客肝！ (misteo.top)，不过是鸽王。
好了开始正题了
json下载 下载玛丽写的Json项目MistEO:Json
git clone https://github.com.cnpmjs.org/MistEO/meojson.git 编译 json静态库 make 运行命令后会在build文件夹生成libmeojson.a,然后就在项目中可以使用了
在代码中添加头文件 #include &amp;#34;json.h&amp;#34; 若您需要解析 Json5, 则请包含 json5.hpp 头文件 #include &amp;#34;json5.hpp&amp;#34; meojson 仅依赖 STL, 但需要 c++17 标准 使用 json /*** * from sample/sample.cpp ***/ #include &amp;lt;iostream&amp;gt; #include &amp;#34;json.hpp&amp;#34; void parsing() { std::string content = R&amp;#34;( { &amp;#34;repo&amp;#34;: &amp;#34;meojson&amp;#34;, &amp;#34;author&amp;#34;: { &amp;#34;MistEO&amp;#34;: &amp;#34;https://github.</description>
    </item>
    
    <item>
      <title>Visual_Studio_2022添加第三方库</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link>
      <pubDate>Tue, 04 Jan 2022 17:36:44 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/visual-studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid>
      <description>文件夹创建 在项目根目录创建Dependencies,然后在Dependencies创建include目录 在Dependencies中创建Libs 把头文件和库文件放到对目录
项目头文件添加 然后用Visual Studio打开项目，找到 红色圈中的功能条
再点击最下边的属性
定位到常规，然后再编辑附加包含目录，添加一条新item为$(SolutionDir)Dependencies\include\
其中 $(SolutionDir)为项目根目录，Dependencies\include\为头文件目录
至此第三方库的头文件已经添加完成
项目库文件添加 点击链接器，常规，附加库目录，添加一条$(SolutionDir)Dependencies\Libs\GLFW,
然后点击输入，附加依赖项，写入要使用的库文件名，点击确定，第三方库已被添加到项目中
End.</description>
    </item>
    
    <item>
      <title>Cmake的安装与CMakeLists.txt的编写</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ecmakelists-txt%E7%9A%84%E7%BC%96%E5%86%99/</link>
      <pubDate>Mon, 03 Jan 2022 16:24:52 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ecmakelists-txt%E7%9A%84%E7%BC%96%E5%86%99/</guid>
      <description>安装 cmake是自动化项目编译工具，可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。
下载地址👉Download | CMake， 建议二进制安装。
win:
https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-windows-x86_64.zip ubuntu:
sudo apt install cmake wget https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-linux-x86_64.tar.gz centos:
sudo yum install cmake arch:
sudo pacman -S cmake 编写CMakeLists.txt 单文件单目录CMakeLists.txt编写 # 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo1) # 指定编译后文件名 set(OUTPUTNAME demo1) set(CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20&amp;#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(. DIR_SRCS) # 编译文件 add_executable(${OUTPUTNAME} ${DIR_SRCS}) 此文件加编写完毕后，创建一个build文件夹，cd进去，执行cmake ..，会生成Makefile文件，再然后执行make编译，最终生成项目文件。
多文件单目录CMakeLists.txt编写 和demo1相同
# 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo2) # 指定编译后文件名 set(OUTPUTNAME demo2) set(CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20&amp;#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-行为模式</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 03 Jan 2022 15:48:22 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。
适用场景:
当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。
当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。
观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。
当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。
订阅列表是动态的， 因此订阅者可随时加入或离开该列表。
/** * Observer Design Pattern * * Intent: Lets you define a subscription mechanism to notify multiple objects * about any events that happen to the object they&amp;#39;re observing. * * Note that there&amp;#39;s a lot of different terms with similar meaning associated * with this pattern.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-结构型模式</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 03 Jan 2022 15:07:58 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
代理模式 解释
对真正要被访问的产品或类加以控制，并可以进行一些控制，把访问产品与代理进行映射，访问代理就相当于访问产品
适用场景：
使用代理模式的方式多种多样， 我们来看看最常见的几种。
延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。
你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。
访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。
代理可仅在客户端凭据满足要求时将请求传递给服务对象。
本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。
在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。
缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。
代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。
智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。
代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。
代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。
class Subject { public: virtual void Request() const = 0; }; /** * The RealSubject contains some core business logic. Usually, RealSubjects are * capable of doing some useful work which may also be very slow or sensitive - * e.</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 01 Jan 2022 19:32:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>推荐看👉 OI Wiki
数据结构：数据结构是为算法服务而设计的。 算法：充分且合理利用计算机资源处理数据而诞生。
数据结构部分 一. 数据结构的存储方式有两种 1.顺序存储(数组,内存连续) 2.链式存储(链表,内存不连续,依靠节点的指针指向下一个节点) 常见的数据结构有：
数组(array),链表(LinkedList),
双向链表(doubly-linked-list),
树：
二叉树(Binary tree),
二叉查找树(Binary Search Tree),平衡二叉树(AVL),
2-3-4树
红黑树(Red Black Tree), B树, B+树, B*树, AA-树
treap树, k-d树, 伸展树(Splay Tree)
最小生成树(Minimum Spanning Tree)
图(graph),
栈(stack), 堆(heap),队列(queue),
散列表(hash), 位图(bitmap),
字典(map)
二 常见数据结构实现 1.链表 链表(LinkedList) 避免数组插入和删除的线性开销,我们需要允许表可以不连续存储,防止数据大量移动
链表的设计 设计成一个链表节点至少包含两部分：
数据部和指针部
数据部为我们要存储的数据,指针部为指向下一个链表节点
typedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 单向链表 typedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 例子 /*1ist.</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://okokfun.github.io/post/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 01 Jan 2022 19:32:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E7%AE%97%E6%B3%95/</guid>
      <description>推荐看👉 OI Wiki
算法部分 位图(bitmap) 通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。
位图BitMap
字典(map) 字典有什么特点呢?
字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情况下取出这些信息. 使用数组的方式: [18, &amp;ldquo;Coderwhy&amp;rdquo;, 1.88]. 可以通过下标值取出信息. 使用字典的方式: {&amp;ldquo;age&amp;rdquo; : 18, &amp;ldquo;name&amp;rdquo; : &amp;ldquo;Coderwhy&amp;rdquo;, &amp;ldquo;height&amp;rdquo;: 1.88}. 可以通过key取出value 字典(map)的详细解释
kmp算法 kmp算法也就是字符串匹配算法。
比如： 在string str = &amp;ldquo;abcababcba&amp;quot;中匹配 string str2 = &amp;ldquo;ababc&amp;ldquo;字符串
最长公共前后缀：要匹配的字符串生成的数组
从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计
0	a
0	a	b
1	a	b	a
2	a	b	a	b
0	a	b	a	b	c
得出的公共前后缀为
0 0 1 2 0 然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为
-1 0 0 1 2 kmp匹配过程</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-创建型模式</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 27 Dec 2021 13:48:06 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
设计模式描述：
用特定的套路解决现实问题，每一个设计模式对应一个法子
分类 根据意图或目的分类
创建型模式: 提供创建对象机制，增加已有的代码灵活性和可复用性 结构型模式: 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 行为模式: 负责对象间的高效沟通和职责委派。 创建型模式 simple_factory_pattern(简单工厂) Factory Method(工厂方法) 在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
要解决的问题：
当增加一个新类，和其他类低耦合
解决方案:
增加一个子类的抽象类，所有的子类继承于抽象类，并且写父类的实现
#include &amp;lt;iostream&amp;gt; class product { public: virtual ~product() {} }; class phone : public product { public: phone() { std::cout &amp;lt;&amp;lt; &amp;#34;make phone&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class tv : public product { public: tv() { std::cout &amp;lt;&amp;lt; &amp;#34;make tv&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class factory { public: virtual ~factory() {} virtual product* make_product() = 0; }; class phone_factory : public factory { public: virtual product* make_product() { return new phone(); } }; class tv_factory : public factory { public: virtual product* make_product() { return new tv(); } }; int main() { factory* factory1 = new phone_factory(); product* product1 = factory1-&amp;gt;make_product(); factory* factory2 = new tv_factory(); product* product2 = factory2-&amp;gt;make_product(); delete factory1; delete product1; delete factory2; delete product2; return 0; } Abstract Factory(抽象工厂模式) 随着业务的发展，更多的类需要创建，比如美国工厂，欧洲工厂，亚洲工厂，南美工厂，每个地区工厂又需要创建各自的产品</description>
    </item>
    
    <item>
      <title>gdb代码调试工具</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 26 Dec 2021 16:46:38 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</guid>
      <description>GDB是是 Linux 平台下最常用的一款程序调试器，通常服务于终端下，无GUI。Linux下很多IDE的调试能力源于GDB调试器
1. Linux下安装二进制版GDB调试器 centos下命令：
sudo yum -y install gdb Ubuntu下安装命令：
sudo apt -y install gdb 2. 源码安装下载： sudo wget https://ftp.gnu.org/gnu/gdb/gdb-13.2.tar.xz 解压：
tar -zxvf gdb-13.2.tar.xz 进入源码目录安装：
./configure make sudo make install 3. 调试准备 GDB supports the following languages (in alphabetical order):
Ada Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust 只是为了调试代码需要在编译时加入：-g参数，关掉编译器优化参数：-O0，打开所有 warning：-Wall 4. GDB的启动与退出 启动gdb调试 gdb 可执行程序文件名
(gdb) gdb app 退出调试
quit = q (gdb) q 命令行传参:show args 设置的时机: 启动gdb之后, 在应用程序启动之前</description>
    </item>
    
    <item>
      <title>从Portainer点击端口号进入容器服务方法</title>
      <link>https://okokfun.github.io/post/nas/%E4%BB%8Eportainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 26 Dec 2021 13:43:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/nas/%E4%BB%8Eportainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/</guid>
      <description>
1.点击home,再点击配置，然后填写nas的ip地址即可 </description>
    </item>
    
    <item>
      <title>OpenMediaVault中docker与工具portainer</title>
      <link>https://okokfun.github.io/post/nas/openmediavault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8Egui%E5%B7%A5%E5%85%B7portainer/</link>
      <pubDate>Sun, 26 Dec 2021 13:42:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/nas/openmediavault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8Egui%E5%B7%A5%E5%85%B7portainer/</guid>
      <description> 1. 安装完第三方插件后，再安装docker与portainer 2. 点击Opem Portainer创建管理账号 3. 然后创建一个容器网络 </description>
    </item>
    
    <item>
      <title>OpenMediaVault软件源修改</title>
      <link>https://okokfun.github.io/post/nas/openmediavault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sun, 26 Dec 2021 13:42:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/nas/openmediavault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/</guid>
      <description>OpenMediaVault 国内软件源镜像服务器
清华大学镜像 https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/ 北京外国语大学镜像 https://mirrors.bfsu.edu.cn/OpenMediaVault/ OMV 5
一、编辑 sources.list 1. 备份配置文件
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2. 清空配置文件
sudo sh -c &amp;#39;echo &amp;gt; /etc/apt/sources.list&amp;#39; 3. 编辑配置文件
sudo nano /etc/apt/sources.list 复制并粘贴以下内容：
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free 二、编辑 openmediavault-kernel-backports.list 1. 备份配置文件</description>
    </item>
    
    <item>
      <title>OpenMediaVault安装与初步设置</title>
      <link>https://okokfun.github.io/post/nas/openmediavault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 26 Dec 2021 13:39:29 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/nas/openmediavault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/</guid>
      <description>OpenMediaVault（omv）是开源的nas系统，本博客尽量采用开源的代码和软件
1. 镜像下载 下载地址
https://sourceforge.net/projects/openmediavault/files/latest/download 2. 刻录或虚拟机安装 可以用etcher软件刻录镜像
安装 omv-extras 启用 OMV 5 社区插件支持 3. 安装依赖的工具 sudo apt --yes --no-install-recommends install dirmngr gnupg 4. 下载最新的omv-extras 安装包 地址：https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 下载命令：sudo wget https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 5. 安装 sudo dpkg -i openmediavault-omvextrasorg_5.6.2_all.deb 6. 安装完开启docker扩展源 7. Docker修改镜像源并在OMV 中的安装和使用 Docker 设置国内镜像服务器
第一步 创建 docker 配置文件目录 sudo mkdir /etc/docker 第二步 创建 daemon.json 配置文件 sudo touch /etc/docker/daemon.json 第三步 编辑配置文件 sudo nano /etc/docker/daemon.json 在编辑器中粘贴以下内容: { &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;https://hub-mirror.c.163.com&amp;#34;, &amp;#34;https://mirror.baidubce.com&amp;#34; ] } 第四步 重启 docker 服务 sudo systemctl daemon-reload sudo systemctl restart docker 检查设置是否生效</description>
    </item>
    
    <item>
      <title>OpenMediaVault创建容器</title>
      <link>https://okokfun.github.io/post/nas/openmediavault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 26 Dec 2021 13:41:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/nas/openmediavault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/</guid>
      <description>要创建的容器有：
Mariadb: 关系型数据库，mysql的开源版本Adminer：开源的数据库管理软件Gitea：开源的私人代码版本管理器Flarum：开源的论坛WordPress：开源的博客软件NextCloud：开源的私人网盘软件1.在一个分区上创建我们需要的文件夹存放配置文件 2.在终端拉取上面的各个镜像文件 1.flarum docker pull mondedie/flarum:latest2.wordpress docker pull wordpress3.adminer docker pull adminer4.mariadb docker pull mariadb5.gitea docker pull gitea/gitea6.nextcloud docker pull nextcloud3.创建各个容器 按顺序应该创建数据库软件与数据库管理软件 1.mariadb容器创建参考 container_name: mariadbenvironment:- PUID=1000- PGID=1000- MYSQL_ROOT_PASSWORD=1- TZ=Asia/Shanghaivolumes:- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/mariadb/config:/configports:- 3306:3306networks:- mynetrestart: alwaysnetworks:mynet:external:name: mynet2.adminer创建参考 container_name: adminerenvironment:- ADMINER_DEFAULT_SERVER=mariadbports:- 8080:8080networks:- mynetrestart: alwaysnetworks:mynet:external:name: mynet3.</description>
    </item>
    
    <item>
      <title>OpenLib-c&#43;&#43;</title>
      <link>https://okokfun.github.io/post/openlib-c/</link>
      <pubDate>Sun, 26 Dec 2021 13:23:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/openlib-c/</guid>
      <description>开源 C++ 库列表 &amp;lt; cpp‎ | links
此页面的目的是构建开源 C++ 库的比较列表，使得人们在需要特定功能的实现时，不必浪费时间在网上（ DuckDuckGo 、谷歌、必应等）搜索。
若你知道可能对其他人有用的库，请在此添加到它的链接。能包含进来的库没有限制，但是必须能便捷地下载库的源码。
以“原态”提供此页面——希望这有用，但不提供任何担保。过时、误导或错误的链接可能出现于此。若你注意到这些错误，则改正它会很有意义。
包管理器 Package manager Description build2 一个开源的 (MIT)、跨平台的构建工具链，旨在为开发和打包 C/C++ 项目时提供如 Rust Cargo 一样的便利性。 cget Cmake 包检索工具，可用于下载并安装 Cmake 包。 cmodule 非侵入式 CMake 依赖管理。 conan 去中心化、开源 (MIT) 的 C/C++ 包管理器。 CPM.cmake 一段可以为 CMake 加入依赖管理功能的 CMake 脚本。它是作为 CMake 的 FetchContent 模块的一个简单包装构建的。该模块加入了版本控制、缓存、简单 API 等功能。 hunter 一个 CMake 驱动的跨平台包管理器，服务于 C/C++ 项目。 spack 一个超级计算机、Linux、macOS 平台的包管理器。它使得安装科学软件变得简单。非绑定于某一特定语言。 teaport 一个受 cocoapods 启发的依赖管理器。 vcpkg 一个 Windows、Linux、macOS 平台的 C++ 包管理器。 库 音频 库名 简述 协议 配置手段 Aquila Aquila 是一个开源、跨平台的 C++11 DSP 库。 MIT 许可 CMake Essentia 开源库，音频和音乐分析、描述和合成工具 (MIR) (源码) Affero GPLv3 FFTW 离散傅里叶变换 (DFT) 计算库 (SSE/SSE2/AVX/Altivec/ARM Neon)。 (源码) GPL-2.</description>
    </item>
    
    <item>
      <title>Arch安装</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/arch%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 24 Dec 2021 19:34:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/arch%E5%AE%89%E8%A3%85/</guid>
      <description>Arch安装 一.准备工作 1.1下载镜像 地址：
清华：https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/ 163:https://mirrors.163.com/archlinux/iso/latest/ 中科大：https://mirrors.ustc.edu.cn/archlinux/iso/latest/ 上海交通：https://mirror.sjtu.edu.cn/archlinux/iso/latest/ 北大：https://mirrors.pku.edu.cn/archlinux/iso/latest/ 本文是Arch官方文档的再次梳理版
https://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 安装方法有很多种比如脚本，实体机，虚拟机
本文采用虚拟机+SSH安装+UEFI，SSH方便复制命令
二.安装 1.键盘布局,默认为us，不需要更改 2.验证引导模式 ls /sys/firmware/efi/efivars 结果无错误切有目录则是UEFI，反之是BIOS引导
3.连接网络 ip link 用 ping 检查网络连接
ping archlinux.org 4.更新系统时间 timedatectl set-ntp true 可用 timedatectl status 检查服务状态
5.建立硬盘分区 cfdisk比fdisk配置简单许多，因此本文采用cfdisk
cfdisk -l cfdisk UEFI采用GPT分区，一般情况下需要创建
挂载点 分区 分区类型 建议大小 /mnt/boot 或 /mnt/efi /dev/efi_system_partition（efi 系统分区） EFI 系统分区 至少 260 MiB [SWAP] /dev/swap_partition（交换空间分区） Linux swap (交换空间) 大于 512 MiB /mnt /dev/root_partition（根分区） Linux x86-64 根目录 (/) 剩余空间 文件系统 创建命令 工具 Archiso [1] 内核文档 [2] 说明 Btrfs mkfs.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;线程池</title>
      <link>https://okokfun.github.io/post/c&#43;&#43;/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Fri, 24 Dec 2021 17:01:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/c&#43;&#43;/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>C++线程池 任务类 #pragma once #include &amp;lt;mutex&amp;gt; #include &amp;lt;queue&amp;gt; // 定义任务结构体 using callback = void (*)(void *); struct Task { Task() { this-&amp;gt;function = nullptr; this-&amp;gt;arg = nullptr; } Task(callback f, void *arg) { this-&amp;gt;function = f; this-&amp;gt;arg = arg; } callback function; void *arg; }; class TaskQueue { public: TaskQueue(); ~TaskQueue(); // 添加任务 void addTask(Task task); void addTask(callback f, void *arg); // 取出一个任务 Task getTask(); // 判断队列任务是否为空 inline bool empty() { return m_taskQ.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://okokfun.github.io/post/%E4%BB%8E%E8%B4%A2%E6%94%BF%E6%94%AF%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9C%8B%E4%B8%AD%E5%9B%BD%E6%94%BF%E5%BA%9C%E7%9A%84%E6%B2%BB%E5%9B%BD%E9%80%BB%E8%BE%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E4%BB%8E%E8%B4%A2%E6%94%BF%E6%94%AF%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9C%8B%E4%B8%AD%E5%9B%BD%E6%94%BF%E5%BA%9C%E7%9A%84%E6%B2%BB%E5%9B%BD%E9%80%BB%E8%BE%91/</guid>
      <description>看了前面那集 &amp;laquo;苛税猛如虎&amp;raquo; 的观众们, 毫无疑问都明白了一条: 中国政府, 是全世界最有钱的祝福, 它可以从全社会的总裁浮肿抽走近五成的资金 注意, 是净现金, 然后大手大脚的花出去, 没有丝毫的顾虑. 现在, 我们需要追问下一个问题: 财政的钱都花到哪里去了? 好吧, 财政支出主要分两个方向: 公共预算支出, 以及政府性基金支出 我们先来看政府性基金支出, 直接给结论, 这一块的指出严重不透明</description>
    </item>
    
  </channel>
</rss>
