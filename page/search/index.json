[{"content":"STM32为意法半导体生产的32位微控制器\n$$ AveP = \\int_0^1 p(r) dr $$\n#incldue \u0026lt;iostream\u0026gt; int main(void) ｛ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; ｝ ","date":"2023-07-22T17:45:15+08:00","permalink":"https://okokfun.github.io/post/stm32/","title":"Myfirst"},{"content":"","date":"2023-07-21T22:33:48Z","permalink":"https://okokfun.github.io/post/12-7pmosnmos%E5%92%8Ce2cmos/","title":"12.7PMOS、NMOS和E2CMOS"},{"content":"","date":"2023-07-21T22:33:24Z","permalink":"https://okokfun.github.io/post/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/","title":"12.6发射极耦合逻辑-ECL电路"},{"content":"","date":"2023-07-21T22:33:03Z","permalink":"https://okokfun.github.io/post/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/","title":"12.5CMOS和TTL性能的比较"},{"content":"","date":"2023-07-21T22:32:51Z","permalink":"https://okokfun.github.io/post/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"12.4TTL在实际使用中的注意事项"},{"content":"","date":"2023-07-21T22:32:37Z","permalink":"https://okokfun.github.io/post/12-3ttl%E7%94%B5%E8%B7%AF/","title":"12.3TTL电路"},{"content":"","date":"2023-07-21T22:32:24Z","permalink":"https://okokfun.github.io/post/12-2cmos%E7%94%B5%E8%B7%AF/","title":"12.2CMOS电路"},{"content":"","date":"2023-07-21T22:32:11Z","permalink":"https://okokfun.github.io/post/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/","title":"12.1基本操作特性和参数"},{"content":"","date":"2023-07-21T22:31:50Z","permalink":"https://okokfun.github.io/post/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/","title":"11.4数字信号处理基础"},{"content":"","date":"2023-07-21T22:31:38Z","permalink":"https://okokfun.github.io/post/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"11.3数—模转换方法"},{"content":"","date":"2023-07-21T22:31:23Z","permalink":"https://okokfun.github.io/post/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"11.2模—数转换方法"},{"content":"","date":"2023-07-21T22:31:03Z","permalink":"https://okokfun.github.io/post/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/","title":"11.1模拟信号转换为数字信号"},{"content":"","date":"2023-07-21T22:30:48Z","permalink":"https://okokfun.github.io/post/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/","title":"10.8磁和光存储"},{"content":"","date":"2023-07-21T22:30:36Z","permalink":"https://okokfun.github.io/post/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/","title":"10.7特殊类型的存储器"},{"content":"","date":"2023-07-21T22:30:22Z","permalink":"https://okokfun.github.io/post/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/","title":"10.6存储器扩展"},{"content":"","date":"2023-07-21T22:30:03Z","permalink":"https://okokfun.github.io/post/10-5%E9%97%AA%E5%AD%98/","title":"10.5闪存"},{"content":"","date":"2023-07-21T22:29:20Z","permalink":"https://okokfun.github.io/post/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/","title":"10.4可编程ROM[PROM和EPROM]"},{"content":"","date":"2023-07-21T22:28:49Z","permalink":"https://okokfun.github.io/post/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/","title":"10.3只读存储器-ROM"},{"content":"","date":"2023-07-21T22:28:08Z","permalink":"https://okokfun.github.io/post/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/","title":"10.2随机存储器-RAM"},{"content":"","date":"2023-07-21T22:27:20Z","permalink":"https://okokfun.github.io/post/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/","title":"10.1半导体存储器基础"},{"content":"","date":"2023-07-21T22:27:02Z","permalink":"https://okokfun.github.io/post/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/","title":"9.9关联标注的逻辑符号"},{"content":"","date":"2023-07-21T22:26:51Z","permalink":"https://okokfun.github.io/post/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/","title":"9.8移位寄存器应用"},{"content":"","date":"2023-07-21T22:26:39Z","permalink":"https://okokfun.github.io/post/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"9.7移位寄存器计数器"},{"content":"","date":"2023-07-21T22:26:26Z","permalink":"https://okokfun.github.io/post/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.6双向移位寄存器"},{"content":"","date":"2023-07-21T22:26:11Z","permalink":"https://okokfun.github.io/post/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.5并行输入/并行输出移位寄存器"},{"content":"","date":"2023-07-21T22:25:20Z","permalink":"https://okokfun.github.io/post/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.4并行输入/串行输出移位寄存器"},{"content":"","date":"2023-07-21T22:25:06Z","permalink":"https://okokfun.github.io/post/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.3串行输入/并行输出移位寄存器"},{"content":"","date":"2023-07-21T22:24:45Z","permalink":"https://okokfun.github.io/post/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.2串行输入/串行输出移位寄存器"},{"content":"","date":"2023-07-21T22:24:31Z","permalink":"https://okokfun.github.io/post/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/","title":"9.1基本移位寄存器的功能"},{"content":"","date":"2023-07-21T22:24:12Z","permalink":"https://okokfun.github.io/post/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/","title":"8.8关联标注的逻辑符号"},{"content":"","date":"2023-07-21T22:23:59Z","permalink":"https://okokfun.github.io/post/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/","title":"8.7计数器应用"},{"content":"","date":"2023-07-21T22:23:32Z","permalink":"https://okokfun.github.io/post/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/","title":"8.6计数器译码"},{"content":"","date":"2023-07-21T22:23:18Z","permalink":"https://okokfun.github.io/post/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"8.5级联计数器"},{"content":"","date":"2023-07-21T22:22:10Z","permalink":"https://okokfun.github.io/post/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"8.4同步计数器的设计"},{"content":"","date":"2023-07-21T22:21:58Z","permalink":"https://okokfun.github.io/post/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"8.3加/减同步计数器"},{"content":"","date":"2023-07-21T22:21:47Z","permalink":"https://okokfun.github.io/post/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/","title":"8.2同步计数器运算"},{"content":"","date":"2023-07-21T22:21:29Z","permalink":"https://okokfun.github.io/post/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/","title":"8.1异步计数器运算"},{"content":"","date":"2023-07-21T22:21:11Z","permalink":"https://okokfun.github.io/post/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"7.6非稳态多谐振荡器"},{"content":"","date":"2023-07-21T22:20:48Z","permalink":"https://okokfun.github.io/post/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"7.5单稳态触发器"},{"content":"","date":"2023-07-21T22:20:19Z","permalink":"https://okokfun.github.io/post/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/","title":"7.4触发器应用"},{"content":"","date":"2023-07-21T22:20:05Z","permalink":"https://okokfun.github.io/post/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/","title":"7.3触发器运算特性"},{"content":"","date":"2023-07-21T22:19:46Z","permalink":"https://okokfun.github.io/post/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"7.2边沿触发器"},{"content":"","date":"2023-07-21T22:19:28Z","permalink":"https://okokfun.github.io/post/7-1%E9%94%81%E5%AD%98%E5%99%A8/","title":"7.1锁存器"},{"content":"","date":"2023-07-21T22:18:55Z","permalink":"https://okokfun.github.io/post/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/","title":"6.10奇偶发生器/校验器"},{"content":"","date":"2023-07-21T22:18:40Z","permalink":"https://okokfun.github.io/post/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/","title":"6.9多路分配器"},{"content":"","date":"2023-07-21T22:18:25Z","permalink":"https://okokfun.github.io/post/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/","title":"6.8多路复用器-数据选择器"},{"content":"","date":"2023-07-21T22:17:58Z","permalink":"https://okokfun.github.io/post/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"6.7代码转换器"},{"content":"","date":"2023-07-21T22:17:47Z","permalink":"https://okokfun.github.io/post/6-6%E7%BC%96%E7%A0%81%E5%99%A8/","title":"6.6编码器"},{"content":"","date":"2023-07-21T22:17:28Z","permalink":"https://okokfun.github.io/post/6-5%E8%AF%91%E7%A0%81%E5%99%A8/","title":"6.5译码器"},{"content":"","date":"2023-07-21T22:17:11Z","permalink":"https://okokfun.github.io/post/6-4%E6%AF%94%E8%BE%83%E5%99%A8/","title":"6.4比较器"},{"content":"","date":"2023-07-21T22:16:29Z","permalink":"https://okokfun.github.io/post/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.3异步进位与超前进位加法器"},{"content":"","date":"2023-07-21T22:16:12Z","permalink":"https://okokfun.github.io/post/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.2并行二进制加法器"},{"content":"","date":"2023-07-21T22:15:49Z","permalink":"https://okokfun.github.io/post/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.1基本加法器"},{"content":"","date":"2023-07-21T22:15:09Z","permalink":"https://okokfun.github.io/post/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/","title":"5.5具有脉冲波形输入的逻辑电路运算"},{"content":"","date":"2023-07-21T22:14:40Z","permalink":"https://okokfun.github.io/post/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/","title":"5.4使用与非门和或非门的组合逻辑"},{"content":"","date":"2023-07-21T22:14:23Z","permalink":"https://okokfun.github.io/post/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/","title":"5.3与非门和或非门的通用特性"},{"content":"","date":"2023-07-21T22:14:09Z","permalink":"https://okokfun.github.io/post/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"5.2组合逻辑电路的实现"},{"content":"","date":"2023-07-21T22:13:52Z","permalink":"https://okokfun.github.io/post/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","title":"5.1基本组合逻辑电路"},{"content":"","date":"2023-07-14T19:07:46Z","permalink":"https://okokfun.github.io/post/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/","title":"4.10:5变量的卡诺图"},{"content":"","date":"2023-07-14T19:07:32Z","permalink":"https://okokfun.github.io/post/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/","title":"4.9卡诺图乘积项之和的最小化"},{"content":"","date":"2023-07-14T19:06:40Z","permalink":"https://okokfun.github.io/post/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/","title":"4.8卡诺图"},{"content":"","date":"2023-07-14T19:06:31Z","permalink":"https://okokfun.github.io/post/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/","title":"4.7布尔表达式和真值表"},{"content":"","date":"2023-07-14T19:06:22Z","permalink":"https://okokfun.github.io/post/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/","title":"4.6布尔表达式的标准形式"},{"content":"","date":"2023-07-14T19:06:12Z","permalink":"https://okokfun.github.io/post/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/","title":"4.5使用布尔代数进行化简"},{"content":"","date":"2023-07-14T19:05:51Z","permalink":"https://okokfun.github.io/post/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/","title":"4.4逻辑电路的布尔分析"},{"content":"","date":"2023-07-14T19:05:42Z","permalink":"https://okokfun.github.io/post/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/","title":"4.3狄摩根定理"},{"content":"","date":"2023-07-14T19:05:32Z","permalink":"https://okokfun.github.io/post/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/","title":"4.2布尔代数的定律和法则"},{"content":"","date":"2023-07-14T19:05:21Z","permalink":"https://okokfun.github.io/post/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"4.1布尔运算和表达式"},{"content":"","date":"2023-07-14T19:05:11Z","permalink":"https://okokfun.github.io/post/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/","title":"3.7固定功能逻辑"},{"content":"","date":"2023-07-14T19:05:01Z","permalink":"https://okokfun.github.io/post/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/","title":"3.6异或门和同或门"},{"content":"","date":"2023-07-14T19:04:51Z","permalink":"https://okokfun.github.io/post/3-5%E6%88%96%E9%9D%9E%E9%97%A8/","title":"3.5或非门"},{"content":"","date":"2023-07-14T19:04:42Z","permalink":"https://okokfun.github.io/post/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/","title":"3.4与非门"},{"content":"","date":"2023-07-14T19:04:34Z","permalink":"https://okokfun.github.io/post/3-3%E6%88%96%E9%97%A8/","title":"3.3或门"},{"content":"","date":"2023-07-14T19:04:25Z","permalink":"https://okokfun.github.io/post/3-2%E4%B8%8E%E9%97%A8/","title":"3.2与门"},{"content":"","date":"2023-07-14T19:04:15Z","permalink":"https://okokfun.github.io/post/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/","title":"3.1反相器"},{"content":"","date":"2023-07-14T19:03:59Z","permalink":"https://okokfun.github.io/post/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/","title":"2.12错误检测码"},{"content":"","date":"2023-07-14T19:03:50Z","permalink":"https://okokfun.github.io/post/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/","title":"2.11数字编码"},{"content":"","date":"2023-07-14T19:03:37Z","permalink":"https://okokfun.github.io/post/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/","title":"2.10二—十进制编码-BCD"},{"content":"","date":"2023-07-14T19:03:11Z","permalink":"https://okokfun.github.io/post/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.9八进制数"},{"content":"","date":"2023-07-14T19:03:03Z","permalink":"https://okokfun.github.io/post/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.8十六进制数"},{"content":"","date":"2023-07-14T19:02:52Z","permalink":"https://okokfun.github.io/post/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/","title":"2.7带符号数的算术运算"},{"content":"","date":"2023-07-14T19:02:43Z","permalink":"https://okokfun.github.io/post/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/","title":"2.6带符号数"},{"content":"","date":"2023-07-14T19:02:15Z","permalink":"https://okokfun.github.io/post/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/","title":"2.5二进制数的反码和补码"},{"content":"","date":"2023-07-14T19:02:06Z","permalink":"https://okokfun.github.io/post/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/","title":"2.4二进制算术"},{"content":"","date":"2023-07-14T19:01:56Z","permalink":"https://okokfun.github.io/post/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/","title":"2.3十进制数到二进制数的转换"},{"content":"","date":"2023-07-14T19:01:45Z","permalink":"https://okokfun.github.io/post/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.2二进制数"},{"content":"","date":"2023-07-14T19:01:36Z","permalink":"https://okokfun.github.io/post/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.1十进制数"},{"content":"","date":"2023-07-14T19:01:23Z","permalink":"https://okokfun.github.io/post/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/","title":"1.3固定功能的集成电路"},{"content":"","date":"2023-07-14T19:01:12Z","permalink":"https://okokfun.github.io/post/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/","title":"1.2二进制数、逻辑电平和数字波形"},{"content":"","date":"2023-07-14T18:57:32Z","permalink":"https://okokfun.github.io/post/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/","title":"1.1数字量与模拟量"},{"content":"","date":"2023-07-14T18:30:27Z","permalink":"https://okokfun.github.io/post/15-5%E5%8A%9F%E7%8E%87%E6%8E%A7%E5%88%B6/","title":"15.5功率控制"},{"content":"","date":"2023-07-14T18:30:17Z","permalink":"https://okokfun.github.io/post/15-4%E5%BA%94%E5%8F%98%E6%B5%8B%E9%87%8F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E9%87%8F%E5%92%8C%E8%BF%90%E5%8A%A8%E6%B5%8B%E9%87%8F/","title":"15.4应变测量、压力测量和运动测量"},{"content":"","date":"2023-07-14T18:30:08Z","permalink":"https://okokfun.github.io/post/15-3%E6%B8%A9%E5%BA%A6%E6%B5%8B%E9%87%8F/","title":"15.3温度测量"},{"content":"","date":"2023-07-14T18:30:00Z","permalink":"https://okokfun.github.io/post/15-2%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/","title":"15.2角度测量"},{"content":"","date":"2023-07-14T18:29:51Z","permalink":"https://okokfun.github.io/post/15-1rms-dc%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"15.1RMS-DC转换器"},{"content":"","date":"2023-07-14T18:29:41Z","permalink":"https://okokfun.github.io/post/14-8%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"14.8故障检测"},{"content":"","date":"2023-07-14T18:29:31Z","permalink":"https://okokfun.github.io/post/14-7v-f%E5%92%8Cf-v%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"14.7V/F和F/V转换器"},{"content":"","date":"2023-07-14T18:29:21Z","permalink":"https://okokfun.github.io/post/14-6a-d%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"14.6A/D转换方法"},{"content":"","date":"2023-07-14T18:26:29Z","permalink":"https://okokfun.github.io/post/14-5a-d%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"14.5A/D转换的基本概念"},{"content":"","date":"2023-07-14T18:26:19Z","permalink":"https://okokfun.github.io/post/14-4d-a%E8%BD%AC%E6%8D%A2/","title":"14.4D/A转换"},{"content":"","date":"2023-07-14T18:26:07Z","permalink":"https://okokfun.github.io/post/14-3%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%95%B0%E5%AD%97%E6%8E%A5%E5%8F%A3/","title":"14.3模拟和数字接口"},{"content":"","date":"2023-07-14T18:25:55Z","permalink":"https://okokfun.github.io/post/14-2%E9%87%87%E6%A0%B7%E4%BF%9D%E6%8C%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"14.2采样保持放大器"},{"content":"","date":"2023-07-14T18:25:46Z","permalink":"https://okokfun.github.io/post/14-1%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/","title":"14.1模拟开关"},{"content":"","date":"2023-07-14T18:25:37Z","permalink":"https://okokfun.github.io/post/13-9%E5%85%89%E7%BA%A4/","title":"13.9光纤"},{"content":"","date":"2023-07-14T18:25:29Z","permalink":"https://okokfun.github.io/post/13-8pll/","title":"13.8PLL"},{"content":"","date":"2023-07-14T18:25:21Z","permalink":"https://okokfun.github.io/post/13-7%E9%A2%91%E7%8E%87%E8%B0%83%E5%88%B6/","title":"13.7频率调制"},{"content":"","date":"2023-07-14T18:25:11Z","permalink":"https://okokfun.github.io/post/13-6if%E5%92%8C%E9%9F%B3%E9%A2%91%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"13.6IF和音频放大器"},{"content":"","date":"2023-07-14T18:25:02Z","permalink":"https://okokfun.github.io/post/13-5am%E8%A7%A3%E8%B0%83/","title":"13.5AM解调"},{"content":"","date":"2023-07-14T18:24:53Z","permalink":"https://okokfun.github.io/post/13-4%E6%B7%B7%E9%A2%91%E5%99%A8/","title":"13.4混频器"},{"content":"","date":"2023-07-14T18:24:46Z","permalink":"https://okokfun.github.io/post/13-3%E5%B9%85%E5%BA%A6%E8%B0%83%E5%88%B6/","title":"13.3幅度调制"},{"content":"","date":"2023-07-14T18:24:36Z","permalink":"https://okokfun.github.io/post/13-2%E7%BA%BF%E6%80%A7%E4%B9%98%E6%B3%95%E5%99%A8/","title":"13.2线性乘法器"},{"content":"","date":"2023-07-14T18:24:26Z","permalink":"https://okokfun.github.io/post/13-1%E5%9F%BA%E6%9C%AC%E6%8E%A5%E6%94%B6%E6%9C%BA/","title":"13.1基本接收机"},{"content":"","date":"2023-07-14T18:24:08Z","permalink":"https://okokfun.github.io/post/12-4%E5%AF%B9%E6%95%B0%E5%92%8C%E5%8F%8D%E5%AF%B9%E6%95%B0%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.4对数和反对数放大器"},{"content":"","date":"2023-07-14T18:23:57Z","permalink":"https://okokfun.github.io/post/12-3ota/","title":"12.3OTA"},{"content":"","date":"2023-07-14T18:23:47Z","permalink":"https://okokfun.github.io/post/12-2%E9%9A%94%E7%A6%BB%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.2隔离放大器"},{"content":"","date":"2023-07-14T18:23:37Z","permalink":"https://okokfun.github.io/post/12-1%E4%BB%AA%E8%A1%A8%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.1仪表放大器"},{"content":"","date":"2023-07-14T18:23:23Z","permalink":"https://okokfun.github.io/post/11-6ic%E7%A8%B3%E5%8E%8B%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/","title":"11.6IC稳压器的应用"},{"content":"","date":"2023-07-14T18:23:13Z","permalink":"https://okokfun.github.io/post/11-5ic%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.5IC稳压器"},{"content":"","date":"2023-07-14T18:23:03Z","permalink":"https://okokfun.github.io/post/11-4%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.4基本开关稳压器"},{"content":"","date":"2023-07-14T18:22:54Z","permalink":"https://okokfun.github.io/post/11-3%E5%9F%BA%E6%9C%AC%E5%B9%B6%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.3基本并联稳压器"},{"content":"","date":"2023-07-14T18:22:44Z","permalink":"https://okokfun.github.io/post/11-2%E5%9F%BA%E6%9C%AC%E4%B8%B2%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.2基本串联稳压器"},{"content":"","date":"2023-07-14T18:22:34Z","permalink":"https://okokfun.github.io/post/11-1%E7%A8%B3%E5%8E%8B/","title":"11.1稳压"},{"content":"","date":"2023-07-14T18:21:32Z","permalink":"https://okokfun.github.io/post/10-7555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"10.7 555定时器作为单稳态触发器"},{"content":"","date":"2023-07-14T18:21:22Z","permalink":"https://okokfun.github.io/post/10-6555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.6 555定时器作为振荡器"},{"content":"","date":"2023-07-14T18:21:12Z","permalink":"https://okokfun.github.io/post/10-5%E5%BC%9B%E8%B1%AB%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/","title":"10.5弛豫振荡器原理"},{"content":"","date":"2023-07-14T18:21:01Z","permalink":"https://okokfun.github.io/post/10-4%E5%85%B7%E6%9C%89lc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.4具有LC反馈电路的振荡器"},{"content":"","date":"2023-07-14T18:20:17Z","permalink":"https://okokfun.github.io/post/10-3%E5%85%B7%E6%9C%89rc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.3具有RC反馈电路的正弦波振荡器"},{"content":"","date":"2023-07-14T18:20:06Z","permalink":"https://okokfun.github.io/post/10-2%E5%8F%8D%E9%A6%88%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/","title":"10.2反馈振荡器原理"},{"content":"","date":"2023-07-14T18:19:51Z","permalink":"https://okokfun.github.io/post/10-1%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.1振荡器"},{"content":"","date":"2023-07-14T18:19:41Z","permalink":"https://okokfun.github.io/post/9-7%E6%B5%8B%E9%87%8F%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/","title":"9.7测量滤波器响应"},{"content":"","date":"2023-07-14T18:19:29Z","permalink":"https://okokfun.github.io/post/9-6%E6%9C%89%E6%BA%90%E5%B8%A6%E9%98%BB%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.6有源带阻滤波器"},{"content":"","date":"2023-07-14T18:19:18Z","permalink":"https://okokfun.github.io/post/9-5%E6%9C%89%E6%BA%90%E5%B8%A6%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.5有源带通滤波器"},{"content":"","date":"2023-07-14T18:19:08Z","permalink":"https://okokfun.github.io/post/9-4%E6%9C%89%E6%BA%90%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.4有源高通滤波器"},{"content":"","date":"2023-07-14T18:18:56Z","permalink":"https://okokfun.github.io/post/9-3%E6%9C%89%E6%BA%90%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.3有源低通滤波器"},{"content":"","date":"2023-07-14T18:18:30Z","permalink":"https://okokfun.github.io/post/9-2%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7/","title":"9.2滤波器的响应特性"},{"content":"","date":"2023-07-14T18:18:20Z","permalink":"https://okokfun.github.io/post/9-1%E5%9F%BA%E6%9C%AC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/","title":"9.1基本滤波器响应"},{"content":"","date":"2023-07-14T18:18:03Z","permalink":"https://okokfun.github.io/post/8-5%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"8.5故障检测"},{"content":"","date":"2023-07-14T18:17:53Z","permalink":"https://okokfun.github.io/post/8-4%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%94%B5%E8%B7%AF/","title":"8.4转换器和其他运算放大器电路"},{"content":"","date":"2023-07-14T18:17:37Z","permalink":"https://okokfun.github.io/post/8-3%E7%A7%AF%E5%88%86%E5%99%A8%E5%92%8C%E5%BE%AE%E5%88%86%E5%99%A8/","title":"8.3积分器和微分器"},{"content":"","date":"2023-07-14T18:17:24Z","permalink":"https://okokfun.github.io/post/8-2%E6%B1%82%E5%92%8C%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"8.2求和放大器"},{"content":"","date":"2023-07-14T18:17:13Z","permalink":"https://okokfun.github.io/post/8-1%E6%AF%94%E8%BE%83%E5%99%A8/","title":"8.1比较器"},{"content":"","date":"2023-07-14T18:16:59Z","permalink":"https://okokfun.github.io/post/7-5%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E8%A1%A5%E5%81%BF/","title":"7.5运算放大器的补偿"},{"content":"","date":"2023-07-14T18:16:45Z","permalink":"https://okokfun.github.io/post/7-4%E6%AD%A3%E5%8F%8D%E9%A6%88%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/","title":"7.4正反馈和稳定性"},{"content":"","date":"2023-07-14T18:16:34Z","permalink":"https://okokfun.github.io/post/7-3%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E9%97%AD%E7%8E%AF%E5%93%8D%E5%BA%94/","title":"7.3运算放大器闭环响应"},{"content":"","date":"2023-07-14T18:16:21Z","permalink":"https://okokfun.github.io/post/7-2%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%BC%80%E7%8E%AF%E5%93%8D%E5%BA%94/","title":"7.2运算放大器开环响应"},{"content":"","date":"2023-07-14T18:16:09Z","permalink":"https://okokfun.github.io/post/7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"7.1基本概念"},{"content":"","date":"2023-07-14T18:15:54Z","permalink":"https://okokfun.github.io/post/6-7%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"6.7故障检测"},{"content":"","date":"2023-07-14T18:15:40Z","permalink":"https://okokfun.github.io/post/6-6%E8%BF%90%E6%94%BE%E9%98%BB%E6%8A%97%E5%92%8C%E5%99%AA%E5%A3%B0/","title":"6.6运放阻抗和噪声"},{"content":"","date":"2023-07-14T18:15:27Z","permalink":"https://okokfun.github.io/post/6-5%E8%B4%9F%E5%8F%8D%E9%A6%88%E8%BF%90%E6%94%BE%E7%BB%84%E6%80%81/","title":"6.5负反馈运放组态"},{"content":"","date":"2023-07-14T18:15:17Z","permalink":"https://okokfun.github.io/post/6-4%E8%B4%9F%E5%8F%8D%E9%A6%88/","title":"6.4负反馈"},{"content":"","date":"2023-07-14T17:41:00Z","permalink":"https://okokfun.github.io/post/6-3%E8%BF%90%E6%94%BE%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/","title":"6.3运放数据手册中的参数"},{"content":"","date":"2023-07-14T17:40:49Z","permalink":"https://okokfun.github.io/post/6-2%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"6.2差分放大器"},{"content":"","date":"2023-07-14T17:40:35Z","permalink":"https://okokfun.github.io/post/6-1%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E4%BB%8B%E7%BB%8D/","title":"6.1运算放大器介绍"},{"content":"","date":"2023-07-14T17:40:23Z","permalink":"https://okokfun.github.io/post/5-8ic%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.8IC功率放大器"},{"content":"","date":"2023-07-14T17:40:12Z","permalink":"https://okokfun.github.io/post/5-7c%E7%B1%BB%E5%92%8Cd%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.7C类和D类功率放大器"},{"content":"","date":"2023-07-14T17:39:59Z","permalink":"https://okokfun.github.io/post/5-6b%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.6B类功率放大器"},{"content":"","date":"2023-07-14T17:39:41Z","permalink":"https://okokfun.github.io/post/5-5a%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.5A类功率放大器"},{"content":"","date":"2023-07-14T17:39:25Z","permalink":"https://okokfun.github.io/post/5-4%E7%9B%B4%E6%8E%A5%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.4直接耦合放大器"},{"content":"","date":"2023-07-14T17:39:11Z","permalink":"https://okokfun.github.io/post/5-3%E5%8F%98%E5%8E%8B%E5%99%A8%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.3变压器耦合放大器"},{"content":"","date":"2023-07-14T17:38:59Z","permalink":"https://okokfun.github.io/post/5-2rf%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.2RF放大器"},{"content":"","date":"2023-07-14T17:38:49Z","permalink":"https://okokfun.github.io/post/5-1%E7%94%B5%E5%AE%B9%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.1电容耦合放大器"},{"content":"","date":"2023-07-14T17:38:35Z","permalink":"https://okokfun.github.io/post/4-8%E7%B3%BB%E7%BB%9F/","title":"4.8系统"},{"content":"","date":"2023-07-14T17:38:25Z","permalink":"https://okokfun.github.io/post/4-7mosfet%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF/","title":"4.7MOSFET开关电路"},{"content":"","date":"2023-07-14T17:38:15Z","permalink":"https://okokfun.github.io/post/4-6fet%E7%BA%BF%E6%80%A7%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"4.6FET线性放大器"},{"content":"","date":"2023-07-14T17:38:02Z","permalink":"https://okokfun.github.io/post/4-5mosfet%E5%81%8F%E7%BD%AE/","title":"4.5MOSFET偏置"},{"content":"","date":"2023-07-14T17:37:50Z","permalink":"https://okokfun.github.io/post/4-4mosfet%E7%89%B9%E6%80%A7/","title":"4.4MOSFET特性"},{"content":"","date":"2023-07-14T17:37:37Z","permalink":"https://okokfun.github.io/post/4-3jfet%E5%81%8F%E7%BD%AE/","title":"4.3JFET偏置"},{"content":"","date":"2023-07-14T17:37:26Z","permalink":"https://okokfun.github.io/post/4-2jfet%E7%89%B9%E6%80%A7/","title":"4.2JFET特性"},{"content":"","date":"2023-07-14T17:37:12Z","permalink":"https://okokfun.github.io/post/4-1fet%E7%9A%84%E7%BB%93%E6%9E%84/","title":"4.1FET的结构"},{"content":"","date":"2023-07-14T17:36:42Z","permalink":"https://okokfun.github.io/post/3-9%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"3.9故障检测"},{"content":"","date":"2023-07-14T17:36:30Z","permalink":"https://okokfun.github.io/post/3-8%E6%99%B6%E4%BD%93%E7%AE%A1%E5%B0%81%E8%A3%85%E5%8F%8A%E7%AB%AF%E5%8F%A3/","title":"3.8晶体管封装及端口"},{"content":"","date":"2023-07-14T17:36:19Z","permalink":"https://okokfun.github.io/post/3-7%E5%BC%80%E5%85%B3%E5%9E%8B%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/","title":"3.7开关型双极型晶体管"},{"content":"","date":"2023-07-14T17:36:07Z","permalink":"https://okokfun.github.io/post/3-6%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.6共基极放大器"},{"content":"","date":"2023-07-14T17:35:56Z","permalink":"https://okokfun.github.io/post/3-5%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.5共集电极放大器"},{"content":"","date":"2023-07-14T17:35:43Z","permalink":"https://okokfun.github.io/post/3-4%E5%85%B1%E5%8F%91%E5%B0%84%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.4共发射极放大器"},{"content":"","date":"2023-07-14T17:35:32Z","permalink":"https://okokfun.github.io/post/3-3%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E4%BA%A4%E6%B5%81%E5%88%86%E6%9E%90/","title":"3.3数据手册中的参数及交流分析"},{"content":"","date":"2023-07-14T17:35:19Z","permalink":"https://okokfun.github.io/post/3-2bjt%E5%81%8F%E7%BD%AE%E7%94%B5%E8%B7%AF/","title":"3.2BJT偏置电路"},{"content":"","date":"2023-07-14T17:35:07Z","permalink":"https://okokfun.github.io/post/3-1bjt%E7%9A%84%E7%BB%93%E6%9E%84/","title":"3.1BJT的结构"},{"content":"","date":"2023-07-14T15:07:06Z","permalink":"https://okokfun.github.io/post/2-10%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"2.10故障检测"},{"content":"","date":"2023-07-14T15:06:51Z","permalink":"https://okokfun.github.io/post/2-9%E4%BA%8C%E6%9E%81%E7%AE%A1%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C/","title":"2.9二极管数据手册"},{"content":"","date":"2023-07-14T15:06:29Z","permalink":"https://okokfun.github.io/post/2-8%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E4%BA%8C%E6%9E%81%E7%AE%A1/","title":"2.8特殊用途二极管"},{"content":"","date":"2023-07-14T15:06:10Z","permalink":"https://okokfun.github.io/post/2-7%E4%BA%8C%E6%9E%81%E7%AE%A1%E9%99%90%E5%B9%85%E7%94%B5%E8%B7%AF%E5%92%8C%E9%92%B3%E4%BD%8D%E7%94%B5%E8%B7%AF/","title":"2.7二极管限幅电路和钳位电路"},{"content":"","date":"2023-07-14T15:05:51Z","permalink":"https://okokfun.github.io/post/2-6%E6%95%B4%E6%B5%81%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%92%8Cic%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"2.6整流滤波器和IC稳压器"},{"content":"","date":"2023-07-14T15:05:29Z","permalink":"https://okokfun.github.io/post/2-5%E6%95%B4%E6%B5%81%E5%99%A8/","title":"2.5整流器"},{"content":"","date":"2023-07-14T15:05:04Z","permalink":"https://okokfun.github.io/post/2-4%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%89%B9%E6%80%A7/","title":"2.4二极管特性"},{"content":"","date":"2023-07-14T15:04:21Z","permalink":"https://okokfun.github.io/post/2-3%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%81%8F%E7%BD%AE/","title":"2.3半导体二极管的偏置"},{"content":"","date":"2023-07-14T15:03:21Z","permalink":"https://okokfun.github.io/post/2-2pn%E7%BB%93/","title":"2.2pn结"},{"content":"","date":"2023-07-14T15:01:04Z","permalink":"https://okokfun.github.io/post/2-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84/","title":"2.1半导体原子结构"},{"content":"","date":"2023-07-14T14:59:05Z","permalink":"https://okokfun.github.io/post/1-5%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/","title":"1.5故障检测"},{"content":"","date":"2023-07-14T14:58:40Z","permalink":"https://okokfun.github.io/post/1-4%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"1.4放大器"},{"content":"","date":"2023-07-14T14:58:21Z","permalink":"https://okokfun.github.io/post/1-3%E4%BF%A1%E5%8F%B7%E6%BA%90/","title":"1.3信号源"},{"content":"","date":"2023-07-14T14:57:45Z","permalink":"https://okokfun.github.io/post/1-2%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/","title":"1.2模拟信号"},{"content":"1.1 模拟电子学 模拟信号: 我们测量到的自然现象的特性(比如,压力，流速和温度)都来源于模拟信号\n信号可分为有 二进制数字 表示的数字信号和有 连续变化量 表示的模拟信号\n模拟电子学包括所有其他(非数字)信号，它包括信号处理功能，比如放大,微分和集成等。\n1.1.1 线型方程 线型方程式:\n$$ y = mx + b $$\n式中，y是因变量，x自变量，m是斜率，b是y轴上的截距。 欧姆定理：\n$$ I=V/R $$\n电流(I)是因变量，自变量是电压(V),斜率是电阻的倒数(1/R), 也就是电导.欧姆定律可变化为：\n$$ I=GV $$\n特性曲线是能够反应一个器件两个变化特性之间关系的图\n","date":"2023-07-12T22:05:41Z","permalink":"https://okokfun.github.io/post/1-1%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E5%AD%A6/","title":"1.1模拟电子学"},{"content":" 第1章 基本概念 1.1 数字量与模拟量 1.2 二进制数、逻辑电平和数字波形 1.3 固定功能的集成电路 关键词 判断题 自测题 习题 答案\n第2章 数字系统、运算和编码 2.1 十进制数 2.2 二进制数 2.3 十进制数到二进制数的转换 2.4 二进制算术 2.5 二进制数的反码和补码 2.6 带符号数 2.7 带符号数的算术运算 2.8 十六进制数 2.9 八进制数 2.10 二—十进制编码(BCD) 2.11 数字编码 2.12 错误检测码 关键词 判断题 自测题 习题 答案\n第3章 逻辑门 3.1 反相器 3.2 与门 3.3 或门 3.4 与非门 3.5 或非门 3.6 异或门和同或门 3.7 固定功能逻辑 关键词 判断题 自测题 习题 答案\n第4章 布尔代数和逻辑化简 4.1 布尔运算和表达式 4.2 布尔代数的定律和法则 4.3 狄摩根定理 4.4 逻辑电路的布尔分析 4.5 使用布尔代数进行化简 4.6 布尔表达式的标准形式 4.7 布尔表达式和真值表 4.8 卡诺图 4.9 卡诺图乘积项之和的最小化 4.10 5变量的卡诺图 数字系统应用 关键词 判断题 自测题 习题 答案\n第5章 组合逻辑分析 5.1 基本组合逻辑电路 5.2 组合逻辑电路的实现 5.3 与非门和或非门的通用特性 5.4 使用与非门和或非门的组合逻辑 5.5 具有脉冲波形输入的逻辑电路运算 数字系统应用 关键词 判断题 自测题 习题 答案\n第6章 组合逻辑电路函数 6.1 基本加法器 6.2 并行二进制加法器 6.3 异步进位与超前进位加法器 6.4 比较器 6.5 译码器 6.6 编码器 6.7 代码转换器 6.8 多路复用器(数据选择器) 6.9 多路分配器 6.10 奇偶发生器/校验器 数字系统应用 关键词 判断题 自测题 习题 答案\n第7章 锁存器、 触发器和定时器 7.1 锁存器 7.2 边沿触发器 7.3 触发器运算特性 7.4 触发器应用 7.5 *稳态触发器 7.6 非稳态多谐振荡器 数字系统应用 关键词 判断题 自测题 习题 答案\n第8章 计数器 8.1 异步计数器运算 8.2 同步计数器运算 8.3 加/减同步计数器 8.4 同步计数器的设计 8.5 *联计数器 8.6 计数器译码 8.7 计数器应用 8.8 关联标注的逻辑符号 数字系统应用 关键词 判断题 自测题 习题 答案\n第9章 移位寄存器 9.1 基本移位寄存器的功能 9.2 串行输入/串行输出移位寄存器 9.3 串行输入/并行输出移位寄存器 9.4 并行输入/串行输出移位寄存器 9.5 并行输入/并行输出移位寄存器 9.6 双向移位寄存器 9.7 移位寄存器计数器 9.8 移位寄存器应用 9.9 关联标注的逻辑符号 数字系统应用 总结 关键词 判断题 自测题 习题 答案\n第10章 内存和外存 10.1 半导体存储器基础 10.2 随机存储器(RAM) 10.3 只读存储器(ROM) 10.4 可编程ROM(PROM和EPROM) 10.5 闪存 10.6 存储器扩展 10.7 特殊类型的存储器 10.8 磁和光存储 数字系统应用 关键词 判断题 自测题 习题 答案\n第11章 数字信号处理 11.1 模拟信号转换为数字信号 11.2 模—数转换方法 11.3 数—模转换方法 11.4 数字信号处理基础 关键词 判断题 自测题 习题 答案\n第12章 集成电路技术 12.1 基本操作特性和参数 12.2 CMOS电路 12.3 TTL电路 12.4 TTL在实际使用中的注意事项 12.5 CMOS和TTL性能的比较 12.6 发射极耦合逻辑(ECL)电路 12.7 PMOS、 NMOS和E2CMOS 关键词 判断题 自测题 习题 答案 附录A 卡诺图或与项(POS)的小化 附录B Q—M方法(奎恩—麦克拉斯基化简法) 附录C 数字电路NI Multisim仿真——仿真、 样机、 测试电路理论、 设计与画图 奇数编号题*\n","date":"2023-07-12T21:20:25Z","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/","title":"数字电子技术"},{"content":"出版者的话 译者序 前言 第1章 基本模拟概念 ##### 1.1 模拟电子学 ##### 1.2 模拟信号 ##### 1.3 信号源 ##### 1.4 放大器 ##### 1.5 故障检测\n第2章 二极管及其应用 ##### 2.1 半导体原子结构 ##### 2.2 pn结 ##### 2.3 半导体二极管的偏置 ##### 2.4 二极管特性 ##### 2.5 整流器 ##### 2.6 整流滤波器和IC稳压器 ##### 2.7 二极管限幅电路和钳位电路 ##### 2.8 特殊用途二极管 ##### 2.9 二极管数据手册 ##### 2.10 故障检测\n第3章 BJT ##### 3.1 BJT的结构 ##### 3.2 BJT偏置电路 ##### 3.3 数据手册中的参数及交流分析 ##### 3.4 共发射极放大器 ##### 3.5 共集电极放大器 ##### 3.6 共基极放大器 ##### 3.7 开关型双极型晶体管 ##### 3.8 晶体管封装及端口 ##### 3.9 故障检测\n第4章 FET ##### 4.1 FET的结构 ##### 4.2 JFET特性 ##### 4.3 JFET偏置 ##### 4.4 MOSFET特性 ##### 4.5 MOSFET偏置 ##### 4.6 FET线性放大器 ##### 4.7 MOSFET开关电路 ##### 4.8 系统\n第5章 多级放大器、RF放大器和功率放大器 ##### 5.1 电容耦合放大器 ##### 5.2 RF放大器 ##### 5.3 变压器耦合放大器 ##### 5.4 直接耦合放大器 ##### 5.5 A类功率放大器 ##### 5.6 B类功率放大器 ##### 5.7 C类和D类功率放大器 ##### 5.8 IC功率放大器\n第6章 运算放大器 ##### 6.1 运算放大器介绍 ##### 6.2 差分放大器 ##### 6.3 运放数据手册中的参数 ##### 6.4 负反馈 ##### 6.5 负反馈运放组态 ##### 6.6 运放阻抗和噪声 ##### 6.7 故障检测\n第7章 运算放大器响应 ##### 7.1 基本概念 ##### 7.2 运算放大器开环响应 ##### 7.3 运算放大器闭环响应 ##### 7.4 正反馈和稳定性 ##### 7.5 运算放大器的补偿\n第8章 基本运算放大器电路 ##### 8.1 比较器 ##### 8.2 求和放大器 ##### 8.3 积分器和微分器 ##### 8.4 转换器和其他运算放大器电路 ##### 8.5 故障检测\n第9章 有源滤波器 ##### 9.1 基本滤波器响应 ##### 9.2 滤波器的响应特性 ##### 9.3 有源低通滤波器 ##### 9.4 有源高通滤波器 ##### 9.5 有源带通滤波器 ##### 9.6 有源带阻滤波器 ##### 9.7 测量滤波器响应\n第10章 振荡器和定时器 ##### 10.1 振荡器 ##### 10.2 反馈振荡器原理 ##### 10.3 具有RC反馈电路的正弦波振荡器 ##### 10.4 具有LC反馈电路的振荡器 ##### 10.5 弛豫振荡器原理 ##### 10.6 555定时器作为振荡器 ##### 10.7 555定时器作为单稳态触发器\n第11章 稳压器 ##### 11.1 稳压 ##### 11.2 基本串联稳压器 ##### 11.3 基本并联稳压器 ##### 11.4 基本开关稳压器 ##### 11.5 IC稳压器 ##### 11.6 IC稳压器的应用\n第12章 特殊用途放大器 ##### 12.1 仪表放大器 ##### 12.2 隔离放大器 ##### 12.3 OTA ##### 12.4 对数和反对数放大器\n第13章 通信电路 ##### 13.1 基本接收机 ##### 13.2 线性乘法器 ##### 13.3 幅度调制 ##### 13.4 混频器 ##### 13.5 AM解调 ##### 13.6 IF和音频放大器 ##### 13.7 频率调制 ##### 13.8 PLL ##### 13.9 光纤\n第14章 数据转换 ##### 14.1 模拟开关 ##### 14.2 采样保持放大器 ##### 14.3 模拟和数字接口 ##### 14.4 D/A转换 ##### 14.5 A/D转换的基本概念 ##### 14.6 A/D转换方法 ##### 14.7 V/F和F/V转换器 ##### 14.8 故障检测\n第15章 测量和控制 ##### 15.1 RMS-DC转换器 ##### 15.2 角度测量 ##### 15.3 温度测量 ##### 15.4 应变测量、压力测量和运动测量 ##### 15.5 功率控制\n附录 部分公式的推导 奇数编号习题的答案 术语表 ","date":"2023-07-12T20:53:37Z","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","title":"模拟电子技术基础"},{"content":" 文件下载链接 https://github.com/txt1994/keil_plugs 本人收集的Keil插件，当然也可用于其他软件\n1.AStyle 下载链接:\nhttps://sourceforge.net/projects/astyle/files 1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令： -n !E --style=google -s4 对多个文件格式化，但需要在同一个文件夹，命令：\n-n \u0026#34;$E*.c\u0026#34; \u0026#34;$E*.h\u0026#34; --style=google -p -s4 -S -f -xW -w -xw -R 2.FileComments 2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令： !E 3.DateTime 3.1 DateTime可以识别当前日期和时间，用的不多，命令： 当前日期：\n!E ~E ^E 当前时间：\n!E ~E ^E T 4.FunctionComment 4.1 FunctionComment可以提供函数快速添加注释，命令： !E ~E 把这些插件添加到keil中，打开keil，依次点击Tools-\u0026gt;Customize Tools Menu,此时页面是这样的： 把上述的插件添加进去，Command是插件路径，Arguments是使用插件时的参数，可以根据需要自行定制\n添加插件的快捷键：点击keil页面的小扳手，找到Shortcut Keys,把下拉框拉到刚才添加的插件处，右边是添加快键键的地方，添加后可以使用了\n","date":"2023-07-11T13:55:45Z","permalink":"https://okokfun.github.io/post/keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/","title":"适用于Keil的插件合集"},{"content":"第三部分 新的标准库组件 本部分介绍了 C++17 的新库组件。\n15 std::optional\u0026lt;\u0026gt; 在编程中，我们经常遇到可能返回/传递/使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布尔成员/标志，表明一个值是否存在。 std::optional\u0026lt;\u0026gt; 以类型安全的方式提供此类对象。\n可选对象仅具有包含对象的内部存储器以及布尔标志。因此，大小通常比包含的对象大一个字节。对于某些包含的类型，甚至可能根本没有大小开销，前提是可以将附加信息放置在包含的对象中。没有分配堆内存。对象使用与包含类型相同的对齐方式。\n但是，可选对象不仅仅是将布尔标志的功能添加到值成员的结构。例如，如果没有值，则不会为包含的类型调用构造函数（因此，您可以为对象提供没有的默认状态）。\n与 std::variant\u0026lt;\u0026gt; 和 std::any 一样，结果对象具有值语义。也就是说，复制被实现为深度复制，创建一个独立的对象，带有标志和包含的值（如果有的话）在它自己的内存中。复制没有包含值的 std::optional\u0026lt;\u0026gt; 很便宜；复制带有包含值的 std::optional\u0026lt;\u0026gt; 与复制包含的类型/值一样便宜/昂贵。支持移动语义。\n15.1 使用 std::optional\u0026lt;\u0026gt; std::optional\u0026lt;\u0026gt;模型是一个任意类型的可忽略的实例。这个实例可能是一个成员，一个参数，或者一个返回值。你也可以说，std::optional\u0026lt;\u0026gt;是一个容纳零或一个元素的容器。\n15.1.1 可选的返回值 以下程序演示了 std::optional\u0026lt;\u0026gt; 用作返回值的能力： lib/optional.cpp\n#include \u0026lt;optional\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; // 如果可能，将字符串转换为 int: std::optional\u0026lt;int\u0026gt; asInt(const std::string\u0026amp; s) { try { return std::stoi(s); } catch (...) { return std::nullopt; } } int main() { for (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 如果可能，尝试将 s 转换为 int 并打印结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int\\n\u0026#34;; } } } 在程序中 asInt() 是将传递的字符串转换为整数的函数。 但是，这可能不会成功。 出于这个原因，使用了 std::optional\u0026lt;\u0026gt; 以便我们可以返回\u0026quot;no int\u0026quot;并避免为其定义一个特殊的 int 值或向调用者抛出异常。 因此，我们要么返回调用 stoi() 的结果，它用一个 int 初始化返回值，要么我们返回 std::nullopt，表明我们没有一个 int 值。 我们可以实现如下相同的行为：\nstd::optional\u0026lt;int\u0026gt; asInt(const std::string\u0026amp; s) { std::optional\u0026lt;int\u0026gt; ret; // 最初没有值 try { ret = std::stoi(s); } catch (...) { } return ret; } 在 main() 中，我们为不同的字符串调用此函数。\nfor (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 将 s 转换为 int 并尽可能使用结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); ... } 对于我们评估的每个返回的 std::optional oi，我们是否有一个值（通过将对象评估为布尔表达式）并通过“取消引用”可选对象来访问该值：\nif (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 请注意，对于字符串“0x33”，asInt() 产生 0，因为 stoi() 不会将字符串解析为十六进制值。 有其他方法可以实现对返回值的处理，例如：\nstd::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi.has_value()) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; oi.value() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 在这里，has_value() 用于检查是否返回了一个值，并使用 value() 访问它。 value() 比 operator * 更安全：如果不存在值，它会抛出异常。 运算符 * 仅应在您确定可选项包含值时使用； 否则你的程序将有未定义的行为。 请注意，我们可以通过使用新类型 std::string_view 来改进 asInt()。\n15.1.2 可选参数和数据成员 另一个使用 std::optional\u0026lt;\u0026gt; 的例子是参数的可选传递 and/or 数据成员的可选设置：\nlib/optionalmember.cpp\n#include \u0026lt;string\u0026gt; #include \u0026lt;optional\u0026gt; #include \u0026lt;iostream\u0026gt; class Name { private: std::string first; std::optional\u0026lt;std::string\u0026gt; middle; std::string last; public: Name (std::string f, std::optional\u0026lt;std::string\u0026gt; m, std::string l) : first{std::move(f)}, middle{std::move(m)}, last{std::move(l)} {} friend std::ostream\u0026amp; operator \u0026lt;\u0026lt; (std::ostream\u0026amp; strm, const Name\u0026amp; n) { strm \u0026lt;\u0026lt; n.first \u0026lt;\u0026lt; \u0026#39; \u0026#39;; if (n.middle) { strm \u0026lt;\u0026lt; *n.middle \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return strm \u0026lt;\u0026lt; n.last; } }; int main() { Name n{\u0026#34;Jim\u0026#34;, std::nullopt, \u0026#34;Knopf\u0026#34;}; std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Name m{\u0026#34;Donald\u0026#34;, \u0026#34;Ervin\u0026#34;, \u0026#34;Knuth\u0026#34;}; std::cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 类名表示由名字、可选的中间名和姓氏组成的名称。 成员 middle 被相应地定义，并且构造函数允许在没有中间名时传递 std::nullopt 。 这是与中间名是空字符串不同的状态。\n请注意，与通常具有值语义的类型一样，定义初始化相应成员的构造函数的最佳方法是按值获取参数并将参数移动到成员：\n还要注意 std::optional\u0026lt;\u0026gt; 改变了对成员中间值的访问。 使用 middle 作为布尔表达式会产生是否存在中间名，必须使用 *middle 来访问当前值（如果有）。\n访问该值的另一个选项是使用成员函数 value_or()，它可以在不存在值的情况下指定一个备用值。 例如，在类 Name 中，我们还可以实现：\nstd::cout \u0026lt;\u0026lt; middle.value_or(\u0026#34;\u0026#34;); // 打印中间名或什么都没有 15.2 std::optional\u0026lt;\u0026gt; 类型和操作 本节详细介绍 std::optional\u0026lt;\u0026gt; 的类型和操作。\n15.2.1 std::optional\u0026lt;\u0026gt; 类型 在头文件 中，C++ 标准库定义类 std::optional\u0026lt;\u0026gt; 如下：\nnamespace std { template\u0026lt;typename T\u0026gt; class optional; } 此外，还定义了以下类型和对象：\nstd::nullopt_t 类型的 nullopt 作为没有值的可选对象的“值”。 异常类std::bad_optional_access，它派生自std::exception，用于没有值的值访问。 可选对象还使用 中定义的对象 std::in_place（std::in_place_t 类型）来初始化具有多个参数的可选对象的值（见下文）。\n15.2.2 std::optional\u0026lt;\u0026gt; 操作 表 std::optional Operations 列出了为 std::optional\u0026lt;\u0026gt; 提供的所有操作。\n建造 特殊构造函数可以将参数直接传递给包含的类型。\n您可以创建一个没有值的可选对象。 在这种情况下，您必须指定包含的 类型：\nstd::optional\u0026lt;int\u0026gt; o1; std::optional\u0026lt;int\u0026gt; o2(std::nullopt); 这不会调用包含类型的任何构造函数.\n您可以传递一个值来初始化包含的类型。 由于推导指南，您不必指定包含的类型，然后：\nstd::optional o3{42}; // 推导出optional\u0026lt;int\u0026gt; std::optional\u0026lt;std::string\u0026gt; o4{\u0026#34;hello\u0026#34;}; std::optional o5{\u0026#34;hello\u0026#34;}; // 推导出 optional\u0026lt;const char*\u0026gt; 操作 作用 constructors 创建一个可选对象（可能为包含的调用构造函数类型） make_optional\u0026lt;\u0026gt;() 创建一个可选对象（传递值来初始化它） destructor 销毁一个可选对象 = 分配一个新值 emplace() 为包含的类型分配一个新值 reset() 销毁任何值（使对象为空） has_value() 返回对象是否有值 conversion to bool 返回对象是否有值 * 值访问（如果没有值，则为未定义行为） -\u0026gt; 访问值的成员（如果没有值，则行为未定义） value() 值访问（如果没有值则例外） value_or() 值访问（如果没有值，则为后备参数） swap() 在两个对象之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较可选对象 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 要使用多个参数初始化可选对象，您必须创建对象或添加 std::in_place 作为第一个参数（无法推断包含的类型）：\nstd::optional o6{std::complex{3.0, 4.0}}; std::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o7{std::in_place, 3.0, 4.0}; 请注意，后一种形式避免了创建临时对象。 通过使用这种形式，你甚至可以传递一个初始化列表和额外的参数：\n// 使用 lambda 作为排序标准初始化集合: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::optional\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt; o8{std::in_place, {4, 8, -7, -2, 0, 5}, sc }; 您可以复制可选对象（包括类型转换）。\nstd::optional o5{\u0026#34;hello\u0026#34;}; // 推导出 optional\u0026lt;const char*\u0026gt; std::optional\u0026lt;std::string\u0026gt; o9{o5}; // OK 请注意，还有一个便利函数 make_optional\u0026lt;\u0026gt;()，它允许使用单个或多个参数进行初始化（不需要 in_place 参数）。 像往常一样 make\u0026hellip; 函数它会衰减：\nauto o10 = std::make_optional(3.0); // optional\u0026lt;double\u0026gt; auto o11 = std::make_optional(\u0026#34;hello\u0026#34;); // optional\u0026lt;const char*\u0026gt; auto o12 = std::make_optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;(3.0, 4.0); 但是，请注意，没有构造函数获取值并根据其值来决定是使用值初始化可选项还是 nullopt。 为此，必须使用运算符 ?:。 例如：\nstd::multimap\u0026lt;std::string, std::string\u0026gt; englishToGerman; ... auto pos = englishToGerman.find(\u0026#34;wisdom\u0026#34;); auto o13 = pos != englishToGerman.end() ? std::optional{pos-\u0026gt;second} : std::nullopt; 在这里，由于 std::optional{pos-\u0026gt;second} 的类模板参数推导，o13 被初始化为 std::optionalstd::string。 对于 std::nullopt 类模板参数推导不起作用，但 operator ?: 在推导表达式的结果类型时也将其转换为这种类型。\n访问值 要检查可选对象是否具有值，您可以在布尔表达式中使用它或调用 has_value()：\nstd::optional o{42}; if (o) ... // true if (!o) ... // false if (o.has_value()) ... // true 然后，为了访问该值，提供了一种指针语法。 也就是说，使用 operator* 您可以直接访问它的值，而 operator-\u0026gt; 可以访问该值的成员：\nstd::optional o{std::pair{42, \u0026#34;hello\u0026#34;}}; auto p = *o; // 将 p 初始化为 pair\u0026lt;int,string\u0026gt; std::cout \u0026lt;\u0026lt; o-\u0026gt;first; // prints 42 请注意，这些运算符要求可选项包含一个值。 在没有值的情况下使用它们是未定义的行为：\nstd::optional\u0026lt;std::string\u0026gt; o{\u0026#34;hello\u0026#34;}; std::cout \u0026lt;\u0026lt; *o; // OK: prints ”hello” o = std::nullopt; std::cout \u0026lt;\u0026lt; *o; // 未定义的行为 请注意，实际上第二个输出仍然会编译并执行一些输出，例如再次打印“hello”，因为可选对象的值的底层内存没有被修改。\n但是，您不能也不应该依赖它。 如果您不知道可选对象是否有值，则必须调用以下代码：\nif (o) std::cout \u0026lt;\u0026lt; *o; // OK (可能什么也不输出) 或者，您可以使用 value()，如果没有包含值，则会引发 std::bad_optional_access 异常：\nstd::cout \u0026lt;\u0026lt; o.value(); // OK (如果没有值则抛出) std::bad_optional_access 直接派生自 std::exception。\n最后，您可以请求该值并传递一个备用值，如果可选对象没有值，则使用该值：\nstd::cout \u0026lt;\u0026lt; o.value_or(\u0026#34;fallback\u0026#34;); // OK (如果没有值则输出fallback) 后备参数作为右值引用传递，因此如果不使用后备，它不会花费任何成本，并且如果使用它，它支持移动语义。 请注意，operator* 和 value() 都通过引用返回包含的对象。 因此，在直接调用这些操作以获取临时返回值时，您必须小心。 例如：\nstd::optional\u0026lt;std::string\u0026gt; getString(); ...; auto a = getString().value(); // OK: 包含对象的副本 auto b = *getString(); // ERROR: 如果 std::nullopt 的行为未定义 const auto\u0026amp; r1 = getString().value(); // ERROR: 引用已删除的包含对象 auto\u0026amp;\u0026amp; r2 = getString().value(); // ERROR: 引用已删除的包含对象 一个示例可能是基于范围的 for 循环的以下用法：\nstd::optional\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getVector(); ...; for (int i : getVector().value()) { // ERROR: 迭代已删除的vector std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 请注意，迭代返回的 int 向量是可行的。 所以，不要盲目地将函数 foo() 的返回类型替换为相应的可选类型，而是调用 foo().value() 。\n对比 您可以使用通常的比较运算符。 操作数可以是可选对象， 包含类型和 std::nullopt。\n如果两个操作数都是具有值的对象，则使用包含类型的相应运算符。 如果两个操作数都是没有值的对象，则它们被认为是相等的（== 产生 true 并且 所有其他比较结果为假）。 如果只有一个操作数是具有值的对象，则认为没有值的操作数小于另一个操作数。 例如：\nstd::optional\u0026lt;int\u0026gt; o0; std::optional\u0026lt;int\u0026gt; o1{42}; /* o0 == std::nullopt // yields true o0 == 42 // yields false o0 \u0026lt; 42 // yields true o0 \u0026gt; 42 // yields false o1 == 42 // yields true o0 \u0026lt; o1 // yields true */ 这意味着对于 unsigned int 的可选对象，有一个小于 0 的值，对于 bool 的可选对象，有一个小于 0 的值：\nstd::optional\u0026lt;unsigned\u0026gt; uo; uo \u0026lt; 0 // yields true std::optional\u0026lt;bool\u0026gt; bo; bo \u0026lt; false // yields true 同样，支持底层类型的隐式类型转换：\nstd::optional\u0026lt;int\u0026gt; o1{42}; std::optional\u0026lt;double\u0026gt; o2{42.0}; /* o2 == 42 // yields true o1 == o2 // yields true */ 请注意，可选的布尔值或原始指针值可能会导致一些意外。\n更改值 赋值和 emplace() 操作对应于初始化存在：\nstd::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o; // 没有值 std::optional ox{77}; // optional\u0026lt;int\u0026gt; with value 77 o = 42; // 值变为 complex(42.0, 0.0) o = {9.9, 4.4}; // 值变为 complex(9.9, 4.4) o = ox; // OK, 因为 int 转换为 complex\u0026lt;double\u0026gt; o = std::nullopt; // o 不再具有值 o.emplace(5.5, 7.7); // 值变为 complex(5.5, 7.7) 分配 std::nullopt 会删除该值，如果之前有值，则调用包含类型的析构函数。 您可以通过调用 reset() 来获得相同的效果：\no.reset(); // o 不再具有值 或分配空花括号：\no = {}; // o 不再具有值 最后，我们还可以使用 operator* 来修改值，因为它通过引用产生值。 但是，请注意，这需要有一个值要修改：\nstd::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o; *o = 42; // 未定义的行为 ...; if (o) { *o = 88; // OK: 值变为 complex(88.0, 0.0) *o = {1.2, 3.4}; // OK: 值变为 complex(1.2, 3.4) } 移动语义 std::optional\u0026lt;\u0026gt; 也支持移动语义。 如果将对象作为一个整体移动，则将复制状态并移动包含的对象（如果有）。 结果，移出的对象仍然具有相同的状态，但任何值都未指定。\n​\t但是您也可以将值移入或移出包含的对象。 例如：\nstd::optional\u0026lt;std::string\u0026gt; os; std::string s = \u0026#34;a very very very long string\u0026#34;; os = std::move(s); // OK, 移动 std::string s2 = *os; // OK 拷贝 std::string s3 = std::move(*os); // OK, 移动 请注意，在最后一次调用之后 os 仍然有一个字符串值，但对于已移动的对象，该值通常是未指定的。 因此，只要您不对它的值做任何假设，您就可以使用它。 您甚至可以在那里分配一个新的字符串值。\n散列 可选对象的哈希值是包含的非常量类型（如果有）的哈希值。\n15.3 特殊情况 特定的可选值类型可能会导致特殊或意外行为。\n15.3.1 可选的布尔值或原始指针值 请注意，使用比较运算符与使用可选对象作为布尔值具有不同的语义。 如果包含的类型是 bool 或指针类型，这可能会变得令人困惑：例如：\nstd::optional\u0026lt;bool\u0026gt; ob{false}; // 有值，为假 if (!ob) ... // 产生错误 if (ob == false) ... // yields true std::optional\u0026lt;int*\u0026gt; op{nullptr}; if (!op) ... // yields false if (op == nullptr) ... // yields true 15.3.2 Optional 的 Optional 原则上，您还可以定义可选值的可选：\nstd::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos1; std::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos2 = \u0026#34;hello\u0026#34;; std::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos3{std::in_place, std::in_place, \u0026#34;hello\u0026#34;}; std::optional\u0026lt;std::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;\u0026gt; ooc{std::in_place, std::in_place, 4.2, 5.3}; 即使使用隐式转换，您也可以分配新值：\noos1 = \u0026#34;hello\u0026#34;; // OK: 分配新值 ooc.emplace(std::in_place, 7.2, 8.3); 由于没有值的两个层次，可选的可选使得在外部或内部具有“无值”，这可以具有不同的语义含义：\n*oos1 = std::nullopt; // 内部可选没有值 oos1 = std::nullopt; // 外部可选没有值 但是您必须特别注意处理可选值：\nif (!oos1) std::cout \u0026lt;\u0026lt; \u0026#34;no value\\n\u0026#34;; if (oos1 \u0026amp;\u0026amp; !*oos1) std::cout \u0026lt;\u0026lt; \u0026#34;no inner value\\n\u0026#34;; if (oos1 \u0026amp;\u0026amp; *oos1) std::cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; **oos1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 但是，因为这在语义上更像是一个具有两个不同状态的值，表示没有值，所以具有两个布尔或单态替代方案的 std::variant\u0026lt;\u0026gt; 可能更合适。\n15.4 后记 可选对象于 2005 年由 Fernando Cacciola 在 https://wg21.link/n1878 中首次提出，将 Boost.Optional 作为参考实现。 正如 Fernando Cacciola 和 Andrzej Krzemienski 在 https://wg21.link/n3793 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。\n正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。\nTony van Eerd 使用 https://wg21.link/n3765 和 https://wg21.link/p0307r2 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::variant\u0026lt;\u0026gt; 和 std::any 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。\n16 std::variant\u0026lt;\u0026gt; 借助 std::variant\u0026lt;\u0026gt;，C++ 标准库提供了一个新的联合类，其中包括支持多态性和处理非同质集合的新方法。 也就是说，它允许我们处理不同数据类型的元素，而无需公共基类和指针（原始或智能）。\n16.1 std::variant\u0026lt;\u0026gt; 的时机 从 C 中采用，C++ 提供对联合的支持，联合是能够保存可能类型列表之一的对象。但是，此语言功能存在一些缺点：\n对象不知道它们当前持有哪种类型的值。 出于这个原因，您不能拥有非平凡的成员，例如 std::string （无需特别努力）。 你不能从工会派生。 使用 std::variant\u0026lt;\u0026gt;，C++ 标准库提供了一个封闭的可区分联合（这意味着有一个指定的可能类型列表，您可以指定您的意思），其中 当前值的类型总是已知的， 可以有任何指定类型的成员，并且 你可以从中得到。 事实上，一个 std::variant\u0026lt;\u0026gt; 保存着各种选择的值，这些选择通常有不同的类型。但是两个替代也可以具有相同的类型，如果具有不同语义含义的替代具有相同的类型，这很有用（例如，持有两个字符串，它们代表不同的数据库列，以便您仍然知道该值代表哪些列） . 变体只是具有用于基础类型的最大大小的内部存储器以及一些固定的开销来管理使用哪个替代方案。 没有分配堆内存。\n一般来说，变量不能为空，除非您使用特定的替代信号来表示空虚。 但是，在极少数情况下（例如由于在分配不同的新值期间出现异常） type) 变体可以进入一个没有任何价值的状态。\n与 std::optional\u0026lt;\u0026gt; 和 std::any 一样，结果对象具有值语义。 通过在自己的内存中创建一个具有当前替代项的当前值的独立对象来进行深度复制。 因此，复制 std::variant\u0026lt;\u0026gt; 与复制当前替代的 type/value 一样便宜/昂贵。 支持移动语义。\n16.2 使用 std::variant\u0026lt;\u0026gt; 以下示例演示了 std::variant\u0026lt;\u0026gt; 的核心功能：\nlib/variant.cpp #include \u0026lt;variant\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::variant\u0026lt;int, std::string\u0026gt; var{\u0026#34;hi\u0026#34;}; // 用字符串替代初始化 std::cout \u0026lt;\u0026lt; var.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 var = 42; // 现在持有 int 替代品 std::cout \u0026lt;\u0026lt; var.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 0 ...; try { int i = std::get\u0026lt;0\u0026gt;(var); // 按索引访问 std::string s = std::get\u0026lt;std::string\u0026gt;(var); // 按类型访问（在这种情况下抛出异常） ...; } catch (const std::bad_variant_access\u0026amp; e) { // 如果使用了错误的type/index std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ...; } } 成员函数 index() 可用于找出当前设置了哪个备选方案（第一个备选方案的索引为 0）。\n初始化和赋值总是使用最佳匹配来找出新的替代方案。 如果类型不完全适合，可能会出现意外。\n请注意，不允许使用空变体、具有引用成员的变体、具有 C 样式数组成员的变体以及具有不完整类型（例如 void）的变体。\n没有空状态。 这意味着对于每个构造对象，必须调用至少一个构造函数。 默认构造函数使用默认构造函数初始化第一个类型：\nstd::variant\u0026lt;std::string, int\u0026gt; var; // =\u0026gt; var.index() == 0, value == ”” 如果没有为第一种类型定义默认构造函数，则调用变体的默认构造函数是编译时错误：\nstruct NoDefConstr { NoDefConstr(int i) { std::cout \u0026lt;\u0026lt; \u0026#34;NoDefConstr::NoDefConstr(int) called\\n\u0026#34;; } }; std::variant\u0026lt;NoDefConstr, int\u0026gt; v1; // ERROR: 不能默认构造第一类型 辅助类型 std::monostate 提供了处理这种情况的能力，也提供了模拟空状态的能力。\nstd::monostate 为了支持第一种类型没有默认构造函数的变体，提供了一个特殊的辅助类型：std::monostate。 std::monostate 类型的对象始终具有相同的状态。 因此，它们总是比较相等。 他们自己的目的是表示一个替代类型，以便该变体没有任何其他类型的值。\n也就是说，struct std::monostate 可以作为第一个替代类型，以使变体类型默认可构造。 例如：\nstd::variant\u0026lt;std::monostate, NoDefConstr\u0026gt; v2; // OK std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 0 在某种程度上，您可以将状态解释为表示空虚。 有多种方法可以检查单态，这也演示了其他一些操作，您可以调用变体：\nif (v2.index() == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (!v2.index()) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::holds_alternative\u0026lt;std::monostate\u0026gt;(v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::get_if\u0026lt;0\u0026gt;(\u0026amp;v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::get_if\u0026lt;std::monostate\u0026gt;(\u0026amp;v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } get_if\u0026lt;\u0026gt;() 使用指向变体的指针，如果当前备选方案是 T，则返回指向当前备选方案的指针。否则返回 nullptr。 这与 get() 不同，get() 采用对变体的引用，如果提供的类型正确，则按值返回当前替代项，否则抛出。\n像往常一样，您可以分配另一个替代的值，甚至分配单态，再次表示空虚：\nv2 = 42; std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // index: 1 v2 = std::monostate{}; std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // index: 0 从变体派生 您可以从 std::variant 派生。 例如，您可以定义从 std::variant\u0026lt;\u0026gt; 派生的聚合，如下所示：\nclass Derived : public std::variant\u0026lt;int, std::string\u0026gt; { }; Derived d = {{\u0026#34;hello\u0026#34;}}; std::cout \u0026lt;\u0026lt; d.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 1 std::cout \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(d) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: hello d.emplace\u0026lt;0\u0026gt;(77); // 初始化 int，销毁字符串 std::cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(d) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 77 16.3 std::variant\u0026lt;\u0026gt; 类型和操作 本节详细介绍 std::variant\u0026lt;\u0026gt; 的类型和操作。\n16.3.1 std::variant\u0026lt;\u0026gt; 类型 在头文件 中，C++ 标准库定义类 std::variant\u0026lt;\u0026gt; 如下：\nnamespace std { template\u0026lt;typename Types...\u0026gt; class variant; } 也就是说，std::variant\u0026lt;\u0026gt; 是一个可变参数类模板（C++11 引入的一个特性，允许处理任意数量的类型）。 此外，还定义了以下类型和对象：\n类型 std::variant_size\n类型 std::variant_alternative\n值 std::variant_npos\n类型 std::monostate\n异常类 std::bad_variant_access，派生自 std::exception。\n变体还使用在 utility\u0026gt; 中定义的两个对象 std::in_place_type（std::in_place_type_t 类型）和 std::in_place_index（std::in_place_index_t 类型）。\n16.3.2 std::variant\u0026lt;\u0026gt; 操作 表 std::variant Operations 列出了为 std::variant\u0026lt;\u0026gt; 提供的所有操作.\n构造 默认情况下，变体的默认构造函数调用第一个替代的默认构造函数：\nstd::variant\u0026lt;int, int, std::string\u0026gt; v1; // 将第一个 int 设置为 0，index()==0 另一种方法是值初始化，这意味着对于基本类型，它是 0、false 或 nullptr。 如果为初始化传递了一个值，则使用最佳匹配类型：\nstd::variant\u0026lt;long, int\u0026gt; v2{42}; std::cout \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 但是，如果两种类型匹配得一样好，则调用是模棱两可的：\nstd::variant\u0026lt;long, long\u0026gt; v3{42}; // ERROR: 模糊的 std::variant\u0026lt;int, float\u0026gt; v4{42.3}; // ERROR: 模糊的 std::variant\u0026lt;int, double\u0026gt; v5{42.3}; // OK std::variant\u0026lt;int, long double\u0026gt; v6{42.3}; // ERROR: 模糊的 std::variant\u0026lt;std::string, std::string_view\u0026gt; v7{\u0026#34;hello\u0026#34;}; // ERROR: 模糊的 std::variant\u0026lt;std::string, std::string_view, const char*\u0026gt; v8{\u0026#34;hello\u0026#34;}; // OK std::cout \u0026lt;\u0026lt; v8.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 2 操作 作用 constructors 创建一个变体对象（可能调用底层类型的构造函数） destructor 销毁一个变体对象 = 分配一个新值 emplace() 为具有类型 T 的替代项分配一个新值 emplace() 为索引 Idx 的替代项分配一个新值 valueless_by_exception() 返回变量是否由于异常而没有值 index() 返回当前替代的索引 swap() 在两个对象之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较不同的对象 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 holds_alternative() 返回是否有类型 T 的值 get() 返回类型为 T 或 throws 的替代项的值 get() 返回具有索引 Idx 或 throws 的替代项的值 get_if() 返回指向 T 或 nullptr 类型的替代值的指针 get_if() 返回指向具有索引 Idx 或 nullptr 的替代项的值的指针 visit() 对当前备选方案执行操作 要为初始化传递多个值，您必须使用 in_place_type 或 in_place_index 标签：\nstd::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v9{3.0, 4.0}; // ERROR std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v10{{3.0, 4.0}}; // ERROR std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v11{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 3.0, 4.0}; std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v12{std::in_place_index\u0026lt;0\u0026gt;, 3.0, 4.0}; 您还可以在初始化期间使用 in_place_index 标记来解决歧义或否决优先级：\nstd::variant\u0026lt;int, int\u0026gt; v13{std::in_place_index\u0026lt;1\u0026gt;, 77}; // 初始化第二个 int std::variant\u0026lt;int, long\u0026gt; v14{std::in_place_index\u0026lt;1\u0026gt;, 77}; // 初始化长，而不是 int std::cout \u0026lt;\u0026lt; v14.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 你甚至可以传递一个初始化列表，后跟其他参数：\n// initialize variant with a set with lambda as sorting criterion: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::variant\u0026lt;std::vector\u0026lt;int\u0026gt;, std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt; v15{std::in_place_index\u0026lt;1\u0026gt;, {4, 8, -7, -2, 0, 5}, sc }; 你不能对 std::variant\u0026lt;\u0026gt; 使用类模板参数推导。 并且没有 make_variant\u0026lt;\u0026gt;() 便利函数（与 std::optional\u0026lt;\u0026gt; 和 std::any 不同）。 两者都没有意义，因为变体的整个目标是处理多种选择。\n访问值 访问该值的常用方法是调用 get\u0026lt;\u0026gt;() 以获得相应的替代方法。 您可以传递它的索引，或者，如果一个类型不被多次使用，它的类型。 例如：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 auto a = std::get\u0026lt;double\u0026gt;(var); // compile-time 错误：没有双精度 auto b = std::get\u0026lt;4\u0026gt;(var); // compile-time 错误: 没有第四选择 auto c = std::get\u0026lt;int\u0026gt;(var); // compile-time 错误: int 两次 try { auto s = std::get\u0026lt;std::string\u0026gt;(var); // 抛出异常（当前设置的第一个 int） auto i = std::get\u0026lt;0\u0026gt;(var); // OK, i==0 auto j = std::get\u0026lt;1\u0026gt;(var); // 抛出异常（当前设置的其他 int） } catch (const std::bad_variant_access\u0026amp; e) { // 在无效访问的情况下 std::cout \u0026lt;\u0026lt; \u0026#34;Exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 还有一个 API 可以通过选项检查它是否存在来访问该值：\nif (auto ip = std::get_if\u0026lt;1\u0026gt;(\u0026amp;var); ip) { std::cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;alternative with index 1 not set\\n\u0026#34;; } 您必须将指向变体的指针传递给 get_if\u0026lt;\u0026gt;()，它要么返回指向当前值的指针，要么返回 nullptr。 请注意，如果使用 with 初始化，则可以检查刚刚初始化的值。 访问不同选项值的另一种方法是变体访问者。\n更改值 赋值和 emplace() 操作对应于初始化存在：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 var = \u0026#34;hello\u0026#34;; // 设置字符串，index()==2 var.emplace\u0026lt;1\u0026gt;(42); // 设置第二个 int，index()==1 您还可以使用 get\u0026lt;\u0026gt;() 或 get_if\u0026lt;\u0026gt;() 为当前替代项分配一个新值：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 std::get\u0026lt;0\u0026gt;(var) = 77; // OK,因为第一个 int 已经设置 std::get\u0026lt;1\u0026gt;(var) = 99; // 抛出异常（当前设置的其他 int） if (auto p = std::get_if\u0026lt;1\u0026gt;(\u0026amp;var); p) { // 如果第二个 int 设置 *p = 42; // 修改它 } 修改不同选项值的另一种方法是变体访问者\n比较 对于相同类型的两个变体（即具有相同顺序的相同替代项），您可以使用通常的比较运算符。 运营商按照以下规则行事：\n具有较早替代值的变体小于具有较晚替代值的变体。 如果两个变体具有相同的备选方案，则评估备选方案类型的相应运算符。 注意 std::monostate 类型的所有对象总是相等的。 特殊状态 valueless_by_exception() 为 true 的两个变体是相等的。 否则，任何 valueless_by_exception() 为 true 的变体都小于任何其他变体。 例如：\nstd::variant\u0026lt;std::monostate, int, std::string\u0026gt; v1, v2{\u0026#34;hello\u0026#34;}, v3{42}; std::variant\u0026lt;std::monostate, std::string, int\u0026gt; v4; /* v1 == v4 // COMPILE-TIME ERROR v1 == v2 // yields false v1 \u0026lt; v2 // yields true v1 \u0026lt; v3 // yields true v2 \u0026lt; v3 // yields false v1 = \u0026#34;hello\u0026#34;; v1 == v2 // yields true v2 = 41; v2 \u0026lt; v3 // yields true */ 移动语义 std::variant\u0026lt;\u0026gt; 也支持移动语义。 如果您将对象作为一个整体移动，则将复制状态并移动当前替代项的值。 结果，移出的对象仍然具有相同的选择，但任何值都变得未指定。 您还可以将值移入或移出包含的对象。\n散列 当且仅当每个成员类型都可以提供哈希值时，才启用变体对象的哈希值。 请注意，哈希值不是当前备选方案的哈希值。\n16.3.3 访客 他们必须明确地为每种可能的类型提供函数调用运算符。 然后，使用相应的重载来处理当前的替代方案。\n使用函数对象作为访问者 例子：\nlib/variantvisit.cpp #include \u0026lt;variant\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; struct MyVisitor { void operator() (int i) const { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator() (std::string s) const { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator() (long double d) const { std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { std::variant\u0026lt;int, std::string, double\u0026gt; var(42); std::visit(MyVisitor(), var); // 为 int 调用 operator() var = \u0026#34;hello\u0026#34;; std::visit(MyVisitor(), var); // 为string调用 operator() var = 42.7; std::visit(MyVisitor(), var); // 为long double调用 operator() } 如果 operator() 不支持所有可能的类型或调用不明确，则 visit() 调用是编译时错误。 此处的示例运行良好，因为 long double 比 int 更适合 double 值。 您还可以使用访问者来修改当前替代的值（但不能分配新的替代）。 例如：\nstruct Twice { void operator()(double\u0026amp; d) const { d *= 2; } void operator()(int\u0026amp; i) const { i *= 2; } void operator()(std::string\u0026amp; s) const { s = s + s; } }; std::visit(Twice(), var); // calls operator() for matching type 因为只有类型很重要，所以对于具有相同类型的替代方案，您不能有不同的行为。 请注意，函数调用运算符应标记为 const，因为它们是无状态的（它们不会改变行为，只会改变传递的值）。\n使用通用 Lambda 作为访问者 使用此功能的最简单方法是使用通用 lambda，它是任意类型的函数对象：\nauto printvariant = [](const auto\u0026amp; val) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; ...; std::visit(printvariant, var); 在这里，通用 lambda 定义了一个闭包类型，其中函数调用运算符作为成员模板：\nclass CompilerSpecifyClosureTypeName { public: template\u0026lt;typename T\u0026gt; auto operator() (const T\u0026amp; val) const { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; 因此，如果生成的函数调用运算符中的语句有效（即调用输出运算符有效），则传递给 std::visit() 的 lambda 调用将编译。 您还可以使用 lambda 来修改当前替代项的值：\n// 将当前替代品的值翻倍: std::visit([](auto\u0026amp; val) { val = val + val; }, var); 或者：\n// 恢复为当前替代的默认值; std::visit([](auto\u0026amp; val) { val = std::remove_reference_t\u0026lt;decltype(val)\u0026gt;{}; }, var); 您甚至可以使用编译时语言功能以不同方式处理不同的替代方案。 例如：\nauto dblvar = [](auto\u0026amp; val) { if constexpr(std::is_convertible_v\u0026lt;decltype(val), std::string\u0026gt;) { val = val + val; } else { val *= 2; } }; ...; std::visit(dblvar, var); 在这里，对于 std::string 替代方案，通用 lambda 的调用实例化其通用函数调用模板以进行计算：\nval = val + val; 而对于其他替代方案，例如 int 或 double，lambda 的调用实例化其通用函数调用模板来计算：\nval *= 2; 使用重载的 Lambda 作为访问者 通过对函数对象和 lambda 使用重载器，您还可以定义一组 lambda，其中最佳匹配用作访问者。 假设重载器是重载定义如下：\ntmpl/overload.hpp // “继承”传递的基类型的所有函数调用运算符: template\u0026lt;typename... Ts\u0026gt; struct overload : Ts... { using Ts::operator()...; }; // 基类型是从传递的参数推导出来的: template\u0026lt;typename... Ts\u0026gt; overload(Ts...) -\u0026gt; overload\u0026lt;Ts...\u0026gt;; 您可以通过为每个替代方案提供 lambdas 来使用重载来访问变体：\nstd::variant\u0026lt;int, std::string\u0026gt; var(42); ...; std::visit(overload{ // 调用当前替代的最佳匹配 lambda [](int i) { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, [](const std::string\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, }, var); 您还可以使用通用 lambda。 始终使用最佳匹配。 例如，要修改变体的当前替代项，您可以使用重载将字符串和其他类型的值“加倍”：\nauto twice = overload{ [](std::string\u0026amp; s) { s += s; }, [](auto\u0026amp; i) { i *= 2; }, }; 有了这个重载，对于字符串替代，当前值被附加，而对于所有其他类型，该值乘以 2，这演示了以下变体的应用：\nstd::variant\u0026lt;int, std::string\u0026gt; var(42); std::visit(twice, var); // value 42 becomes 84 ...; var = \u0026#34;hi\u0026#34;; std::visit(twice, var); // value \u0026#34;hi\u0026#34; becomes \u0026#34;hihi\u0026#34; 16.3.4 例外情况下无值 当修改变体以获取新值并且此修改引发异常时，变体可能会进入一个非常特殊的状态：变体已经失去了旧值，但没有获得新值。 例如：\nstruct S { operator int() { throw \u0026#34;EXCEPTION\u0026#34;; } // 任何到 int 的转换都会抛出 }; std::variant\u0026lt;double,int\u0026gt; var{12.2}; // 初始化为 double var.emplace\u0026lt;1\u0026gt;(S{}); // OOPS: 设置为 int 时抛出 如果发生这种情况，那么：\nvar.valueless_by_exception() 返回真 var.index() 返回 std::variant_npos 这表明该变体根本没有任何价值。 具体保证如下： 如果 emplace() 抛出 valueless_by_exception() 总是设置为 true。 如果 operator=() 抛出并且修改不会改变替代 valueless_by_exception() 并且 index() 保持它们的旧状态。值的状态取决于值类型的异常保证。 如果 operator=() 抛出并且新值将设置不同的替代项，则该变体可能没有值（valueless_by_exception() 可能变为 true）。这取决于何时抛出异常。如果它发生在值的实际修改开始之前的类型转换期间，则变体仍将保留其旧值。 通常，只要您不再使用您尝试修改的变体，这种行为应该没有问题。如果你仍然想使用一个变体，尽管使用它会导致异常，你最好检查它的状态。例如：\nstd::variant\u0026lt;double,int\u0026gt; var{12.2}; // 初始化为 double try { var.emplace\u0026lt;1\u0026gt;(S{}); // OOPS: 设置为 int 时抛出 } catch (...) { if (!var.valueless_by_exception()) { ...; } } 16.4 使用std::variant的多态性和非同质化的集合 具有 std::variant 的多态性和非同质集合\nstd::variant 启用了一种新形式的多态性并处理非同质集合。 它是一种具有一组紧密数据类型的 compile-time 多态性形式。\n也就是说，通过使用 variant\u0026lt;\u0026gt;，您可以定义一个对象是多种可能的类型之一。 然后，该对象具有值语义，您可以将这些对象插入到非同质集合中。 因为每个变体都知道它拥有哪个替代方案，并且由于访问者界面，我们可以在运行时针对不同类型进行编程，调用不同的函数/方法（不需要任何虚函数、引用和指针）。\n16.4.1 使用std::variant的几何对象 例如，假设我们必须对几何对象系统进行编程：\nlib/variantpoly1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;variant\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;coord.hpp\u0026#34; #include \u0026#34;line.hpp\u0026#34; #include \u0026#34;circle.hpp\u0026#34; #include \u0026#34;rectangle.hpp\u0026#34; // 所有几何对象类型的通用类型: using GeoObj = std::variant\u0026lt;Line, Circle, Rectangle\u0026gt;; // 创建和初始化几何对象的集合: std::vector\u0026lt;GeoObj\u0026gt; createFigure() { std::vector\u0026lt;GeoObj\u0026gt; f; f.push_back(Line{Coord{1,2},Coord{3,4}}); f.push_back(Circle{Coord{5,5},2}); f.push_back(Rectangle{Coord{3,3},Coord{6,4}}); return f; } int main() { std::vector\u0026lt;GeoObj\u0026gt; figure = createFigure(); for (const GeoObj\u0026amp; geoobj : figure) { std::visit([] (const auto\u0026amp; obj) { obj.draw(); // draw() 的多态调用 }, geoobj); } } 首先，我们为所有可能的类型定义一个通用数据类型：\nusing GeoObj = std::variant\u0026lt;Line, Circle, Rectangle\u0026gt;; 这三种类型不需要任何特殊关系。 事实上，它们不必有一个通用的基类，没有虚函数，它们的接口甚至可能不同。 例如：\nlib/circle.hpp\n#ifndef CIRCLE_HPP #define CIRCLE_HPP #include \u0026#34;coord.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; class Circle { private: Coord center; int rad; public: Circle (Coord c, int r) : center{c}, rad{r} { } void move(const Coord\u0026amp; c) { center += c; } void draw() const { std::cout \u0026lt;\u0026lt; \u0026#34;circle at \u0026#34; \u0026lt;\u0026lt; center \u0026lt;\u0026lt; \u0026#34; with radius \u0026#34; \u0026lt;\u0026lt; rad \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; #endif 现在我们可以通过创建相应的对象并将它们按值传递到容器中来将这些类型的元素放入一个集合中：\nstd::vector\u0026lt;GeoObj\u0026gt; createFigure() { std::vector\u0026lt;GeoObj\u0026gt; f; f.push_back(Line{Coord{1,2},Coord{3,4}}); f.push_back(Circle{Coord{5,5},2}); f.push_back(Rectangle{Coord{3,3},Coord{6,4}}); return f; } 这段代码在运行时多态下是不可能的，因为那样的话类型必须将 GeoObj 作为一个公共基类，我们需要一个 GeoObj 元素的指针向量，并且由于指针，我们必须使用 new 创建对象，这样 我们必须跟踪何时调用 delete 或使用智能指针（unique_ptr 或 shared_ptr）。 通过使用访问者，我们可以遍历元素并根据元素类型“做正确的事”：\nstd::vector\u0026lt;GeoObj\u0026gt; figure = createFigure(); for (const GeoObj\u0026amp; geoobj : figure) { std::visit([] (const auto\u0026amp; obj) { obj.draw(); // polymorphic call of draw() }, geoobj); } 在这里，visit() 使用通用 lambda 来为每个可能的 GeoObj 类型实例化。 也就是说，在编译 visit() 调用时，lambda 被实例化并编译为三个函数：\n编译 Line 类型的代码：\n[] (const Line\u0026amp; obj) { obj.draw(); // call of Line::draw() } 编译 Circle 类型的代码：\n[] (const Circle\u0026amp; obj) { obj.draw(); // call of Circle::draw() } 编译 Rectangle 类型的代码：\n[] (const Rectangle\u0026amp; obj) { obj.draw(); // call of Rectangle::draw() } 如果这些实例之一没有编译，则 visit() 的调用根本不会编译。 如果全部编译，则为每种元素类型生成调用相应函数的代码。 请注意，生成的代码没有 if-else 链。 该标准保证调用的性能不依赖于备选方案的数量。 也就是说，实际上我们得到了与虚函数表相同的行为（每个 visit() 都有一个本地虚函数表）。 请注意，调用的 draw() 函数不必是虚拟的。\n如果类型接口不同，我们可以使用编译时 if 或访问者重载来处理这种情况（参见下面的第二个示例）。\n16.4.2 其他使用std::variant的非同质集合 作为将非同质集合与 std::variant\u0026lt;\u0026gt; 一起使用的另一个示例，请考虑以下示例：\nlib/variantpoly2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;variant\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;type_traits\u0026gt; int main() { using Var = std::variant\u0026lt;int, double, std::string\u0026gt;; std::vector\u0026lt;Var\u0026gt; values {42, 0.19, \u0026#34;hello world\u0026#34;, 0.815}; for (const Var\u0026amp; val : values) { std::visit([] (const auto\u0026amp; v) { if constexpr(std::is_same_v\u0026lt;decltype(v), const std::string\u0026amp;\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }, val); } } 同样，我们为表示多种可能类型之一的对象定义自己的类型：\nusing Var = std::variant\u0026lt;int, double, std::string\u0026gt;; 我们可以用它们创建一个初始化非同质集合：\nstd::vector\u0026lt;Var\u0026gt; values {42, 0.19, \u0026#34;hello world\u0026#34;, 0.815}; 请注意，我们可以使用不均匀的元素集合来初始化vector，因为它们都转换为变体类型。 只有当我们传递一个 long 时，编译器才会知道是将它转换为 int 还是 double，这样就不会编译。\n当我们迭代时，我们使用访问者为他们调用不同的函数。 然而，因为在这里我们想做不同的事情（如果值是字符串，则在值周围加上引号），我们使用compile-time if：\nfor (const Var\u0026amp; val : values) { std::visit([] (const auto\u0026amp; v) { if constexpr(std::is_same_v\u0026lt;decltype(v), const std::string\u0026amp;\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }, val); } 这样输出就变成了：\n42 0.19 \u0026#34;hello world\u0026#34; 0.815 通过使用访问者重载，我们还可以如下实现：\nfor (const auto\u0026amp; val : values) { std::visit(overload{ [] (auto v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }, [] (const std::string\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } }, val); } 16.4.3 比较变体多态性 让我们总结一下使用 std::variant\u0026lt;\u0026gt; 处理多态性和非同质集合的优缺点。 好处是：\n您不需要常见的基本类型（非侵入式）。 您不必为非同质集合使用指针。 不需要虚拟成员函数。 值语义（无法访问已释放的内存或内存泄漏）。 向量中的元素位于一起（而不是通过堆内存中的指针分布）。 限制和缺点是：\n关闭类型集（您必须在编译时了解所有替代方案）。 元素都具有最大元素类型的大小（如果元素类型大小差异很大，则会出现问题）。 复制元素可能更昂贵。 一般来说，我现在建议默认使用 std::variant\u0026lt;\u0026gt; 来编程多态，因为它通常更快（没有 new 和 delete，没有用于非多态使用的虚函数），更安全（没有指针），并且 通常所有类型在所有代码的编译时都是已知的。 就在您必须处理引用语义（在多个地方使用相同的对象）或传递对象变得昂贵（即使使用移动语义）时，运行时多态性 继承可能仍然是合适的。\n16.5 std::variant\u0026lt;\u0026gt; 的特殊情况 特定变体可能导致特殊或意外行为\n16.5.1 同时拥有bool和std::string的选择 如果 std::variant\u0026lt;\u0026gt; 同时具有 bool 和 std::string 替代项，则分配字符串文字可能会变得令人惊讶，因为字符串文字转换为 bool 比转换为 std::string 更好。 例如：\nstd::variant\u0026lt;bool, std::string\u0026gt; v; v = \u0026#34;hi\u0026#34;; // OOPS: sets the bool alternative std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::visit([](const auto\u0026amp; val) { std::cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, v); 此代码段将具有以下输出：\nindex: 0 value: true 因此，字符串文字被解释为通过布尔值 true 初始化变量（因为指针不为 0，所以为 true）。 这里有几个选项可以“修复”分配：\nv.emplace\u0026lt;1\u0026gt;(\u0026#34;hello\u0026#34;); // 明确分配给第二个备选方案 v.emplace\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;); // 显式分配给字符串替代 v = std::string{\u0026#34;hello\u0026#34;}; // 确保分配了一个字符串 using namespace std::literals; // 确保分配了一个字符串 v = \u0026#34;hello\u0026#34;s; 16.6 后记 变体对象于 2005 年由 Axel Naumann 在 https://wg21.link/n4218 中首次提出，将 Boost.Variant 作为参考实现。 制定了最终接受的措辞 Axel Naumann 在 https://wg21.link/p0088r3 中。\nTony van Eerd 使用 https://wg21.link/p0393r3 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::optional\u0026lt;\u0026gt; 和 std::any 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。 Erich Keane 与 https://wg21.link/p0510r0 制定了禁止引用、不完整类型和数组以及空变体的限制。 在 C++17 发布后，Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 使用 https://wg21.link/p0739r0 修复了一个小缺陷。\n17 std::any 一般来说，C++ 是一种具有类型绑定和类型安全性的语言。值对象被声明为具有特定类型，它定义了哪些操作是可能的以及它们的行为方式。并且值对象不能改变它们的类型。\nstd::any 是一种能够改变其类型的值类型，同时仍具有类型安全性。也就是说，对象可以保存任意类型的值，但它们知道当前保存的值是哪种类型。声明此类型的对象时无需指定可能的类型。\n诀窍是对象既包含包含的值，也包含使用 typeid 的包含值的类型。因为该值可以具有任何大小，所以内存可能会在堆上分配。但是，实现应避免将堆内存用于包含的小值，例如 int。\n也就是说，如果您分配一个字符串，该对象会为该值分配内存并复制该字符串，同时还在内部存储分配的字符串。稍后，可以进行运行时检查以找出当前值具有哪种类型，并将该值用作其类型，any_cast\u0026lt;\u0026gt; 是必要的。\n至于 std::optional\u0026lt;\u0026gt; 和 std::variant\u0026lt;\u0026gt; 结果对象具有值语义。也就是说，通过在自己的内存中创建一个具有当前包含值及其类型的独立对象来进行深度复制。因为可能涉及堆内存，所以复制 std::any 通常很昂贵，您应该更喜欢通过引用传递对象或移动值。部分支持移动语义。\n17.1 使用 std::any 以下示例演示了 std::any 的核心功能：\nstd::any a; // a 为空 std::any b = 4.3; // b 具有 double 类型的值 4.3 a = 42; // a 具有 int 类型的值 42 b = std::string{\u0026#34;hi\u0026#34;}; // b 具有 std::string 类型的值 \u0026#34;hi\u0026#34; if (a.type() == typeid(std::string)) { std::string s = std::any_cast\u0026lt;std::string\u0026gt;(a); useString(s); } else if (a.type() == typeid(int)) { useInt(std::any_cast\u0026lt;int\u0026gt;(a)); } 您可以将 std::any 声明为空或由特定类型的值初始化。 初始值的类型成为包含值的类型。\n通过使用成员函数 type()，您可以根据任何类型的类型 ID 检查包含值的类型。 如果对象为空，则类型 ID 为 typeid(void)。\n要访问包含的值，您必须使用 std::any_cast\u0026lt;\u0026gt; 将其转换为它的类型：\nauto s = std::any_cast\u0026lt;std::string\u0026gt;(a); 如果转换失败，因为对象为空或包含的类型不适合，则抛出 std::bad_any_cast。 因此，在不检查或不知道类型的情况下，您最好实现以下内容：\ntry { auto s = std::any_cast\u0026lt;std::string\u0026gt;(a); ... } catch (std::bad_any_cast\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 注意 std::any_cast\u0026lt;\u0026gt; 创建一个传递类型的对象。 如果您将 std::string 作为模板参数传递给 std::any_cast\u0026lt;\u0026gt;，它会创建一个临时字符串（prvalue），然后用于初始化新对象 s。 如果没有这样的初始化，通常最好转换为引用类型以避免创建临时对象：\nstd::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a); 为了能够修改该值，您需要强制转换为相应的引用类型：\nstd::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(a) = \u0026#34;world\u0026#34;; 您还可以调用 std::any_cast 以获得 std::any 对象的地址。 在这种情况下，如果类型适合，则强制转换返回相应的指针，否则返回 nullptr：\nauto p = std::any_cast\u0026lt;std::string\u0026gt;(\u0026amp;a); if (p) { ... } 要清空现有的 std::any 对象，您可以调用：\na.reset(); // 使其为空 或者：\na = std::any{}; 要不就：\na = {}; 您可以直接检查对象是否为空：\nif (a.has_value()) { ... } 另请注意，值是使用其衰减类型存储的（数组转换为指针，顶级引用和 const 被忽略）。 对于字符串文字，这意味着值类型是 const char*。\n要检查 type() 并使用 std::any_cast\u0026lt;\u0026gt; 您必须完全使用这种类型：\nstd::any a = \u0026#34;hello\u0026#34;; // type() is const char* if (a.type() == typeid(const char*)) { // true ... } if (a.type() == typeid(std::string)) { // false ... } std::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;const char*\u0026gt;(v[1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK std::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;std::string\u0026gt;(v[1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // EXCEPTION 这些或多或少都是所有操作。 没有定义比较运算符（因此，您不能比较或排序对象），没有定义散列函数，也没有定义 value() 成员函数。 并且因为类型只在运行时才知道，所以不能使用通用 lambda 来处理独立于其类型的当前值。 您总是需要运行时函数 std::any_cast\u0026lt;\u0026gt; 才能处理当前值，这意味着在处理值时需要一些特定于类型的代码来重新进入 C++ 类型系统。\n但是，可以将 std::any 对象放入容器中。 例如：\nstd::vector\u0026lt;std::any\u0026gt; v; v.push_back(42); std::string s = \u0026#34;hello\u0026#34;; v.push_back(s); for (const auto\u0026amp; a : v) { if (a.type() == typeid(std::string)) { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if (a.type() == typeid(int)) { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::any_cast\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 17.2 std::any 类型和操作 本节详细介绍 std::any 的类型和操作。\n17.2.1 Any 类型 在头文件 中，C++ 标准库定义类 std::any 如下：\nnamespace std { class any; } 也就是说， std::any 根本不是类模板。 此外，还定义了以下类型和对象：\n异常类std::bad_any_cast，派生自std::bad_cast，派生自std::exception，如果类型转换失败。 任何对象也使用 中定义的对象 std::in_place_type（类型为 std::in_place_type_t）。\n17.2.2 Any 操作 表 std::any 操作列出了为 std::any 提供的所有操作。\nOperation 作用 constructors 创建一个任意对象（可能调用底层类型的构造函数） make_any() 创建一个任意对象（传递值来初始化它） destructor 销毁任何对象 = 分配一个新值 emplace() 分配一个类型为 T 的新值 reset() 销毁任何值（使对象为空） has_value() 返回对象是否有值 type() 将当前类型作为 std::type_info 对象返回 any_cast() 使用当前值作为类型 T 的值（其他类型除外） swap() 在两个对象之间交换值 构造 默认情况下， std::any 初始化为空。\nstd::any a1; // a1 为空 如果一个值被传递给初始化，它的衰减类型被用作包含值的类型：\nstd::any a2 = 42; // a2 包含 int 类型的值 std::any a3 = \u0026#34;hello\u0026#34;; // a2 包含 const char* 类型的值 要保存与初始值类型不同的类型，您必须使用 in_place_type 标签：\nstd::any a4{std::in_place_type\u0026lt;long\u0026gt;, 42}; std::any a5{std::in_place_type\u0026lt;std::string\u0026gt;, \u0026#34;hello\u0026#34;}; 甚至传递给 in_place_type 的类型也会衰减。 以下声明包含一个 const char*：\nstd::any a5b{std::in_place_type\u0026lt;const char[6]\u0026gt;, \u0026#34;hello\u0026#34;}; 要通过多个参数初始化可选对象，您必须创建对象或添加 std::in_place_type 作为第一个参数（无法推断包含的类型）：\nstd::any a6{std::complex{3.0, 4.0}}; std::any a7{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 3.0, 4.0}; 你甚至可以传递一个初始化列表，后跟其他参数：\n// initialize a std::any with a set with lambda as sorting criterion: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::any a8{std::in_place_type\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt;, {4, 8, -7, -2, 0, 5}, sc}; 请注意，还有一个便利函数 make_any\u0026lt;\u0026gt;()，可用于单个或多个参数（不需要 in_place_type 参数）。 您始终必须明确指定初始化类型（如果仅传递一个参数，则不会推导出）：\nauto a10 = std::make_any\u0026lt;float\u0026gt;(3.0); auto a11 = std::make_any\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;); auto a13 = std::make_any\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;(3.0, 4.0); auto a14 = std::make_any\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt;({4, 8, -7, -2, 0, 5}, sc); 更改值 存在相应的赋值和 emplace() 操作。 例如：\nstd::any a; a = 42; // a 包含 int 类型的值 a = \u0026#34;hello\u0026#34;; // a 包含 const char* 类型的值 a.emplace{std::in_place_type\u0026lt;std::string\u0026gt;, \u0026#34;hello\u0026#34;}; // a 包含 std::string 类型的值 a.emplace{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 4.4, 5.5}; // a 包含 std::complex\u0026lt;double\u0026gt; 类型的值 访问值 要访问包含的值，您必须使用 std::any_cast\u0026lt;\u0026gt; 将其转换为它的类型。 要将值转换为字符串，您有几个选项：\nstd::any_cast\u0026lt;std::string\u0026gt;(a) // 生成值的副本 std::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(a); // 通过引用写入值 std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a); // 引用读访问 在这里，如果转换失败，则抛出 std::bad_any_cast 异常。 如果删除了顶级引用的传递类型具有相同的类型 ID，则该类型适合。 如果转换失败，您可以传递一个地址来获取 nullptr，因为当前类型不适合：\nstd::any_cast\u0026lt;std::string\u0026gt;(\u0026amp;a) // 通过指针写访问 std::any_cast\u0026lt;const std::string\u0026gt;(\u0026amp;a); // 通过指针读取访问 请注意，此处转换为引用会导致运行时错误：\nstd::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(\u0026amp;a); // RUN-TIME ERROR 移动语义 std::any 还支持移动语义。 但是，请注意，仅具有复制语义的类型才支持移动语义。 也就是说，不支持将仅移动类型作为包含值类型。\n处理移动语义的最佳方式可能并不明显。 所以，这里是你应该怎么做：\nstd::string s(\u0026#34;hello, world!\u0026#34;); std::any a; a = std::move(s); // move s into a s = std::move(std::any_cast\u0026lt;string\u0026amp;\u0026gt;(a)); // 将 a 中的分配字符串移动到 s 像往常一样，对于移出对象，在最后一次调用之后，a 的包含值是未指定的。 因此，只要不假设包含的字符串值具有哪个值，就可以将 a 用作字符串。 以下语句的输出可能是空字符串，而不是“NIL”：\nstd::cout \u0026lt;\u0026lt; (a.has_value() ? std::any_cast\u0026lt;std::string\u0026gt;(a) : std::string(\u0026#34;NIL\u0026#34;)); 注意：\ns = std::any_cast\u0026lt;string\u0026gt;(std::move(a)); 也可以，但需要额外的动作。\n直接转换为右值引用不会编译：\ns = std::any_cast\u0026lt;std::string\u0026amp;\u0026amp;\u0026gt;(a); // compile-time error 请注意，而不是调用\na = std::move(s); // 将 s 移动到 a 以下可能并不总是有效（尽管它是 C++ 标准中的一个示例）：\nstd::any_cast\u0026lt;string\u0026amp;\u0026gt;(a) = std::move(s); // OOPS: a 必须持有一个字符串 这仅在 a 已经包含 std::string 类型的值时才有效。 如果不是，则在我们移动分配新值之前，演员表会抛出一个 std::bad_any_cast 异常。\n17.3 后记 2006 年，Kevlin Henney 和 Beman Dawes 在 https://wg21.link/n1939 中首次提出任何对象，将 Boost.Any 作为参考实现。 正如 Beman Dawes、Kevlin Henney 和 Daniel Krugler 在 https://wg21.link/n3804 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。\n正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。\nVicente J. Botet Escriba 将 API 与 std::variant\u0026lt;\u0026gt; 和 std::optional\u0026lt;\u0026gt; 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。\n18 std::byte 程序将数据保存在内存中。 对于 std::byte，C++17 为它引入了一种类型，它确实代表了内存元素字节的“自然”类型。 与 char 或 int 等类型的主要区别在于，这种类型不能（容易）（ab）用作整数值或字符类型。 对于数字计算或字符序列不是目标的情况，这会带来更多的类型安全性。\n唯一支持的“计算”操作是按位运算符。\n18.1 使用 std::byte 以下示例演示了 std::byte 的核心功能：\n#include \u0026lt;cstddef\u0026gt; // for std::byte std::byte b1{0x3F}; std::byte b2{0b1111’0000}; std::byte b3[4] {b1, b2, std::byte{1}}; // 4 bytes (last is 0) if (b1 == b3[0]) { b1 \u0026lt;\u0026lt;= 1; } std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // outputs: 126 在这里，我们定义了两个具有两个不同初始值的字节。 b2 使用自 C++14 以来可用的两个功能进行初始化：\n前缀 0b 可以定义二进制文字。 数字分隔符 \u0026rsquo; 允许使数字文字在源代码中更具可读性（它可以放在数字文字的任意两位之间）。 请注意，列表初始化（使用花括号）是您可以直接初始化 std::byte 对象的单个值的唯一方法。 所有其他形式不编译：\nstd::byte b1{42}; // ok（对于自 C++17 以来具有固定基础类型的所有枚举） std::byte b2(42); // ERROR std::byte b3 = 42; // ERROR std::byte b4 = {42}; // ERROR 这是 std::byte 被实现为枚举类型这一事实的直接结果，使用可以用整数值初始化作用域枚举的新方式。 也没有隐式转换，因此您必须使用显式转换的整数文字来初始化字节数组：\nstd::byte b5[] {1}; // ERROR std::byte b6[] {std::byte{1}}; // OK 在没有任何初始化的情况下，堆栈上的对象的 std::byte 的值是未定义的：\nstd::byte b; // 未定义的值 像往常一样（除了原子），您可以通过列表初始化强制将所有位设置为零的初始化：\nstd::byte b{}; // 与b{0}一样 std::to_integer\u0026lt;\u0026gt;() 提供将字节对象用作整数值（包括 bool 和 char）的能力。 如果没有转换，输出运算符将无法编译。 请注意，因为它是一个模板，您甚至需要使用 std:: 完全限定的转换\nstd::cout \u0026lt;\u0026lt; b1; // ERROR std::cout \u0026lt;\u0026lt; to_integer\u0026lt;int\u0026gt;(b1); // ERROR (ADL 在这里不起作用) std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b1); // OK 这样的转换对于使用 std::byte 作为布尔值也是必要的。 例如：\nif (b2) ... // ERROR if (b2 != std::byte{0}) ... // OK if (to_integer\u0026lt;bool\u0026gt;(b2)) ... // ERROR (ADL 在这里不起作用) if (std::to_integer\u0026lt;bool\u0026gt;(b2)) ... // OK 因为 std::byte 被定义为枚举类型，底层类型为 unsigned char，所以 std::byte 的大小始终为 1：\nstd::cout \u0026lt;\u0026lt; sizeof(b); // always 1 位数取决于 unsigned char 类型的位数，您可以通过标准数字限制找到：\nstd::cout \u0026lt;\u0026lt; std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits; // std::byte 的位数 大多数时候是 8，但有些平台并非如此。\n18.2 std::byte 类型和操作 本节详细介绍 std::byte 的类型和操作。\n18.2.1 std::byte 类型 在头文件 中，C++ 标准库定义类型 std::byte 如下：\nnamespace std { enum class byte : unsigned char { }; } 也就是说，std::byte 只不过是一个范围枚举类型，其中定义了一些补充的按位运算符：\nnamespace std { ... template\u0026lt;typename IntType\u0026gt; constexpr byte operator\u0026lt;\u0026lt; (byte b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte\u0026amp; operator\u0026lt;\u0026lt;= (byte\u0026amp; b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte operator\u0026gt;\u0026gt; (byte b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte\u0026amp; operator\u0026gt;\u0026gt;= (byte\u0026amp; b, IntType shift) noexcept; constexpr byte\u0026amp; operator|= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator| (byte l, byte r) noexcept; constexpr byte\u0026amp; operator\u0026amp;= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator\u0026amp; (byte l, byte r) noexcept; constexpr byte\u0026amp; operator^= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator^ (byte l, byte r) noexcept; constexpr byte operator~ (byte b) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr IntType to_integer (byte b) noexcept; } 18.2.2 std::byte 操作 表 std::byte 操作列出了为 std::byte 提供的所有操作。\nOperation 作用 constructors 创建一个字节对象（使用默认构造函数未定义的值） destructor 销毁一个字节对象（什么都不做） = 分配一个新值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较字节对象 `\u0026laquo;, \u0026raquo;, , \u0026amp;, ^, ~` `\u0026laquo;=, \u0026raquo;=, =, \u0026amp;=, ^=` to_integer() 将字节对象转换为整型 T sizeof() Yields 1 转换为整型 通过使用 to_integer\u0026lt;\u0026gt;()，您可以将 std::byte 转换为任何基本的整数类型（bool、字符类型或整数类型）。 例如，这是将 std::byte 与数值进行比较或在条件中使用它所必需的：\nif (b2) ... // ERROR if (b2 != std::byte{0}) ... // OK if (to_integer\u0026lt;bool\u0026gt;(b2)) ... // ERROR (ADL 在这里不起作用) if (std::to_integer\u0026lt;bool\u0026gt;(b2)) ... // OK 另一个使用示例是 std::byte I/O to_integer\u0026lt;\u0026gt;() 使用从 unsigned char 到目标类型的静态转换规则。 例如：\nstd::byte ff{0xFF}; std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;unsigned int\u0026gt;(ff); // 255 std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(ff); // also 255 (没有负值) std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(std::to_integer\u0026lt;signed char\u0026gt;(ff)); // -1 带有 std::byte 的 I/O 没有为 std::byte 定义输入和输出运算符，因此您必须将它们转换为整数值：\nstd::byte b; ... std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b); // 将值打印为十进制值 std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b); // 将值打印为十六进制值 通过使用 std::bitset\u0026lt;\u0026gt;，您还可以将值输出为二进制值（位序列）：\n#include \u0026lt;bitset\u0026gt; #include \u0026lt;limits\u0026gt; using ByteBitset = std::bitset\u0026lt;std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits\u0026gt;; std::cout \u0026lt;\u0026lt; ByteBitset{std::to_integer\u0026lt;unsigned char\u0026gt;(b1)}; using 声明定义了一个 bitset 类型，其位数与 std::byte 一样，然后我们创建并输出这样一个用字节的整数类型初始化的对象。 您还可以使用它将 std::byte 的二进制表示形式写入字符串：\nstd::string s = ByteBitset{std::to_integer\u0026lt;unsigned char\u0026gt;(b1)}.to_string(); 输入方式类似：只需将值读取为整数、字符串或位集值并进行转换。 例如，您可以编写一个输入运算符，从二进制表示中读取一个字节，如下所示：\nstd::istream\u0026amp; operator\u0026gt;\u0026gt; (std::istream\u0026amp; strm, std::byte\u0026amp; b) { // 读入 bitset: std::bitset\u0026lt;std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits\u0026gt; bs; strm \u0026gt;\u0026gt; bs; // 没有失败，转换为 std::byte: if (! std::cin.fail()) { b = static_cast\u0026lt;std::byte\u0026gt;(bs.to_ulong()); // OK } return strm; } 请注意，我们必须使用 static_cast\u0026lt;\u0026gt;() 将 bitset 转换为 unsigned long 转换为 std::byte。 列表初始化不起作用，因为转换范围缩小：\nb = std::byte{bs.to_ulong()}; // ERROR: 缩小 而且我们没有其他的初始化方式.\n18.3 后记 std::byte 最初由 Neil MacIntosh 提出，传入 https://wg21.link/p0298r0。 最终接受的措辞由 Neil MacIntosh 在 https://wg21.link/p0298r3 中制定。\n19 String Views 在 C++17 中，C++ 标准库采用了一个特殊的字符串类，它允许我们处理像字符串这样的字符序列，而无需为它们分配内存：std::string_view。 也就是说，std::string_view 对象引用外部字符序列而不拥有它们。 也就是说，对象可以被认为是对字符序列的引用。\nstring_view 使用这样的字符串视图既便宜又快速（按值传递 string_view 总是很便宜）。 然而，它也有潜在的危险，因为与原始指针类似，程序员需要确保在使用 string_view 时引用的字符序列仍然有效）。\n19.1 与 std::string 的区别 与 std::string 相比，std::string_view 对象具有以下属性：\n底层字符序列是只读的。 没有允许修改字符的操作。 您只能分配新值、交换值以及删除开头或结尾的字符。\n不保证字符序列以空值结尾。 因此，字符串视图不是以空结尾的字节流 (NTBS)。\n该值可以是 nullptr，例如在使用默认构造函数初始化字符串视图后由 data() 返回。\n没有分配器支持。 由于可能的 nullptr 值和可能缺少的 null 终止符，您应该始终在通过 operator[] 或 data() 访问字符之前使用 size() （除非您知道得更好）。\n19.2 使用 String Views 字符串视图有两个主要应用：\n您可能已经使用字符序列或字符串分配或映射数据，并希望在不分配更多内存的情况下使用这些数据。典型的例子是使用内存映射文件或处理大文本中的子字符串。\n您想提高接收字符串的函数/操作的性能，只是直接以只读方式处理它们，不需要尾随的空终止符。 这种情况的一种特殊形式可能是将字符串文字处理为具有类似于字符串的 API 的对象：\nstatic constexpr std::string_view hello{\u0026#34;hello world\u0026#34;}; 第一个示例通常意味着通常只传递字符串视图，而编程逻辑必须确保底层字符序列保持有效（即，映射的文件内容未被取消映射）。在任何时候，您都可以使用字符串视图来初始化或将它们的值分配给 std::string。\n但请注意，使用字符串视图就像“更好的字符串”一样。这可能会导致更差的性能和严重的运行时错误。因此，请仔细阅读以下小节。\n19.3 使用与字符串相似的字符串视图 第一个示例，使用像只读字符串一样的 string_view，是一个打印带有作为字符串视图传递的前缀的元素集合的函数：\n#include \u0026lt;string_view\u0026gt; template\u0026lt;typename T\u0026gt; void printElems(const T\u0026amp; coll, std::string_view prefix = std::string_view{}) { for (const auto\u0026amp; elem : coll) { if (prefix.data()) { // 检查 nullptr std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 在这里，仅通过声明函数将采用 std::string_view，与采用 std::string 的函数相比，我们可以节省分配堆内存的调用。 详细信息取决于是否传递了短字符串以及是否使用了短字符串优化 (SSO)。 例如，如果我们将函数声明如下：\ntemplate\u0026lt;typename T\u0026gt; void printElems(const T\u0026amp; coll, const std::string\u0026amp; prefix = std::string{}); 我们传递一个字符串文字，调用会创建一个临时字符串，它将分配内存，除非字符串很短并且使用了短字符串优化。 通过使用字符串视图，不需要分配，因为字符串视图只引用字符串文字。\n但是，请注意，在使用字符串视图的任何未知值之前，必须根据 nullptr 检查 data()。\n另一个示例，使用像只读字符串一样的 string_view，是 std::optional\u0026lt;\u0026gt; 的 asInt() 示例的改进版本，它是为字符串参数声明的：\nlib/asint.cpp #include \u0026lt;optional\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;charconv\u0026gt; // 对于 from_chars() #include \u0026lt;iostream\u0026gt; // 如果可能，将字符串转换为 int: std::optional\u0026lt;int\u0026gt; asInt(std::string_view sv) { int val; // 将字符序列读入 int: auto [ptr, ec] = std::from_chars(sv.data(), sv.data()+sv.size(), val); // 如果我们有错误代码，则不返回任何值: if (ec != std::errc{}) { return std::nullopt; } return val; } int main() { for (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 如果可能，尝试将 s 转换为 int 并打印结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int\\n\u0026#34;; } } } 现在， asInt() 按值获取字符串视图。但是，这会产生重大影响。首先，使用 std::stoi() 创建整数不再有意义，因为 stoi() 接受一个字符串，而从字符串视图创建一个字符串是一项相对昂贵的操作。\n相反，我们将字符串视图的字符范围传递给新的标准库函数 std::from_chars()。它需要一对原始字符指针来转换字符的开头和结尾。请注意，这意味着我们可以跳过对空字符串视图的任何特殊处理，其中 data() 为 nullptr 且 size() 为 0，因为从 nullptr 到 nullptr+0 的范围是有效的空范围（对于添加的任何指针类型0 受支持且无效）。\nstd_from_chars() 返回一个 std::from_chars_result，它是一个具有两个成员的结构，一个指向未处理的第一个字符的指针 ptr 和一个 std::errc ec，其中 std::errc 表示没有错误。因此，在使用返回值的 ec 成员（使用结构化绑定）初始化 ec 后，如果转换失败，则以下检查返回 nullopt：\nif (ec != std::errc{}) { return std::nullopt; } 在对子字符串进行排序时，使用字符串视图还可以显着提高性能。\n19.3.1 被认为是有害的字符串视图 通常，诸如智能指针之类的“智能对象”被认为比相应的语言功能更安全（或至少不更危险）。 因此，给人的印象可能是字符串视图（一种字符串引用）更安全，或者至少与使用字符串引用一样安全。 但不幸的是，事实并非如此。 字符串视图实际上比字符串引用或智能指针更危险。 它们的行为更像原始字符指针。\n不要将字符串分配给字符串视图 考虑我们声明一个返回新字符串的函数：\nstd::string retString(); 使用返回值通常很安全：\n将其分配给使用 auto 声明的字符串或对象是安全的（但可以移动，这通常是可以的，但没有最佳性能）：\nauto std::string s1 = retString(); // safe 如果可能的话，将返回值分配给字符串引用是非常安全的，只要我们在本地使用该对象，因为引用会将返回值的生命周期延长到其生命周期的末尾：\nstd::string\u0026amp; s2 = retString(); // 编译时错误（缺少常量） const std::string\u0026amp; s3 = retString(); // s3 延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK auto\u0026amp;\u0026amp; s4 = retString(); // s4 延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; 4 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 对于字符串视图，没有给出这种安全性。 它既不复制也不延长返回值的生命周期：\nstd::string_view sv = retString(); // sv 不会延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; sv \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 运行时错误：返回的字符串被破坏 在这里，返回的字符串在第一条语句的末尾被破坏，因此从字符串视图 sv 中引用它是一个致命的运行时错误，导致未定义的行为。 问题与调用时相同：\nconst char* p = retString().c_str(); 或者：\nauto p = retString().c_str(); 出于这个原因，您还应该非常小心地返回一个字符串视图：\n// 非常危险: std::string_view substring(const std::string\u0026amp;, std::size_t idx = 0); // 因为: auto sub = substring(\u0026#34;very nice\u0026#34;, 5); // 将视图返回到传递的临时字符串 // 但调用后临时字符串被破坏 std::cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 运行时错误：tmp 字符串已被破坏 不要将字符串视图返回给字符串 尤其是让字符串成员的 getter 返回字符串视图是一种非常危险的设计。 因此，您不应执行以下操作：\nclass Person { std::string name; public: Person (std::string n) : name{std::move(n)} { } std::string_view getName() const { // don’t do this return name; } }; 因为，同样，以下结果将成为致命的运行时错误，导致未定义的行为：\nPerson createPerson(); auto n = createPerson().getName(); // OOPS：删除临时字符串 std::cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 致命的运行时错误 如果 getName() 按值或按引用返回字符串，这又是一个问题。\n函数模板应该使用返回类型 auto 请注意，很容易意外地将返回的字符串分配给字符串视图。 例如，考虑两个单独看起来非常有用的函数的定义：\n// 为返回字符串的字符串视图定义 +: std::string operator+ (std::string_view sv1, std::string_view sv2) { return std::string(sv1) + std::string(sv2); } // 泛型串联: template\u0026lt;typename T\u0026gt; T concat (const T\u0026amp; x, const T\u0026amp; y) { return x + y; } 但是，再次将它们一起使用可能很容易导致致命的运行时错误：\nstd::string_view hi = \u0026#34;hi\u0026#34;; auto xy = concat(hi, hi); // xy 是 std::string_view std::cout \u0026lt;\u0026lt; xy \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 致命的运行时错误：引用的字符串被破坏 这样的代码很容易被意外编写。 这里真正的问题是 concat() 的返回类型。 如果声明它的返回类型由编译器推断，上面的示例将 xy 初始化为 std::string：\n// 改进的通用连接: template\u0026lt;typename T\u0026gt; auto concat (const T\u0026amp; x, const T\u0026amp; y) { return x + y; } 此外，在调用链中使用字符串视图会适得其反，因为在调用链中或在其末尾需要字符串。 例如，如果您使用以下构造函数定义类 Person：\nclass Person { std::string name; public: Person (std::string_view n) : name{n} { } ... }; 传递您仍然需要的字符串文字或字符串很好：\nPerson p1{\u0026#34;Jim\u0026#34;}; // 没有性能开销 std::string s = \u0026#34;Joe\u0026#34;; Person p2{s}; // 没有性能开销 但是在字符串中移动变得不必要的昂贵，因为传递的字符串首先被隐式转换为字符串视图，然后用于创建一个新的字符串再次分配内存：\nPerson p3{std::move(s)}; // 性能开销：移动损坏 不要在这里处理 std::string_view 。 按值取参数并将其移动到成员仍然是最好的解决方案。 因此，构造函数和 getter 应该如下所示：\nclass Person { std::string name; public: Person (std::string n) : name{std::move(n)} { } std::string getName() const { return name; } }; 字符串视图的安全使用总结 总而言之，请谨慎使用 std::string_view，这意味着您还应该更改 您编程的一般风格：\n不要在 API 中使用将参数传递给字符串的字符串视图。 – 不要从字符串视图参数初始化字符串成员。 – 字符串视图链的末尾没有字符串。 不要返回字符串视图。 – 除非它只是一个转发的输入参数，或者您通过例如相应地命名函数来发出危险信号。 出于这个原因，函数模板永远不应该返回传递的泛型参数的类型 T。 – 改为返回 auto。 永远不要使用返回值来初始化字符串视图。 出于这个原因，不要将返回泛型类型的函数模板的返回值分配给 auto。 – 这意味着，AAA（几乎总是自动）模式被字符串视图打破。 如果这些规则太复杂或难以遵循，请不要使用 std::string_view （除非您知道自己在做什么）。 19.4 String View 类型和操作 本节详细介绍字符串视图的类型和操作。\n19.4.1 具体字符串视图类型 在头文件 \u0026lt;string_view\u0026gt; 中，C++ 标准库提供了一些类 basic_string_view\u0026lt;\u0026gt; 的特化：\n类 std::string_view 是该模板的预定义特化，用于 char 类型的字符： namespace std { using string_view = basic_string_view\u0026lt;char\u0026gt;; } 对于使用更广泛字符集（例如 Unicode 或某些亚洲字符集）的字符串，预定义了其他三种类型： namespace std { using u16string_view = basic_string_view\u0026lt;char16_t\u0026gt;; using u32string_view = basic_string_view\u0026lt;char32_t\u0026gt;; using wstring_view = basic_string_view\u0026lt;wchar_t\u0026gt;; } 在以下部分中，这些类型的字符串视图之间没有区别。用法和问题是相同的，因为所有字符串视图类都具有相同的接口。因此，“字符串视图”表示任何字符串视图类型：string_view、u16string_view、u32string_view 和 wstring_view。本书中的示例通常使用 string_view 类型，因为欧洲和英美环境是软件开发的常见环境。\n19.4.2 字符串视图操作 表字符串视图操作列出了为字符串视图提供的所有操作。 除了 remove_prefix() 和 remove_suffix() 之外，还为 std::strings 提供了字符串视图的所有操作。 但是，保证可能略有不同，因为对于字符串视图， data() 返回的值可能是 nullptr 并且缺少保证以空终止符结束序列。\n操作 作用 constructors 创建或复制字符串视图 destructor 销毁字符串视图 = 分配一个新值 swap() 在两个字符串视图之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, compare() 比较字符串视图 empty() 返回字符串视图是否为空 size(), length() 返回字符数 max_size() 返回最大可能的字符数 [], at() 访问一个字符 front(), back() 访问第一个或最后一个字符 \u0026laquo; 将值写入流 copy() 将内容复制或写入字符数组 data() 将值作为 nullptr 或常量字符返回，数组（注意：没有终止空字符） find functions 搜索某个子字符串或字符 begin(), end() 提供正常的迭代器支持 cbegin(), cend() 提供常量迭代器支持 rbegin(), rend() 提供反向迭代器支持 crbegin(), crend() 提供常量反向迭代器支持 substr() 返回某个子字符串 remove_prefix() 删除前导字符 remove_suffix() 删除尾随字符 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 构造 您可以使用默认构造函数创建字符串视图，作为副本，从原始字符数组（以 null 终止或具有指定长度），从 std::string 或作为带有后缀 sv 的文字。 但是，请注意以下几点：\n使用默认构造函数创建的字符串视图将 nullptr 作为 data()。 因此，没有有效的 operator[] 调用。\nstd::string_view sv; auto p = sv.data(); // 产生 nullptr std::cout \u0026lt;\u0026lt; sv[0]; // ERROR: 没有有效字符 当通过空终止字节流初始化字符串视图时，结果大小是不带 \u0026lsquo;\\0\u0026rsquo; 的字符数，并且使用终止空字符的索引是无效的：\nstd::string_view sv{\u0026#34;hello\u0026#34;}; std::cout \u0026lt;\u0026lt; sv; // OK std::cout \u0026lt;\u0026lt; sv.size(); // 5 std::cout \u0026lt;\u0026lt; sv.at(5); // 抛出 std::out_of_range 异常 std::cout \u0026lt;\u0026lt; sv[5]; // 未定义的行为，但在这里它通常有效 std::cout \u0026lt;\u0026lt; sv.data(); // 未定义的行为，但在这里它通常有效 最后两个调用是形式上未定义的行为。 因此，它们不能保证工作，尽管在这种情况下您可以假设在最后一个字符之后有空终止符。 您可以通过传递包括空终止符在内的字符数来初始化具有空终止符作为其值的一部分的字符串视图：\nstd::string_view sv{\u0026#34;hello\u0026#34;, 6}; // NOTE: 6 to include ’\\0’ std::cout \u0026lt;\u0026lt; sv.size(); // 6 std::cout \u0026lt;\u0026lt; sv.at(5); // OK, 打印 ’\\0’的值 std::cout \u0026lt;\u0026lt; sv[5]; // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::cout \u0026lt;\u0026lt; sv.data(); // OK 要从 std::string 创建字符串视图，std::string 类中提供了隐式转换运算符。 同样，在最后一个字符之后有空终止符，通常保证字符串，不保证字符串视图存在：\nstd::string s = \u0026#34;hello\u0026#34;; std::cout \u0026lt;\u0026lt; s.size(); // 5 std::cout \u0026lt;\u0026lt; s.at(5); // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::cout \u0026lt;\u0026lt; s[5]; // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::string_view sv{s}; std::cout \u0026lt;\u0026lt; sv.size(); // 5 std::cout \u0026lt;\u0026lt; sv.at(5); // 抛出 std::out_of_range 异常 std::cout \u0026lt;\u0026lt; sv[5]; // 未定义的行为，但在这里它通常有效 std::cout \u0026lt;\u0026lt; sv.data(); // 未定义的行为，但在这里它通常有效 由于为后缀 sv 定义了文字运算符，因此您还可以创建一个字符串视图，如下所示：\nusing namespace std::literals; auto s = \u0026#34;hello\u0026#34;sv; 这里的关键点是，通常你不应该期望空终止字符并且在访问字符之前总是使用 size() （除非你知道关于值的具体事情）。\n作为一种解决方法，您可以将 \u0026lsquo;\\0\u0026rsquo; 作为字符串视图的一部分，但您不应该使用字符串视图作为空终止字符串，而空终止符不是它的一部分，即使空终止符就在后面。\n散列 C++ 标准库保证字符串和字符串视图的哈希值是相等的。\n修改字符串视图 只提供了几个操作来修改字符串视图：\n您可以分配一个新值或交换两个字符串视图的值：\nstd::string_view sv1 = \u0026#34;hey\u0026#34;; std::string_view sv2 = \u0026#34;world\u0026#34;; sv1.swap(sv2); sv2 = sv1; 您可以跳过前导或尾随字符（即，将开头移动到第一个字符后面的字符或将结尾移动到最后一个字符之前的字符）。\nstd::string_view sv = \u0026#34;I like my kindergarten\u0026#34;; sv.remove_prefix(2); sv.remove_suffix(8); std::cout \u0026lt;\u0026lt; sv; // prints: like my kind ​ 请注意，不支持 operator+。 因此：\nstd::string_view sv1 = \u0026#34;hello\u0026#34;; std::string_view sv2 = \u0026#34;world\u0026#34;; auto s1 = sv1 + sv2; // ERROR 其中一个操作数必须是字符串：\nauto s2 = std::string(sv1) + sv2; // OK 请注意，没有隐式转换为字符串，因为这是一项昂贵的操作，因为它可能会分配内存。 因此，只能进行显式转换。\n19.4.3 其他类型的字符串视图支持 原则上，可以传递字符串的每个地方也传递字符串视图是有意义的，期望接收者何时需要将该值以空值终止（例如，通过将值传递给字符串的 C 函数）。\n​\t但是，到目前为止，我们只添加了对最重要的地方的支持：\n字符串可以在有用的地方使用或与字符串视图结合使用。 您可以从中创建一个字符串（构造函数是显式的）、分配、追加、插入、替换、比较或通过传递字符串视图来查找子字符串。 还有从字符串到字符串视图的隐式转换。 你可以将一个字符串视图传递给std::quoted，它可以打印出其带引号的值。比如说: using namespace std::literals; auto s = R\u0026#34;\u0026#34;(some\\value) \u0026#34;sv; // 原始字符串视图 std::cout \u0026lt;\u0026lt; std::quoted(s); // 输出。\u0026#34;some\\value\u0026#34; 你可以用字符串视图初始化、扩展或比较文件系统路径。 但是，例如，在C++标准库的regex组件中还没有对字符串视图的支持。标准库中，还没有对字符串视图的支持。\n19.5 使用 String Views in API’s 字符串视图很便宜，每个std::string都可以作为一个字符串视图使用。所以，似乎std::string_view是处理字符串参数的更好的类型。嗯，细节很重要\u0026hellip; 首先，使用std::string_view只有在使用该参数的函数具有以下条件时才有意义 以下的限制条件时，使用std::string_view才有意义。\n它不期望在结尾处有一个空的终结符。例如，当把参数作为一个单一的const char*传递给C函数时，情况就不是这样了。\n它尊重所传递参数的生命周期。通常这意味着接收函数只使用传递的值，直到它结束。\n调用函数不应该处理底层字符的所有者（比如删除它，改变它的值，或者释放它的内存）。\n它可以将nullptr作为值来处理。 请注意，如果你同时为std::string和std::string_view的函数重载，可能会出现歧义错误。std::string_view。\nvoid foo(const std::string\u0026amp;); void foo(std::string_view); foo(\u0026#34;hello\u0026#34;); // ERROR: 模糊的 19.5.1 使用用于初始化字符串的字符串视图 看起来字符串视图的一个简单而有用的应用是在初始化字符串时将其声明为参数类型 当初始化一个字符串时。但是要注意!\n考虑用 \u0026ldquo;老办法 \u0026ldquo;来初始化一个字符串成员。\nclass Person { std::string name; public: Person (const std::string\u0026amp; n) : name(n) { } ... }; 这个构造函数有其缺点。用一个字符串字头初始化一个人，会产生一个不必要的拷贝，这可能会导致对堆内存的不必要的请求。比如说:\nPerson p(\u0026#34;Aprettylong NonSSO Name\u0026#34;); 首先调用 std::string 构造函数来创建临时参数 n，因为请求了 std::string 类型的引用。 如果字符串很长或没有启用短字符串优化，这意味着为字符串值分配堆内存。 即使使用移动语义，临时字符串也会被复制以初始化成员名称，这意味着再次分配内存。 您只能通过添加更多构造函数重载或引入模板构造函数来避免这种开销，这可能会导致其他问题。 相反，如果我们使用字符串视图，性能会更好：\nclass Person { std::string name; public: Person (std::string_view n) : name(n) { } ... }; 现在，一个临时的字符串视图n被创建，它根本不分配内存，因为字符串视图只引用了字符串字面的字符。只有name的初始化为成员name分配了一次内存。\n然而，有一个问题：如果你传递一个临时字符串或用std::move()标记的字符串，该字符串被转换为字符串视图的类型（这很便宜），然后字符串视图被用来为新字符串分配内存（这很昂贵）。换句话说。使用字符串视图会禁用移动语义，除非你为它提供一个额外的重载。\n对于如何初始化带有字符串成员的对象，仍然有明确的建议。以 字符串的值和移动。\nclass Person { std::string name; public: Person (std::string n) : name(std::move(n)) { } ... }; 无论如何，我们必须创建一个字符串。因此，尽快创建它可以使我们在传递参数的那一刻就能从所有可能的优化中受益。当我们拥有它时，我们只需移动，这是一个廉价的操作。\n如果我们通过一个返回临时字符串的辅助函数来初始化这个字符串:\nstd::string newName() { ...; return std::string{...}; } Person p{newName()}; 强制性的复制消除将推迟新字符串的物化，直到该值被传递给构造函数。在那里我们有一个名为n的字符串，这样我们就有了一个有位置的对象（一个glvalue）。 然后这个对象的值被移动到初始化成员名。 这个例子再次证明了。\n字符串视图并不是一个更好的取用字符串的接口。 事实上，字符串视图只应该在调用链中使用，在那里它们永远不必作为字符串使用 19.5.2 使用字符串视图而不是字符串 还有其他通过字符串视图替换字符串的可能。但还是要小心。 例如，用下面的代码代替:\n// 将时间点（带前缀）转换为字符串: std::string toString (const std::string\u0026amp; prefix, const std::chrono::system_clock::time_point\u0026amp; tp) { // 转换为日历时间: auto rawtime = std::chrono::system_clock::to_time_t(tp); std::string ts = std::ctime(\u0026amp;rawtime); // 注意：不是线程安全的 ts.resize(ts.size()-1); // 跳过尾随换行符 return prefix + ts; } 您可以实现以下内容：\nstd::string toString (std::string_view prefix, const std::chrono::system_clock::time_point\u0026amp; tp) { auto rawtime = std::chrono::system_clock::to_time_t(tp); std::string_view ts = std::ctime(\u0026amp;rawtime); // 注意：不是线程安全的 ts.remove_suffix(1); // 跳过尾随换行符 return std::string(prefix) + ts; // 不幸的是还没有运算符 + } 除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。 但只是因为 ctime() 返回的 C 字符串在一段时间内有效（直到下一次调用 ctime() 或 asctime() 才有效）。 请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。 相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。\n19.6 后记 除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。但只是因为ctime()返回的C字符串有一段时间有效（一直有效到下一个有引用语义的字符串类是由Jeffrey Yasskin在https://wg21.link/n3334提出的（使用名称string_ref ). 该课程被 Jeffrey Yasskin 在 https://wg21.link/n3921 中提出的图书馆基础知识 TS 中采用。 正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。 Marshall Clow 在 https://wg21.link/p0254r2 和 https://wg21.link/p0403r1 以及 Nicolai Josuttis 在 https://wg21.link/p0392r0 中添加了一些用于更好集成的修改。 Daniel Krugler 的其他修复在 https://wg21.link/lwg2946 中（这可能是针对 C++17 的缺陷）。调用 ctime() 或 asctime())。请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。\n20 文件系统库 在C++17中，Boost.filesystem库最终被采纳为C++标准库。通过这样做，该库根据新的语言特性进行了调整，与库的其他部分更加一致，进行了清理，并对一些缺失的部分进行了扩展（比如计算文件系统路径之间相对路径的操作）。\n20.1 基本例子 让我们从一些基本的例子开始。\n20.1.1 打印一个通过文件系统路径的属性 以下程序允许我们使用传递的字符串作为文件系统路径来根据文件类型打印补丁的某些方面：\nfilesystem/checkpath1.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） if (is_regular_file(p)) { // 路径 p 是常规文件吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } else if (is_directory(p)) { // 路径 p 是目录吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } else if (exists(p)) { // 路径 p 真的存在吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a special file\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;path \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; does not exist\\n\u0026#34;; } } 我们首先将任何传递的命令行参数转换为文件系统路径：\nstd::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） 然后，我们执行以下检查：\n如果路径代表一个现有的常规文件，我们打印它的大小：\nif (is_regular_file(p)) { // 路径 p 是普通文件吗? std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } 调用这个程序如下：\ncheckpath checkpath.cpp 将输出如下内容：\n\u0026#34;checkpath.cpp\u0026#34; exists with 907 bytes 请注意，路径的输出运算符会自动写入引用的路径名（在双引号内，反斜杠被另一个反斜杠转义，这是 Windows 路径的一个问题）。\n如果文件系统路径作为目录存在，我们遍历目录中的文件并打印路径：\nif (is_directory(p)) { // 路径 p 是目录吗? std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator(p)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 这里我们使用了 directory_iterator，它提供了 begin() 和 end()，我们可以使用基于范围的 for 循环遍历 directory_entry 元素。 在这种情况下，我们使用 directory_entry 成员函数 path()，它产生条目的文件系统路径。 调用这个程序如下：\ncheckpath . 将输出如下内容：\n\u0026#34;.\u0026#34; is a directory containing: \u0026#34;./checkpath.cpp\u0026#34; \u0026#34;./checkpath.exe\u0026#34; ... 最后，我们检查传递的文件系统路径是否存在：\nif (!exists(p)) { // 路径 p 真的存在吗? ... } Windows下的路径处理 在 Windows 下，默认情况下路径被引用的事实是一个问题，因为通常的目录分隔符反斜杠总是被转义并写入两次。 因此，在 Windows 下调用该程序如下：\ncheckpath C:\\ 将输出如下内容：\n\u0026#34;C:\\\\\u0026#34; is a directory containing: ... \u0026#34;C:\\\\Users\u0026#34; \u0026#34;C:\\\\Windows\u0026#34; 写入引用的路径可确保写入的文件名可以读入程序，以便您取回原始文件名。 但是，对于标准输出，这通常是不可接受的。\n出于这个原因，在 Windows 下运行良好的可移植版本应该避免使用成员函数 string() 将引用的路径写入标准输出：\nfilesystem/checkpath2.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） if (is_regular_file(p)) { // 路径 p 是普通文件吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } else if (is_directory(p)) { // 路径 p 是目录吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } else if (exists(p)) { // 路径 p 真的存在吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a special file\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;path \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; does not exist\\n\u0026#34;; } } 现在，在 Windows 下调用这个程序如下：\ncheckpath C:\\ 将输出如下内容：\n\u0026#34;C:\\\u0026#34; is a directory containing: ... \u0026#34;C:\\Users\u0026#34; \u0026#34;C:\\Windows\u0026#34; 提供了其他转换以使用通用字符串格式或将字符串转换为本机编码。\n20.1.2 切换文件系统类型 我们仍然可以对之前的程序进行一些修改和改进，如下所示：\nfilesystem/checkpath3.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } namespace fs = std::filesystem; switch (fs::path p{argv[1]}; status(p).type()) { case fs::file_type::not_found: std::cout \u0026lt;\u0026lt; \u0026#34;path \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; does not exist\\n\u0026#34;; break; case fs::file_type::regular: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; break; case fs::file_type::directory: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } break; default: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a special file\\n\u0026#34;; break; } } 命名空间 fs 首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：\nnamespace fs = std::filesystem; 使用这个命名空间，我们初始化，例如，switch 语句中的路径 p：\nfs::path p{argv[1]}; switch 语句是带有初始化的新 switch 的应用，我们在其中初始化路径并为其类型提供不同的情况：\nswitch (fs::path p{argv[1]}; status(p).type()) { ... } 表达式 status(p).type() 创建一个 file_status，type() 为此创建一个 file_type。 这样我们就可以直接处理不同的类型，而不是像 is_regular_file()、is_directory() 等一连串的调用。 提供类型是在多个步骤中有意提供的，这样如果我们对状态信息不感兴趣，我们就不必支付操作系统调用的代价。\n另请注意，特定于实现的 file_type 可能存在。 例如，Windows 提供了特殊的文件类型连接。 但是使用它不是便携式的。\n20.1.3 创建不同类型的文件 在仅对文件系统进行读取访问之后，现在让我们给出第一个修改它的示例。 以下程序在子目录 tmp 中创建不同类型的文件：\nfilesystem/createfiles.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;filesystem\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main () { namespace fs = std::filesystem; try { // 创建目录 tmp/test/（如果它们还不存在）: fs::path testDir{\u0026#34;tmp/test\u0026#34;}; create_directories(testDir); // 创建数据文件 tmp/test/data.txt: auto testFile = testDir / \u0026#34;data.txt\u0026#34;; std::ofstream dataFile{testFile}; if (!dataFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, can\u0026#39;t open \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testFile.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; std::exit(EXIT_FAILURE); // 退出程序失败 } dataFile \u0026lt;\u0026lt; \u0026#34;The answer is 42\\n\u0026#34;; // 创建从 tmp/slink/ 到 tmp/test/ 的符号链接: create_directory_symlink(\u0026#34;test\u0026#34;, testDir.parent_path() / \u0026#34;slink\u0026#34;); // 递归列出所有文件（也遵循符号链接） std::cout \u0026lt;\u0026lt; fs::current_path().string() \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; auto iterOpts{fs::directory_options::follow_directory_symlink}; for (const auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } catch (fs::filesystem_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34; path1: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path1().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } 让我们一步一步地完成这个程序。\n命名空间 fs 首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：\nnamespace fs = std::filesystem; 例如，我们使用这个命名空间初始化临时文件的基本子目录的路径：\nfs::path testDir{\u0026#34;tmp/test\u0026#34;}; 创建目录 然后我们尝试创建子目录：\ncreate_directories(testDir); 通过使用 create_directories() 我们创建整个传递路径的所有缺失目录（还有 create_directory() 仅在现有目录内创建目录）。\n如果目录已经存在，则执行此调用不是错误。 但是，任何其他问题都是错误并引发相应的异常。\n如果 testDir 已经存在，create_directories() 返回 false。 因此，您也可以调用：\nif (!create_directories(testDir)) { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testDir.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; already exists\\n\u0026#34;; } 但是，请注意，如果 testDir 存在但不是目录，这也不是错误。 因此，返回 true 并不意味着在调用之后有一个具有请求名称的目录。 我们可以检查一下，但在这种情况下，这是间接涉及的，因为下一次在目录中创建文件的调用将失败。 但是，错误消息可能会令人困惑。 为了获得更好的错误消息，您可能需要检查之后是否真的存在目录。\n创建常规文件 然后我们创建一个包含一些内容的新文件 /tmp/test/data.txt：\nauto testFile = testDir / \u0026#34;data.txt\u0026#34;; std::ofstream dataFile(testFile); if (!dataFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, can\u0026#39;t open \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testFile.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; std::exit(EXIT_FAILURE); // 退出程序失败 } dataFile \u0026lt;\u0026lt; \u0026#34;The answer is 42\\n\u0026#34;; 这里我们使用运算符 / 来扩展路径，然后我们将其作为参数传递给文件流的构造函数。 如您所见，常规文件的创建仍然只能使用现有的 I/O 流库来完成。 但是，为构造函数提供了一个新的重载，以便能够直接传递文件系统路径。 请注意，您仍应始终检查创建/打开文件是否成功。 很多事情都可能在这里出错（见下文）。\n创建符号链接 下一条语句尝试创建一个引用目录 tmp/test 的符号链接 tmp/slink：\ncreate_directory_symlink(\u0026#34;test\u0026#34;, testDir.parent_path() / \u0026#34;slink\u0026#34;); 请注意，第一个参数定义了创建链接视图的路径。 因此，您必须通过“test”而不是“tmp/test”才能有效地从 tmp/slink 链接到 tmp/test。 如果你调用：\nstd::filesystem::create_directory_symlink(\u0026#34;tmp/test\u0026#34;, \u0026#34;tmp/slink\u0026#34;); 您将有效地创建 tmp/slink 作为指向 tmp/tmp/test 的符号链接。\n请注意，通常调用 create_symlink() 而不是 create_directory_symlink() 也可以，但是某些操作系统对目录的符号链接有特殊处理，或者当它们知道文件是目录时执行得更好，因此如果您应该使用 create_directory_symlink() 知道符号链接是指一个目录。\n目录递归 最后，我们递归地列出当前目录：\nauto iterOpts = fs::directory_options::follow_directory_symlink; for (auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 因为我们使用递归目录迭代器并传递选项以跟随符号链接，follow_directory_symlink，我们应该在基于 POSIX 的系统上获得如下输出：\n# /home/nico: ... tmp tmp/slink tmp/slink/data.txt tmp/test tmp/test/data.txt ... 在 Windows 系统上的输出如下所示：\n# C:/Users/nico: ... tmp tmp\\slink tmp\\slink\\data.txt tmp\\test tmp\\test\\data.txt ... 请注意，我们在打印所有目录条目的路径时使用 lexically_normal()。 如果我们跳过它，目录条目的路径将包含一个带有初始化迭代器的目录的前缀。 因此，只打印循环内的路径：\nauto iterOpts = fs::directory_options::follow_directory_symlink; for (auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 将在基于 POSIX 的系统下输出：\n# all files: ... \u0026#34;./testdir\u0026#34; \u0026#34;./testdir/data.txt\u0026#34; \u0026#34;./tmp\u0026#34; \u0026#34;./tmp/test\u0026#34; \u0026#34;./tmp/test/data.txt\u0026#34; 在 Windows 上，输出将是：\n# all files: ... \u0026#34;.\\\\testdir\u0026#34; \u0026#34;.\\\\testdir\\\\data.txt\u0026#34; \u0026#34;.\\\\tmp\u0026#34; \u0026#34;.\\\\tmp\\\\test\u0026#34; \u0026#34;.\\\\tmp\\\\test\\\\data.txt\u0026#34; 因此，通过调用 lexically_normal() 我们产生了规范化的路径，它确实删除了当前目录的前导点。 如前所述，通过调用 string() 我们避免了每个路径都被引用，这对于基于 POSIX 的系统来说是可以的（只是将名称放在双引号中），但在 Windows 系统上看起来非常令人惊讶（因为每个反斜杠 被另一个反斜杠转义）。\n错误处理 文件系统是麻烦的根源。 由于使用了错误的字符、没有必要的权限或其他进程可能会在您处理文件系统时修改文件系统，您可能无法执行操作。 因此，根据平台和权限，该程序可能会出现一些问题。\n对于那些没有被返回值覆盖的情况（这里是目录已经存在的情况），我们捕获相应的异常并打印一般消息和其中的第一个路径：\ntry { ... } catch (fs::filesystem_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34; path1: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path1().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } 例如，如果我们无法创建目录，则可能会打印出如下消息：\nEXCEPTION: filesystem error: cannot create directory: [tmp/test] path1: \u0026#34;tmp/test\u0026#34; 或者，如果我们无法创建符号链接，例如因为它已经存在，您会收到类似以下消息：\nEXCEPTION: create_directory_symlink: Can’t create a file when it already exists: \u0026#34;tmp\\test\\data.txt\u0026#34;, \u0026#34;testdir\u0026#34; path1: \u0026#34;tmp\\test\\data.txt\u0026#34; 如前所述，当目录已经作为常规文件存在时，在目录中创建新文件的尝试将失败。因此，不要忘记检查打开文件的状态。默认情况下，用于读取和写入常规文件的 I/O Stream 库不会将错误作为异常处理。\n无论如何请注意，多用户/多进程操作系统中的情况随时可能发生变化。因此，您创建的目录甚至可能在您创建后被删除、重命名或替换为常规文件。因此，根本不可能通过找出当前情况来确保未来请求的有效性。出于这个原因，它通常是尝试做你想做的事情（即创建目录、打开文件）并处理异常和错误或验证检查预期行为的最佳方法。\n但是，有时尝试对文件系统做一些事情可能会奏效，但不是您想的那样。例如，如果您想在特定目录中创建文件并且已经存在指向另一个目录的符号链接，则该文件会在意外位置创建或覆盖。这可能没问题（用户可能有充分的理由在预期目录的位置创建符号链接）。但是，如果您想检测这种情况，则必须在创建文件之前检查文件是否存在（这比您最初想象的要复杂一些）。\n但同样：不能保证文件系统检查的结果在您处理它们时仍然有效。\n20.1.4 使用并行算法处理文件系统的问题 有关使用并行算法累积目录树中所有常规文件大小的另一个示例，请参见 dirsize.cpp。\n20.2 原则和术语 在讨论文件系统库的细节之前，我们必须介绍一些设计原则和术语。 这是必要的，因为该标准涵盖了不同的操作系统并将它们映射到一个通用 API。\n20.2.1 一般可移植性声明 C++ 标准不仅标准化了所有可能的操作系统对其文件系统的共同点。 在许多情况下，它遵循 POSIX 标准，而 C++ 标准要求尽可能地遵循 POSIX。 只要它是合理的，行为应该仍然存在，但有一些限制。 如果不可能有合理的行为，则实现应报告错误。 此类错误的可能示例是：\n字符用于不支持的文件名 创建了不受支持的文件系统元素（例如，符号链接） 特定文件系统的差异仍然可能很重要： 区分大小写： “hello.txt”和“Hello.txt”和“hello.TXT”可能指同一个（Windows）或三个不同的文件（基于POSIX）。 绝对路径与相对路径： 在某些系统上，“/bin”是绝对路径（基于 POSIX），而在其他系统上则不是（Windows）。 20.2.2 命名空间 文件系统库在 std 中有自己的子命名空间文件系统。 为其引入快捷方式 fs 是一个非常常见的约定：\nnamespace fs = std::filesystem; 例如，这允许使用 fs::current_path() 而不是 std::filesystem::current_path()。 本章的进一步代码示例通常会使用 fs 作为相应的快捷方式。 请注意，不限定文件系统调用有时会导致意外行为。\n20.2.3 路径 文件系统库的关键元素是路径。它是一个名称，表示文件系统中文件的（潜在）位置。它由一个可选的根名称、一个可选的根目录和一系列由目录分隔符分隔的文件名组成。路径可以是相对的（因此文件位置取决于当前工作目录）或绝对的。 不同的格式是可能的：\n通用格式，可移植\n一种原生格式，特定于底层文件系统 在基于 POSIX 的操作系统上，通用格式和本机格式之间没有区别。 在 Windows 上，通用格式 /tmp/test.txt 是除 \\tmp\\test.txt 之外的有效原生格式，它也受支持（因此，/tmp/test.txt 和 \\tmp\\test.txt 是相同的路径）。在 OpenVMS 上，相应的原生格式可能是 [tmp]test.txt。 存在特殊文件名：\n“.”代表当前目录\n\u0026ldquo;..\u0026rdquo; 代表父目录 通用路径格式如下：\n[rootname] [rootdir] [relativepath] 在哪里：\n可选的根名称是特定于实现的（例如，在 POSIX 系统上可以是 //host，在 Windows 系统上可以是 C:） 可选的根目录是目录分隔符 相对路径是由目录分隔符分隔的一系列文件名 根据定义，目录分隔符由一个或多个“/”或特定于实现的首选目录分隔符组成。\n可移植通用路径的示例是：\n//host1/bin/hello.txt . tmp/ /a/b//../c 请注意，最后一个路径与 /a/c 指向相同的位置，并且在 POSIX 系统上是绝对的，但在 Windows 系统上是相对的（因为缺少驱动器/分区）。\n另一方面，诸如 C:/bin 之类的路径在 Windows 系统上是绝对路径（“C”驱动器/分区上的根目录“bin”），但在 POSIX 上是相对路径（目录中的子目录“bin”） “C：”）。\n在 Windows 系统上，反斜杠是实现特定的目录分隔符，因此上面的路径也可以通过使用反斜杠作为首选目录分隔符来编写：\n\\\\host1\\bin\\hello.txt . tmp\\ \\a\\b\\..\\c 文件系统库提供了在本地格式和通用格式之间转换路径的功能。 路径可能是空的。 这意味着没有定义路径。 这不一定与“.”相同。 它的含义取决于上下文。\n20.2.4 规范化 路径可能已经或可以被规范化。 在规范化路径中：\n文件名仅由一个首选目录分隔符分隔。 文件名“.”除非整个路径只是“.”，否则不使用。 （代表当前目录）。 文件名不包含“..”文件名（我们不会先向下然后再向上），除非它们位于相对路径的开头。 如果尾部的文件名是一个名称不是\u0026rdquo;\u0026hellip; \u0026ldquo;或\u0026rdquo;\u0026hellip; \u0026ldquo;的目录，路径才以目录分隔符结束。 请注意，规范化仍然意味着以目录分隔符结尾的文件名与不以分隔符结尾的文件名不同。原因是在某些操作系统上，当知道路径是目录时，行为会有所不同（例如，带有尾随分隔符的符号链接可能会被解析）。\n路径规范化的表效果列出了一些在 POSIX 和 Windows 系统上进行规范化的示例。再次注意，在 POSIX 系统上，C:bar 和 C: are 只是文件名，并没有像在 Windows 上那样指定分区的特殊含义。\n路径 POSIX 标准化 windows 标准化 foo/.///bar/../ foo/ foo\\ //host/../foo.txt //host/foo.txt \\host\\foo.txt ./f/../.f/ .f/ .f\\ C:bar/../ . C: C:/bar/.. C:/ C:\\ C:\\bar.. C:\\bar.. C:\\ /./../data.txt /data.txt \\data.txt ././ . . 请注意，在基于POSIX的系统上进行规范化处理时，路径C:\\bar...保持不变。原因是在那里反斜杠不是目录分隔符，所以整个路径只是一个文件名，其中有一个冒号、两个反斜杠和两个点作为其名称的一部分。 文件系统为词法规范化（不考虑文件系统）和依赖文件系统的规范化都提供了功能。\n20.2.5 成员函数与独立的函数 文件系统库提供了几个函数，它们既可以是成员函数也可以是独立函数。一般的做法是：\n成员函数很便宜。原因是它们是纯词法操作，不考虑实际的文件系统，所以不需要调用操作系统。\n例如：\nmypath.is_absolute() // 检查路径是绝对的还是相对的 独立的函数是昂贵的，因为它们通常考虑到实际的文件系统，所以不需要调用操作系统。\n例子：\nequivalent(path1, path2); // 如果两个路径都指向同一个文件，则为true 有时，文件系统库甚至提供了相同的功能，既在词法上操作，又考虑到了实际的文件系统。\nstd::filesystem::path fromP, toP; ... toP.lexically_relative(fromP); // 产生从 fromP 到 toP 的词法路径 relative(toP, fromP); // 产生从 fromP 到 toP 的实际路径 由于参数依赖性查找（ADL），在调用独立的文件系统函数和一个参数具有文件系统的特定类型时，你通常不需要指定完整的命名空间std::filesystem。只有在使用其他类型的隐式转换时，你才需要限定 调用。比如说:\ncreate_directory(std::filesystem::path{\u0026#34;tmpdir\u0026#34;}); // OK remove(std::filesystem::path{\u0026#34;tmpdir\u0026#34;}); // OK std::filesystem::create_directory(\u0026#34;tmpdir\u0026#34;); // OK std::filesystem::remove(\u0026#34;tmpdir\u0026#34;); // OK create_directory(\u0026#34;tmpdir\u0026#34;); // ERROR remove(\u0026#34;tmpdir\u0026#34;); // OOPS: 调用 C 函数 remove() 请注意，最后一个调用通常会编译，但会找到C函数remove()，它也会删除一个指定的文件，但在Windows下不会删除空目录。\n20.2.6 错误处理 正如第二个例子所讨论的，文件系统是一个错误的来源。你必须考虑到必要的文件可能不存在，文件操作不被允许，或者操作违反了资源限制。此外，当程序运行时，其他进程可能会创建、修改或删除文件，因此，即使提前检查也不能保证没有错误。\n问题是，原则上你无法确保下一个文件系统操作会成功。任何检查的结果在你处理它时可能不再有效。因此，通常最好的方法是执行一个或多个文件系统操作，并处理由此产生的异常或错误。\n还要注意的是，当用普通文件进行读写时，I/O流库默认不会抛出错误。它将任何操作转换为无操作。因此，我们建议至少检查一下文件是否能成功打开。\n因为处理异常并不总是合适的（比如当你想直接对一个失败的文件系统调用做出反应时），文件系统库在处理以下问题时使用了混合方法 文件系统时，采用混合方法:\n默认情况下，文件系统错误被作为异常处理。 但是，如果你有或者想要，你可以在本地处理特定的错误。 这是通过文件系统操作实现的，通常每个操作都有两个重载。 默认情况下（没有额外的错误处理参数），操作在出错时抛出一个filesystem_error异常。 通过传递一个额外的输出参数，你可以在出错时得到一个错误代码。 请注意，在后一种情况下，你可能仍然有特殊的返回值，标志着一个特定的错误没有被作为异常处理。 使用 filesystem_error 异常 例如，你可以尝试创建一个目录，如下所示:\nif (!create_directory(p)) { // 错误异常（除非路径存在） std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; already exists\\n\u0026#34;; // 路径存在 } 这里，没有传递错误代码参数，所以错误通常会引发一个异常。但是请注意，路径已经存在的特殊情况（是否是一个目录并不重要），将通过返回false来处理。因此，一个异常是由于其他问题引起的，比如缺少创建目录的权限，无效的路径p，或者违反文件系统资源（比如超过路径长度 限制）。 像这样的代码应该直接或间接地包含在一个try-catch子句中，它可以处理std::filesystem::filesystem_error类型的异常:\ntry { ...; if (!create_directory(p)) { // 错误异常（除非路径存在） std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; already exists\\n\u0026#34;; // 路径存在 } ...; } catch (const std::filesystem::filesystem_error\u0026amp; e) { // 源自 std::exception std::cout \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; path: \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 正如你所看到的，文件系统异常提供了通常的标准异常API，通过what()产生一个特定于实现的错误信息。然而，它还提供了path1()，如果涉及到一个路径，甚至是 path2()，如果涉及到第二个路径。\n使用 error_code 参数 使用error_code参数 另一种调用函数创建目录的方法如下。\nstd::error_code ec; create_directory(p, ec); // 出错时设置错误代码 if (ec) { // 如果设置了错误代码(由于错误) std::cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 之后，我们还可以针对特定的错误代码进行检查。\nif (ec == std::errc::read_only_file_system) { // if specific error code set std::cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is read-only/n\u0026#34;; } 注意，在这种情况下，我们仍然可以检查create_directory()的返回值。\nstd::error_code ec; if (!create_directory(p, ec)) { // 出错时设置错误代码 std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t create directory \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // any error occurred std::cout \u0026lt;\u0026lt; \u0026#34;ERROR:\u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 然而，并不是所有的文件系统操作都提供这种能力（因为它们在正常情况下返回一些值正常情况下）。 在C++11中引入了error_code类型，包括一个可移植错误条件的列表，如 如std::errc::read_only_filesystem。在POSIX系统中，这些映射为errno值\n20.2.7 文件类型 不同的操作系统支持不同的文件类型。标准文件系统库考虑到了这一点。原则上，有一个枚举类型file_type，它被标准化为有以下值:\nnamespace std::filesystem { enum class file_type { regular, directory, symlink, block, character, fifo, socket, ...; none, not_found, unknown, }; } 表file_type Values列出了这些值的含义。 平台可能会提供额外的文件类型值，但这是不可移植的。例如:\nWindows提供了文件类型值junction，它用于NTFS文件系统的NTFS结点（也称为软链接）。它们被用作位于同一台计算机的不同本地卷上的目录的链接。在同一台计算机上的不同卷上的目录的链接。\n值 意义 regular 常规文件 directory 目录文件 symlink 符号连接 character 字符专用文件 block 块特殊文件 fifo FIFO或管道文件 socket 套接字文件 \u0026hellip; 额外的执行定义的文件类型 none 文件类型未知（尚） unknown 文件存在但无法确定类型 not_found 表示未找到该文件的伪类型 除了常规文件和目录之外，最常见的其他类型是符号链接，它是一种指向另一个文件系统位置的文件的类型。在那个位置可能有一个文件，也可能没有。请注意，某些操作系统和/或文件系统（例如 FAT 文件系统）根本不支持符号链接。某些操作系统仅对常规文件支持它们。请注意，在 Windows 上，您需要特殊权限才能创建符号链接，例如，您可以使用 mklink 命令执行此操作。 字符特殊文件、块特殊文件、FIFO 和套接字来自 UNIX 文件系统。目前，所有四种类型都不能与 Visual C++ 一起使用。 如您所见，对于文件不存在或其文件类型未知或无法检测的情况，存在特殊值。在本章的其余部分中，我使用两个通用类别来表示几种文件类型：\n其他文件：具有除常规文件、目录和符号链接之外的任何文件类型的文件。库函数 is_other() 匹配该术语。 特殊文件：具有以下任何文件类型的文件：字符特殊文件、块特殊文件、FIFO 和套接字。 特殊文件类型加上实现定义的文件类型共同构成了其他文件类型。 20.3 路径操作 为了处理文件系统，有很多操作可以调用。处理文件系统的一个关键类型是std::filesystem::path，它可以作为一个文件的绝对或相对路径，这个文件可能存在，也可能不存在（尚未存在）。\n你可以创建路径，检查它们，修改它们，以及比较它们。因为这些操作通常不考虑文件系统（关心现有文件、符号链接等），所以它们的调用很便宜。因此，它们通常是成员函数（如果它们不是构造函数或 操作符）。\n20.3.1 创建路径 表Path Creation列出了创建新路径对象的方法。\n调用 作用 path(string) 从一个字符串创建路径 path(beg,end) 从一个范围创建路径 u8path(u8string) 从一个UTF-8字符串中创建路径 current_path() 产生当前工作目录的路径 temp_directory_path() 产生临时文件的路径 注意，current_path()和temp_directory_path()都是比较昂贵的操作，因为它们是基于操作系统的调用。通过传递一个参数，current_path()也可以用来修改当前工作目录。 通过u8path()，你可以使用所有UTF-8字符创建可移植的路径。比如说:\nstd::filesystem::path{u8path(u8\u0026#34;K\\u00F6ln\u0026#34;); // ”Koln” (Cologne native) ¨ ... // 从返回的UTF-8字符串中创建目录: std::string utf8String = readUTF8String(...); create_directory(std::filesystem::u8path(utf8String)); 20.3.2 路径检查 表Path Inspection列出了你可以调用的检查路径p的函数。注意，这些操作不考虑文件系统，因此是路径的成员函数。 每个路径都是绝对或相对的。如果它没有根目录，它就是相对的（根名称是可能的；例如，C:hello.txt在Windows下是一个相对路径）。 has_\u0026hellip;()函数检查没有has_的相应函数是否产生一个空路径。 请注意以下几点。\n如果根元素或目录分隔符是路径的一部分，总是有一个父路径。如果路径只由根元素组成（即相对路径是空的），parent_path()得到的是相同的路径。也就是说，例如，\u0026rdquo;/\u0026ldquo;的父路径是\u0026rdquo;/\u0026quot;。只有像 \u0026ldquo;hello.txt \u0026ldquo;这样的纯文件名的父路径是空的。 调用 作用 p.empty() 产生路径是否为空 p.is_absolute() 产生一个路径是否是绝对的 p.is_relative() 产生是否是相对路径 p.has_filename() 产生路径是否既不是目录也不是根名的问题 p.has_stem() 与has_filename()相同（因为任何文件名都有一个干）。 p.has_extension() 产生路径是否有扩展名 p.has_root_name() yields 路径是否有根名 p.has_root_directory() yields 路径是否有根目录 p.has_root_path() yields 路径是否有根名或根目录 p.has_parent_path() 产生路径是否有一个父路径 p.has_relative_path() 产生路径是否不只由根元素组成 p.filename() 产生文件名（或空路径）。 p.stem() 产生不带扩展名的文件名（或空路径） p.extension() 产生扩展名(或空路径) p.root_name() 产生根名(或空路径) p.root_directory() 产生根目录(或空路径) p.root_path() 产生根元素(或空路径) p.parent_path() 产生父路径(或空路径) p.relative_path() 产生没有根元素的路径(或空路径) p.begin() 路径迭代的开始 p.end() 路径迭代结束 如果一个路径有一个文件名，它也总是有一个茎。 空路径是一个相对路径（对于除is_empty()和is_relative()之外的所有其他操作，产生false或空路径）。 这些操作的结果可能取决于操作系统。例如，路径C:/hello.txt 在Unix系统上 是相对的 没有根元素（既没有根名称也没有根目录），因为C:是一个文件名。 有父路径C: 具有相对路径C:/hello.txt 在Windows系统上 是绝对的 有根名称C：和根目录/ 没有父路径 有相对路径 hello.txt 路径迭代 你可以对一个路径进行迭代，产生路径中的元素：根名（如果有），根目录（如果有），以及所有的文件名。如果路径以目录分隔符结束，最后一个元素是一个空文件名。 迭代器是一个双向的迭代器，这样你就可以使用\u0026mdash;-。迭代器引用的值又是路径类型的。然而，两个迭代器在同一路径上迭代时，即使它们引用了相同的元素，也可能不会引用相同的路径对象。 比如说：\nvoid printPath(const std::filesystem::path\u0026amp; p) { std::cout \u0026lt;\u0026lt; \u0026#34;path elements of \u0026#34; \u0026lt;\u0026lt; p.string \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; for (auto pos = p.begin(); pos != p.end(); ++pos) { std::filesystem::path elem = *pos; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; elem; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 如果这个函数被调用如下:\nprintPath(\u0026#34;../sub/file.txt\u0026#34;); printPath(\u0026#34;/usr/tmp/test/dir/\u0026#34;); printPath(\u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;); 在基于POSIX的系统上的输出将是:\npath elements of \u0026#34;../sub/file.txt\u0026#34;: \u0026#34;..\u0026#34; \u0026#34;sub\u0026#34; \u0026#34;file.txt\u0026#34; path elements of \u0026#34;/usr/tmp/test/dir/\u0026#34;: \u0026#34;/\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; path elements of \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;: \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34; 注意，最后一个路径只是一个文件名，因为在基于POSIX的系统下，C:既不是有效的根名，反斜杠也不是有效的目录分隔符。 在Windows系统上的输出将是：\npath elements of \u0026#34;../sub/file.txt\u0026#34;: \u0026#34;..\u0026#34; \u0026#34;sub\u0026#34; \u0026#34;file.txt\u0026#34; path elements of \u0026#34;/usr/tmp/test/dir/\u0026#34;: \u0026#34;/\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; path elements of \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;: \u0026#34;C:\u0026#34; \u0026#34;\\\\\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; 要检查一个路径p是否以目录分隔符结束，你可以实现:\nif (!p.empty() \u0026amp;\u0026amp; (--p.end())-\u0026gt;empty()) { std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; has a trailing separator\\n\u0026#34;; } 20.3.3 路径I/O和转换 表中路径I/O和转换列出了读取或写入以及产生转换后的路径的操作。 这些功能没有考虑到实际的文件系统。如果你必须处理符号链接重要的路径，你可能想使用与文件系统相关的路径转换。\n调用 作用 strm \u0026laquo; p 把路径的值写成引号字符串 strm \u0026raquo; p 将路径的值读成带引号的字符串 p.string() 得到的路径是std::string p.wstring() 得到的路径是std::wstring p.u8string() 产生路径的UTF-8字符串，类型为std::u8string p.u16string() 产生路径的UTF-16字符串，类型为std::u16string p.u32string() 产生路径的UTF-32字符串，类型为std::u32string p.string\u0026lt;\u0026hellip;\u0026gt;() 得到的路径是std::basic_string\u0026lt;\u0026hellip;\u0026gt;。 p.lexically_normal() 产生 p 作为标准化路径 p.lexically_relative(p2) 产生从p2到p的路径（如果没有则为空路）。 p.lexically_proximate(p2) 产生从 p2 到 p 的路径（如果没有，则为 p） lexically_\u0026hellip;()函数返回一个新的路径，而其他转换函数产生一个相应的字符串类型。这些函数都没有修改它们所调用的路径。 例如，下面的代码:\nstd::filesystem::path p{\u0026#34;/dir/./sub//sub1/../sub2\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;path: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;string(): \u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;wstring(): \u0026#34; \u0026lt;\u0026lt; p.wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 对前三行有相同的输出:\npath: \u0026#34;/dir/./sub//sub1/../sub2\u0026#34; string(): /dir/./sub//sub1/../sub2 wstring(): /dir/./sub//sub1/../sub2 但最后一行的输出取决于目录分隔符。在基于POSIX的系统中，它是:\nlexically_normal(): \u0026#34;/dir/sub/sub2\u0026#34; 而在Windows上，它是:\nlexically_normal(): \u0026#34;\\\\dir\\\\sub\\\\sub2\u0026#34; 路径I/O 首先，请注意，I/O操作符是以带引号的字符串形式写入和读取路径。你必须把它们转换为字符串，以便在写它们时不加引号:\nstd::filesystem::path file{\u0026#34;test.txt\u0026#34;} std::cout \u0026lt;\u0026lt; file \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // writes: \u0026#34;test.txt\u0026#34; std::cout \u0026lt;\u0026lt; file.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // writes: test.txt 在Windows上，这有更糟糕的效果。下面的代码:\nstd::filesystem::path tmp{\u0026#34;C:\\\\Windows\\\\Temp\u0026#34;}; std::cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; tmp.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; tmp.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; 有以下输出:\n\u0026#34;C:\\\\Windows\\\\Temp\u0026#34; C:\\Windows\\Temp \u0026#34;C:\\Windows\\Temp\u0026#34; 注意，读取文件名支持两种形式（带前导 \u0026ldquo;的引号和不带引号）。因此，所有打印出来的形式将被正确地读回，使用标准输入操作符的路径:\nstd::filesystem::path tmp; std::cin \u0026gt;\u0026gt; tmp; // 正确读取带引号和不带引号的路径 正常化 当你处理可移植代码时，malization可能有更多令人惊讶的结果。比如说：\ntd::filesystem::path p2{\u0026#34;//dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p2.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 在Windows系统上有以下可能的预期输出:\np2: \u0026#34;//host\\\\dir/sub\\\\/./\\\\\u0026#34; lexically_normal(): \u0026#34;\\\\\\\\host\\\\dir\\\\sub\\\\\u0026#34; 然而，在基于POSIX的系统上，输出变成了:\np2: \u0026#34;//host\\\\dir/sub\\\\/./\\\\\u0026#34; lexically_normal(): \u0026#34;/host\\\\dir/sub\\\\/\\\\\u0026#34; 原因是在基于POSIX的系统中，反斜杠不是目录分隔符，也不是根名的有效字符，所以我们有一个绝对路径，有三个文件名host\\dir、sub\\和\\。在基于POSIX的系统中，没有办法检测到反斜杠是一个可能的目录分隔符（在这种情况下，generic_string()和make_preferred()都没有帮助）。 因此，对于可移植代码来说，在处理路径时，你应该始终使用通用路径格式。 尽管如此，在迭代当前目录时，使用lexically_normal()函数去掉前面的点也是一个好办法。\n相对路径 lexically_relative()和lexically_proximate()都可以被调用来计算相对于 路径之间的相对路径。唯一的区别是在没有路径的情况下的行为，只有在一个路径是相对的，另一个是绝对的或者根名称不同的情况下才会发生。在这种情况下。\np.lexically_relative(p2)如果没有从p2到p的相对路径，则产生空路径。\np.lexically_proximate(p2)如果没有从p2到p的相对路径，则产生p。 由于这两个操作都是词法操作，实际的文件系统（可能有符号链接）和current_path()都没有被考虑在内。如果两个路径相等，则相对路径为\u0026rdquo;.\u0026quot;。 例子:\nfs::path{\u0026#34;/a/d\u0026#34;}.lexically_relative(\u0026#34;/a/b/c\u0026#34;) // \u0026#34;../../d\u0026#34; fs::path{\u0026#34;/a/b/c\u0026#34;}.lexically_relative(\u0026#34;/a/d\u0026#34;) // \u0026#34;../b/c\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b/\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b\\\\\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/d/../c\u0026#34;) // \u0026#34;../b fs::path{\u0026#34;a/d/../b\u0026#34;}.lexically_relative(\u0026#34;a/c\u0026#34;) // \u0026#34;../d/../b\u0026#34; fs::path{\u0026#34;a//d/..//b\u0026#34;}.lexically_relative(\u0026#34;a/c\u0026#34;) // \u0026#34;../d/../b\u0026#34; 在Windows系统上，我们有:\nfs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_relative(\u0026#34;c:/c/d\u0026#34;) ; // \u0026#34;\u0026#34; fs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_relative(\u0026#34;D:/c/d\u0026#34;) ; // \u0026#34;\u0026#34; fs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_proximate(\u0026#34;D:/c/d\u0026#34;) ; // \u0026#34;C:/a/b\u0026#34; 转换为字符串 使用u8string()，你可以将路径作为UTF-8字符串使用，这也是当今存储数据的常用格式。存储数据的常用格式。比如说;\n// 将路径存储为UTF-8字符串: std::vector\u0026lt;std::string\u0026gt; utf8paths; // std::u8string with C++20 for (const auto\u0026amp; entry : fs::directory_iterator(p)) { utf8paths.push_back(entry.path().u8string()); } 请注意，u8string()的返回值可能会在C++20中从std::string变为std::u8string（新的UTF-8字符串类型，与char8_t一起在https://wg21.link/p0482，用于UTF-8字符）。 成员模板string\u0026lt;\u0026gt;()可以用来转换为一个特殊的字符串类型，例如一个不区分大小写的字符串类型:\nstruct ignoreCaseTraits : public std::char_traits\u0026lt;char\u0026gt; { // 不敏感地比较两个字符的情况: static bool eq(const char\u0026amp; c1, const char\u0026amp; c2) { return std::toupper(c1) == std::toupper(c2); } static bool lt(const char\u0026amp; c1, const char\u0026amp; c2) { return std::toupper(c1) \u0026lt; std::toupper(c2); } // 比较s1和s2的多达n个字符: static int compare(const char* s1, const char* s2, std::size_t n); // 检索字符c在s中的位置: static const char* find(const char* s, std::size_t n, const char\u0026amp; c); }; // 为这类字符串定义一个特殊的类型: using icstring = std::basic_string\u0026lt;char, ignoreCaseTraits\u0026gt;; std::filesystem::path p{\u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; icstring s2 = p.string\u0026lt;char,ignoreCaseTraits\u0026gt;(); 还需要注意的是，你不应该使用同样提供的函数c_str()，因为它可以转换为本地字符串格式，可能是一个wchar_t，这样你就必须使用，例如 std::wcout而不是std::cout来将其写入流中。\n20.3.4 本地格式和通用格式之间的转换 在本地和通用格式之间的转换表列出了在通用路径格式和实际平台的特定实现格式之间的转换操作。\n这些函数在基于POSIX的系统中应该没有影响，因为本地路径格式和通用路径格式之间没有区别。在其他平台上调用这些函数可能会有影响：\ngeneric\u0026hellip;() path 函数产生转换为具有通用格式的相应字符串格式的路径，\n调用 作用 p.generic_string() 得到的路径是一个通用的std::string p.generic_wstring() 得到的路径是一个通用的std::wstring p.generic_u8string() 得到的路径是一个通用的std::u8string p.generic_u16string() 得到的路径是一个通用的std::u16string p.generic_u32string() 得到的路径是一个通用的std::u32string p.generic_string\u0026lt;\u0026hellip;\u0026gt;() 得到的路径是一个通用的std::basic_string\u0026lt;\u0026hellip;\u0026gt; p.native() 产生本地格式的路径，类型为path::string_type conversionToNativeString 隐式转换为本地字符串类型 p.c_str() 产生作为本地字符串格式的字符序列的路径 p.make_preferred() 用本地格式替换p中的目录分隔符，并得到修改后的p native()产生转换为本地字符串编码的路径，它由std::filesystem::path::string_type类型定义。在Windows下，这个类型是std::wstring类型，所以你必须使用std::wcout而不是std::cout来直接将其写入标准输出流。新的重载允许我们将本地字符串传递给文件流的新重载。 c_str()做了同样的事情，但产生的结果是一个空尾的字符序列。注意，使用这个函数也是不可移植的，因为在Windows上用std::cout打印序列并不能产生正确的输出。你必须在那里使用std::wcout。 make_preferred()用本地目录分隔符替换了除根名之外的任何目录分隔符。注意，这是唯一一个修改它所调用的路径的函数。因此，严格来说属于下一节修改路径的函数，但由于它处理的是本地格式的转换，所以也在这里列出。 例如，在Windows下，下面的代码。\nstd::filesystem::path p{\u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;string(): \u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;wstring(): \u0026#34; \u0026lt;\u0026lt; p.wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;generic_string(): \u0026#34; \u0026lt;\u0026lt; p.generic_string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;generic_wstring(): \u0026#34; \u0026lt;\u0026lt; p.generic_wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 因为它是Windows，而且本地字符串类型是wstring。: std::wcout \u0026lt;\u0026lt; \u0026#34;native(): \u0026#34; \u0026lt;\u0026lt; p.native() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Windows! std::wcout \u0026lt;\u0026lt; \u0026#34;c_str(): \u0026#34; \u0026lt;\u0026lt; p.c_str() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;make_preferred(): \u0026#34; \u0026lt;\u0026lt; p.make_preferred() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 有以下输出:\np: \u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34; string(): /dir\\subdir/subsubdir\\/./\\ wstring(): /dir\\subdir/subsubdir\\/./\\ lexically_normal(): \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\u0026#34; generic_string(): /dir/subdir/subsubdir//.// generic_wstring(): /dir/subdir/subsubdir//.// native(): /dir\\subdir/subsubdir\\/./\\ c_str(): /dir\\subdir/subsubdir\\/./\\ make_preferred(): \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\\\\.\\\\\\\\\u0026#34; p: \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\\\\.\\\\\\\\\u0026#34; 再次注意:\n本地字符串类型是不可移植的。在Windows上它是一个wstring，在基于POSIX的系统上它是一个字符串，所以你必须使用cout而不是wcout来打印native()和c_str()的结果。使用wcout只对wstring()和generic_wstring()的返回值具有可移植性。generic_wstring()的返回值。 只有make_preferred()的调用会修改它所调用的路径。所有其他的调用使p 不受影响。 20.3.5 路径修改 表Path Modifications列出了允许我们直接修改路径的操作。 +=和concat()只是在路径上添加新的字符，而/、/=和append()则是在路径上添加一个子 路径，并用当前目录的分隔符分隔:\nstd::filesystem::path p{\u0026#34;myfile\u0026#34;}; p += \u0026#34;.git\u0026#34;; // p: myfile.git p /= \u0026#34;.git\u0026#34;; // p: myfile.git/.git p.concat(\u0026#34;1\u0026#34;); // p: myfile.git/git1 p.append(\u0026#34;1\u0026#34;); // p: myfile.git/git1/1 std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; p / p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 在基于POSIX的系统上，输出是:\n\u0026#34;myfile.git/.git1/1\u0026#34; \u0026#34;myfile.git/.git1/1/myfile.git/.git1/1\u0026#34; 在Windows系统上，输出为:\n\u0026#34;myfile.git\\\\.git1\\\\1\u0026#34; \u0026#34;myfile.git\\\\.git1\\\\1\\\\myfile.git\\\\.git1\\\\1\u0026#34; 注意，追加一个绝对子路径意味着替换现有的路径。例如，在:\nnamespace fs = std::filesystem; auto p1 = fs::path(\u0026#34;/usr\u0026#34;) / \u0026#34;tmp\u0026#34;; // path is /usr/tmp or /usr\\tmp auto p2 = fs::path(\u0026#34;/usr/\u0026#34;) / \u0026#34;tmp\u0026#34;; // path is /usr/tmp auto p3 = fs::path(\u0026#34;/usr\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is /tmp 调用 作用 p = p2 指定一个新的路径 p = sv 指定一个字符串（视图）作为新的路径 p.assign(p2) 指定一个新的路径 p.assign(sv) 将一个字符串(视图)作为一个新的路径。 p.assign(beg, end) 将范围内的元素从开始到结束分配给路径 p1 / p2 将p2作为p1的子路径连接起来，产生路径。 p /= sub 将子路径作为子路径附加到路径p上 p.append(sub) 将子路径作为子路径附加到路径p上 p.append(beg, end) 将范围内从开始到结束的元素作为子路径附加到路径p p += str 将str的字符附加到路径p中 p.concat(sub) 将str的字符附加到路径p中 p.concat(beg, end) 将范围内从beg到end的元素追加到路径p中。 p.remove_filename() 从路径中删除尾部的文件名 p.replace_filename(repl) 替换尾部的文件名（如果有的话） p.replace_extension() 删除任何尾部的文件名扩展名 p.replace_extension(repl) 替换尾部文件名的扩展名（如果有）。 p.clear() 使路径为空 p.swap(p2) 交换两个路径的值 swap(p1, p2) 交换两个路径的值 p.make_preferred() 用本地格式替换p中的目录分隔符，并产生修改后的p auto p4 = fs::path(\u0026#34;/usr/\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is /tmp 我们有4个路径，分别指向两个不同的文件。\np1和p2相等，指向文件/usr/tmp（注意，在Windows下它们相等，p1是/usr/tmp）。\np3和p4是相等的，指的是文件/tmp，因为附加了一个绝对路径。 对于根元素来说，是否分配了一个新元素也很重要。例如，在Windows下\n我们有:\nauto p1 = fs::path(\u0026#34;usr\u0026#34;) / \u0026#34;C:/tmp\u0026#34;; // path is C:/tmp auto p2 = fs::path(\u0026#34;usr\u0026#34;) / \u0026#34;C:\u0026#34;; // path is C: auto p3 = fs::path(\u0026#34;C:\u0026#34;) / \u0026#34;\u0026#34;; // path is C: auto p4 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is C:/tmp auto p5 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;C:tmp\u0026#34;; // path is C:usr\\tmp auto p6 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;c:tmp\u0026#34;; // path is c:tmp auto p7 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;D:tmp\u0026#34;; // path is D:tmp 函数make_preferred()将路径中的目录分隔符转换为本地格式。 比如说:\nstd::filesystem::path p{\u0026#34;//server/dir//subdir///file.txt\u0026#34;}; p.make_preferred(); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 写在基于POSIX的平台上:\n\u0026#34;//server/dir/subdir/file.txt\u0026#34; 在Windows上，输出结果如下:\n\u0026#34;\\\\\\\\server\\\\dir\\\\\\\\subdir\\\\\\\\\\\\file.txt\u0026#34; 请注意，前导根名不会被修改，因为它必须由两个斜线或反斜线组成。 还要注意的是，在基于POSIX的系统上，这个函数不能将反斜线转换为斜线，因为反斜线不被认为是目录分隔符。 replace_extension() 替换、添加或删除一个扩展名。\n如果文件有一个扩展名，它被替换\n如果文件没有扩展名，将添加新的扩展名。\n如果你跳过新的扩展名或者新的扩展名是空的，任何现有的扩展名都会被删除。 你是否在替换处放置一个前导点并不重要。该函数确保 例如：\nfs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // file.tmp fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;.tmp\u0026#34;) // file.tmp fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;\u0026#34;) // file fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension() // file fs::path{\u0026#34;dir\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // dir.tmp fs::path{\u0026#34;.git\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // .git.tmp 注意，作为 \u0026ldquo;纯扩展名 \u0026ldquo;的文件名（如.git）不算是扩展名。\n20.3.6 路径比较 表路径比较列出了你可以用来比较两个不同路径的操作。 请注意，大多数比较不考虑文件系统，这意味着它们只进行词法操作，这很便宜，但可能会导致令人惊讶的返回值。\n使用==、!=和compare()，下列路径都是不同的。\ntmp1/f ./tmp1/f tmp1/./f tmp1/tmp11/../f 调用 作用 p1 == p2 产生两个路径是否相等 p1 != p2 得出两条路径是否不相等 p1 \u0026lt; p2 产生一个路径是否小于另一个路径的结果 p1 \u0026lt;= p2 产生一条路径是否小于或等于另一条路径 p1 \u0026gt;= p2 产生一条路径是否大于或等于另一条路径 p1 \u0026gt; p2 产生一条路径是否大于另一条路径 p.compare(p2) 得出p2是否小于、等于或大于p的结论 p.compare(sv) 产生p2是否小于、等于或大于字符串(view)的结果，sv转换为路径 equivalent(p1, p2) 考虑到文件系统的昂贵的路径比较 只检测指定目录分隔符的不同格式。因此，下列路径都是相同的（只要反斜线是有效的目录分隔符）。\ntmp1/f /tmp1//f /tmp1\\f tmp1/\\/f 只有当你为每个路径调用lexically_normal()时，上面所有的路径才是相等的（只要反斜杠是有效的目录分隔符）。比如说:\nstd::filesystem::path p1{\u0026#34;tmp1/f\u0026#34;}; std::filesystem::path p2{\u0026#34;./tmp1/f\u0026#34;}; p1 == p2 // true p1.compare(p2) // not 0 p1.lexically_normal() == p2.lexically_normal() // true p1.lexically_normal().compare(p2.lexically_normal()) // 0 如果你想把文件系统考虑进去，以便正确处理符号链接，你可以使用equivalent()。然而，请注意，这个函数要求两个路径都代表现有的文件。因此，一个尽可能准确地比较路径的通用方法（但没有最好的性能） 是这样的:\nbool pathsAreEqual(const std::filesystem::path\u0026amp; p1, const std::filesystem::path\u0026amp; p2) { return exists(p1) \u0026amp;\u0026amp; exists(p2) ? equivalent(p1, p2) : p1.lexically_normal() == p2.lexically_normal(); } 20.3.7 其他路径操作 表中其他路径操作列出了尚未列出的其余路径操作。\n调用 作用 p.hash_value() 产生一个路径的哈希值 注意，只有相等的路径才有相同的哈希值。也就是说，以下的路径产生不同的 哈希值：\ntmp1/f ./tmp1/f tmp1/./f tmp1/tmp11/../f 出于这个原因，你可能想在将路径放入哈希表之前将其规范化。\n20.4 文件系统操作 本节涵盖了考虑到当前文件系统的更昂贵的文件系统操作。 因为这些操作通常要考虑到文件系统（照顾现有文件、符号链接等），所以它们比纯路径操作要昂贵。 因此，它们通常是独立的函数。\n20.4.1 文件属性 有几个属性你可以得到关于一个给定路径后面的文件。首先，表 \u0026ldquo;文件类型的操作 \u0026ldquo;列出了你可以调用的函数，以检查由路径p指定的文件是否存在以及它的整体类型（如果有的话）。注意，这些操作确实考虑到了文件系统，因此是独立的函数。 文件系统类型的函数与相应的file_type值相匹配。然而，请注意，这些函数（除了is_symlink()）遵循符号链接。也就是说，对于一个目录的符号链接，is_symlink()和is_directory()都会产生true。 还要注意的是，根据其他文件类型的定义，对于所有检查特殊文件（没有普通文件、没有目录、没有符号链接）的is_other()也会产生真值。 对于特定实现的文件类型，没有特定的便利函数，因此对它们来说 只有is_other()为真（如果我们有一个符号链接到这样的文件，则is_symlink()为真）。你可以 使用文件状态API来检查这些特定的类型。 为了不跟踪符号链接，使用symlink_status()并为返回的 file_status，正如接下来讨论的exists()。 调用 作用 exists(p) 产生是否有文件可以打开的结果 is_symlink(p) 产生文件p是否存在并且是一个符号链接 is_regular_file(p) 产生文件p是否存在并且是一个普通文件 is_directory(p) 产生文件p是否存在并且是一个目录 is_other(p) 产生文件是否存在 p 并且既不是常规也不是目录也不是符号链接 is_block_file(p) 产生文件p是否存在并且是一个块状的特殊文件 is_character_file(p) 产生文件p是否存在并且是一个特殊字符的文件 is_fifo(p) 产生文件 p 是否存在，并且是 FIFO 或管道文件 is_socket(p) 产生文件p是否存在并且是一个套接字文件 检查文件是否存在 exists()回答的问题是，是否有一个有效的文件可以打开。因此，正如刚才讨论的，它遵循符号链接。所以，如果有一个符号链接到一个不存在的文件，它就会产生错误。 因此，像这样的代码不会像预期的那样工作：\n// 如果还没有做，就创建一个符号链接到文件: if (!exists(p)) { // OOPS：检查p所指的文件是否不存在 std::filesystem::create_symlink(file, p); } 如果p已经作为一个不存在的文件的符号链接存在，它将尝试在已经存在符号链接的位置创建符号链接，并引发一个相应的异常。\n因为多用户/多进程文件系统中的情况可能随时发生变化，通常最好的办法是尝试执行一个操作，并在操作失败时处理错误。因此，我们可以简单地调用操作并处理相应的异常或处理作为附加参数传递的错误代码。\n然而，有时你需要检查一个文件是否存在（在执行文件系统操作之前）。例如，如果你想在一个特定的位置创建一个文件，而那里已经有一个符号链接，那么这个文件就会在一个可能意想不到的位置被创建或被覆盖。在这种情况下，你 在这种情况下，你应该检查文件是否存在，方法如下:\nif (!exists(symlink_status(p))) { // OK: 检查p是否还不存在（作为符号链接）。 ... } 这里我们使用symlink_status()，它产生的是不跟随符号链接的状态，来检查 检查在p的位置是否存在任何文件。\n其他文件属性 文件属性的表操作列出了几个独立的函数来检查额外的文件属性。\n调用 作用 is_empty(p) 产生文件是否为空 file_size(p) 产生文件的大小 hard_link_count(p) 产生硬链接的数量 last_write_time(p) 产生最后一次写到一个文件的时间点 请注意，一个路径是否为空和一个路径所指定的文件是否为是空的：\np.empty() // 如果路径p是空的，则为真（廉价操作）。 is_empty(p) // 如果路径p上的文件是空的，则为真(文件系统操作) file_size(p)返回文件p的大小，如果它作为常规文件存在的话（就像POSIX函数stat()的成员st_size一样）。对于所有其他的文件，其结果是执行定义的，不可移植。 hard_link_count(p) 返回一个文件在文件系统中存在的次数。通常这个数字是1，但在某些文件系统中，同一个文件可以存在于文件系统的不同位置（即有不同的路径）。这与符号链接不同，在符号链接中，一个文件指的是另一个文件。在这里，我们有一个具有不同路径的文件，可以直接访问它。只有当最后一个硬链接被删除时，文件本身才会被删除。文件本身也会被删除。\n处理最后一次修改 last_write_time(p)返回文件最后一次修改或写入的时间点。返回类型是标准Chrono库中用于时间点的特殊time_point类型:\nnamespace std::filesystem { using file_time_type = chrono::time_point\u0026lt;trivialClock\u0026gt;; } 时钟类型trivialClock是一个特定实现的时钟类型，反映了文件时间值的分辨率和范围。例如，你可以按以下方式使用它:\nvoid printFileTime(const std::filesystem::path\u0026amp; p) { auto filetime = last_write_time(p); auto diff = std::filesystem::file_time_type:🕰:now() - filetime; std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::seconds\u0026gt;(diff).count() \u0026lt;\u0026lt; \u0026#34; Seconds old.\\n\u0026#34;; } 这可能会输出:\n\u0026#34;fileattr.cpp\u0026#34; is 4 Seconds old. 而不是\nstd::filesystem::file_time_type:🕰:now() 在这个例子中，你也可以这样写:\ndecltype(filetime):🕰:now() 请注意，文件系统时间点使用的时钟并不保证是标准的system_clock。由于这个原因，目前还没有标准化的支持将文件系统的时间点转换为time_t类型，以便在字符串或输出中使用它作为绝对时间。下面的函数 \u0026ldquo;大致 \u0026ldquo;地将任何时钟的时间点转换为time_t对象:\ntemplate\u0026lt;typename TimePoint\u0026gt; std::time_t toTimeT(TimePoint tp) { using system_clock = std::chrono::system_clock; return system_clock::to_time_t(system_clock::now() + (tp - decltype(tp):🕰:now())); } 诀窍是计算出文件系统时间点相对于现在的持续时间，然后把这个差值加到系统时钟的当前时间上。这个函数并不精确，因为两个时钟可能有不同的分辨率，而且我们在稍微不同的时间调用now()两次。然而，在一般情况下 一般来说，这样做效果很好。 例如，对于一个路径p，我们可以调用:\nauto ftime = last_write_time(p); std::time_t t = toTimeT(ftime); // 转换为日历时间（包括跳过尾部换行）。: std::string ts = ctime(\u0026amp;t); ts.resize(ts.size()-1); std::cout \u0026lt;\u0026lt; \u0026#34;last access of \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; ts \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 其中可能会打印:\nlast access of \u0026#34;fileattr.exe\u0026#34;: Sun Jun 24 10:41:12 2018 为了以我们想要的方式格式化一个字符串，我们可以调用:\nstd::time_t t = toTimeT(ftime); char mbstr[100]; if (std::strftime(mbstr, sizeof(mbstr), \u0026#34;last access: %B %d, %Y at %H:%M\\n\u0026#34;, std::localtime(\u0026amp;t))) { std::cout \u0026lt;\u0026lt; mbstr; } 这可能会输出:\nlast access: June 24, 2018 at 10:41 将任何文件系统的时间点转换为字符串的一个有用的辅助工具是:\nfilesystem/ftimeAsString.hpp #include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;filesystem\u0026gt; std::string asString(const std::filesystem::file_time_type\u0026amp; ft) { using system_clock = std::chrono::system_clock; auto t = system_clock::to_time_t(system_clock::now() + (ft - std::filesystem::file_time_type:🕰:now())); // 转换为日历时间（包括跳过尾部的新行）。 std::string ts = ctime(\u0026amp;t); ts.resize(ts.size()-1); return ts; } 注意，ctime()和strftime()不是线程安全的，不能同时调用。 请参阅修改现有文件，了解修改最后一次写入权限的相应API。\n20.4.2 文件状态 为了避免文件系统的访问，有一个特殊的类型file_status，可以用来保持和修改缓存的文件类型和权限。 缓存的文件类型和权限。这个状态可以在询问特定路径的文件状态时被设置。\n当询问特定路径的文件状态时，如表 \u0026ldquo;文件状态的操作 \u0026ldquo;中所列。\n当在一个目录上迭代时\n调用 作用 status(p) 产生文件p的file_status（包括符号链接) symlink_status(p) 读取p的文件状态（不遵循符号链接） 不同的是，如果路径p在符号链接中解析，status()跟随链接并打印那里的文件属性（状态可能是没有文件），而symlink_status(p)打印的是符号链接本身的状态。 表file_status Operations列出了对file_status对象fs的可能调用。\n调用 作用 exists(fs) 产生一个文件是否存在。 is_regular_file(fs) 产生文件是否存在并且是一个常规文件 is_directory(fs) 产生文件是否存在并且是一个目录。 is_symlink(fs) 产生文件是否存在并且是一个符号链接。 is_other(fs) 产生文件是否存在，并且既不是普通文件也不是目录也不是象征性链接 is_character_file(fs) 产生文件是否存在并且是一个特殊字符的文件。 is_block_file(fs) 产生文件是否存在并且是一个块状特殊文件。 is_fifo(fs) 产生文件是否存在并且是FIFO或管道文件 is_socket(fs) 产生文件是否存在并且是一个套接字。 fs.type() 产生文件的文件类型。 fs.permissions() 产生文件的权限。 状态操作的一个好处是，你可以为同一个文件保存多个操作系统的调用。同一个文件。例如，不使用\nif (!is_directory(path)) { if (is_character_file(path) || is_block_file(path)) { ... } ... } 你最好执行:\nauto pathStatus{status(path)}; if (!is_directory(pathStatus)) { if (is_character_file(pathStatus) || is_block_file(pathStatus)) { ... } ... } 另一个关键的好处是，通过使用symlink_status()，你可以在不遵循任何符号链接的情况下检查路径的状态。例如，这有助于检查某个特定路径上是否存在任何文件。 因为这些文件状态不使用操作系统，所以不提供返回错误代码的重载。提供。\n路径参数的exists()和is_\u0026hellip;()函数是调用和检查文件状态的type()的捷径。比如说:\nis_regular_file(mypath) 快捷方式:\nis_regular_file(status(mypath)) 捷径，它是\nstatus(mypath).type() == file_type::regular 20.4.3 权限 处理文件权限的模式是从UNIX/POSIX世界中采用的。有一些位来表示对文件所有者、同一组的成员或所有其他人的阅读、写入和/或执行/搜索访问。此外，还有 \u0026ldquo;执行时设置用户ID\u0026rdquo;、\u0026ldquo;执行时设置组ID \u0026ldquo;和粘性位（或其他与系统有关的含义）的特殊位。 表Permission Bits列出了在命名空间std::filesystem中定义的bitmask范围枚举类型perms的值，它代表一个或多个权限位。\n枚举 八进制 POSIX 意义 none 0 未设置权限 owner_read 0400 S_IRUSR 对所有者的阅读权限 owner_write 0200 S_IWUSR 对所有者的写入权限 owner_exec 0100 S_IXUSR 所有者的执行/搜索权限 owner_all 0700 S_IRWXU 所有者的所有权限 group_read 040 S_IRGRP 组的读取权限 group_write 020 S_IWGRP 组的写入权限 group_exec 010 S_IXGRP 组的执行/搜索权限 group_all 070 S_IRWXG 群组的所有权限 others_read 04 S_IROTH 所有其他人的读取权限 others_write 02 S_IWOTH 所有其他人的写入权限 others_exec 01 S_IXOTH 所有其他人的执行/搜索权限 others_all 07 S_IRWXO 所有其他人的所有权限 all 0777 所有人的所有权限 set_uid 04000 S_ISUID 在执行时设置用户 ID set_gid 02000 S_ISGID 在执行时设置组 ID sticky_bit 01000 S_ISVTX 依赖于操作系统 mask 07000 所有可能位掩码 unkonwn 0xFFFF 权限未知 你可以询问当前的权限，结果是检查返回的perms对象的位。 为了组合标志，你必须使用位操作符。比如说：\n// 如果可写: if ((fileStatus.permissions() \u0026amp; (fs::perms::owner_write | fs::perms::group_write | fs::perms::others_write)) != fs::perms::none) { ... } 初始化比特掩码的一个更短的方法（但可能不太容易读懂）是直接使用相应的八进制值和放松枚举的初始化:\n// 如果可写: if ((fileStatus.permissions() \u0026amp; fs::perms{0222}) != fs::perms::none) { ... } 注意，在将结果与特定的值进行比较之前，你必须将\u0026amp;表达式放在括号里。还要注意的是，你不能跳过比较，因为对于比特掩码范围的枚举类型，没有隐含的转换为bool。 再比如，要把一个文件的权限转换为UNIX ls -l命令中的字符串，你可以使用下面的辅助函数:\nfilesystem/permAsString.hpp\n#include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;filesystem\u0026gt; std::string asString(const std::filesystem::perms\u0026amp; pm) { using perms = std::filesystem::perms; std::string s; s.resize(9); s[0] = (pm \u0026amp; perms::owner_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[1] = (pm \u0026amp; perms::owner_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[2] = (pm \u0026amp; perms::owner_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; s[3] = (pm \u0026amp; perms::group_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[4] = (pm \u0026amp; perms::group_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[5] = (pm \u0026amp; perms::group_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; s[6] = (pm \u0026amp; perms::others_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[7] = (pm \u0026amp; perms::others_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[8] = (pm \u0026amp; perms::others_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; return s; } 这允许你打印一个文件的权限，作为标准ostream命令的一部分:\nstd::cout \u0026lt;\u0026lt; \u0026#34;permissions: \u0026#34; \u0026lt;\u0026lt; asString(status(mypath).permissions()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 对于一个拥有所有者所有权限和所有其他人的读/执行权限的文件，可能的输出结果是:\npermissions: rwxr-xr-x 然而，请注意，Windows的ACL（访问控制列表）方法并不真正适合这个方案。由于这个原因，在使用Visual C++时，可写文件总是设置了所有的读、写和执行位（即使它们不是可执行文件），带有只读标志的文件总是设置了所有的读和可执行位。这也影响了可移植地修改权限的API。\n20.4.4 文件系统的修改 你也可以通过创建和删除文件或修改现有文件来修改文件系统。\n创建和删除文件 创建和删除文件表列出了路径 p 创建和删除文件的操作。\n调用 作用 create_directory(p) 创建一个目录 create_directory(p, attrPath) 创建一个具有attrPath属性的目录。 create_directories(p) 创建一个目录和上面的所有目录，还不存在的目录 create_hard_link(old, new) 创建另一个文件系统的条目，以取代现有的文件old create_symlink(to, new) 创建一个符号链接，从新文件到新文件。 create_directory_symlink(to, new) 创建一个符号链接，从新的目录连接到 copy(from, to) 复制一个任何类型的文件 copy(from, to, options) 复制一个带有选项的任何类型的文件 copy_file(from, to) 复制一个文件（但不是目录或符号链接） copy_file(from, to, options) 拷贝一个带有选项的文件 copy_symlink(from, to) 复制一个符号链接（to指的是from指的地方）。 remove(p) remove(p) 删除一个文件或空目录 remove_all(p) 删除p和其子树中的所有文件（如果有的话）任何）。 没有创建普通文件的功能。这是由I/O流标准库涵盖的。 例如，下面的语句创建一个新的空文件（如果它还不存在）:\nstd::ofstream{\u0026#34;log.txt\u0026#34;}; 创建一个或多个目录的函数会返回是否创建了一个新目录。 因此，查找已经存在的目录不会出错。 但是，在那里找到不是目录的文件也不是错误。 因此，在 create_directory() 或 create_directories() 返回 false 之后，您不知道是否已经存在请求的目录或其他内容。 当然，如果您之后对该文件执行特定于目录的操作并获得异常，您会发现它可能没问题（因为处理这个罕见的问题可能不值得付出努力）。 但是，如果您想要更正错误消息或出于其他原因必须确保确实有一个目录，您必须执行以下操作：\nif (!create_directory(myPath) \u0026amp;\u0026amp; !is_directory(myPath)) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; myPath.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is already something else\\n\u0026#34;; ... // 处理这个错误 } copy\u0026hellip;() 函数不适用于特殊文件类型。 默认情况下，它们：\n如果现有文件被覆盖，则报告错误\n不要递归操作\n按照符号链接 这个默认值可以被参数 options 覆盖，它具有位掩码范围的枚举类型 copy_options，定义在命名空间 std::filesystem 中。 表复制选项。 列出可能的值。\n复制选项 作用 none 默认值（值 0） skip_existing 跳过覆盖现有文件 overwrite_existing 覆盖现有文件 update_existing 如果新文件较新，则覆盖现有文件 recursive 递归复制子目录及其内容 copy_symlinks 将符号链接复制为符号链接 skip_symlinks 忽略符号链接 directories_only 仅复制目录 create_hard_links 创建额外的硬链接而不是文件副本 create_symlinks 创建符号链接而不是文件副本（源路径必须是绝对路径，除非目标路径在当前目录中） rename() 可以处理任何类型的文件，包括目录和符号链接。 对于符号链接，链接被重命名，而不是它所指的位置。 请注意， rename() 需要包含文件名的完整新路径才能将其移动到不同的目录：\n// move \u0026#34;tmp/sub/x\u0026#34; to \u0026#34;tmp/x\u0026#34;: std::filesystem::rename(\u0026#34;tmp/sub/x\u0026#34;, \u0026#34;top\u0026#34;); // ERROR std::filesystem::rename(\u0026#34;tmp/sub/x\u0026#34;, \u0026#34;top/x\u0026#34;); // OK last_write_time() 使用处理上次修改中描述的时间点格式。 例如：\n// 创建文件p（更新最后的文件访问）。: last_write_time(p, std::filesystem::file_time_type:🕰:now()); permissions() 使用权限中描述的权限 API 格式。 可选模式是位掩码枚举类型 perm_options，在命名空间 std::filesystem 中定义。 它一方面允许在替换、添加和删除之间进行选择，另一方面允许使用 nofollow 来修改符号链接而不是它们所引用的文件的权限。 例如：\n// 删除组的写访问权限和其他人的任何访问权限: permissions(mypath, std::filesystem::perms::group_write | std::filesystem::perms::others_all, std::filesystem::perm_options::remove); 再次注意，Windows 由于其 ACL 权限概念仅支持两种模式：\n读取、写入和执行/搜索所有 (rwxrwxrwx)\n读取、执行/搜索所有（r-xr-xr-x） 要在这两种模式之间进行可移植的切换，您必须同时启用或禁用所有三个写入标志（一个接一个地删除不起作用）：\n// 启用/禁用写访问的可移植值: auto allWrite = std::filesystem::perms::owner_write | std::filesystem::perms::group_write | std::filesystem::perms::others_write; // 可移植地删除写入权限: permissions(file, allWrite, std::filesystem::perm_options::remove); 初始化allWrite的一个更短的方法（但可能不那么好读）（使用放松的枚举初始化）如下。:\nstd::filesystem::perms allWrite{0222}; resize_file() 可用于减小或扩展常规文件的大小：例如：\n// 使文件为空: resize_file(file, 0); 20.4.5 符号链接和依赖文件系统的路径转换 表中文件系统路径转换列出了处理文件路径的操作，其中考虑到了文件系统。如果你需要处理符号链接，这一点尤其重要。对于不考虑文件系统的廉价路径转换，请参见纯路径转换。 注意，这些调用对文件是否必须存在、是否规范化以及是否遵循符号链接的处理方式不同。表中的文件系统路径转换属性给出了这些函数的要求和执行情况的概述。 下面的函数演示了大多数这些操作的用法和效果（在处理符号链接时）:\nfilesystem/symlink.hpp 调用 作用 read_symlink(symlink) 产生现有符号链接引用的文件 absolute(p) 产生现有的 p 作为绝对路径（不遵循符号链接） canonical(p) 产生现有的 p 作为绝对路径（遵循符号链接） weakly_canonical(p) 产生 p 作为绝对路径（遵循符号链接） relative(p) 产生从当前目录到 p 的相对（或空）路径 relative(p, base) 产生从 base 到 p 的相对（或空）路径 proximate(p) 产生从当前目录到 p 的相对（或绝对）路径 proximate(p, base) 产生从 base 到 p 的相对（或绝对）路径 调用 必须存在 规范化 遵循符号链接 read_symlink() yes yes once absolute() no yes no canonical() yes yes all weakly_canonical() no yes all relative() no yes all proximate() no yes all #include \u0026lt;filesystem\u0026gt; #include \u0026lt;iostream\u0026gt; void testSymLink(std::filesystem::path top) { top = absolute(top); // 在我们更改当前路径时使用绝对路径 create_directory(top); // 确保 top 存在 current_path(top); // 这样我们就可以将目录更改为它 std::cout \u0026lt;\u0026lt; std::filesystem::current_path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 打印top路径 // 定义我们的子目录（不创建它们）: std::filesystem::path px{top / \u0026#34;a/x\u0026#34;}; std::filesystem::path py{top / \u0026#34;a/y\u0026#34;}; std::filesystem::path ps{top / \u0026#34;a/s\u0026#34;}; // 打印一些相对路径（对于不存在的文件）： std::cout \u0026lt;\u0026lt; px.relative_path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 相对路径，从top std::cout \u0026lt;\u0026lt; px.lexically_relative(py) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 py 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, py) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 py 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从curr.path到px : \u0026#34;a/x\u0026#34; std::cout \u0026lt;\u0026lt; px.lexically_relative(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; // 现在创建所有子目录和符号链接: create_directories(px); create_directories(py); if (!is_symlink(ps)) { create_directory_symlink(top, ps); } std::cout \u0026lt;\u0026lt; \u0026#34;ps: \u0026#34; \u0026lt;\u0026lt; ps \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; read_symlink(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 并查看词法和文件系统相关之间的区别: std::cout \u0026lt;\u0026lt; px.lexically_relative(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;a/x\u0026#34; } 注意，我们首先将可能的相对路径转换为绝对路径，因为否则改变当前路径会影响路径变量的位置。 relative_path()和lexically_relative()是廉价的路径成员函数，没有考虑到实际的文件系统。因此，它们忽略了符号链接。独立的函数relative() 将文件系统考虑在内。只要我们还没有文件，它的作用就像lexically_relative()。但在创建符号链接ps（top/a/s）之后，它就会跟随符号链接，并给出不同的结果。 在POSIX系统中，从\u0026rdquo;/tmp \u0026ldquo;调用该函数，参数为 \u0026ldquo;top\u0026rdquo;，其输出结果如下:\n\u0026#34;/tmp/sub\u0026#34; \u0026#34;tmp/sub/a/x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;a/x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;../x\u0026#34; ps: \u0026#34;/tmp/sub/a/s\u0026#34; -\u0026gt; \u0026#34;/tmp/sub\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;a/x\u0026#34; 在Windows系统中，从 \u0026ldquo;C:/temp \u0026ldquo;调用该函数，参数为 \u0026ldquo;top\u0026rdquo;，输出结果为如下所示:\n\u0026#34;C:\\\\temp\\\\top\u0026#34; \u0026#34;temp\\\\top\\\\a/x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;a\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; ps: \u0026#34;C:\\\\temp\\\\top\\\\a/s\u0026#34; -\u0026gt; \u0026#34;C:\\\\temp\\\\top\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;a\\\\x\u0026#34; 请再次注意，你需要管理员权限才能在Windows上创建符号链接。\n20.4.6 其他文件系统操作 表 \u0026ldquo;其他操作 \u0026ldquo;列出了尚未提及的其他文件系统操作。\n调用 作用 equivalent(p1, p2) 得出 p1 和 p2 是否引用同一个文件 space(p) 产生有关路径 p 处可用磁盘空间的信息 current_path(p) 将当前工作目录的路径设置为 p 在关于路径比较的章节中讨论了equivalent()函数。 space()的返回值是以下结构：\nnamespace std::filesystem { struct space_info { uintmax_t capacity; uintmax_t free; uintmax_t available; }; } 因此，使用结构化绑定可以打印 root 的可用磁盘空间，如下所示：\nauto [cap, _, avail] = std::filesystem::space(\u0026#34;/\u0026#34;); std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::precision(2) \u0026lt;\u0026lt; avail/1.0e6 \u0026lt;\u0026lt; \u0026#34; of \u0026#34; \u0026lt;\u0026lt; cap/1.0e6 \u0026lt;\u0026lt; \u0026#34; MB available\\n\\n\u0026#34;; 输出可能是例如：\n43019.82 of 150365.79 MB available 为路径参数调用的 current_path() 会修改整个程序的当前工作目录（因此，它适用于所有线程）。 离开范围时，您可以通过以下方式切换到另一个工作目录并恢复旧目录：\nauto current{std::filesystem::current_path()}; try { std::filesystem::current_path(subdir); ...; } catch (...) { std::filesystem::current_path(current); throw; } std::filesystem::current_path(subdir); 20.5 遍历目录 文件系统库的一个关键应用是遍历目录或文件系统（子）树的所有文件。 最方便的方法是使用基于范围的 for 循环。 您可以遍历目录中的所有文件：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 或递归遍历文件系统（子）树中的所有文件：\nfor (const auto\u0026amp; e : std::filesystem::recursive_directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 传递的参数 dir 可以是路径或任何可隐式转换为路径的内容（尤其是所有形式的字符串）； 请注意， e.path() 产生的文件名包括迭代开始的目录。\n因此，如果我们遍历“.” 文件名 file.txt 变为 ./file.txt 或 .\\file.txt。\n此外，此路径被引用到流中，因此此文件名的输出变为“./file.txt”或“.\\file.txt”。 因此，正如之前在初始示例中所讨论的，以下循环更便于移植：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 要在当前目录上进行迭代，你应该传递\u0026rdquo;. \u0026ldquo;作为当前目录而不是\u0026rdquo;\u0026quot;。传递一个空的路径在Windows上是可行的，但不能移植。\n范围的目录迭代器 你可以将一个迭代器传递给一个基于范围的for循环，这可能看起来令人惊讶，因为你通常需要一个范围。\n诀窍在于，directory_iterator和recursive_directory_iterator都是提供begin()和end()的全局重载的类。\nbegin()产生迭代器本身。 end()产生结束迭代器，你也可以用默认的构造函数来创建它。 出于这个原因，你也可以按以下方式进行迭代。\nstd::filesystem::directory_iterator di{p}; for (auto pos = begin(di); pos != end(di); ++pos) { std::cout \u0026lt;\u0026lt; pos-\u0026gt;path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 或者如下:\nfor (std::filesystem::directory_iterator pos{p}; pos != std::filesystem::directory_iterator{}; ++pos) { std::cout \u0026lt;\u0026lt; pos-\u0026gt;path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 目录迭代器选项 遍历目录时，您可以传递 directory_options 类型的值，这些值列在表 Directory Iterator Options 中。 该类型是位掩码范围的枚举类型，在命名空间 std::filesystem 中定义。\n目录选项 作用 none 默认（值 0） follow_directory_symlink 跟随符号链接（而不是跳过它们） skip_permission_denied 跳过权限被拒绝的目录 默认情况下，不跟踪符号链接，并跳过你不允许迭代的目录。使用 skip_permission_denied 遍历一个被拒绝的目录时，会产生一个异常。 createfiles.cpp显示了follow_directory_symlink的一个应用:\n20.5.1 目录条目 目录迭代器所迭代的元素是std::filesystem::directory_entry类型的。因此，如果一个目录迭代器是有效的，operator*()就会产生该类型。这意味着，基于范围的for循环的正确类型如下。\nfor (const std::filesystem::directory_entry\u0026amp; e : std::filesystem::directory_iterator(p)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 目录条目既包含路径对象，也包含额外的属性，如硬链接计数、文件状态、文件大小、最后写入时间、是否是符号链接，以及如果是的话，它指向哪里。\n注意，这些迭代器是输入迭代器。原因是在一个目录上迭代可能导致不同的结果，因为在任何时候目录条目都可能改变。在并行算法中使用目录迭代器时，必须考虑到这一点。\n表中目录条目操作列出了你可以为一个目录条目e调用的操作，它们或多或少是你可以调用的查询文件属性、获取文件状态检查权限和比较路径的操作。\n调用 作用 e.path() 产生当前条目的文件系统路径 e.exists() 产生文件是否存在 e.is_regular_file() 产生文件是否存在并且是一个普通文件 e.is_directory() 产生文件是否存在并且是一个目录 e.is_symlink() 得出文件是否存在并且是一个符号链接 e.is_other() 产生文件是否存在，并且既不是常规文件也不是目录也不是象征性链接 e.is_block_file() 产生文件是否存在并且是一个块状特殊文件 e.is_character_file() 产生文件是否存在并且是一个特殊字符的文件。 e.is_fifo() 产生文件是否存在，并且是FIFO或管道文件 e.is_socket() 产生文件是否存在并且是一个套接字。 e.file_size() 产生文件的大小。 e.hard_link_count() 产生硬链接的数量 e.last_write_time() 产生最后一次写到文件的时间点 e.status() 产生文件的状态p e.symlink_status() 产生文件的状态（在符号链接之后） p e1 == e2 产生两个入口的路径是否相等 e1 != e2 产生两个入口路径是否不相等 e1 \u0026lt; e2 产生是否一个条目路径小于另一个条目路径的结果 e1 \u0026lt;= e2 产生一个条目路径是否比另一个条目路径小或相等 e1 \u0026gt;= e2 产生一个条目路径是否大于或等于另一个条目路径 e1 \u0026gt; e2 产生一个条目路径是否大于另一个条目路径。 e.assign(p) 用p替换e的路径并更新所有条目属性 e.replace_filename(p) 用p替换e的当前路径的文件名并更新所有条目属性 e.refresh() 更新此条目的所有缓存属性 assign()和replace_filename()调用相应的修改路径操作，但不修改底层文件系统中的文件。\n目录条目缓存 我们鼓励实现者缓存这些额外的文件属性，以避免在使用条目时对文件系统的额外访问。然而，实现并不要求缓存数据，这意味着这些通常很便宜的操作可能会变得更昂贵。 因为所有的值通常都被缓存了，这些调用通常是廉价的，因此是成员函数。\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { auto t = e.last_write_time(); // 通常便宜 ... } 无论是否有缓存，在一个多用户或多进程的操作系统中，所有这些迭代可能产生不再有效的文件数据。文件内容和大小可能会改变，文件可能被删除或替换（因此，甚至文件类型也可能改变），权限可能被修改。 在这种情况下，你可以要求刷新一个目录项所持有的数据:\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { ...; // 数据数据变旧 e.refresh(); // 刷新文件的缓存数据 if (e.exists()) { auto t = e.last_write_time(); ...; } } 另外，你可能总是问当前的情况：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { ...; // 数据数据变旧 if (exists(e.path())) { auto t = last_write_time(e.path()); ... } } 20.6 后记 文件系统库在Beman Dawes的领导下作为一个Boost库开发了多年。在2014年，它第一次成为一个正式的测试标准，即文件系统技术规范（见https://wg21.link/n4100）。 随着https://wg21.link/p0218r0，文件系统技术规范被采纳为 由Beman Dawes提出的标准库。对计算相对路径的支持被添加到 由Beman Dawes, Nicolai Josuttis和Jamie Allsop在https://wg21.link/p0219r1。由Beman Dawes在https://wg21.link/p0317r1 中提议增加了几个小的修正。Nicolai Josuttis在https://wg21.link/p0392r0，Jason Liu和Hubert Tong在https: //wg21.link/p0430r2，特别是文件系统小组的成员（Beman Dawes, S. Davis Herring, Nicolai Josuttis, Jason Liu, Billy O\u0026rsquo;Neal, P.J. Plauger, and Jonathan Wakely）在https://wg21.link/p0492r2。\n","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/","title":"第三部分-新的标准库组件"},{"content":"第五部分 专业工具 这部分介绍了普通应用程序程序员通常不必知道的新语言和库特性。 它可能涵盖基础库、特定模式或特殊环境中的程序员的工具。\n27 多态的内存资源 (PMR) 自C++98以来，标准库就支持配置类分配其内部（堆）内存的方式的能力。由于这个原因，标准库中几乎所有分配内存的类型都有一个分配器参数。因此，你可以配置容器、字符串和其他类型分配其内部内存的方式，如果它们需要比堆栈上分配的空间更多的话。 分配这种内存的默认方式是从堆中分配。但是有不同的理由来修改这个默认行为：\n你可以使用你自己的方式分配内存，以减少系统调用的数量。 你可以确保分配的内存位于彼此的旁边，以从CPU缓存中获益。 你可以把容器和它们的元素放在可供多进程使用的共享内存中。 你甚至可以重定向这些堆内存调用，以使用早期在堆栈上分配的内存。因此，可以有性能和功能方面的原因。 然而，在C++17之前，使用分配器（右）在很多方面都是既棘手又笨拙的（由于一些缺陷，太过复杂，以及与后向兼容的修改）。 现在，C++17为预定义和用户定义的内存分配方式提供了一个相当容易使用的方法，它可以用于标准类型和用户定义的类型。 基于这个原因，本章将讨论：\n使用标准库提供的标准内存资源 定义自定义内存资源 为自定义类型提供内存资源支持 如果没有Pablo Halpern、Arthur O\u0026rsquo;Dwyer、David Sankel和Jonathan Wakely的大力帮助，本章就不可能完成。一些视频解释了这里提供的功能：\n分配器：Pablo Halpern 的好零件 C++17 的 std::pmr 有代价 David Sankel 分配器是 Arthur O\u0026rsquo;Dwyer 的堆句柄 27.1 使用标准内存资源 本节介绍了标准内存资源以及如何使用它们。\n27.1.1 激励性的例子 让我们首先比较一下没有和有标准内存资源的内存消耗。\n为容器和字符串分配内存 假设在你的程序中，你有一个由一些字符串组成的向量，你用相当长的方式初始化这些字符串字符串：\npmr/pmr0.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 注意，我们使用一个类来跟踪内存分配的数量，该类跟踪所有用以下循环执行的::new调用：\nstd::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } 有很多的分配，因为 vector 内部使用内存来存储元素。此外，字符串元素本身可能会在堆上分配内存以保存其当前值（由于经常实现小字符串优化，这通常只在字符串超过15个字符时发生）。 该程序的输出可能类似于以下内容。\n1018 allocations for 134,730 bytes 这将意味着为每个元素分配一次，加上 vector 内部的18次分配，因为它18次分配（更多）内存来容纳其元素。 这样的行为可能变得很关键，因为内存（重新）分配需要时间，在某些情况下（如嵌入式系统），分配堆内存可能是个问题。 我们可以要求 vector 在前面预留足够的内存，但一般来说，你无法避免重新分配，除非你知道前面要处理的数据量。如果你不知道到底要处理多少数据，你总是要在避免重新分配和不浪费太多内存之间找到一个折中点。而你至少需要1001个分配（一个分配用于保存向量中的元素，一个用于不使用小字符串优化的每个字符串）。\n不为容器分配内存 通过使用多态分配器，我们可以轻松地改善这种情况。首先，我们可以使用std::pmr::vector，让向量在堆栈中分配其内存。 pmr/pmr1.cpp。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); // 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; // 并将其用作vector的初始内存池： std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 首先，我们使用新类型 std::byte 在堆栈上分配我们自己的内存：\n// 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; 除了 std::byte 你也可以只使用 char。 然后，我们用这个内存初始化一个 monotonic_buffer_resource，传递它的地址和它的大小：\nstd::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; 最后，我们使用一个std::pmr::vector，它占用了所有分配的内存资源:\nstd::pmr::vector\u0026lt;std::string\u0026gt; coll{\u0026amp;pool}; 这个声明只是以下的一个快捷方式:\nstd::vector\u0026lt;std::string, std::pmr::polymorphic_allocator\u0026lt;std::string\u0026gt;\u0026gt; coll{\u0026amp;pool}; 也就是说，我们声明向量使用多态分配器，它可以在运行时在不同的内存资源之间切换。monotonic_buffer_resource类派生于memory_resource类，因此可以作为多态分配器的内存资源。因此，通过传递我们的内存资源的地址，我们确保向量使用我们的内存资源作为多态分配器。 如果我们测量这个程序的分配的内存，输出结果可能是。 32000字节的1000次分配 矢量的18次分配不再是在堆上进行的。相反，我们初始化的缓冲区buf被使用。 如果预先分配的200000字节的内存不够用，向量仍然会在堆上分配更多的内存。发生这种情况，是因为monotonic_memory_resource使用了默认的分配器，它用new来分配内存，作为退路。\n完全不分配内存 我们甚至可以通过定义std::pmr::vector的元素类型来避免使用堆内存 的元素类型为std::pmr::string:\npmr/pmr2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); // 在堆栈中分配一些内存： std::array\u0026lt;std::byte, 200\u0026#39;000\u0026gt; buf; // 并将其作为vector及其字符串的初始内存池。: std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 由于以下的矢量定义：\nstd::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; 程序的输出成为:\n0 allocations for 0 bytes 原因是，默认情况下，pmr向量试图将其分配器传播给其元素。当元素不使用多态分配器时，这是不成功的，如std::string类型的情况。然而，通过使用std::pmr::string类型，它是一个使用多态分配器的字符串，传播工作正常。 同样，只有当缓冲区中没有更多的内存时，新的内存才会由堆上的池分配。例如，这种情况可能发生在以下修改中:\nfor (int i=0; i \u0026lt; 50000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } 当输出可能突然变得:\n8 allocations for 14777448 bytes 重复使用内存池 我们甚至可以重复使用我们的堆栈内存池。比如说:\npmr/pmr3.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { // 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; for (int num : {1000, 2000, 500, 2000, 3000, 50000, 1000}) { std::cout \u0026lt;\u0026lt; \u0026#34;-- check with \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; elements:\\n\u0026#34;; TrackNew::reset(); std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; num; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } } 这里，在分配了堆栈上的200,000字节后，我们再次使用这块内存，为vector及其元素初始化一个新的资源池:\n输出可能变为：\n-- check with 1000 elements: 0 allocations for 0 bytes -- check with 2000 elements: 1 allocations for 300000 bytes -- check with 500 elements: 0 allocations for 0 bytes -- check with 2000 elements: 1 allocations for 300000 bytes -- check with 3000 elements: 2 allocations for 750000 bytes -- check with 50000 elements: 8 allocations for 14777448 bytes -- check with 1000 elements: 0 allocations for 0 bytes 每次200000字节足够的时候，我们不需要额外的分配（在这里，它是最多1000个元素的情况）。这200000字节被使用，当内存池被销毁时，可用于下一次迭代。 每次内存被超过时，内存池会在堆上分配额外的内存，当内存池被销毁时，这些内存会被删除。 这样你就可以很容易地对内存池进行编程，你只需分配一次内存（无论是在堆栈还是在堆上），并在每个新任务（服务请求、事件、要处理的数据文件等）中重复使用它。等等）。 我们将在后面讨论更复杂的内存池的例子。\n27.1.2 标准内存资源 为了支持多态分配器，C++标准库提供了表标准内存资源中列出的内存。\n内存资源 行为 new_delete_resource() 产生一个指向内存资源的指针，调用new和删除 synchronized_pool_resource 类来创建内存资源，碎片少，线程安全。 unsynchronized_pool_resource 创建零散的内存资源的类，不是线程安全的 monotonic_buffer_resource 创建内存资源的类，该类永远不会取消分配，可以选择使用一个传递的缓冲区，不是线程安全的 null_memory_resource() 产生一个指向内存资源的指针，每次分配都会失败 new_delete_resource()和null_memory_resource()是返回全局内存资源指针的函数，它被定义为一个单子。其他三个内存资源是类，你必须创建对象并将这些对象的指针传递给多态分配器。一些使用例子:\nstd::pmr::string s1{\u0026#34;my string\u0026#34;, std::pmr::new_delete_resource()}; std::pmr::synchronized_pool_resource pool1; std::pmr::string s2{\u0026#34;my string\u0026#34;, \u0026amp;pool1}; std::pmr::monotonic_buffer_resource pool2{...}; std::pmr::string s3{\u0026#34;my string\u0026#34;, \u0026amp;pool2}; 一般来说，内存资源是作为指针传递的。由于这个原因，重要的是你要确保这些指针所指的资源对象在最后一次调用去分配之前一直存在（如果你移动对象并且内存资源可以互换，这可能比你预期的要晚）。\n默认的内存资源 多态分配器有一个默认的内存资源，如果没有传递其他的内存资源，就会使用它。表中默认内存资源的操作列出了为其定义的操作。\n内存资源 行为 get_default_resource() 产生一个指向当前默认内存资源的指针 set_default_resource(memresPtr) 设置默认的内存资源（传递一个指针），并且产生一个指向前一个的指针 你可以用std::pmr::get_default_resource()来获取当前的默认资源，你可以通过它来初始化一个多态分配器。你可以用std::pmr::set_default_resource()全局性地设置一个不同的默认内存资源。这个资源在任何范围内都作为默认资源使用，直到下一次调用std::pmr::set_default_resource()。比如说\nstatic std::pmr::synchronized_pool_resource myPool; // 设置myPool为新的默认内存资源。 std::pmr::memory_resource* old = std::pmr::set_default_resource（\u0026amp;myPool）。 ...; // 恢复旧的默认内存资源为默认值。 std::pmr::set_default_resource(old)。 如果你在程序中创建了一个自定义的内存资源，并将其作为默认资源使用，那么在main()中作为静态对象先创建它，这是一个好办法。\nint main() { static std::pmr::synchronized_pool_resource myPool; ... } 或者，提供一个全局函数，将你的资源作为静态对象返回。\nmemory_resource* myResource() { static std::pmr::synchronized_pool_resource myPool; return \u0026amp;myPool; } 返回类型 memory_resource 是所有内存资源的基类。 请注意，以前的默认资源在被替换时可能仍然被使用。除非你知道（并确保）情况并非如此，例如，这意味着没有使用该资源创建静态对象，否则你应该让你的资源尽可能长地存活（同样，最好是在main()的开头创建，以便它最后被销毁）。\n27.1.3 标准内存资源的详细介绍 让我们详细讨论一下不同的标准内存资源。\nnew_delete_resource() new_delete_resource()是默认的内存资源。它是由get_default_resource()返回的。 返回，除非你通过调用set_default_resource()定义了一个不同的默认内存资源。 它处理分配，就像使用默认分配器时的处理方式。\n每次分配都调用new 每一次去分配都调用delete 然而，请注意，具有这种内存资源的多态分配器不能与默认分配器互换，因为它们只是具有不同的类型。由于这个原因\nstd::string s{\u0026#34;my string with some value\u0026#34;}。 std::pmr::string ps{std::move(s), std::pmr::new_delete_resource()}; // copies 将不会移动（将分配给s的内存传递给ps）。相反，s的内存将被复制到ps的新内存中，用new分配。\n(un)synchronized_pool_resource synchronized_pool_resource和unsynchronized_pool_resource是内存资源的类，它们试图将所有内存定位在彼此附近。因此，它们迫使内存的碎片化很少。 不同的是，synchronized_pool_resource是线程安全的（这需要花费更多的性能），而unsynchronized_pool_resource则不是。因此，如果你知道这个池子的内存只由一个线程处理（或者（去）分配是同步的），你应该选择unsynchronized_pool_resource。 这两个类仍然使用底层内存资源来实际执行分配和去分配。它们只是作为一个封装器，确保这些分配能更好地被集群起来。因此:\nstd::pmr::synchronized_pool_resource myPool。 与\nstd::pmr::synchronized_pool_resource myPool{std::pmr::get_default_resource()}。 此外，当池子被销毁时，它们会删除所有的内存。 这些池子的一个主要应用是确保基于节点的容器中的元素位于彼此的旁边。这也可能大大增加了容器的性能，因为这样CPU缓存就会把元素装在一起的缓存行中。其效果是，当你访问一个元素后，访问其他元素就变得非常快，因为它们已经在缓存中了。 然而，你应该衡量一下，因为这取决于内存资源的实现。例如，如果内存资源使用mutex来同步内存访问，性能可能会明显变差。 让我们用一个简单的例子来看看这个效果。下面的程序创建了一个地图，它将积分值映射到字符串。\npmr/pmrsync0.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; int main() { std::map\u0026lt;long, std::string\u0026gt; coll; for (int i=0; i\u0026lt;10; ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } // print element distances: for (const auto\u0026amp; elem : coll) { static long long lastVal = 0; long long val = reinterpret_cast\u0026lt;long long\u0026gt;(\u0026amp;elem); std::cout \u0026lt;\u0026lt; \u0026#34;diff: \u0026#34; \u0026lt;\u0026lt; (val-lastVal) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lastVal = val; } } 这个数据结构是一个平衡的二叉树，每个节点都执行自己的分配来存储一个元素。因此，对每个元素进行分配，这些分配默认当前在堆上分配内存（使用标准默认分配器）。 为了看清效果，程序打印了元素地址之间的距离，同时迭代了 它们之间的距离。例如，一个输出可能看起来如下:\ndiff: 1777277585312 diff: -320 diff: 60816 diff: 1120 diff: -400 diff: 80 diff: -2080 diff: -1120 diff: 2720 diff: -3040 这些元素不是彼此相邻的。我们有60,000字节的距离，10个元素的大小约为24字节。如果在元素的分配之间分配了其他的内存，这种碎片化就会变得更严重。 现在让我们用多态分配器运行这个程序，使用synchronized_pool_resource:\npmr/pmrsync1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory_resource\u0026gt; int main() { std::pmr::synchronized_pool_resource pool; std::pmr::map\u0026lt;long, std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i\u0026lt;10; ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } // 打印元素距离: for (const auto\u0026amp; elem : coll) { static long long lastVal = 0; long long val = reinterpret_cast\u0026lt;long long\u0026gt;(\u0026amp;elem); std::cout \u0026lt;\u0026lt; \u0026#34;diff: \u0026#34; \u0026lt;\u0026lt; (val-lastVal) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lastVal = val; } } 正如你所看到的，我们简单地创建了资源并将其作为参数传递给容器的构造函数:\nstd::pmr::synchronized_pool_resource pool; std::pmr::map\u0026lt;long, std::pmr::string\u0026gt; coll{\u0026amp;pool}; 例如，现在的输出看起来如下:\ndiff: 2548552461600 diff: 128 diff: 128 diff: 105216 diff: 128 diff: 128 diff: 128 diff: 128 diff: 128 diff: 128 正如你所看到的，这些元素现在都位于彼此附近。但是，它们仍然没有位于一个内存块中。当内存池发现第一块内存不足以容纳所有的元素时，它为更多的元素分配更多的内存。因此，我们分配的内存越多，内存块就越大，这样就有更多的元素被放在彼此附近。这个算法的细节是由实现定义的。\n当然，这个输出是特殊的，因为我们按照元素在容器内的排序来创建它们。因此，在实践中，如果你用随机值创建对象，这些元素将不会一个接一个地顺序定位（在不同的内存块中）。然而，它们仍然位于彼此之间，这对于处理这个容器中的元素时的良好性能是很重要的。\n还请注意，我们不看元素值的内存是如何安排的。在这里，通常小字符串的优化导致对元素没有分配内存。但是一旦我们放大了字符串值，池子也会尝试将这些字符串放在一起。请注意，池为不同的分配大小管理不同的内存块。也就是说，在一般情况下，元素之间是相互定位的，相同字符串大小的元素的字符串值是相互靠近的。\nmonotonic_buffer_resource monotonic_buffer_resource类也提供了将所有内存放在大块内存中的能力。然而，它还有另外两种能力。\n你可以传递一个缓冲区来作为内存使用。这一点，特别是可以在堆栈上分配内存。 内存资源永远不会被取消分配，直到整个资源被取消分配。也就是说，它也试图避免碎片化。而且，它的速度超快，因为去分配是一个无操作的过程，你跳过了追踪去分配的内存以便进一步使用。每当有分配内存的请求时，它只是返回下一块空闲的内存，直到所有的内存都用完。 请注意，对象仍然是被销毁的。只有它们的内存没有被释放。如果你删除了对象，这通常会删除它们的内存，但删除并没有影响。 如果你没有删除对象，或者你有足够的内存可以浪费（不重复使用之前被其他对象使用的内存），你应该更喜欢这种资源。 我们已经在第一个激励性的例子中看到了monotonic_buffer_resource的应用，我们把在堆栈中分配的内存传递给了池。\nstd::array\u0026lt;std::byte, 200000\u0026gt; buf。 std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}。 你也可以使用这个池子让任何内存资源跳过去分配（可以选择传递一个初始大小）。默认情况下，这将适用于默认的内存资源，默认是new_delete_resource()。就是说，用\n//使用默认的内存资源，但只要池子还在，就跳过去分配。 { std::pmr::monotonic_buffer_resource pool。 std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;)。 } coll.clear(); // 销毁但不去分配 } // 取消分配所有分配的内存 带有循环的内部块将不时为向量及其元素分配内存。由于我们使用的是一个池子，分配的内存被组合成块状。例如，这可能导致14次分配。通过首先调用coll.reserve(100)，这通常会变成只有两个分配。 正如所写的那样，只要池子存在，就不做任何取消分配。因此，如果向量的创建和使用是在一个循环中完成的，池子分配的内存会不断增加。 monotonic_buffer_resource也允许我们传递一个初始大小，然后它使用其第一次分配的最小大小（当第一次内存请求发生时进行）。此外，你可以定义它使用哪个内存资源来执行分配。这使得我们可以通过连锁内存资源来提供更复杂的内存资源。 考虑一下下面的例子:\n{ // 分配大块内存（从10k开始），而不去分配: std::pmr::monotonic_buffer_resource keepAllocatedPool{10000}; std::pmr::synchronized_pool_resource pool{\u0026amp;keepAllocatedPool}; for (int j=0; j \u0026lt; 100; ++j) { std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } } // 去分配的数据被送回池中，但没有解除分配。 // 到目前为止，没有任何东西被释放 } // 释放所有分配的内存 通过这段代码，我们首先为我们所有的内存创建一个池，只要它活着就永远不会去分配，初始化时开始分配10000字节（使用默认的内存资源分配）。\nstd::pmr::monotonic_buffer_resource keepAllocatedPool{10000}。 然后我们创建另一个池，使用这个非去分配的池来分配内存块。\nstd::pmr::synchronized_pool_resource pool{\u0026amp;keepAllocatedPool}。 综合的效果是，我们的所有内存都有一个池子，它从10000字节开始分配，如果有必要，可以分配更多的内存，而且几乎没有碎片，可以被所有使用这个池子的pmr对象使用。 当keepAllocatedPool超出范围时，所分配的内存（可能是最初的10000字节加上一些更大的内存块的额外分配）都将被释放。\n这里到底发生了什么，将在后面我们扩展这个例子以追踪这个嵌套池的所有分配时进行演示。\nnull_memory_resource() null_memory_resource()处理分配的方式是每次分配都会抛出一个bad_alloc异常。 最重要的应用是确保使用堆栈上分配的内存的内存池不会突然在堆上分配内存，如果它需要更多的话。 考虑一下下面的例子:\npmr/pmrnull.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; int main() { // 使用堆栈上的内存而不在堆上进行回退: std::array\u0026lt;std::byte, 200000\u0026gt; buf; std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size(), std::pmr::null_memory_resource()}; // 并分配太多内存: std::pmr::unordered_map\u0026lt;long, std::pmr::string\u0026gt; coll {\u0026amp;pool}; try { for (int i=0; i\u0026lt;buf.size(); ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } } catch (const std::bad_alloc\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;BAD ALLOC EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; coll.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 我们在堆栈中分配内存，并将其传递给单调的缓冲区作为内存资源:\nstd::array\u0026lt;std::byte, 200000\u0026gt; buf; std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size(), std::pmr::null_memory_resource()}; 通过传递null_memory_resource()作为后备内存资源，我们确保任何分配更多内存的尝试都会抛出一个异常，而不是在堆上分配内存。 其结果是，程序迟早会结束，例如，输出结果如下:\nBAD ALLOC EXCEPTION: bad allocation size: 2048 当堆内存分配不是一种选择时，这有助于获得合理的反馈，而不是碰上你必须避免的行为。\n27.2 定义自定义内存资源 你可以提供你自定义的内存资源。为此，你只需要\n派生自std::pmr::memory_resource 实现私有成员 do_allocate() 来分配内存 do_deallocate()来删除内存 do_is_equal()定义你的类型是否以及何时可以与另一个内存资源对象交换分配的内存 下面是一个完整的例子，它仅仅允许我们跟踪任何 其他的内存资源:\npmr/tracker.hpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory_resource\u0026gt; class Tracker : public std::pmr::memory_resource { private: std::pmr::memory_resource* upstream; // 包装的内存资源 std::string prefix{}; public: // 我们包装传递的或默认的资源: explicit Tracker(std::pmr::memory_resource* us = std::pmr::get_default_resource()) : upstream{us} { } explicit Tracker(std::string p, std::pmr::memory_resource* us = std::pmr::get_default_resource()) : prefix{std::move(p)}, upstream{us} { } private: void* do_allocate(size_t bytes, size_t alignment) override { std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#34;allocate \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; Bytes\\n\u0026#34;; void* ret = upstream-\u0026gt;allocate(bytes, alignment); return ret; } void do_deallocate(void* ptr, size_t bytes, size_t alignment) override { std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#34;deallocate \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; Bytes\\n\u0026#34;; upstream-\u0026gt;deallocate(ptr, bytes, alignment); } bool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // 相同的类型和前缀以及相等的上游？ auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix \u0026amp;\u0026amp; upstream-\u0026gt;is_equal(other); } }; 像通常的智能内存资源一样，我们支持传递另一个内存资源（通常称为上游）来包裹它或将其作为后备资源。此外，我们还可以传递一个可选的前缀。在每次分配和去分配时，我们都会用可选的前缀来追踪这个调用。 我们唯一需要实现的其他函数是do_is_equal()，它定义了两个分配器何时可以互换（也就是说，一个多态内存资源对象是否以及何时可以去分配另一个分配的内存）。在这种情况下，我们简单地说，只要前缀相同，任何这种类型的对象都可以取消从任何其他这种类型的对象分配的内存:\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // 相同的类型和前缀以及相等的上游？: auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix \u0026amp;\u0026amp; upstream-\u0026gt;is_equal(other); } 第一个比较的存在只是为了跳过其他更昂贵的与下限的比较。如果我们不使用相同的跟踪器，我们要求另一个内存资源也是具有相同前缀的跟踪器（相同意义上的相同）和可交换的底层内存资源。否则，如果我们使用不同底层内存资源的跟踪器，应用程序会认为从完全不同的内存资源中分配的内存是可以取消的。 让我们使用这个跟踪器来理解之前演示的嵌套池的行为，以分配大块的内存而不去分配:\npmr/tracker.cpp\n#include \u0026#34;tracker.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory_resource\u0026gt; int main() { { // 追踪分配内存块（从10k开始）而不去分配。: Tracker track1{\u0026#34;keeppool:\u0026#34;}; std::pmr::monotonic_buffer_resource keeppool{10000, \u0026amp;track1}; { Tracker track2{\u0026#34; syncpool:\u0026#34;, \u0026amp;keeppool}; std::pmr::synchronized_pool_resource pool{\u0026amp;track2}; for (int j=0; j \u0026lt; 100; ++j) { std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; coll.reserve(100); for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } if (j==2) std::cout \u0026lt;\u0026lt; \u0026#34;--- third iteration done\\n\u0026#34;; } // 去分配的数据被送回池子里，但没有去分配。 // 到目前为止，没有分配到任何东西 std::cout \u0026lt;\u0026lt; \u0026#34;--- leave scope of pool\\n\u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;--- leave scope of keeppool\\n\u0026#34;; } // 删除所有已分配的内存 } 输出可能如下所示：\nsyncpool:allocate 48 Bytes keeppool:allocate 10000 Bytes syncpool:allocate 16440 Bytes keeppool:allocate 16464 Bytes syncpool:allocate 96 Bytes keeppool:allocate 24696 Bytes syncpool:deallocate 48 Bytes syncpool:allocate 312 Bytes syncpool:allocate 568 Bytes syncpool:allocate 1080 Bytes syncpool:allocate 2104 Bytes syncpool:allocate 4152 Bytes syncpool:deallocate 312 Bytes syncpool:deallocate 568 Bytes syncpool:deallocate 1080 Bytes syncpool:deallocate 2104 Bytes syncpool:allocate 8248 Bytes syncpool:deallocate 4152 Bytes --- third iteration done --- leave scope of pool syncpool:deallocate 8248 Bytes syncpool:deallocate 16440 Bytes syncpool:deallocate 96 Bytes --- leave scope of keeppool keeppool:deallocate 24696 Bytes keeppool:deallocate 16464 Bytes keeppool:deallocate 10000 Bytes 输出显示了以下情况。\n随着一个对象的第一次分配，syncpool分配了48个字节，这导致keeppool分配其初始的10,000字节。这10,000字节是在堆上分配的，使用的是keeppool初始化时get_default_resource()的资源。 后来的对象会分配和删除内存，这使得syncpool不时地分配更多的内存块，但也会删除内存块。如果syncpool有效地分配了比keeppool所分配的更多的内存，keeppool再次从堆中分配更多的内存。也就是说，只有keeppool的分配成为（相当昂贵的）系统调用。 通过对第三个迭代结束时的额外追踪，你可以看到所有这些分配都发生在外循环的前三个迭代中。然后，（重新）使用的内存量是稳定的。因此，剩下的97次迭代根本就没有从操作系统中分配任何内存。 即使syncpool已经分配了所有的内存，keeppool也没有分配任何内存。 只有当keeppool被销毁时，分配的六块内存才会真正地被调用::delete（或者当keeppool被初始化时用set_default_resource()定义的任何东西）而被取消分配。 如果我们在这个程序中引入第三个跟踪器，我们也可以跟踪对象从syncpool分配和删除内存的时间:\n// 跟踪每个调用，同步池中的效果，以及单池中的效果: Tracker track1{\u0026#34;keeppool:\u0026#34;}; std::pmr::monotonic_buffer_resource keepAllocatedPool{10000, \u0026amp;track1}; Tracker track2{\u0026#34; syncpool:\u0026#34;, \u0026amp;keepAllocatedPool}; std::pmr::synchronized_pool_resource syncPool{\u0026amp;track2}; Tracker track3{\u0026#34; objects:\u0026#34;, \u0026amp;syncPool}; ... std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;track3}; 27.2.1 内存资源的平等性 让我们谈谈 do_is_equal()，该函数定义两个内存资源何时可互换。 这个功能需要比最初看起来更多的思考。 在我们的跟踪器中，我们定义了分配器是可互换的，如果它们都是 Tracker 类型并且使用相同的前缀：\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // same type and prefix?: auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix; } 这具有以下效果：\nTracker track1{\u0026#34;track1:\u0026#34;}; Tracker track2{\u0026#34;track2:\u0026#34;}; std::pmr::string s1{\u0026#34;more than 15 chars\u0026#34;, \u0026amp;track1}; // 用 track1 分配 std::pmr::string s2{std::move(s1), \u0026amp;track1}; // 移动（相同的跟踪器） std::pmr::string s3{std::move(s2), \u0026amp;track2}; // 拷贝（不同的前缀） std::pmr::string s4{std::move(s3)}; // 移动（复制分配器） std::string s5{std::move(s4)}; // 移动（其他分配器） 也就是说，只有当源码和目的码具有可互换的分配器时，移动才会作为移动执行。对于多态分配类型，当使用移动构造函数时就是这种情况（新对象复制了分配器）。但是如果需要一个不可互换的分配器（如这里的跟踪器有不同的前缀），或者使用不同的分配器类型（如移动到std::string，它使用默认的分配器），内存会被复制。因此，互换性会影响移动的性能。 如果我们让所有Tracker类型的内存资源都可以互换，只检查类型:\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // 如果所有 Tracker 具有相同的类型，则它们都可以互换: return this == \u0026amp;other || dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other) != nullptr; } 我们会得到以下行为:\nTracker track1{\u0026#34;track1:\u0026#34;}; Tracker track2{\u0026#34;track2:\u0026#34;}; std::pmr::string s1{\u0026#34;more than 15 chars\u0026#34;, \u0026amp;track1}; // 用 track1 分配 std::pmr::string s2{std::move(s1), \u0026amp;track1}; // 移动（相同的跟踪器类型） std::pmr::string s3{std::move(s2), \u0026amp;track2}; // 移动 (same tracker type) std::pmr::string s4{std::move(s3)}; // 移动 (allocator copied) std::string s5{std::move(s4)}; // 拷贝 (other allocator) 如您所见，效果是track1分配的内存通过s3传递给s4，两者都使用track2，因此我们得到：\ntrack1:allocate 32 Bytes track2:deallocate 32 Bytes 如果我们的内存资源不会有不同的状态（即不会有前缀），这将是一个很好的实现，因为这可以提高移动的性能。 所以，使内存资源可互换是值得的，因为较少的移动会转换为拷贝。但你不应该让它们的互换性超过其目的需要。\n27.3 为自定义类型提供内存资源支持 在我们介绍了标准内存资源和用户定义的内存资源之后，还有一个问题。我们怎样才能使我们的自定义类型具有多态分配器意识，从而使它们像pmr::string一样作为pmr容器的一个元素，使用其分配器进行分配。\n27.3.1 PMR类型的定义 支持多态分配器的方法出奇的简单，只要对所有需要堆内存的数据使用pmr成员就可以了。你必须这样做。\n将allocator_type定义为多态分配器的公共成员 为所有构造函数添加重载，使其将分配器作为附加参数（包括复制和移动构造函数）。 让没有分配器参数的初始化构造函数使用allocator_type（如果实现的话，这不适用于复制和移动构造函数）。 下面是第一个例子:\npmr/pmrcustomer.hpp #include \u0026lt;string\u0026gt; #include \u0026lt;memory_resource\u0026gt; // 一个多态分配器感知类型 客户 // - 分配器存储在字符串成员中 class PmrCustomer { private: std::pmr::string name; // 也用于存储分配器 public: using allocator_type = std::pmr::polymorphic_allocator\u0026lt;char\u0026gt;; // 初始化构造函数 constructor(s): PmrCustomer(std::pmr::string n, allocator_type alloc = {}) : name{std::move(n), alloc} { } // 使用分配器复制/移动: PmrCustomer(const PmrCustomer\u0026amp; c, allocator_type alloc) : name{c.name, alloc} { } PmrCustomer(PmrCustomer\u0026amp;\u0026amp; c, allocator_type alloc) : name{std::move(c.name), alloc} { } // setters/getters: void setName(std::pmr::string s) { name = std::move(s); } std::pmr::string getName() const { return name; } std::string getNameAsString() const { return std::string{name}; } }; 首先注意，我们使用一个pmr字符串作为成员。这不仅持有值（这里是名称），还持有当前使用的分配器:\nstd::pmr::string name; // 也用于存储分配器 然后，我们必须指定这个类型支持多态分配器，这可以通过提供一个相应的allocator_type类型的声明来简单完成:\nusing allocator_type = std::pmr::polymorphic_allocator\u0026lt;char\u0026gt;; 传递给polymorphic_allocator的类型并不重要（当它被使用时，分配器会被反弹到必要的类型）。例如，你也可以在那里使用std::byte。4 另外，你也可以使用字符串成员的allocator_type:\nusing allocator_type = decltype(name)::allocator_type; 接下来我们定义通常的构造函数，增加一个可选的分配器参数。\nPmrCustomer(std::pmr::string n, allocator_type alloc = {}) : name{std::move(n), alloc} { } 你可以考虑将这样的构造函数声明为显式的。至少如果你有一个默认的构造函数，你应该这样做以避免从分配器到客户的隐式转换。\nexplicit PmrCustomer(allocator_type alloc = {}) : name{alloc} { } 然后，我们必须提供要求特定分配器的复制和移动操作。这是pmr容器的主要接口，确保其元素使用容器的分配器。\nPmrCustomer(const PmrCustomer\u0026amp; c, allocator_type alloc) : name{c.name, alloc} { } PmrCustomer(PmrCustomer\u0026amp;\u0026amp; c, allocator_type alloc) : name{std::move(c.name), alloc} { } 注意，这两个都不是noexcept，因为如果所需的分配器allocator不能互换，即使是move构造函数也可能要复制一个被传递的客户。 最后，我们实现必要的setters和getters，它们通常是。\nvoid setName(std::pmr::string s) { name = std::move(s); } std::pmr::string getName() const { return name; } 还有一个getter，getNameAsString()，我们提供这个getter来廉价地将名字返回为 std::string。我们将在后面讨论它。目前，你也可以不使用它。\n27.3.2 PMR类型的用法 有了上面 PmrCustomer 的定义，我们就可以在 pmr 容器中使用这个类型了。 例如：\npmr/pmrcustomer1.cpp\n#include \u0026#34;pmrcustomer.hpp\u0026#34; #include \u0026#34;tracker.hpp\u0026#34; #include \u0026lt;vector\u0026gt; int main() { Tracker tracker; std::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); coll.reserve(100); // 用跟踪器分配 PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 coll.push_back(c1); // 使用vector分配器（跟踪器）进行分配 coll.push_back(std::move(c1)); // 副本（分配器不可互换） for (const auto\u0026amp; cust : coll) { std::cout \u0026lt;\u0026lt; cust.getName() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 为了让人们看到所发生的事情，我们使用追踪器来追踪所有的分配和取消分配:\nTracker tracker; std::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); 当我们为100个元素保留内存时，vector使用我们的跟踪器来分配必要的数据:\ncoll.reserve(100); //用跟踪器分配 当我们创建消费者时，不使用跟踪器：\nPmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 然而，当我们把customer的副本推到vector中时，vector会确保元素也都使用其多态分配器。由于这个原因，PmrCustomer的扩展拷贝构造函数被调用，其第二个参数是vector分配器，这样元素就被初始化了 与跟踪器一起初始化。\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 coll.push_back(c1); // 使用vector分配器（跟踪器）进行分配 如果我们把customer 移到vector中，也会发生同样的情况，因为vector的分配器（跟踪器）和客户的分配器（使用默认资源）是不能互换的：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 ... coll.push_back(std::move(c1)); // 副本（分配器不可互换） 如果我们还使用跟踪器初始化客户，则移动将起作用：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;, \u0026amp;tracker}; // 用跟踪器分配 ... coll.push_back(std::move(c1)); // 移动（相同的分配器） 如果我们根本不使用任何跟踪器，情况也是如此：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll; // 使用默认资源分配 ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 使用默认资源分配 ... coll.push_back(std::move(c1)); // 移动（相同的分配器） 27.3.3 处理不同的类型 虽然将 PmrCustomer 与 pmr 类型一起使用变得非常好，但我们有一个问题：通常，程序使用 std::string 类型的字符串。 那么我们如何处理同时使用 std::string 和 std::pmr::string 呢？ 首先，不同字符串类型之间存在显式但没有隐式转换：\nstd::string s; std::pmr::string t1{s}; // OK std::pmr::string t2 = s; // ERROR s = t1; // ERROR s = std::string(t1); // OK 支持显式转换，因为任何字符串都会隐式转换为 std::string_view，它可以显式转换为任何字符串类型。 进一步降低成本，但后者需要分配内存（假设小字符串优化不适用）。 在我们的示例中，这意味着：\nstd::string s{\u0026#34;Paul Kalkbrenner\u0026#34;}; PmrCustomer c1 = s; // 错误：没有隐式转换 PmrCustomer c2{s}; // 错误：没有隐式转换 PmrCustomer c3{std::pmr::string{s}}; // OK（隐式将 s 转换为 string_view） 我们可能想提供额外的构造函数，但不提供它们的好处是程序员被迫实现昂贵的转换。 此外，如果您为不同的字符串类型（std::string 和 std::pmr::string）重载，则会产生额外的歧义（例如，采用 string_view 或字符串文字），因此需要更多的重载。 无论如何，getter 只能返回一种类型（因为我们不能只重载不同的返回类型）。 因此，我们只能提供一个 getter，它通常应该返回 API 的“本机”类型（这里是 std::pmr::string）。 这意味着，如果我们返回一个 std::pmr::string 并且需要名称为 std::string，我们再次需要显式转换：\nPmrCustomer c4{\u0026#34;Mr. Paul Kalkbrenner\u0026#34;}; // OK：使用默认资源分配 std::string s1 = c4.getName(); // 错误：没有隐式转换 std::string s2 = std::string{c4.getName()}; // OOPS：两个分配 这不仅不太方便，这也是一个性能问题，因为在最后一条语句中发生了两次分配：\n首先我们为返回值分配内存，然后 那么从 std::pmr::string 类型到 std::string 的转换需要另一个分配。 出于这个原因，提供一个额外的 getNameAsString() 直接创建并返回请求的类型可能是个好主意：\nstd::string s3 = c4.getNameAsString(); // OK：一次分配 27.4 后记 多态分配器首先由 Pablo Halpern 在 https://wg21.link/n3525 中提出。 这 采用 Pablo Halpern 在 https://wg21.link/n3916 中提出的方法成为图书馆基础 TS 的一部分。 该方法与 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的 C++17 的其他组件一起采用。\n28 对齐数据上的new和delete 从C++11开始，你可以指定过度对齐的类型，通过使用alignas指定器，拥有比默认对齐方式更大的对齐方式。比如说:\nstruct alignas(32) MyType32 { int i; char c; std::string s[4]; }; MyType32 val1; // 32 字节对齐 alignas(64) MyType32 val2; // 64 字节对齐 请注意，对齐值必须是 2 的幂，并且指定小于该类型默认对齐的任何值都是错误的。 但是，过度对齐数据的动态/堆分配在 C++11 和 C++14 中未正确处理。 默认情况下，对过度对齐的类型使用 operator new 会忽略请求的对齐方式，因此通常 63 字节对齐的类型可能例如仅 8 字节或 16 字节对齐。 C++17 弥补了这一差距。 新行为的结果是提供了带有对齐参数的新重载，以便能够为过度对齐的数据提供您自己的 operator new 实现。\n28.1 使用新的对齐方式 通过使用过度对齐的类型，例如：\nstruct alignas(32) MyType32 { int i; char c; std::string s[4]; }; 一个新的表达式现在可以保证所请求的堆内存是按要求对齐的（前提是 支持过度对齐）:\nMyType32* p = new MyType32; // 因为 C++17 保证是 32 字节对齐的 ... 在C++17之前，请求不保证是32字节对齐的。 像往常一样，没有任何初始化的值，对象是默认初始化的，这意味着可用的构造器被调用，但基本类型的（子）对象有一个未定义的值。由于这个原因，你最好使用带大括号的列表初始化，以确保（子）对象要么有其默认值或0/false/nullptr：\nMyType32* p = new MyType32{}; // 对齐和初始化 28.1.1 不同的动态/堆栈内存领域 请注意，对对齐内存的请求可能会导致调用从一个不相连的内存分配机制中获取内存。由于这个原因，对对齐内存的请求可能需要一个特定的相应请求来取消对齐数据。有可能内存是用C11函数aligned_alloc()分配的（现在在C++17中也可用）。在这种情况下，用free()去分配还是可以的，这样与用malloc()分配的内存相比就没有什么区别。 然而，对于平台来说，new和delete的其他实现是允许的，这就导致了必须用不同的内部函数去分配默认对齐的和超对齐的数据的要求。例如，在Windows上通常使用_aligned_malloc()，这就要求使用_aligned_free()作为对应。 与C标准相比，C++标准尊重这种情况，因此在概念上假定有两个互不相干的、不可操作的内存区域，一个用于默认对齐的数据，一个用于超对齐的数据。大多数情况下，编译器知道如何正确地处理这个问题：\nstd::string* p1 = new std::string; // 使用默认对齐的内存操作 MyType32* p2 = new MyType32; // 使用过度对齐的内存操作 ... delete p1; // 使用默认对齐的内存操作 delete p2; // 使用过度对齐的内存操作 但有时程序员必须做正确的事情，正如我们将在本章的其余部分中看到的那样。\n28.1.2 用new表达式传递对齐方式 还有一种方法是为特定的新调用请求特定的过度对齐。比如说：\n#include \u0026lt;new\u0026gt; // for align_val_t ... std::string* p = new(std::align_val_t{64}) std::string; // 64 字节对齐 MyType32* p = new(std::align_val_t{64}) MyType32{}; // 64 字节对齐 ... std::align_val_t 类型在标头 中定义如下：\nnamespace std { enum class align_val_t : size_t { }; } 它被规定为现在能够将对齐请求传递给运算符new()的相应实现。请记住，在C++中运算符new()可以用不同的方式实现。\n作为一个全局函数（默认提供了不同的重载，可以由程序员替换）。 作为特定类型的实现，可以由程序员提供，并具有比全局重载更高的 优先级高于全局重载。 然而，这是第一个例子，必须特别注意正确处理不同的动态内存领域，因为当用新的表达式指定对齐方式时，编译器不能使用类型来知道是否以及哪种对齐方式被请求。程序员必须指定调用哪个删除操作。 不幸的是，没有一个删除操作符，你可以传递一个额外的参数，你必须直接调用相应的操作符delete()，这意味着你必须知道多个重载中的哪一个被实现。事实上，在这个例子中，对于一个T类型的对象，可以调用以下函数中的一个 类型的对象，可以调用以下函数之一:\nvoid T::operator delete(void* ptr, std::size_t size, std::align_val_t align); void T::operator delete(void* ptr, std::align_val_t align); void T::operator delete(void* ptr, std::size_t size); void T::operator delete(void* ptr); void ::operator delete(void* ptr, std::size_t size, std::align_val_t align); void ::operator delete(void* ptr, std::align_val_t align); void ::operator delete(void* ptr, std::size_t size); void ::operator delete(void* ptr); 是的，就是这么复杂，我将在后面详细解释。目前，请使用三个选项中的一个。\n不要在新的表达式中直接使用过度对齐。 提供操作者new()和操作者delete()的实现，使用相同的内存区域（这样调用delete总是可以的）。 提供与运算符new()相匹配的运算符delete()的特定类型实现，并直接调用它们，而不是使用delete表达式。 注意，你不能使用类型定义或使用声明来代替:\nusing MyType64 = alignas(64) MyType32; // ERROR typedef alignas(64) MyType32 MyType64; // ERROR ... MyType64* p = new MyType64; // 因此不可能 原因是typedef或using声明只是原始类型的一个新名称/别名，这里所要求的是一个不同的类型，遵循不同的对齐规则。 如果你想调用一个对齐的new，获得nullptr作为返回值，而不是抛出 std::bad_alloc，你可以这样做：\n// 分配一个 64 字节对齐的字符串（如果没有，则为 nullptr）: std::string* p = new(std::align_val_t{64}, std::nothrow) std::string; if (p != nullptr) { ... } 28.2 为对齐的内存实现操作符new() 在C++中，当new和delete被调用时，你可以提供你自己的分配和删除内存的实现。这种机制现在也支持传递一个对齐参数。\n28.2.1 在C++17之前实现对齐分配 在全局范围内，C++提供了操作符new()和操作符delete()的重载，除非定义了特定类型的实现，否则会使用这些操作符。如果存在这些操作符的特定类型的实现，就会使用它们。请注意，有一个特定类型的操作符new()，就不能使用该类型的任何全局操作符new()实现（同样适用于delete、new[]和 delete[]）。\n也就是说，每次为类型 T 调用 new 时，都会调用特定类型的 T::operator new() 或（如果不存在）全局 ::operator new() 的相应调用：\nauto p = new T; // 尝试调用特定类型的运算符 new()（如果有） // 如果没有尝试调用全局 ::operator new() 同样地，每次你为一个类型T调用delete时，都会相应地调用特定类型的T::operator delete()或全局的::operator delete()。如果数组被分配/去分配，相应的特定类型或全局操作符operator new和operator delete被调用。 在C++17之前，要求的对齐方式不会自动传递给这些函数，默认机制分配动态内存时不会考虑对齐方式。一个过度对齐的类型总是需要自己实现operator new()和operator delete()才能在动态内存上正确对齐。更糟糕的是，没有可移植的方法来执行对过度对齐的动态内存的请求。 因此，举例来说，你必须定义如下的东西:\nlang/alignednew11.hpp #include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;string\u0026gt; #if __STDC_VERSION \u0026gt;= 201112L #include \u0026lt;stdlib.h\u0026gt; // for aligned_alloc() #else #include \u0026lt;malloc.h\u0026gt; // for _aligned_malloc() or memalign() #endif struct alignas(32) MyType32 { int i; char c; std::string s[4]; ...; static void* operator new (std::size_t size) { // 为要求的排列方式分配内存: #if __STDC_VERSION \u0026gt;= 201112L // use API of C11: return aligned_alloc(alignof(MyType32), size); #else #ifdef _MSC_VER // use API of Windows: return _aligned_malloc(size, alignof(MyType32)); #else // use API of Linux: return memalign(alignof(MyType32), size); #endif #endif } static void operator delete (void* p) { // 为所要求的对齐方式取消分配内存: #ifdef _MSC_VER // 使用Windows的特殊API: _aligned_free(p); #else // C11/Linux可以使用通用的free()函数。: free(p); #endif } // since C++14: static void operator delete (void* p, std::size_t size) { MyType32::operator delete(p); // 使用非尺寸删除 } ...; // also for arrays (new[] and delete[]) }; 注意，从C++14开始，你可以为删除操作符提供一个大小参数。然而，可能会发生尺寸不可用的情况（例如，当处理不完整的类型时），有些情况下，平台可以选择是否向操作符delete()传递一个尺寸参数。出于这个原因，自C++14以来，你应该总是同时替换操作符delete()的无大小和有大小的重载。让一个人调用另一个人通常是可以的。 有了这个定义，下面的代码表现得很正确：\nlang/alignednew11.cpp #include \u0026#34;alignednew11.hpp\u0026#34; int main() { auto p = new MyType32; ...; delete p; } 如所写，从 C++17 开始，您可以跳过执行操作以分配/取消分配对齐数据的开销。 即使没有为您的类型定义 operator new() 和 operator delete()，该示例也能正常工作：\nlang/alignednew17.cpp #include \u0026lt;string\u0026gt; struct alignas(32) MyType32 { int i; char c; std::string s[4]; ... }; int main() { auto p = new MyType32; // 从C++17开始分配32字节对齐的内存 ...; delete p; } 28.2.2 实现特定类型操作符new() 如果你必须自己实现运算符new()和运算符delete()，现在已经支持超对齐数据。在实践中，特定类型的相应代码 实现的相应代码自C++17以来看起来如下：\nlang/alignednew.hpp #include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;new\u0026gt; // for std::align_val_t #include \u0026lt;cstdlib\u0026gt; // for malloc(), aligned_alloc(), free() #include \u0026lt;string\u0026gt; struct alignas(32) MyType32 { int i; char c; std::string s[4]; ...; static void* operator new (std::size_t size) { // 要求默认对齐的数据: // 调用默认对其数据： std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size); } static void* operator new (std::size_t size, std::align_val_t align) { // 要求过度对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; and alignment \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;std::size_t\u0026gt;(align) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size, align); } static void operator delete (void* p) { // 要求默认对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::delete() without alignment\\n\u0026#34;; ::operator delete(p); } static void operator delete (void* p, std::size_t size) { MyType32::operator delete(p); // 使用非大小删除 } static void operator delete (void* p, std::align_val_t align) { // 要求默认对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::delete() with alignment\\n\u0026#34;; ::operator delete(p, align); } static void operator delete (void* p, std::size_t size, std::align_val_t align) { MyType32::operator delete(p, align); // 使用非大小删除 } // also for arrays (operator new[] and operator delete[]) ...; }; 原则上，我们只需要额外对齐参数的重载，并调用函数来分配和释放对齐的内存。 最便携的方法是调用为过度对齐（取消）分配提供的全局函数：\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; return ::operator new(size, align); } ...; static void operator delete (void* p, std::align_val_t align) { ...; ::operator delete(p); } 您也可以直接调用 C11 函数进行对齐分配：\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); } ...; static void operator delete (void* p, std::align_val_t align) { ...; std::free(p); } 然而，由于Windows对aligned_alloc()的问题，在实践中，我们需要特殊的处理方式来进行移植，那么:\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; #ifdef _MSC_VER // 特定于 Windows 的 API: return aligned_malloc(size, static_cast\u0026lt;size_t\u0026gt;(align)); #else // 标准 C++17 API: return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); #endif } static void operator delete (void* p, std::align_val_t align) { ...; #ifdef _MSC_VER // 特定于 Windows 的 API: _aligned_free(p); #else // 标准 C++17 API: std::free(p); #endif } 请注意，所有的分配函数都将对齐参数作为size_t类型，这意味着我们必须使用静态转换来从std::align_val_t类型转换数值。 此外，你可能想用[[nodiscard]]声明运算符new()的重载。属性:\n[[nodiscard]] static void* operator new (std::size_t size) { ...; } [[nodiscard]] static void* operator new (std::size_t size, std::align_val_t align) { ...; } 直接调用运算符new()（不使用new表达式）是很罕见的，但（正如你在这里看到的）是可能的。有了[[nodiscard]]，编译器会检测到，如果调用者忘记使用返回值，这将导致内存泄漏。\noperator new() 什么时候调用？ 正如所介绍的，我们现在可以有两个重载的操作符new()。\n只有size参数的版本，在C++17之前也被支持，一般是为默认对齐的数据请求提供的。 然而，如果没有提供用于大对齐数据的版本，它也可以作为回退。 带有额外对齐参数的版本，自C++17以来得到了特别的支持，一般是为超对齐数据的请求提供的。 使用哪个重载不一定取决于是否使用了alignas。它取决于特定平台对过对齐数据的定义。 编译器会根据一个一般的对齐值从默认对齐切换到超对齐，这个值 你可以在新的预处理程序常量中找到 stdcpp_default_new_alignment。 也就是说，在任何大于这个常数的对齐方式下，调用new会从试图调用\noperator new(std::size_t) 试调用：\noperator new(std::size_t, std::align_val_t) 因此，以下代码的输出可能因平台而异:\nstruct alignas(32) MyType32 { ...; static void* operator new (std::size_t size) { std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size); } static void* operator new (std::size_t size, std::align_val_t align) { std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; and alignment \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;std::size_t\u0026gt;(align) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size, align); ::operator delete(p); } ...; }; auto p = new MyType32; 如果默认的对齐方式是32（或者更少，并且代码可以编译），表达式new MyType32将调用运算符new()的第一个重载，只有大小参数，所以输出是这样的 像这样:\nMyType32::new() with size 128 如果默认对齐方式小于32，将调用两个参数的运算符new()的第二个重载，这样输出就变成了这样:\nMyType32::new() with size 128 and alignment 32 如果没有为特定类型的运算符new()提供std::align_val_t重载，没有这个参数的重载将被用作回退。因此，一个只提供C++17之前支持的运算符new()重载的类仍然可以编译并具有相同的行为（注意，对于全局运算符new()来说，情况不是这样的）:\nstruct NonalignedNewOnly { ...; static void* operator new (std::size_t size) { ...; } ...; // 不operato new(std::size_t, std::align_val_t align) }; auto p = new NonalignedNewOnly; // OK：使用了操作符new(size_t)。 反之则不然。如果一个类型只提供了带有对齐方式参数的重载，那么任何使用默认对齐方式的new分配存储的尝试都会失败：\nstruct AlignedNewOnly { ...; // no operator new(std::size_t) static void* operator new (std::size_t size, std::align_val_t align) { return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); } }; auto p = new AlignedNewOnly; // 错误：没有用于默认对齐的运算符 new() 如果对该类型要求的对齐方式是（小于）默认的对齐方式，这也将是一个错误。\n在新的表达式中请求对齐 如果你在new表达式中传递了一个要求的对齐方式，那么传递的对齐方式参数总是被传递，并且必须被操作符new()所支持。事实上，对齐方式参数的处理与你可以传递给新表达式的任何其他额外参数一样。它们被作为附加参数传递给运算符new()。 因此，一个调用，如:\nstd::string* p = new(std::align_val_t{64}) std::string; // 64 字节对齐 将始终尝试调用：\noperator new(std::size_t, std::align_val_t) 一个仅有大小的重载在这里不会作为fallback。 如果你对一个过度对齐的类型有一个特定的对齐请求，其行为就更加有趣了。例如，如果你调用:\nMyType32* p = new(std::align_val_t{64}) MyType32{}; 并且 MyType32 过度对齐，编译器首先尝试调用:\noperator new(std::size_t, std::align_val_t, std::align_val_t) 32作为第二个参数（type的一般过度对齐），64作为第三个参数（要求的特定对齐）。只作为退步:\noperator new(std::size_t, std::align_val_t) 被调用，并将64作为请求的特定对齐方式。原则上，你可以为这三个参数提供一个重载，以实现对超对齐类型请求特定对齐时的特定行为。 再次注意，如果你需要为超对齐的数据提供特殊的去分配函数，你必须在新表达式中传递对齐方式时调用正确的去分配函数:\nstd::string* p1 = new(std::align_val_t{64}) std::string{}; MyType32* p2 = new(std::align_val_t{64}) MyType32{}; ...; ::operator delete(p2, std::align_val_t{64}); // !!! MyType32::operator delete(p1, std::align_val_t{64}); // !!! 这意味着，本例中的新表达式将调用\noperator new(std::size_t size, std::align_val_t align); 而 delete 表达式将为默认对齐的数据调用以下两个操作之一：\noperator delete(void* ptr, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t align); 以及针对过度对齐数据的以下四种操作之一：\noperator delete(void* ptr, std::align_val_t typealign, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t typealign, std::align_val_t align); operator delete(void* ptr, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t align); 28.3 实现全局操作符new() 默认情况下，C++ 平台现在为 operator new() 和 delete() 提供了大量的全局重载（包括相应的数组版本）：\nvoid* ::operator new(std::size_t); void* ::operator new(std::size_t, std::align_val_t); void* ::operator new(std::size_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new(std::size_t, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete(void*) noexcept; void ::operator delete(void*, std::size_t) noexcept; void ::operator delete(void*, std::align_val_t) noexcept; void ::operator delete(void*, std::size_t, std::align_val_t) noexcept; void ::operator delete(void*, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete(void*, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new[](std::size_t); void* ::operator new[](std::size_t, std::align_val_t); void* ::operator new[](std::size_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new[](std::size_t, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete[](void*) noexcept; void ::operator delete[](void*, std::size_t) noexcept; void ::operator delete[](void*, std::align_val_t) noexcept; void ::operator delete[](void*, std::size_t, std::align_val_t) noexcept; void ::operator delete[](void*, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete[](void*, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; 如果你想实现自己的内存管理（例如，为了能够调试动态内存调用），你不必全部覆盖它们。只要实现以下基本函数就足够了，因为默认情况下，所有其他函数（包括所有数组版本）都会调用这些基本函数中的一个:\nvoid* ::operator new(std::size_t); void* ::operator new(std::size_t, std::align_val_t); void ::operator delete(void*) noexcept; void ::operator delete(void*, std::size_t) noexcept; void ::operator delete(void*, std::align_val_t) noexcept; void ::operator delete(void*, std::size_t, std::align_val_t) noexcept; 原则上，操作者delete()的默认大小版本也只是调用非大小版本。然而，这在将来可能会发生变化，因此要求你同时实现这两个功能（如果你不这样做，有些编译器会发出警告）。\n28.3.1 向后的不相容性 请注意，以下程序的行为会随着 C++17 默默地改变：\nlang/alignednewincomp.cpp\n#include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;cstdlib\u0026gt; // for std::malloc() #include \u0026lt;cstdio\u0026gt; // for std::printf() void* operator new (std::size_t size) { std::printf(\u0026#34;::new called with size: %zu\\n\u0026#34;, size); return ::std::malloc(size); } int main() { struct alignas(64) S { int i; }; S* p = new S; // 仅在 C++17 之前调用我们的运算符 new } 在 C++14 中，为所有新表达式调用全局 ::operator new(size_t) 重载，以便程序始终具有以下输出：\n::new called with size: 64 从 C++17 开始，这个程序的行为发生了变化，因为现在默认重载了过度对齐的数据\n::operator new(size_t, align_val_t) 在这里调用，没有被替换。 结果，程序将不再输出上面的行。\n请注意，此问题仅适用于全局运算符 new()。 如果为 S 定义了特定于类型的运算符 new()，则该运算符仍用作过度对齐数据的后备，以便此类程序的行为与 C++17 之前一样。 另请注意，此处有意使用 printf() 以避免 std::cout 的输出在我们分配内存时分配内存，这可能会导致严重错误（充其量是核心转储）。\n28.4 跟踪所有::new的调用 下面的程序演示了如何使用 new 运算符 new() 重载结合内联变量和 [[nodiscard]] 来跟踪 ::new 的所有调用，只需包含此头文件：\nlang/tracknew.hpp\n#ifndef TRACKNEW_HPP #define TRACKNEW_HPP #include \u0026lt;new\u0026gt; // for std::align_val_t #include \u0026lt;cstdio\u0026gt; // for printf() #include \u0026lt;cstdlib\u0026gt; // for malloc() and aligned_alloc() #ifdef _MSC_VER #include \u0026lt;malloc.h\u0026gt; // for _aligned_malloc() and _aligned_free() #endif class TrackNew { private: static inline int numMalloc = 0; // num malloc 调用 static inline size_t sumSize = 0; // 到目前为止分配的字节数 static inline bool doTrace = false; // 启用跟踪 static inline bool inNew = false; // 不要在新的重载中跟踪输出 public: static void reset() { //重置新/内存计数器 numMalloc = 0; sumSize = 0; } static void trace(bool b) { // 启用/禁用跟踪 doTrace = b; } // 实施跟踪分配: static void* allocate(std::size_t size, std::size_t align, const char* call) { // 跟踪和跟踪分配: ++numMalloc; sumSize += size; void* p; if (align == 0) { p = std::malloc(size); } else { #ifdef _MSC_VER p = _aligned_malloc(size, align); // Windows API #else p = std::aligned_alloc(align, size); // C++17 API #endif } if (doTrace) { // 不要在这里使用 std::cout 因为它可能会分配内存 // 当我们分配内存时（充其量是核心转储） printf(\u0026#34;#%d %s \u0026#34;, numMalloc, call); printf(\u0026#34;(%zu bytes, \u0026#34;, size); if (align \u0026gt; 0) { printf(\u0026#34;%zu-bytes aligned) \u0026#34;, align); } else { printf(\u0026#34;def-aligned) \u0026#34;); } printf(\u0026#34;=\u0026gt; %p (total: %zu Bytes)\\n\u0026#34;, (void*)p, sumSize); } return p; } static void status() { // 打印当前状态 printf(\u0026#34;%d allocations for %zu bytes\\n\u0026#34;, numMalloc, sumSize); } }; [[nodiscard]] void* operator new (std::size_t size) { return TrackNew::allocate(size, 0, \u0026#34;::new\u0026#34;); } [[nodiscard]] void* operator new (std::size_t size, std::align_val_t align) { return TrackNew::allocate(size, static_cast\u0026lt;size_t\u0026gt;(align), \u0026#34;::new aligned\u0026#34;); } [[nodiscard]] void* operator new[] (std::size_t size) { return TrackNew::allocate(size, 0, \u0026#34;::new[]\u0026#34;); } [[nodiscard]] void* operator new[] (std::size_t size, std::align_val_t align) { return TrackNew::allocate(size, static_cast\u0026lt;size_t\u0026gt;(align), \u0026#34;::new[] aligned\u0026#34;); } // 确保释放匹配: void operator delete (void* p) noexcept { std::free(p); } void operator delete (void* p, std::size_t) noexcept { ::operator delete(p); } void operator delete (void* p, std::align_val_t) noexcept { #ifdef _MSC_VER _aligned_free(p); // Windows API #else std::free(p); // C++17 API #endif } void operator delete (void* p, std::size_t, std::align_val_t align) noexcept { ::operator delete(p, align); } #endif // TRACKNEW_HPP 考虑在以下 CPP 文件中使用此头文件：\nlang/tracknew.cpp\n#include \u0026#34;tracknew.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { TrackNew::reset(); TrackNew::trace(true); std::string s = \u0026#34;string value with 26 chars\u0026#34;; auto p1 = new std::string{\u0026#34;an initial value with even 35 chars\u0026#34;}; auto p2 = new(std::align_val_t{64}) std::string[4]; auto p3 = new std::string[4] { \u0026#34;7 chars\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;or 11 chars\u0026#34;, \u0026#34;a string value with 28 chars\u0026#34; }; TrackNew::status(); ...; delete p1; delete[] p2; delete[] p3; } 输出取决于何时初始化跟踪以及为其他初始化执行了多少分配。 但它应该包含类似于以下几行的内容：\n#1 ::new (27 bytes, def-aligned) =\u0026gt; 0x8002ccc0 (total: 27 Bytes) #2 ::new (24 bytes, def-aligned) =\u0026gt; 0x8004cd28 (total: 51 Bytes) #3 ::new (36 bytes, def-aligned) =\u0026gt; 0x8004cd48 (total: 87 Bytes) #4 ::new[] aligned (100 bytes, 64-bytes aligned) =\u0026gt; 0x8004cd80 (total: 187 Bytes) #5 ::new[] (100 bytes, def-aligned) =\u0026gt; 0x8004cde8 (total: 287 Bytes) #6 ::new (29 bytes, def-aligned) =\u0026gt; 0x8004ce50 (total: 316 Bytes) 6 allocations for 316 bytes 第一个输出是，例如，为s的值初始化内存。注意，根据std::string类的分配策略，这个值可能更大。 接下来写的两行是由第二个请求引起的:\nauto p1 = new std::string{\u0026#34;an initial value with even 35 chars\u0026#34;}; 它为核心字符串对象分配了24个字节，加上36个字节的字符串初始值（同样，这些值可能会有所不同）。 第三次调用要求一个64字节的4个字符串的数组。 最后一个调用再次执行两个分配：一个用于数组，一个用于最后一个字符串的初始值。是的，只为最后一个字符串，因为库的实现通常使用小/短字符串优化（SSO），它将通常不超过15个字符的字符串存储在数据成员中，而不是完全分配堆内存。其他实现可能在这里进行5次分配。\n28.5 后记 堆/动态内存分配的对齐由 Clark Nelson 在 https://wg21.link/n3396 中首次提出。 最终接受的措辞由 Clark Nelson 在 https://wg21.link/p0035r4 中制定。\n29 其他专业库的改动 对于专家来说，C++标准库还有一些进一步的改进，例如基础库的程序员，本章将介绍这些改进。\n29.1 字符序列和数字值之间的低级转换 自 C 以来，将整数值转换为字符序列（反之亦然）一直是一个问题。虽然 C 提供了 sprintf() 和 sscanf()，但 C++ 首先引入了字符串流，但是这需要大量资源。使用 C++11 引入了方便的函数，例如 std::to_string 和 std::stoi() ，它们只接受 std::string 参数。 C++17 引入了具有以下能力的新基本字符串转换函数（引用自最初的提议）：\n没有格式字符串的运行时解析 接口本身不需要动态内存分配 不考虑语言环境 不需要通过函数指针进行间接寻址 防止缓冲区溢出 解析字符串时，错误可与有效数字区分开来 解析字符串时，空格或装饰不会被忽略 除了浮点数之外，此功能还将提供往返保证，即转换为字符序列并转换回原始值的值。\n这些函数在头文件 中提供。\n29.1.1 使用实例 提供了两个重载函数：\nstd::from_chars() 将给定的字符序列转换为数值。 std::to_chars() 将数值转换为给定的字符序列。 from_chars() std::from_chars() 将给定的字符序列转换为数值。 例如：\n#include \u0026lt;charconv\u0026gt; const char* str = \u0026#34;12 monkeys\u0026#34;; int value; std::from_chars_result res = std::from_chars(str, str+10, value); 在成功解析后，值包含解析后的值（本例中为12）。结果值是以下结构:\nstruct from_chars_result { const char* ptr; std::errc ec; }; 在调用之后，ptr指的是第一个没有被解析为数字的一部分的字符（或者传递的第二个参数，如果所有的字符都被传递了），ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。因此，你可以这样检查结果如下:\nif (res.ec != std::errc{}) { ... // error handling } 注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:\nif (res.ec) { // 错误：没有隐式转换为布尔值 或者：\nif (!res.ec) { // 错误：没有操作员！ 定义 但是，通过使用结构化绑定并且如果使用初始化，您可以编写：\nif (auto [ptr, ec] = std::from_chars(str, str+10, value); ec != std::errc{}) { ... // error handling } 另一个例子是解析传递的字符串视图:\nto_chars() std::to_chars() 将数值转换为给定的字符序列。 例如：\n#include \u0026lt;charconv\u0026gt; int value = 42; char str[10]; std::to_chars_result res = std::to_chars(str, str+9, value); *res.ptr = \u0026#39;\\0\u0026#39;; // 确保后面有一个尾随空字符 转换成功后，str包含了代表传递值的字符序列（本例中为42），没有尾部空字符。 结果值是以下结构:\nstruct to_chars_result { char* ptr; std::errc ec; }; 在调用之后，ptr指的是最后一个写入的字符之后的字符，ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。 因此，你可以按以下方式检查结果:\nif (res.ec != std::errc{}) { ... // 错误处理 } else { process (str, res.ptr - str); //传递字符和长度 } 再次注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:\nif (res.ec) { // 错误：没有隐式转换为布尔值 或者：\nif (!res.ec) { // 错误：没有操作员！ 定义 由于未写入尾随空终止符，因此您必须确保仅使用写入的字符或添加尾随空字符，如本示例中使用返回值的 ptr 成员所做的那样：\n*res.ptr = \u0026#39;\\0\u0026#39;; // 确保后面有一个尾随空字符 同样，通过使用结构化绑定，如果使用初始化，您可以编写：\nif (auto [ptr, ec] = std::to_chars(str, str+10, value); ec != std::errc{}) { ... // 错误处理 } else { process (str, res.ptr - str); // 传递字符和长度 } 请注意，使用现有的std::to_string()函数，这种行为更安全，更容易实现。使用std::to_char()只有在进一步处理直接需要所写的 字符序列。\n29.1.2 支持浮点往返运算 如果没有给出精度，to_chars()和from_chars()保证对浮点值的往返支持。这意味着一个转换为字符序列的值在读回时正好是其原始值。不过，这种保证只适用于在同一实现中的写入和读取。 因此，浮点值必须被写成具有最高精度的最细粒度的字符序列。由于这个原因，数值被写入的字符序列可能有很大的尺寸。 请看下面的函数:\nlib/charconv.hpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;charconv\u0026gt; #include \u0026lt;cassert\u0026gt; void d2str2d(double value1) { std::cout \u0026lt;\u0026lt; \u0026#34;in: \u0026#34; \u0026lt;\u0026lt; value1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 转换为字符序列: char str[1000]; std::to_chars_result res1 = std::to_chars(str, str+999, value1); *res1.ptr = \u0026#39;\\0\u0026#39;; // 添加尾随空字符 std::cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(res1.ec == std::errc{}); // 从字符序列回读: double value2; std::from_chars_result res2 = std::from_chars(str, str+999, value2); std::cout \u0026lt;\u0026lt; \u0026#34;out: \u0026#34; \u0026lt;\u0026lt; value2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(res2.ec == std::errc{}); assert(value1 == value2); // should never fail } 在这里，我们将传递的双精度值转换为字符序列并将其解析回来。 最后的断言再次检查该值是否相同。 下面的程序演示了效果：\nlib/charconv.cpp #include \u0026#34;charconv.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; int main() { std::vector\u0026lt;double\u0026gt; coll{0.1, 0.3, 0.00001}; // 创建两个略有不同的浮点值: auto sum1 = std::accumulate(coll.begin(), coll.end(), 0.0, std::plus\u0026lt;\u0026gt;()); auto sum2 = std::accumulate(coll.rbegin(), coll.rend(), 0.0, std::plus\u0026lt;\u0026gt;()); // look the same: std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 但不一样: std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::setprecision(20); std::cout \u0026lt;\u0026lt; \u0026#34;equal: \u0026#34; \u0026lt;\u0026lt; (sum1==sum2) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // false !! std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 检查往返: d2str2d(sum1); d2str2d(sum2); } 我们以不同的顺序累积两个小的浮点序列。 sum1 是从左到右累积的总和，而 sum2 是从右到左累积的总和（使用反向迭代器）。 结果，这些值看起来相同但不是：\nsum1: 0.40001 sum1: 0.40001 equal: false sum1: 0.40001000000000003221 sum1: 0.40000999999999997669 将值传递给 d2str2d() 时，您可以看到这些值存储为具有必要粒度的不同字符序列：\nin: 0.40001000000000003221 str: 0.40001000000000003 out: 0.40001000000000003221 in: 0.40000999999999997669 str: 0.40001 out: 0.40000999999999997669 再次注意，粒度（以及字符序列的必要大小）取决于平台。 往返支持适用于所有浮点数，包括 NAN 和 INFINITY。 例如，将 INFINITY 传递给 d2st2d() 应该具有以下效果：\nvalue1: inf str: inf value2: inf 但是，请注意，对于 NAN，d2str2d() 中的断言将失败，因为它从不与任何东西进行比较，包括它自己。\n29.2 后记 字符序列和数字值之间的低级转换是由Jens Maurer在https://wg21.link/p0067r0 中首次提出的。最终被接受的措辞是由Jens Maurer在https://wg21.link/p0067r5。然而，重要的澄清和新的头文件被指定为Jens Maurer在https://wg21.link/p0682r1，作为针对C++17的缺陷报告。\n词汇表 ","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/","title":"第五部分-专业工具"},{"content":"第四部分 标准库扩展和修改 这一部分介绍了用C++17对现有库组件的扩展和修改。\n21类型特征扩展 关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。\n21.1 类型特征的Suffix _v 从C++17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是\nstd::is_const\u0026lt;T\u0026gt;::value 你现在可以写:\nstd::is_const_v\u0026lt;T\u0026gt; // since C++17 这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:\nnamespace std { template\u0026lt;typename T\u0026gt; constexpr bool is_const_v = is_const\u0026lt;T\u0026gt;::value; } 通常，这有助于制定布尔条件，你可以在运行时使用:\nif (std::is_signed_v\u0026lt;char\u0026gt;) { ... } 但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:\nif constexpr (std::is_signed_v\u0026lt;char\u0026gt;) { ... } 或在实例化模板时:\n// C\u0026lt;T\u0026gt;类的主要模板 template\u0026lt;typename T, bool = std::is_pointer_v\u0026lt;T\u0026gt;\u0026gt; class C { ... }; // 指针类型的部分特殊化。 template\u0026lt;typename T\u0026gt; class C\u0026lt;T, true\u0026gt; { ... }; 在这里，以C类为例，它为指针类型提供了一个特殊的实现。 但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme\u0026lt;\u0026gt;。它产生的是一个原始数组的维度大小:\nint a[5][7]; std::cout \u0026lt;\u0026lt; std::extent_v\u0026lt;decltype(a)\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 5 std::cout \u0026lt;\u0026lt; std::extent_v\u0026lt;decltype(a),1\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 7 21.2 新类型特征 C++17 引入了几个新的类型特征。 此外， is_literal_type\u0026lt;\u0026gt; 和 result_of\u0026lt;\u0026gt; 自 C++17 起已弃用。 正在建设中的详细说明\nis_aggregate\u0026lt;\u0026gt; std::is_aggregate 评估 T 是否为聚合类型：\ntemplate\u0026lt;typename T\u0026gt; struct D : std::string, std::complex\u0026lt;T\u0026gt; { std::string data; }; D\u0026lt;float\u0026gt; s{{\u0026#34;hello\u0026#34;}, {4.5,6.7}, \u0026#34;world\u0026#34;}; // OK since C++17 std::cout \u0026lt;\u0026lt; std::is_aggregate\u0026lt;decltype(s)\u0026gt;::value; // outputs: 1 (true) 21.3 std::bool_constant\u0026lt; \u0026gt;。 如果特征产生布尔值，它们现在使用别名模板 bool_constant\u0026lt;\u0026gt;：\nnamespace std { template\u0026lt;bool B\u0026gt; using bool_constant = integral_constant\u0026lt;bool, B\u0026gt;; // since C++17 using true_type = bool_constant\u0026lt;true\u0026gt;; using false_type = bool_constant\u0026lt;false\u0026gt;; } 特征 作用 is_aggregate 是聚合类型 has_unique_object_representations 任何两个具有相同值的对象在内存中具有相同的表示 is_invocable\u0026lt;T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用对象\u0026hellip; is_nothrow_invocable\u0026lt;T,Args\u0026hellip;\u0026gt; 可用作 Args\u0026hellip; 的可调用对象\u0026hellip;无需抛出 is_invocable_r\u0026lt;RT,T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用\u0026hellip; 返回 RT is_nothrow_invocable_r\u0026lt;RT,T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用对象\u0026hellip;返回 RT 而不抛出 invoke_result\u0026lt;T,Args\u0026hellip;\u0026gt; 如果用作 Args 的可调用结果类型\u0026hellip; is_swappable is_swappable 可以为此类型调用 swap() is_nothrow_swappable 可以为此类型调用 swap() 并且该操作不能抛出 is_swappable_with\u0026lt;T,T2\u0026gt; 可以为这两种具有特定值类别的类型调用 swap() is_nothrow_swappable_with\u0026lt;T,T2\u0026gt; 可以为这两种具有特定值类别的类型调用 swap() 并且该操作不能抛出 conjunction\u0026lt;B\u0026hellip;\u0026gt; 逻辑和布尔特征 B\u0026hellip; disjunction\u0026lt;B\u0026hellip; \u0026gt; 逻辑或布尔特征 B\u0026hellip; negation 逻辑不用于布尔特征 B 在C++17之前，std::true_type和std::false_type分别被直接定义为std::integral_constant\u0026lt;bool,true\u0026gt;和std::integral_constant\u0026lt;bool,false\u0026gt;的别名定义。 尽管如此，如果一个特定的属性适用，布尔特性通常继承自std::true_type，如果不适用则继承自std::false_type。比如说:\n// 主模板：通常 T 不是 void 类型 template\u0026lt;typename T\u0026gt; struct IsVoid : std::false_type { }; // void 类型的特化: template\u0026lt;\u0026gt; struct IsVoid\u0026lt;void\u0026gt; : std::true_type { }; 但是现在你可以通过派生自bool_constant\u0026lt;\u0026gt;来定义你自己的类型特质，如果你能够把相应的编译时表达式表述为布尔条件的话。比如说:\ntemplate\u0026lt;typename T\u0026gt; struct IsLargerThanInt : std::bool_constant\u0026lt;(sizeof(T) \u0026gt; sizeof(int))\u0026gt; { } 这样你就可以使用这样一个特性，根据一个类型是否大于int来进行编译:\ntemplate\u0026lt;typename T\u0026gt; void foo(T x) { if constexpr(IsLargerThanInt\u0026lt;T\u0026gt;::value) { ... } } 通过添加后缀_v的相应变量模板作为内联变量:\ntemplate\u0026lt;typename T\u0026gt; inline static constexpr auto IsLargerThanInt_v = IsLargerThanInt\u0026lt;T\u0026gt;::value; 你也可以缩短该特性的用法，如下所示:\ntemplate\u0026lt;typename T\u0026gt; void foo(T x) { if constexpr(IsLargerThanInt_v\u0026lt;T\u0026gt;) { ... } } 作为另一个例子，我们可以定义一个特质，检查一个类型T的移动构造函数是否保证不抛出，大致如下:\ntemplate\u0026lt;typename T\u0026gt; struct IsNothrowMoveConstructibleT : std::bool_constant\u0026lt;noexcept(T(std::declval\u0026lt;T\u0026gt;()))\u0026gt; { }; 21.4 std::void_t\u0026lt; \u0026gt; 在C++17中，一个小小的，但令人难以置信的有用的定义类型特征的辅助工具被标准化了：std::void_t\u0026lt;\u0026gt;。 它被简单地定义如下：\nnamespace std { template\u0026lt;typename...\u0026gt; using void_t = void; } 也就是说，它对任何模板参数的变量列表都会产生无效。这很有帮助，我们只想在参数列表中处理类型。 主要的应用是在定义新的类型特征时检查条件的能力。下面的例子演示了这个帮助器的应用：\n#include \u0026lt;utility\u0026gt; // 对于declval\u0026lt;\u0026gt;来说 #include \u0026lt;type_traits\u0026gt; // 为true_type，false_type，和void_t // 主模板: template\u0026lt;typename, typename = std::void_t\u0026lt;\u0026gt;\u0026gt; struct HasVarious : std::false_type { }; // 部分专业（可能会被SFINAE所取代）: template\u0026lt;typename T\u0026gt; struct HasVarious\u0026lt;T, std::void_t\u0026lt;decltype(std::declval\u0026lt;T\u0026gt;().begin()), typename T::difference_type, typename T::iterator\u0026gt;\u0026gt; : std::true_type { }; 在这里，我们定义了一个新的类型特质HasVariousT\u0026lt;\u0026gt;，它检查三件事。\n该类型是否有一个成员函数begin()？\n该类型是否有一个类型成员 difference_type？\n该类型是否有一个类型成员迭代器？ 只有当所有相应的表达式都对一个类型T有效时，才会使用部分专业化。那么它就比主模板更具体，而且由于我们从std::true_type派生出来，对这个特征的值进行检查会得到true。\nif constexpr (HasVarious\u0026lt;T\u0026gt;::value) { ... } 如果任何一个表达式的结果是无效的代码（即T没有begin()，或者没有类型成员difference_type，或者没有类型成员iterator），部分专业化就会被SFINAE\u0026rsquo;d掉，这意味着由于替换失败不是错误的规则，它被忽略。然后，只有主模板是可用的，它派生自std::false_type，所以对这个特质的值进行检查会产生false。 同样地，你可以使用std::void_t轻松地定义其他特质来检查一个或多个条件，其中一个成员或操作的存在/能力很重要。\n21.5 后记 标准类型性状的变量模板最早是由Stephan T. Lavavej在2014年提出的 https://wg21.link/n3854。它们最终被采纳为图书馆基本原理TS的一部分 的一部分，由Alisdair Meredith在https://wg21.link/p0006r0。\n类型特质std::is_aggregate\u0026lt;\u0026gt;是作为美国国家机构的评论引入的，用于C++17的标准化。C++17的标准化而引入的（见https://wg21.link/lwg2911）。\nstd::bool_constant\u0026lt;\u0026gt;是由袁志豪在https://wg21.link/n4334 中首次提出的。它们最终被采纳为袁志豪在https://wg21.link/n4389 中的提议。\nstd::void_t_\u0026lt;\u0026gt;是由Walter E. Brown在https://wg21.link/n3911 中提出的，被采用。建设中\n22 并行STL算法 为了从现代多核架构中获益，C++17标准库引入了让STL标准算法使用多线程运行的能力，以并行处理不同的元素。\n许多算法通过一个新的第一参数进行了扩展，以指定是否以及如何在并行线程中运行算法（当然，没有这个参数的老方法仍然被支持）。此外，还引入了一些专门支持并行处理的补充算法。\n一个简单的计时器助手 在本章的例子中，有时我们需要一个定时器来测量算法的速度。为此，我们使用了一个简单的辅助类，它初始化了一个定时器，并提供了printDiff()来打印消耗的毫秒数并重新初始化定时器:\nlib/timer.hpp #ifndef TIMER_HPP #define TIMER_HPP #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; /******************************************** * timer to print elapsed time ********************************************/ class Timer { private: std::chrono::steady_clock::time_point last; public: Timer() : la st{std::chrono::steady_clock::now()} { } void printDiff(const std::string\u0026amp; msg = \u0026#34;Timer diff: \u0026#34;) { auto now{std::chrono::steady_clock::now()}; std::chrono::duration\u0026lt;double, std::milli\u0026gt; diff{now - last}; std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34;ms\\n\u0026#34;; last = std::chrono::steady_clock::now(); } }; #endif // TIMER_HPP 22.1 使用并行算法 让我们从一些例子程序开始，展示让现有算法并行运行和使用新的并行算法的能力。\n22.1.1 使用并行的for_each() 这是并行运行标准算法 for_each() 的第一个非常简单的示例：\nlib/parforeach.cpp #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; // 对于执行策略 #include \u0026#34;timer.hpp\u0026#34; int main() { int numElems = 1000; struct Data { double value; // 初始值 double sqrt; // 并行计算平方根 }; // 初始化没有平方根的 NumElems 值: std::vector\u0026lt;Data\u0026gt; coll; coll.reserve(numElems); for (int i=0; i\u0026lt;numElems; ++i) { coll.push_back(Data{i * 4.37, 0}); } // 平方根的并行计算: for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); } 正如你所看到的，使用并行算法在原则上是非常容易的。\n包括头文件。 按照你通常调用算法的方式来调用算法，并附加一个第一个参数，这个参数通常是简单的std::execution::par。 在这种情况下，我们使用标准算法for_each()来计算传递的向量coll中所有元素的成员值的平方根。由于额外的第一个参数std::execution::par，我们要求该算法以并行模式运行:\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;execution\u0026gt; ... for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); 像往常一样，coll在这里可以是任何范围。但是请注意，所有的并行算法都要求迭代器至少是前向迭代器（我们在不同的线程中迭代相同的元素，如果迭代器不迭代相同的值，那就没有意义）。 算法并行运行的方式是具体实现的。当然，使用多线程也不一定更快，因为启动和处理多线程也需要时间。\n性能优势 为了找到如何、是否以及何时值得并行运行这个算法，让我们把这个例子修改如下。 lib/parforeach.cpp\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; // for the execution policy #include \u0026#34;timer.hpp\u0026#34; int main() { int numElems = 1000; struct Data { double value; // 初始值 double sqrt; // 并行计算平方根 }; // 初始化没有平方根的 NumElems 值: std::vector\u0026lt;Data\u0026gt; coll; coll.reserve(numElems); for (int i=0; i\u0026lt;numElems; ++i) { coll.push_back(Data{i * 4.37, 0}); } // 平方根的并行计算: for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); } 关键的修改是。\n我们可以通过命令行传递我们操作的数值的多少。 我们使用类Timer来测量调用算法的持续时间。 我们在一个循环中进行多次测量，以使持续时间更加成熟。 结果在很大程度上取决于所使用的硬件、C++编译器和C++库。在我的笔记本电脑上（在英特尔i7上使用Visual C++，带有2个核心和超线程），我们得到的结果如下。 在100个元素的情况下，顺序算法要快10倍以上。这是因为启动和管理线程需要太多的时间，对于几个元素来说不值得。 对于10,000个元素，我们接近于收支平衡。 对于1,000,000个元素，并行执行的速度大约是3倍。 同样，这也不是一个一般性的证明，在什么地方和什么时候并行算法是值得的。但它表明，即使对于非微不足道的数字运算，也值得使用它们。关键是，它值得用在\n长操作 许多许多元素 例如，使用并行版本的算法count_if()计算一个ints vector中的偶数元素的数量是不值得的。元素的并行版本是不值得的；即使有1,000,000,000个元素也不值得。 auto num = std::count_if(std::execution::par, // execute policy coll.cbegin(), coll.cend(), // 范围 [](int elem){ //准则 return elem % 2 == 0; }); 事实上，对于本例中具有快速谓词的简单算法，并行运行可能永远不会有回报。每个元素都应该发生一些需要大量时间的事情，并且与其他元素的处理无关。 但你无法预测任何事情，因为何时以及如何使用并行线程，都取决于C++标准库的实现者。事实上，无法控制使用多少线程，实现者可能会决定只在一定数量的元素上使用多线程。 测量! 用你的目标平台上的典型场景。\n22.1.2 使用并行的sort() 排序是另一个例子，并行算法可以提供帮助。因为排序标准对每个元素的使用不只一次，你可以节省大量时间。 例如，考虑一下，我们初始化一个字符串的向量如下:\nstd::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; numElems / 2; ++i) { coll.emplace_back(\u0026#34;id\u0026#34; + std::to_string(i)); coll.emplace_back(\u0026#34;ID\u0026#34; + std::to_string(i)); } 也就是说，我们创建一个以 \u0026ldquo;id \u0026ldquo;或 \u0026ldquo;ID \u0026ldquo;开头的元素向量，后面是一个整数:\nid0 ID0 id1 ID1 id2 ID2 id3 ... id99 ID99 id100 ID100 ... 我们可以像往常一样按以下顺序对元素进行排序:\nsort(coll.begin(), coll.end()); 现在也可以通过明确传递一个 \u0026ldquo;顺序 \u0026ldquo;执行策略来实现:\nsort(std::execution::seq, coll.begin(), coll.end()); 如果在运行时决定是顺序运行还是并行运行，并且你不想有不同的函数调用，那么将顺序执行作为参数传递会很有用。 要求用并行排序来代替是很容易的:\nsort(std::execution::par, coll.begin(), coll.end()); 请注意，还有另一个并行执行策略：\nsort(std::execution::par_seq, coll.begin(), coll.end()); 我稍后将解释其中的区别。 所以，问题又来了，（什么时候）使用并行排序更好？在我的笔记本电脑上，只有10,000个字符串，你可以看到排序的时间是顺序排序的一半。而且，即使是对1000个字符串进行排序，使用并行执行也略胜一筹。\n与其他改进措施相结合 请注意，还有其他的修改可能会给你带来更多或额外的好处。例如，如果我们只按数字排序，使用没有两个前导字符的子串，我们可以在谓词中使用字符串操作，并再次看到并行执行的2倍的改进:\nsort(std::execution::par, coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return a.substr(2) \u0026lt; b.substr(2); }); 然而，substr()对于字符串来说是一个相当昂贵的成员函数，因为它创建并返回一个新的临时字符串。通过使用string_view类，我们甚至在连续执行的情况下，也会比以前好3倍。顺序执行的情况下，我们的速度也会提高3倍:\nsort(coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return std::string_view{a}.substr(2) \u0026lt; std::string_view{b}.substr(2); }); 结合使用并行算法，我们的速度提高了多达 10 倍：\nsort(std::execution::par, coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return std::string_view{a}.substr(2) \u0026lt; std::string_view{b}.substr(2); }); 与使用字符串的 substr() 成员的顺序执行相比：\nsort(coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return a.substr(2) \u0026lt; b.substr(2); 22.2 执行策略 你可以把不同的执行策略作为第一个参数传递给并行STL算法。它们被定义在头文件中。表Execution Policies列出了标准化的执行策略。\n策略 意义 std::execution::seq 顺序执行 std::execution::par 并行顺序执行 std::execution::par_unseq 并行无序列（矢量）执行 让我们详细讨论一下执行策略。\n使用seq的顺序执行 意味着和非并行算法一样，当前的执行线程按顺序逐个元素执行必要的操作。使用这个策略的行为应该和使用非并行方式调用算法一样，根本不需要传递任何执行策略。然而，对于接受这个参数的并行算法，可能会有额外的限制，比如for_each()不返回任何值，或者所有的迭代器必须至少是前向迭代器。 提供这个策略是为了能够通过传递一个不同的参数而不是使用一个不同的签名来请求顺序执行。但是请注意，采用这种策略的并行算法的行为可能与相应的非并行算法略有不同。 使用par的并行顺序执行 意味着多个线程可能依次执行元素的必要操作。当一个算法开始执行必要的操作时，它在处理其他元素之前完成这一执行。 与par_unseq相比，这可以确保没有问题或死锁发生，因为在处理完一个元素的步骤后，需要在同一个线程对另一个元素执行第一步之前调用另一个步骤。 使用par_unseq的并行无序执行 意味着多个线程可能为多个元素执行必要的操作，但不能保证一个线程执行该元素的所有步骤而不切换到其他 元素。这特别是使矢量执行成为可能，在这种情况下，一个线程可能首先执行多个元素的第一步 在执行下一个步骤之前，一个线程可能首先执行多个元素的执行步骤。 并行的无序执行需要编译器/硬件的特别支持，以检测哪里和如何操作可以被矢量化。操作如何被矢量化。\n22.3 异常处理 所有的并行算法都会调用std::terminate()，如果元素访问函数通过一个未捕获的异常退出。 请注意，如果选择的是顺序执行策略，这也适用。如果不能接受这种情况，使用算法的非并行版本可能是更好的选择。 还要注意的是，并行算法仍有可能被抛出。如果它们不能为并行执行获得临时的内存资源，它们会抛出std::bad_alloc。然而，没有其他 可能会被抛出。\n22.4 不使用并行算法的好处 有了调用并行算法的能力，以及它们甚至提供了一个顺序执行策略的事实，可能会出现这样的问题：我们是否还需要非并行算法。 然而，除了向后兼容之外，使用非并行算法可能有很大的好处。\n可以使用输入和输出迭代器。 算法不会在异常情况下terminate()。 算法可以避免由于非故意使用元素而产生的副作用。 算法可能提供额外的功能，例如for_each()返回传递的可调用，以便能够处理其结果状态。 22.5 并行算法的概述 表Unmodified Parallel STL Algorithms列出了标准化的算法，可以不加任何修改地支持并行处理。 表Modified Parallel STL Algorithms列出了经过一些修改的支持并行处理的标准化算法。 表STL算法无并行化列出了不支持并行处理的算法。 请注意，对于 accumulate() 和 inner_product() ，新的并行算法被提供了宽松的要求。放宽了要求。\n算法 备注 find_end(), adjacent_find() 除了搜索者 search(), search_n() swap_ranges() replace(), replace_if() fill() generate() remove(), remove_if() unique() reverse() rotate() partition(), stable_partition() sort(), stable_sort(), partial_sort() is_sorted(), is_sorted_until() nth_element() inplace_merge() is_heap(), is_heap_until() min_element(), max_element(), min_max_element() 除了搜索者 for_each() 前向迭代器和返回类型 void all_of(), any_of(), none_of() 前向迭代器 for_each_n() find(), find_if(), find_if_not() find_first_of() count(), count_if() mismatch() equal() is_partitioned() partial_sort_copy() includes() lexicographical_compare() fill_n() generate_n() reverse_copy() rotate_copy() copy(), copy_n(), copy_if() move() transform() replace_copy(), replace_copy_if() remove_copy(), remove_copy_if() unique_copy() partition_copy() merge() set_union(), set_intersection() set_difference(), set_symmetric_difference() exclusive_scan(), inclusive_scan() 前向迭代器 accumulate(), inner_product(), partial_sum() 改用 reduce() 和 transform_reduce() search() with searcher copy_backward() move_backward() sample(), shuffle() partition_point() lower_bound(), upper_bound(), equal_range() binary_search() is_permutation(), next_permutation(), prev_permutation() push_heap(), pop_heap(), make_heap(), sort_heap() 改用 reduce() 和 transform_reduce() 22.6 并行处理的新算法 一些补充算法被引入，以处理自C++98以来可用的标准算法的并行处理。\n22.6.1 reduce() 例如，reduce()是作为 accumulate()的平行形式引入的，它 \u0026ldquo;累积 \u0026ldquo;所有元素（你可以定义，哪个操作执行 \u0026ldquo;累积\u0026rdquo;）。例如，考虑以下 accumulate() 的用法。\nlib/accumulate.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for accumulate() void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::accumulate(coll.begin(), coll.end(), 0L); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 我们计算所有元素的总和，输出：\naccumulate(): 10 accumulate(): 10000 accumulate(): 10000000 换算运算的平行化 这个程序可以通过改用reduce()来实现并行化:\nlib/reduce.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for reduce() #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::reduce(std::execution::par, coll.begin(), coll.end(), 0L); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在输出相同的情况下，现在的程序可能运行得更快或更慢（取决于是否支持启动多线程，以及所花费的时间是否比我们并行运行算法所节省的时间多）。 这里使用的操作是+，它是换元的，所以加入积分元素的顺序并不重要。\n非共轭运算的并行化 然而，对于浮点值来说，顺序很重要，这就证明了以下程序:\nlib/reducefloat.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 0.1 0.3 0.0001 的 num 个序列创建 coll: std::vector\u0026lt;double\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {0.1, 0.3, 0.00001}); } auto sum1 = std::accumulate(coll.begin(), coll.end(), 0.0); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; auto sum2 = std::reduce(std::execution::par, coll.begin(), coll.end(), 0.0); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; (sum1==sum2 ? \u0026#34;equal\\n\u0026#34; : \u0026#34;differ\\n\u0026#34;); } #include\u0026lt;iomanip\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::setprecision(20); printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 这里我们同时使用 accumulate() 和 reduce() 并比较结果。一个可能的输出是:\naccumulate(): 0.40001 reduce(): 0.40001 equal accumulate(): 400.01 reduce(): 400.01 differ accumulate(): 400010 reduce(): 400010 differ accumulate(): 4.0001e+06 reduce(): 4.0001e+06 differ 虽然结果看起来是一样的，但有时会有差异。这可能是以不同的顺序添加 的顺序不同而造成的。 如果我们改变打印浮点值的精度:\nstd::cout \u0026lt;\u0026lt; std::setprecision(20); 我们可以看到结果值略有不同：\naccumulate(): 0.40001000000000003221 reduce(): 0.40001000000000003221 equal accumulate(): 400.01000000000533419 reduce(): 400.01000000000010459 differ accumulate(): 400009.99999085225863 reduce(): 400009.9999999878346 differ accumulate(): 4000100.0004483023658 reduce(): 4000100.0000019222498 differ 由于没有定义是否、何时以及如何实现并行算法，因此在某些平台上的结果可能看起来是一样的（达到一定数量的元素）。\n非关联性操作的并行化 现在让我们改变一下操作，通过总是添加每个值的平方来累积值:\nlib/accumulate2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // 对于 accumulate() void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll： std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; auto sum = std::accumulate(coll.begin(), coll.end(), 0L, squaredSum); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在这里，我们传递一个lambda，对于每一个值，都要取当前的和，并加上新值的平方:\nauto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; 使用 accumulate() 输出看起来很好:\naccumulate(): 30 accumulate(): 30000 accumulate(): 30000000 accumulate(): 300000000 但是，让我们使用 reduce() 切换到并行处理：\nlib/reduce2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // 对于reduce() #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll： std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; auto sum = std::reduce(std::execution::par, coll.begin(), coll.end(), 0L, squaredSum); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 输出可能会变成这样：\nreduce(): 30 reduce(): 30000 reduce(): -425251612 reduce(): 705991074 是的，结果有时可能是错误的。问题是，该操作不是关联性的。例如，如果我们对元素1、2和3应用这个操作，我们可能先计算0+11和2+33，但当我们把中间的结果结合起来时，我们又把3平方了，基本上是 计算:\n(0+1*1) + (2+3*3) * (2+3*3) 但为什么这里的结果有时是正确的呢？嗯，似乎在这个平台上，reduce()只在一定数量的元素中并行运行。而这是完全可以的。因此，使用有足够多元素的测试案例来检测这样的问题。 解决这个问题的方法是使用另一种新的算法，transform_reduce()。它把我们要对每个元素进行的修改（这是我们可以并行化的一件事）和结果的累积分开，只要它是换元的（这是我们可以并行化的另一件事）。\nlib/transformreduce.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for transform_reduce() #include \u0026lt;execution\u0026gt; #include \u0026lt;functional\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::transform_reduce(std::execution::par, coll.begin(), coll.end(), 0L, std::plus{}, [] (auto val) { return val * val; }); std::cout \u0026lt;\u0026lt; \u0026#34;transform_reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在调用transform_reduce()时，我们传递了\n执行策略，以便（允许）并行地运行这个程序 要处理的值的范围 0L作为外部累加的初始值 操作+作为外部累加的操作 一个lambda，用于在累加之前处理每个值 transform_reduce()可能是迄今为止最重要的并行算法，因为我们经常在合并数值之前修改它们（也称为map reduce原则）。\n用于文件系统操作的transform_reduce()函数 下面是另一个并行运行transform_reduce()的例子:\nlib/dirsize.cpp\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; // for transform_reduce() #include \u0026lt;execution\u0026gt; // 对于执行策略 #include \u0026lt;filesystem\u0026gt; // filesystem library int main(int argc, char* argv[]) { // 根目录作为命令行参数被传递: if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path root{argv[1]}; // 在通过的文件树中启动所有文件路径的列表: std::vector\u0026lt;std::filesystem::path\u0026gt; paths; try { std::filesystem::recursive_directory_iterator dirpos{root}; std::copy(begin(dirpos), end(dirpos), std::back_inserter(paths)); } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } // 累积所有常规文件的大小: auto sz = std::transform_reduce( std::execution::par, // 并行执行 paths.cbegin(), paths.cend(), // range std::uintmax_t{0}, // 初始值 std::plus\u0026lt;\u0026gt;(), // accumulate ... [](const std::filesystem::path\u0026amp; p) { // 如果是普通文件，文件大小 return is_regular_file(p) ? file_size(p) : std::uintmax_t{0}; }); std::cout \u0026lt;\u0026lt; \u0026#34;size of all \u0026#34; \u0026lt;\u0026lt; paths.size() \u0026lt;\u0026lt; \u0026#34; regular files: \u0026#34; \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 首先，我们递归地收集作为命令行参数的目录中的所有文件系统路径:\nstd::filesystem::path root{argv[1]}; std::vector\u0026lt;std::filesystem::path\u0026gt; paths; std::filesystem::recursive_directory_iterator dirpos{root}; std::copy(begin(dirpos), end(dirpos), std::back_inserter(paths)); 请注意，由于我们可能会传递一个无效的路径，可能的（文件系统）异常会被捕获。 然后，我们遍历文件系统路径的集合，积累它们的大小，如果它们是 正常的文件:\nauto sz = std::transform_reduce( std::execution::par, // 并行执行 paths.cbegin(), paths.cend(), // range std::uintmax_t{0}, // initial value std::plus\u0026lt;\u0026gt;(), // accumulate ... [](const std::filesystem::path\u0026amp; p) { // 文件大小（如果是常规文件） return is_regular_file(p) ? file_size(p) : std::uintmax_t{0}; }); 新的标准算法transform_reduce()的操作方法如下。\n最后一个参数被应用于每个元素。在这里，对每个路径元素调用传递的lambda，如果它是一个普通文件，则查询其大小。 第二个但也是最后一个参数是合并所有大小的操作。因为我们要累积大小，所以我们使用标准函数对象std::plus\u0026lt;\u0026gt;。 第三个但也是最后一个参数是合并所有大小的操作的初始值。因此，如果路径列表是空的，我们从0开始。我们使用与file_size()的返回值相同的类型，std::uintmax_t。 请注意，询问文件的大小是一个相当昂贵的操作，因为它需要一个操作系统调用。由于这个原因，使用一个算法来调用这个转换（从路径到大小），并以任何顺序与多个线程并行，并计算出总和，是非常快的回报。第一次测量显示了一个明显的胜利（程序的速度提高了一倍）。 还要注意的是，你不能把目录迭代器所迭代的路径直接传递给并行的 算法，因为目录迭代器是输入迭代器，而并行算法需要正向的 迭代器。 最后请注意，transform_reduce()被定义在头文件中，而不是。 (就像 accumulate() 一样，它也算作数字算法。\n22.7 并行算法的详细介绍 22.8 后记 2012 年，Jared Hoberock Michael Garland Olivier Giroux Vinod Grover、Ujval Kapasi 和 Jaydeep Marathe 在 https://wg21.link/n3408 中首次提出了并行化 STL 算法。 它成为了一个正式的 beta 标准，即并行 C++ 扩展技术规范（参见 https://wg21.link/n3850）。 Jared Hoberock、Grant Mercer、Agustin Berge 和 Harmut Kaiser 在 https://wg21.link/n4276 中添加了其他算法。 通过 https://wg21.link/p0024r2，Jared Hoberock 提出的标准库采用了 C++ 并行扩展技术规范。 JF Bastien 和 Bryce Adelstein Lelbach 在 https://wg21.link/p0394r4 中提出的异常处理被接受。\n23 子字符串和子序列搜索 自C++98以来，C++标准库提供了一种搜索算法来寻找一个范围内元素的子序列。然而，存在着不同的搜索算法。例如，通过预先计算关于要搜索的模式的统计数据，这些算法对于特殊的任务，如在一个大文本中寻找子串，可以有明显的表现。 因此，C++17引入了Boyer-Moore和Boyer-Moore-Horspool搜索算法以及使用它们的各种接口。它们特别适用于搜索大文本中的子串，但也可以改进寻找容器或范围中的子序列。\n23.1 使用子串搜索器 新的搜索器是专门为搜索大型文本中的字符串（例如，单词或短语）而开发的。 因此，让我们首先演示一下在这种情况下如何使用它们，以及你如何利用它们来获益。\n23.1.1 通过search()使用搜索器 我们现在有以下选项来搜索一个字符串文本中的子串子:\n字符串成员 find(): std::size_type idx = text.find(sub)。 算法搜索()。 auto pos = std::search(text.begin(), text.end(), sub.begin(), sub.end())。 并行算法 search(): auto pos = std::search(std::execution::par, text.begin(), text.end(), sub.begin(), sub.end()）。 使用 default_searcher: auto pos = std::search(text.begin(), text.end(), std::default_searcher{sub.begin(), sub.end()})。 使用boyer_moore_searcher: auto pos = std::search(text.begin(), text.end(), std::boyer_moore_searcher{sub.begin(), sub.end()}）。 使用boyer_moore_horspool_searcher: auto pos = std::search(text.begin(), text.end(), std::boyer_moore_horspool_searcher{sub.begin(), sub.end()}）。 新的搜索器被定义在中。 Boyer-Moore和Boyer-Moore-Horspool搜索器是众所周知的算法，在搜索开始前预先计算表格（哈希值），以提高搜索的速度，如果搜索覆盖了相当大的文本和/或子串。使用它们，算法需要随机访问的迭代器（而不是正向迭代器，这对于天真的搜索（）来说已经足够了）。\n在lib/searcher1.cpp中，你可以找到一个完整的程序，演示如何使用这些不同的方式来搜索子串。 请注意，所有search()的应用都会产生一个指向匹配子串的第一个字符的迭代器。如果没有，则返回文本的末端。这样我们就可以搜索到一个子串的所有出现，如下所示。\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; for (auto pos = std::search(text.begin(), text.end(), bm); pos != text.end(); pos = std::search(pos+sub.size(), text.end(), bm)) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; pos - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 搜索器的性能 哪一种是搜索子字符串的最佳方法（最快和/或最少的内存）？ 这个问题的一个特殊方面是我们现在也可以在并行模式下使用传统的 search() （使用新的搜索器时这是不可能的）。 答案取决于具体情况：\n仅使用（非并行）search() 通常是最慢的，因为对于文本中的每个字符，我们开始找出子字符串是否匹配。\n使用 default_searcher 应该是等价的，但我看到更糟糕的运行时间高达 3 倍。\n使用find()可能会更快，但这取决于库中实现的质量。在我所做的测量中，我看到与search()相比，运行时间提高了20%到100倍之间。\n对于文本和相当大小的子串，boyer_moore_searcher应该是最快的。与search()相比，我看到了50倍甚至100倍的改进。在有大量子串的大文本中，这始终是最快的搜索。\nboyer_moore__horspool_searcher以空间换时间。它通常比boyer_moore_searcher慢，但不应该使用那么多内存。我看到的改进在不同的平台上确实有很大的不同。在一个平台上，它接近boyer_moore（比search()好50倍，比find()好10倍），而在其他平台上，对search()的改进只有2或3倍，而使用find()则快得多。\n使用并行的search()与普通的search()相比，我得到了3倍的支持，看起来使用Boyer-Moore搜索器通常还是要快很多。\n所以我只能给出一个建议。测量! 在你的目标平台上测试典型场景。 这是值得的，因为你可能会得到100倍的改进（例如，我在一个有1000万个字符的字符串中搜索一个接近结尾的1000个字符的子串）。 lib/searcher1.cpp中的代码还打印了不同搜索选项的测量值，这样你就可以比较你的平台上的数字。\n23.1.2 直接使用搜索器 或者，你可以使用搜索器的函数调用操作，它返回一对开始和结束的一对子序列。 代码看起来如下。\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; for (auto begend = bm(text.begin(), text.end()); begend.first != text.end(); begend = bm(begend.second, text.end())) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; begend.first - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; begend.second - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 然而，由于你可以使用std::tie()将新的值重新分配给结构化绑定的 std::pair\u0026lt;\u0026gt;，你可以将代码简化如下:\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; for (auto [beg, end] = bm(text.begin(), text.end()); beg != text.end(); std::tie(beg,end) = bm(end, text.end())) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; beg - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; end - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 只是直接使用搜索器寻找子串的第一次出现，你可以使用如果与 初始化和结构化绑定:\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; if (auto [beg, end] = bm(text.begin(), text.end()); beg != text.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; first at index \u0026#34; \u0026lt;\u0026lt; beg - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; end - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 23.2 使用通用子序列搜索器 Boyer-Moore 和 Boyer-Moore-Horspool 是作为字符串搜索器开发的。 但是，C++17 采用它们作为通用算法，以便您可以使用它们在容器或范围中查找元素的子序列。 也就是说，您现在可以实现以下内容：\nstd::vector\u0026lt;int\u0026gt; coll; ...; std::deque\u0026lt;int\u0026gt; sub{0, 8, 15, ...}; pos = std::search(coll.begin(), coll.end(), std::boyer_moore_searcher{sub.begin(), sub.end()}); 同样，您还可以使用搜索器的函数调用运算符：\nstd::vector\u0026lt;int\u0026gt; coll; ...; std::deque\u0026lt;int\u0026gt; sub{0, 8, 15, ...}; std::boyer_moore_searcher bm{sub.begin(), sub.end()}; auto [beg, end] = bm(coll.begin(), coll.end()); if (beg != coll.end) { std::cout \u0026lt;\u0026lt; \u0026#34;found subsequence at \u0026lt;\u0026lt; \u0026#34; beg - coll.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 为了实现这一点，元素必须能够在哈希表中使用（即必须提供一个默认的哈希函数，并且必须支持用==来比较两个元素）。如果不是这种情况，你可以使用谓词（如下所述）。 再说一遍。测量发现你在性能（速度和内存）方面的好处。在尝试一些例子时，我看到了更多不同的因素。例如，使用boyer_moore_searcher可以将搜索的速度再次提高100倍（这又比使用并行算法快多了）。但是使用boyer_moore_horspool_searcher可以使搜索速度提高50倍，但也会慢2倍。 lib/searcher2.cpp中的代码演示了对一个向量中的子序列的不同搜索，还打印了不同搜索选项的测量结果，这样你就可以比较 在你的平台上进行比较。\n23.3 使用搜索器的谓词 使用搜索时，您可以使用谓词，这可能是必要的，原因有两个：\n您想定义自己的方式来比较两个元素。\n你想提供一个哈希函数，这对于 Boyer-Moore(-Horspool) 搜索器是必需的。 您必须将谓词作为附加参数提供给搜索器的构造函数。 例如，这里我们不区分大小写地搜索子字符串：\nstd::boyer_moore_searcher bmic{substr.begin(), substr.end(), [](char c){ return std::hash\u0026lt;char\u0026gt;{}(std::toupper(c)); }, [](char c1, char c2){ return std::toupper(c1)==std::toupper(c2); } }; auto begend = bmic(sub.begin(), sub.end()); 在散列值之前不要忘记调用 toupper()，否则你违反了散列值对于所有值必须相同的要求，其中 operator== 产生 true。 在这里，如果我们有一个类 Customer 定义如下：\nclass Customer { ...; public: Customer() = default; std::string getID() const { return id; } friend bool operator== (const Customer\u0026amp; c1, const Customer\u0026amp; c2) { return c1.id == c2.id; } }; 我们可以在Customer vector中搜索客户子序列，如下所示：\nstd::vector\u0026lt;Customer\u0026gt; customers; ...; std::vector\u0026lt;Customer\u0026gt; sub{...}; ...; std::boyer_moore_searcher bmcust(sub.begin(), sub.end(), [](const Customer\u0026amp; c) { return std::hash\u0026lt;std::string\u0026gt;{}(c.getID()); }); auto pos = bmcust(customers.begin(), customers.end()); if (pos.first != customers.end()) { ...; } 但是请注意，使用谓词可能会给使用搜索器带来很大的开销，所以只有当你有大量的元素并搜索一个相当大的子序列时才值得使用它们（例如，在100万个客户的集合中寻找1000个客户的子序列）。 再次强调。要有大的思维，要有大的度量。\n23.4 后记 这些搜索最初是由 Marshall Clow 在 https://wg21.link/n3411 中提出的，将 Boost.Algorithm 作为参考实现。 它们成为第一个图书馆基础 TS 的一部分。 对于 C++17，它们随后与 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的其他组件一起采用，包括 Marshall Clow 在 https://wg21.link/p0253R1 中提出的接口修复。\n24 其他工具函数和算法 C++17 提供了一些新的实用函数和算法，本章将对其进行介绍。\n24.1 size(), empty(), and data() 为了支持通用代码的灵活性，C++标准库提供了三个新的辅助函数：size()、empty()和data()。 正如其他用于泛型代码迭代范围和集合的全局辅助函数std::begin(), std::end(), 和std::advance()一样，这些函数被定义在头文件中。\n24.1.1 通用的size()函数 通用的std::size()函数允许我们询问任何范围的大小，只要它有一个迭代器接口或者是一个原始数组。有了它，你可以写这样的代码:\nlib/last5.hpp\n#ifndef LAST5_HPP #define LAST5_HPP #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printLast5(const T\u0026amp; coll) { // 计算大小: auto size{std::size(coll)}; // 前进到从最后 5 个元素开始的位置 std::cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; elems: \u0026#34;; auto pos{std::begin(coll)}; if (size \u0026gt; 5) { std::advance(pos, size - 5); std::cout \u0026lt;\u0026lt; \u0026#34;... \u0026#34;; } // 打印剩余元素: for ( ; pos != std::end(coll); ++pos) { std::cout \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif // LAST5_HPP 在这里，与\nauto size{std::size(coll)}; 我们用传递的集合的大小来初始化 size，它要么映射到 coll.size() 要么映射到传递的原始数组的大小。 因此，如果我们调用：\nstd::array arr{27, 3, 5, 8, 7, 12, 22, 0, 55}; std::vector v{0.0, 8.8, 15.15}; std::initializer_list\u0026lt;std::string\u0026gt; il{\u0026#34;just\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;literals\u0026#34;}; printLast5(arr); printLast5(v); printLast5(il); 输出是：\n9 elems: ... 7 12 22 0 55 3 elems: 0 8.8 15.15 5 elems: just five small string literal 并且因为支持原始 C 数组，我们也可以调用:\nprintLast5(\u0026#34;hello world\u0026#34;); 打印:\n12 elems: ... o r l d 请注意，此函数模板因此替换了使用 countof 或 ARRAYSIZE 定义为类似以下内容的计算数组大小的常用方法：\n#define ARRAYSIZE(a) (sizeof(a)/sizeof(*(a))) 另请注意，您不能将内联定义的初始化列表传递给 last5\u0026lt;\u0026gt;()。 原因是模板参数不能推导出 std::initializer_list()。 为此，您必须使用以下声明重载 last5()：\ntemplate\u0026lt;typename T\u0026gt; void printLast5(const std::initializer_list\u0026lt;T\u0026gt;\u0026amp; coll) 最后，请注意此代码不适用于 forward_list\u0026lt;\u0026gt;，因为转发列表没有成员函数 size()。 所以，如果你只想检查集合是否为空，你最好使用std::empty()，这将在后面讨论。\n24.1.2 通用的empty()函数 与新的全局 size() 类似，新的通用 std::empty() 允许我们检查容器、原始 C 数组或 std::initializer_list\u0026lt;\u0026gt; 是否为空。 因此，与上面的示例类似，您可以一般地检查传递的集合是否为空：\nif (std::empty(coll)) { return; } 与 std::size() 相比，std::empty() 也适用于前向列表/\n24.1.3 通用的data()函数 最后，新的通用 std::data() 函数允许我们访问具有 data() 成员和原始数组的容器的原始数据。 容器、原始 C 数组或 std::initializer_list\u0026lt;\u0026gt;。 例如，以下代码每隔一个元素打印一次：\nlib/data.hpp #ifndef DATA_HPP #define DATA_HPP #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printData(const T\u0026amp; coll) { // 每隔一个元素打印一次: for (std::size_t idx{0}; idx \u0026lt; std::size(coll); ++idx) { if (idx % 2 == 0) { std::cout \u0026lt;\u0026lt; std::data(coll)[idx] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif // DATA_HPP 因此，如果我们调用：\nstd::array arr{27, 3, 5, 8, 7, 12, 22, 0, 55}; std::vector v{0.0, 8.8, 15.15}; std::initializer_list\u0026lt;std::string\u0026gt; il{\u0026#34;just\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;literals\u0026#34;}; printData(arr); printData(v); printData(il); printData(\u0026#34;hello world\u0026#34;); 输出：\n27 5 7 22 55 0 15.15 just small literals h l o w r d 24.2 as_const() 新的辅助函数 std::as_const() 将值转换为相应的 const 值，而不使用 static_cast\u0026lt;\u0026gt; 或 add_const_t\u0026lt;\u0026gt; 类型特征。 它允许我们强制为非 const 对象调用函数的 const 重载，以防万一：\nstd::vector\u0026lt;std::string\u0026gt; coll; foo(coll); // 喜欢非常量重载 foo(std::as_const(coll)); // 强制使用 const 重载 如果 foo() 是一个函数模板，这也将强制将模板实例化为 const 类型而不是原始的非常量类型。\n24.2.1 通过常量引用进行捕获 as_const() 的一种应用是通过 const 引用捕获 lambda 参数的能力。 例如：\nstd::vector\u0026lt;int\u0026gt; coll {8, 15, 7, 42}; auto printColl = [\u0026amp;coll = std::as_const(coll)] { std::cout \u0026lt;\u0026lt; \u0026#34;coll: \u0026#34;; for (int elem : coll) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; 现在调用:\nprintColl(); 将打印 coll 的当前状态，而不会有意外修改其值的危险。\n24.3 clamp() C++17 提供了一个新的实用函数clamp()，它可以在传递的最小值和最大值之间“钳制”一个值。 它是 min() 和 max() 的组合调用。 例如： lib/clamp.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // for sample() int main() { for (int i : {-7, 0, 8, 15}) { std::cout \u0026lt;\u0026lt; std::clamp(i, 5, 13) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 调用clamp(i, 5, 13) 与调用std::min(std::max(i, 5), 13) 的效果相同，因此程序具有以下输出：\n5 5 8 13 至于 min() 和 max()，clamp() 要求所有通过 const 引用传递的参数都具有相同的类型 T：\nnamespace std { template\u0026lt;typename T\u0026gt; constexpr const T\u0026amp; clamp(const T\u0026amp; value, const T\u0026amp; min, const T\u0026amp; max); } 返回值是对传递参数之一的 const 引用。 如果传递不同类型的参数，则可以显式指定模板参数 T：\ndouble d{4.3}; int max{13}; ... std::clamp(d, 0, max); // 编译时错误 std::clamp\u0026lt;double\u0026gt;(d, 0, max); // OK 你也可以传递浮点值，只要它们没有 NaN 值。 至于 min() 和 max() 你可以传递一个谓词作为比较操作。 例如：\nfor (int i : {-7, 0, 8, 15}) { std::cout \u0026lt;\u0026lt; std::clamp(i, 5, 13, [] (auto a, auto b) { return std::abs(a) \u0026lt; std::abs(b); }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 具有以下输出：\n-7 5 8 13 因为 -7 的绝对值介于 5 和 13 的绝对值之间，所以在这种情况下，clamp() 产生 -7。 没有采用值的初始化列表（如 min() 和 max() 所具有的）的 clamp() 的重载。\n24.4 sample() 通过sample()，C++17提供了一种算法，可以从一个给定的数值范围（群体）中提取一个随机子集（样本）。这有时被称为蓄水池采样或选择采样。 考虑一下下面的例子程序。\nlib/sample1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; // for clamp() #include \u0026lt;random\u0026gt; // for default_random_engine int main() { // 初始化一个包含 10,000 个字符串值的vector: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(\u0026#34;value\u0026#34; + std::to_string(i)); } // 打印此集合的 10 个随机选择的值: sample(coll.begin(), coll.end(), std::ostream_iterator\u0026lt;std::string\u0026gt;{std::cout, \u0026#34;\\n\u0026#34;}, 10, std::default_random_engine{}); } 在使用大量字符串值（value0、value1、\u0026hellip;）初始化向量后，我们使用 sample() 来提取这些字符串值的随机子集：\n// 打印此集合的 10 个随机选择的值: sample(coll.begin(), coll.end(), std::ostream_iterator\u0026lt;std::string\u0026gt;{std::cout, \u0026#34;\\n\u0026#34;}, 10, std::default_random_engine{}); 我们通过：\n我们从中提取值子集的范围的开始和结束， 一个迭代器，用于将提取的值写入（这里是一个 ostream 迭代器将它们写入标准输出） 要提取的值的最大数量（我们可能会提取较少的值，范围太小） 用于计算随机子集的随机引擎 结果，我们打印了 coll 的 10 个元素的随机子集。 输出可能是：\nvalue0 value488 value963 value1994 value2540 value2709 value2835 value3518 value5172 value7996 如您所见，元素的顺序是稳定的（与它们在 coll 中的顺序相匹配）。 但是，只有在传递范围的迭代器至少是前向迭代器时，才能保证这一点。 算法声明如下：\nnamespace std { template\u0026lt;typename InputIterator, typename OutputIterator, typename Distance, typename UniformRandomBitGenerator\u0026gt; OutputIterator sample(InputIterator sourceBeg, InputIterator sourceEnd, OutputIterator destBeg, Distance num, UniformRandomBitGenerator\u0026amp;\u0026amp; eng); } 它具有以下规范和约束：\n源范围的迭代器必须至少是输入迭代器，目标范围的迭代器必须至少是输出迭代器。 但是，两者都不可能。 如果源迭代器不是最小前向迭代器，则目标迭代器必须是随机访问迭代器。 像往常一样，目标迭代器会覆盖，如果没有足够的元素可以覆盖并且没有使用插入器，则会导致未定义的行为。 该算法返回最后一个复制元素之后的位置。 目标迭代器不得在传递的源范围内。 num 可以是整数类型。 如果源范围内的元素不足，则提取源范围内的所有元素。 提取元素的顺序是稳定的，除非源范围内的迭代器是纯输入迭代器。 这是另一个演示 sample() 用法的示例：\nlib/sample2.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; // for clamp() #include \u0026lt;random\u0026gt; // for default_random_engine int main() { // initialize a vector of 10,000 string values: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(\u0026#34;value\u0026#34; + std::to_string(i)); } // 使用随机种子初始化 Mersenne Twister 引擎: std::random_device rd; // 随机种子（如果支持） std::mt19937 eng{rd()}; // Mersenne twister engine // 初始化目标范围（必须足够大以容纳 10 个元素）: std::vector\u0026lt;std::string\u0026gt; subset; subset.resize(100); // 将 10 个随机选择的值从源范围复制到目标范围: auto end = sample(coll.begin(), coll.end(), subset.begin(), 10, eng); // 打印提取的元素（使用返回值作为新的结束）: for_each(subset.begin(), end, [] (const auto\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;random elem: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); } 在再次用大量字符串值（value0，value1，\u0026hellip;）初始化一个vector之后，我们初始化一个用随机种子初始化的随机数引擎：\n// 用一个随机种子初始化一个Mersenne Twister引擎: std::random_device rd; // 随机种子（如果支持） std::mt19937 eng{rd()}; // Mersenne Twister引擎 和一个目标范围:\n// 初始化目标范围（必须足够大以容纳 10 个元素）: std::vector\u0026lt;std::string\u0026gt; subset; subset.resize(100); sample() 的调用现在将源范围的 10 个元素复制到目标范围：\n// 将 10 个随机选择的值从源范围复制到目标范围: auto end = sample(coll.begin(), coll.end(), subset.begin(), 10, eng); 返回值 end 初始化为包含最后一个随机提取的元素后面的位置，之后可以使用该位置，例如，打印提取的元素：\n// 打印提取的元素（使用返回值作为新的结束）： for_each(subset.begin(), end, [] (const auto\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;random elem: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); 24.5 for_each_n() 作为并行 STL 算法的一部分，提出了一种新算法 for_each_n()，该算法从 C++17 开始也以传统的非并行形式提供。 与 copy_n()、fill_n() 和 generate_n() 类似，它需要一个整数参数来将传递的可调用对象应用于给定范围的 n 个元素。 例如： lib/foreachn.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; // for for_each_n() int main() { // 初始化一个包含 10,000 个字符串值的vector: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(std::to_string(i)); } // 修改前 5 个元素： for_each_n(coll.begin(), 5, [] (auto\u0026amp; elem) { elem = \u0026#34;value\u0026#34; + elem; }); // 打印前 10 个元素： for_each_n(coll.begin(), 10, [] (const auto\u0026amp; elem) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); } 在用大量字符串值（value0、value1、\u0026hellip;）初始化一个vector后，我们首先修改前 5 个字符串：\nfor_each_n(coll.begin(), 5, [] (auto\u0026amp; elem) { elem = \u0026#34;value\u0026#34; + elem; }); 然后打印前 10 个字符串：\nfor_each_n(coll.begin(), 10, [] (const auto\u0026amp; elem) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); 因此，该程序具有以下输出：\nvalue0 value1 value2 value3 value4 5 6 7 8 9 算法声明如下：\nnamespace std { template\u0026lt;typename InputIterator, typename Size, typename Function\u0026gt; InputIterator for_each_n(InputIterator first, Size n, Function f); } 请注意以下事项：\nfor_each_n() 的非并行版本保证为每个元素按顺序调用传递的可调用对象。 for_each_n() 算法作为迭代器返回最后处理的元素后面的位置。 由调用者确保给定范围有足够的元素。 传递的可调用对象的任何返回值都将被忽略。 该算法也可用作并行 STL 算法，它允许我们将任何函数应用于前 n 个元素，而无需保证任何顺序。\n24.6 后记 size()、empty() 和 data() 最早由 Riccardo Marcangelo 在 https://wg21.link/n4017 中提出。 最终接受的措辞由 Riccardo Marcangelo 在 https://wg21.link/n4280 中制定。 as_const() 由 ADAM David Alan Martin 和 Alisdair Meredith 在 https://wg21.link/n4380 中首次提出。 最终接受的措辞由 ADAM David Alan Martin 和 Alisdair Meredith 在 https://wg21.link/p0007r1 中制定。 clamp() 由 Martin Moene 和 Niels Dekker 在 https://wg21.link/n4536 中首次提出。 最终接受的措辞由 Martin Moene 和 Niels Dekker 在 https://wg21.link/p002501 中制定。\nsample() 由 Walter E. Brown 在 https://wg21.link/n3842 中首次提出。 最终接受的措辞由 Walter E. Brown 在 https://wg21.link/n3925 中制定。\n25 容器扩展 C++ 标准库的标准容器有一些细微的变化，本章将对此进行描述。\n25.1 支持不完整的容器类型 由于 C++17 需要 std::vector、std::list 和 std__forward_list 来支持不完整类型。 这样做的主要动机在 Matt Austern 的一篇名为“标准图书馆员：不完整类型的容器”的文章中进行了描述（参见 http://drdobbs.com/184403814）：您现在可以拥有一个类型，它递归地拥有一个成员 其类型的容器。 例如：\nstruct Node { std::string value; std::vector\u0026lt;Node\u0026gt; children; // 好的，因为 C++17（节点在这里是不完整的类型） }; 这也适用于具有私有成员和公共 API 的类。 这是一个完整的例子：\nlib/incomplete.hpp\n#ifndef NODE_HPP #define NODE_HPP #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Node { private: std::string value; std::vector\u0026lt;Node\u0026gt; children; // 好的，因为 C++17（节点在这里是不完整的类型） public: // 创建一个带值的节点: Node(std::string s) : value{std::move(s)}, children{} { } // 添加子节点: void add(Node n) { children.push_back(std::move(n)); } // 访问子节点: Node\u0026amp; operator[](std::size_t idx) { return children.at(idx); } // 递归打印节点树: void print(int indent = 0) const { std::cout \u0026lt;\u0026lt; std::string(indent, \u0026#39; \u0026#39;) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (const auto\u0026amp; n : children) { n.print(indent+2); } } ...; }; #endif // NODE_HPP 您可以使用此类，例如，如下所示：\nlib/incomplete.cpp\n#include \u0026#34;incomplete.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { // 创建节点树: Node root{\u0026#34;top\u0026#34;}; root.add(Node{\u0026#34;elem1\u0026#34;}); root.add(Node{\u0026#34;elem2\u0026#34;}); root[0].add(Node{\u0026#34;elem1.1\u0026#34;}); // print node tree: root.print(); } 该程序具有以下输出：\ntop elem1 elem1.1 elem2 25.2 节点处理程序 通过引入从关联或无序容器中拼接节点的能力，你可以轻松地：\n修改键或（无序）maps或maps或（无序）集合。 在（无序） sets 和 maps中使用移动语义，以及 在（无序）sets 和 maps之间移动元素。 例如，在定义和初始化一个map后，如下所示。\nstd::map\u0026lt;int, std::string\u0026gt; m{{1,\u0026#34;mango\u0026#34;}, {2,\u0026#34;papaya\u0026#34;}, {3,\u0026#34;guava\u0026#34;}}; 您可以使用键 2 修改元素，如下所示：\nauto nh = m.extract(2); // nh 的类型为 decltype(m)::node_type nh.key() = 4; m.insert(std::move(nh)); 代码将键为 2 的元素的节点从容器中取出，修改键，然后将其移回，如图 25.1 中所述。 请注意，不使用内存（取消）分配，并且对元素的指针和引用保持有效。 但是，在元素保存在节点句柄中时使用指针和引用会导致未定义的行为。\n节点句柄的类型是 container::node_type。 它为会员提供\n所有（无序）集合类型的value() 所有（无序）map类型的成员 key() 和 mapped() 您还可以使用节点句柄将元素从一个容器移动到另一个容器。 容器甚至可以通过以下方式有所不同：\n一个支持重复，而另一个不支持（例如，您可以将元素从多地图移动到地图） 比较函数和散列函数可能不同 )\n例子：\nstd::multimap\u0026lt;double, std::string\u0026gt; src {{1.1,\u0026#34;one\u0026#34;}, {2.2,\u0026#34;two\u0026#34;}, {3.3,\u0026#34;three\u0026#34;}}; std::map\u0026lt;double, std::string\u0026gt; dst {{3.3,\u0026#34;old data\u0026#34;}}; // 将一些元素从 multimap src 移动到 map dst: dst.insert(src.extract(src.find(1.1))); // 使用迭代器拼接 dst.insert(src.extract(2.2)); // 使用键拼接 请注意， insert() 函数返回一个包含三个元素的结构（按以下顺序）：\n如果无法插入，则为现有元素的迭代器位置。 插入一个布尔值，表示插入是否成功。 如果无法插入，则带有节点句柄的 mode_type 节点。 即，关键信息是插入的第二个成员。 使用结构化绑定，您可以按如下方式使用返回值：\nauto [pos,done,node] = dst.insert(src.extract(3.3)); if (!done) { std::cout \u0026lt;\u0026lt; \u0026#34;insert() of node handle failed:\u0026#34; \u0026lt;\u0026lt; \u0026#34; tried to insert key \u0026#39;\u0026#34; \u0026lt;\u0026lt; node.key() \u0026lt;\u0026lt; \u0026#34;\u0026#39; with value \u0026#39;\u0026#34; \u0026lt;\u0026lt; node.mapped() \u0026lt;\u0026lt; \u0026#34;\u0026#39; but key exists with value \u0026#39;\u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; } 25.3 后记 容器对不完整类型的支持首先是由 Matt Austern 在 http://drdobbs.com/184403814 中讨论的，最初是由袁志豪在 https://wg21.link/n3890 中提出的。 最终接受的措辞由袁志豪在 https://wg21.link/n4510 中制定。\n节点句柄首先由 Alan Talbot 间接提出，请求拼接操作作为库问题 https://wg21.link/lwg839 和 Alisdair Meredith 请求对节点元素的移动支持作为库问题 https://wg21.link/lwg1041。 最终接受的措辞由 Alan Talbot、Jonathan Wakely、Howard Hinnant 和 James Dennett 在 https://wg21.link/p0083r3 中制定。 最终，Howard E. Hinnant 在 https://wg21.link/p0508r0 中稍微澄清了 API。\n26 多线程和并发 在多线程和并发领域引入了一些小的扩展和改进。\n26.1 补充的互斥和锁 26.1.1 std::scoped_lock C++11 引入了一个简单的 std::lock_guard 来以一种简单的 RAII 风格的方式来锁定互斥锁：\n构造函数锁 析构函数解锁（可能由异常引起） 不幸的是，这没有标准化为可变参数模板，以便能够通过单个声明锁定多个互斥锁。 std::scoped_lock\u0026lt;\u0026gt; 弥补了这一差距。 它允许我们锁定一个或多个互斥锁。 互斥锁可能有不同的互斥锁类型。 例如：\n#include \u0026lt;mutex\u0026gt; ...; std::vector\u0026lt;std::string\u0026gt; allIssues; std::mutex allIssuesMx; std::vector\u0026lt;std::string\u0026gt; openIssues; std::timed_mutex openIssuesMx; // lock both issue lists: { std::scoped_lock lg(allIssuesMx, openIssuesMx) ...; // 操作 allIssues 和 openIssues } 请注意，由于类模板参数推导，您在声明 lg 时不必指定互斥锁的类型。 此示例用法等价于以下代码，从 C++11 开始可以调用：\n// 锁定两个问题清单: { std::lock(allIssuesMx, openIssuesMx); // 避免死锁的锁 std::lock_guard\u0026lt;std::mutex\u0026gt; lg1(allIssuesMx, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lg2(openIssuesMx, std::adopt_lock); ... // 同时操作allIssues和openIssues } 因此，如果传递了多个互斥锁，则 scoped_lock 的构造函数使用可变参数便利函数 lock(\u0026hellip;)，它保证调用不会导致死锁（标准注释：“死锁避免算法，例如 因为必须使用try-and-back-off，但没有指定具体算法以避免过度约束实现”）。 如果只将一个互斥锁传递给 scoped_lock 的构造函数，它只会锁定互斥锁。 因此，在具有单个构造函数参数的 scoped_lock 中，其作用类似于 lock_guard）。 然后它甚至定义了没有为多个互斥锁定义的成员 mutex_type。1 因此，您可以将 lock_guard 的所有用法替换为 scoped_lock。 如果没有传递互斥体，则锁守卫不起作用。 请注意，您还可以采用多个锁：\n// 锁定两个问题清单: { std::lock(allIssuesMx, openIssuesMx); // 注意：使用的死锁避免算法 std::scoped_lock lg(std::adopt_lock, allIssuesMx, openIssuesMx); ... // 同时操作allIssues和openIssues } 然而，请注意，采用锁的构造函数现在在前面有 adopt_lock 参数。\n26.1.2 std::shared_mutex C++14添加了shared_timed_mutex来支持读/写锁，即多个线程同时读取一个值，而不时地有线程可能会更新这个值。因为在一些平台上，不支持定时锁的mutex可以更有效地实现，现在引入了shared_mutex类型（就像自C++11以来，除了std::timed_mutex之外，还有std::mutex存在）。 shared_mutex定义在头文件\u0026lt;shared_mutex\u0026gt;中，支持以下操作。\n对于独占锁：lock(), try_lock(), unlock() 对于共享的读访问：lock_shared(), try_lock_shared(), unlock_shared() native_handle() 也就是说，与shared_times_mutex不同，它不支持try_lock_for()、try_lock_until()。try_lock_shared_for(), and try_lock_shared_until()。\n使用 shared_mutex 使用shared_mutex的方法如下。假设你有一个共享vector，它通常被多个线程读取，但不时地被修改：\n#include \u0026lt;shared_mutex\u0026gt; #include \u0026lt;mutex\u0026gt; ... std::vector\u0026lt;double\u0026gt; v; // 共享资源 std::shared_mutex vMutex; // 控制对 v 的访问（C++14 中的 shared_timed_mutex） 要进行共享读取访问（以便多个读取器不会相互阻塞），请使用 shared_lock，它是共享读取访问的锁保护（在 C++14 中引入）。 例如：\nif (std::shared_lock sl(vMutex); v.size() \u0026gt; 0) { ... // （共享）对vector v 元素的读取访问 } 只有在排他性的写访问中，你才会使用排他性的锁防护，这可能是一个简单的lock_guard或scoped_lock（如刚刚介绍的），或者是一个复杂的unique_lock。比如说:\n{ std::scoped_lock sl(vMutex); ... // 对vector 的独占写读访问 } 26.2 原子的 is_always_lock_free() 你现在可以通过一个C++库的功能来检查一个特定的原子类型是否总是可以在没有锁的情况下使用不加锁。比如说：\nif constexpr(std::atomic\u0026lt;int\u0026gt;::is_always_lock_free) { ... } else { ... } 如果该值为真，那么对于相应的原子类型的任何对象来说，is_lock_free()产生真:\nif constexpr(atomic\u0026lt;T\u0026gt;::is_always_lock_free) { static_assert(atomic\u0026lt;T\u0026gt;().is_lock_free()); // 从未失败 } 如果有的话，这个值与相应的宏的值相匹配，在C++17之前必须使用。 例如，如果且仅当ATOMIC_INT_LOCK_FREE产生2（代表 \u0026ldquo;总是\u0026rdquo;），那么std::atomic::is_always_lock_free()产生true。:\nif constexpr(std::atomic\u0026lt;int\u0026gt;::is_always_lock_free) { // ATOMIC_INT_LOCK_FREE == 2 ... } else { // ATOMIC_INT_LOCK_FREE == 0 || ATOMIC_INT_LOCK_FREE == 1 ... } 用静态成员代替宏的原因是为了有更多的类型安全，并支持在棘手的通用代码中使用这种检查（例如，使用SFINAE）。 请记住，std::atomic\u0026lt;\u0026gt;也可以用于琐碎的可复制类型。因此，你也可以检查，如果你自己的结构在原子上使用，是否需要锁。比如说：\ntemplate\u0026lt;auto SZ\u0026gt; struct Data { bool set; int values[SZ]; double average; }; if constexpr(std::atomic\u0026lt;Data\u0026lt;4\u0026gt;\u0026gt;::is_always_lock_free) { ... } else { ... } 26.3 缓存线的大小 有时对于一个程序来说，处理缓存线的大小是很重要的。\n一方面，不同线程访问的不同对象不属于同一个缓存线，这对并发性很重要。否则，当不同的线程同时访问时，同样数量的内存必须在它们之间进行同步。 另一方面，你的目标可能是将多个对象放在同一个缓存线中，这样访问第一个对象就可以直接访问其他对象，而不是将它们加载到缓存中。 为此，C++标准库在头文件中引入了两个内联变量。\nnamespace std { inline constexpr size_t hardware_destructive_interference_size; inline constexpr size_t hardware_constructive_interference_size; } 这些对象有以下执行定义的值。\nhardware_destructive_interference_size是推荐的两个可能被不同线程同时访问的对象之间的最小偏移量，以避免因为同一L1缓存线受到影响而导致性能下降。 hardware_constructive_interference_size是推荐的两个对象放在同一L1缓存行内的最大连续内存大小。 这两个值只是提示，因为理想的值可能取决于具体的架构。这些常数是编译器在处理生成的代码所支持的各种平台时所能提供的最佳值。所以，如果你知道的更多，请使用特定的值，但对于支持多种平台的代码来说，使用这些值比任何假定的固定尺寸要好。 这些值至少都是alignof(std::max_align_t)。通常情况下，值是相同的。然而，从语义上讲，它们代表了使用不同对象的不同目的，所以你应该使用它们 相应地使用它们，\n如下所示:\n如果你想通过不同的线程访问两个不同的（原子）对象。 struct Data { alignas(std::hardware_destructive_interference_size) int valueForOneThread; alignas(std::hardware_destructive_interference_size) int valueForAnotherThread; }; 如果你想通过同一个线程访问两个不同的（原子）对象。 struct Data { int valueForOneThread; int valueForTheSameThread; }; // 仔细检查，由于共享缓存线，我们有最好的性能。 static_assert(sizeof(Data) \u0026lt;= std::hardware_constructive_interference_size); // 确保对象被正确对齐。 alignas(sizeof(Data)) Data myDataForAThread; 26.4 后记 scoped_locks 最初是由 Mike Spertus 在 https://wg21.link/n4470 中将 lock_guard 修改为可变参数，被接受为 https://wg21.link/p0156r0。然而，因为这被证明是 ABI 破坏，新名称 scoped_lock 由 Mike Spertus 用 https://wg21.link/p0156r2 引入并最终被接受。 Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 后来通过 https://wg21.link/p0739r0 将构造函数的顺序更改为针对 C++17 的缺陷：\nshared_mutex 最初是由 Howard Hinnant 在 https://wg21.link/n2406 中与 C++11 的所有其他互斥体一起提出的。然而，要让 C++ 标准化委员会相信所有提议的互斥锁都是有用的，需要时间。因此，最终接受的措辞是由 Gor Nishanov 在 https://wg21.link/n4508 中为 C++17 制定的。\nstd::atomic\u0026lt;\u0026gt; 静态成员 std::is_always_lock_free 由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 https://wg21.link/n4509 中首次提出。最终接受的措辞也是由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 https://wg21.link/p0152r1 中制定的。\nJF Bastien 和 Olivier Giroux 在 https://wg21.link/n4523 中首次提出了硬件干扰（缓存线）大小。最终接受的措辞也是由 JF Bastien 和 Olivier Giroux 在 https://wg21.link/p0154r1 中制定的。\n","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/","title":"第四部分-标准库扩展和修改"},{"content":"第二部分: 模板特性 9 类模板参数推导 C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：\nstd::complex\u0026lt;double\u0026gt; c{5.1,3.3}; 也不能忽略第二次的std::mutex：\nstd::mutex mx; std::lock_guard\u0026lt;std::mutex\u0026gt; lg(mx); C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。\n比如：\n你可以这样声明： std::complex c{5.1,3.3}; // 好的：推断出 std::complex\u0026lt;double\u0026gt; 你可以这样实现： std::mutex mx; std::lock_guard lg{mx}; // OK: 推断出 std::lock_guard\u0026lt;std_mutex\u0026gt; 你甚至可以让容器推导其元素的类型： std::vector v1 {1, 2, 3} // OK: 推断出 std::vector\u0026lt;int\u0026gt; std::vector v2 {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; // OK: 推断出 std::vector\u0026lt;const char*\u0026gt; 9.1 类模板参数推导的使用 只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：\nstd::complex c1{1.1, 2.2}; // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c2(2.2, 3.3); // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c3 = 3.3; // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c4 = {4.4}; // 推断出 std::complex\u0026lt;double\u0026gt; c3和c4的初始化方式是可行的，因为你可以传递一个值来初始化std::complex\u0026lt;\u0026gt;，这对于推导出模板参数T来说足够了，它会被用于实数和虚数部分：\nnamespace std { template\u0026lt;typename T\u0026gt; class complex { constexpr complex(const T\u0026amp; re = T(), const T\u0026amp; im = T()); ... } }; 假设有如下声明\nstd::complex c1{1.1, 2.2}; 编译器会在调用的地方找到构造函数\nconstexpr complex(const T\u0026amp; re = T(), const T\u0026amp; im = T()); 因为两个参数T都是double，所以编译器推导出T是double，然后编译下面的代码：\ncomplex\u0026lt;double\u0026gt;::complex(const double\u0026amp; re = double(), const double\u0026amp; im = double()); 注意模板参数必须是无歧义、可推导的。因此，下面的初始化是有问题的：\nstd::complex c5{5,3.3}; // 错误：尝试将 int 和 double 作为 T 对于模板来说，不会在推导模板参数的时候做类型转换。\n对于可变参数模板的类模板参数推导也是支持的。比如，std::tuple\u0026lt;\u0026gt;定义如下：\nnamespace std { template\u0026lt;typename... Types\u0026gt; class tuple; public: constexpr tuple(const Types\u0026amp;...); ... }; }; 这个声明：\nstd::tuple t{42, \u0026#39;x\u0026#39;, nullptr}; 推导出的类型是std::tuple。\n你也可以推导出非类型模板参数。举个例子，像下面例子中传递一个数组，在推导模板参数的时候可以同时推导出元素类型和数组大小：\ntemplate\u0026lt;typename T, int SZ\u0026gt; class MyClass { public: MyClass (T(\u0026amp;)[SZ]) { ... } }; MyClass mc(\u0026#34;hello\u0026#34;); // 将 T 推导出为 const char 并将 SZ 推导出为 6 SZ推导为6，因为模板参数类型传递了一个六个字符的字符串字面值。\n你甚至可以推导出用作基类的lambda的类型，或者推导出auto模板参数类型。\n9.1.1 默认复制 如果类模板参数推导发现一个行为更像是拷贝初始化，它就倾向于这么认为。比如，在用一个元素初始化std::vector后：\nstd::vector v1{42}; // 带有一个元素的vector\u0026lt;int\u0026gt; 用这个vector去初始化另一个vector：\nstd::vector v2{v1}; // v2 也是 vector\u0026lt;int\u0026gt; v2会被解释为vector而不是vector\u0026gt;\n又比如，这个规则适用于下面所有初始化形式：\nstd::vector v3(v1); // v3 也是 vector\u0026lt;int\u0026gt; std::vector v4 = {v1}; // v4 也是 vector\u0026lt;int\u0026gt; auto v5 = std::vector{v1}; // v5 也是 vector\u0026lt;int\u0026gt; 如果传递多个元素时，就不能被解释为拷贝初始化，此时initializer list的类型会成为新vector的元素类型：\nstd::vector vv{v, v}; // vv vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; 那么问题来了，如果传递可变参数模板，那么类模板参数推导会发生什么：\ntemplate\u0026lt;typename... Args\u0026gt; auto make_vector(const Args\u0026amp;... elems) { return std::vector{elems...}; } std::vector\u0026lt;int\u0026gt; v{1, 2, 3}; auto x1 = make_vector(v, v); // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; auto x2 = make_vector(v); // vector\u0026lt;int\u0026gt; 或vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ? 当前，不同的编译器有不同的处理方式，这个问题还在讨论中。\n9.1.2 推导 Lambda 的类型 有了类模板参数推导，我们现在终于可以用lambda的类型实例化类模板类。举个例子，我们可以提供一个泛型类，然后包装一下callback，并统计调用了多少次callback：\n// tmpl/classarglambda.hpp #include \u0026lt;utility\u0026gt; // for std::forward() template\u0026lt;typename CB\u0026gt; class CountCalls { private: CB callback; // callback to call long calls = 0; // counter for calls public: CountCalls(CB cb) : callback(cb) { } template\u0026lt;typename... Args\u0026gt; auto operator() (Args\u0026amp;\u0026amp;... args) { ++calls; return callback(std::forward\u0026lt;Args\u0026gt;(args)...); } long count() const { return calls; } }; 这里，构造函数接受一个callback，然后包装一下，用它的类型来推导出模板参数CB。比如，我们可以传一个lambda：\nCountCalls sc([](auto x, auto y) { return x \u0026gt; y; }); 这意味着sc的类型被推导为CountCalls。\n通过这种方式，我们可以计算传递给排序函数的sc的调用次数：\nstd::sort(v.begin(), v.end(), td::ref(sc)); std::cout \u0026lt;\u0026lt; \u0026#34;sorted with \u0026#34; \u0026lt;\u0026lt; sc.count() \u0026lt;\u0026lt; \u0026#34; calls\\n\u0026#34;; 包装后的lambda通过引用的方式传递给排序函数，因为如若不然std::sort()只会计算传递给他的lambda的拷贝的调用，毕竟是传值的方式。\n然而，我没可以传递包装后的lambda给std::for_each，因为这个算法可以返回传递给他的callback的拷贝：\nauto fo = std::for_each(v.begin(), v.end(), CountCalls([](auto i) { std::cout \u0026lt;\u0026lt; \u0026#34;elem: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; })); std::cout \u0026lt;\u0026lt; \u0026#34;output with \u0026#34; \u0026lt;\u0026lt; fo.count() \u0026lt;\u0026lt; \u0026#34; calls\\n\u0026#34;; 9.1.3 非部分类模板参数推导 不像函数模板那样，类模板参数不能部分推导（显示模板参数的一部分）。比如：\ntemplate\u0026lt;typename T1, typename T2, typename T3 = T2\u0026gt; class C { public: C (T1 x = T1{}, T2 y = T2{}, T3 z = T3{}) { ... } ... }; // all deduced: C c1(22, 44.3, \u0026#34;hi\u0026#34;); // OK：T1 是 int，T2 是 double，T3 是 const char* C c2(22, 44.3); // OK: T1 是 int，T2 和 T3 是 double C c3(\u0026#34;hi\u0026#34;, \u0026#34;guy\u0026#34;); // OK: T1、T2 和 T3 是 const char* // only some deduced: C\u0026lt;string\u0026gt; c4(\u0026#34;hi\u0026#34;, \u0026#34;my\u0026#34;); // ERROR: 只有 T1 明确定义 C\u0026lt;\u0026gt; c5(22, 44.3); // ERROR: 既不是 T1 也不是 T2 明确定义 C\u0026lt;\u0026gt; c6(22, 44.3, 42); // ERROR: T1 和 T2 都没有明确定义 // all specified: C\u0026lt;string,string,int\u0026gt; c7; // OK: T1,T2 是字符串，T3 是整数 C\u0026lt;int,string\u0026gt; c8(52, \u0026#34;my\u0026#34;); // OK: T1 是 int，T2 和 T3 是字符串 C\u0026lt;string,string\u0026gt; c9(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // OK: T1,T2,T3 是字符串 因为第三个模板参数类型有默认值，所以如果已经指定了第二个就可以省略第三个。\n如果i想知道为什么不支持偏特化，下面是造成这个抉择的原因：\nstd::tuple\u0026lt;int\u0026gt; t(42, 43); // still ERROR std::tuple是一个可变参数模板，所以你可以指定任意数量的参数。在这种情况下，到底是认为这是只指定了一个类型的而导致的错误还是有意为之很难说清。看起来是有问题的。后期有更多考量后，偏特化也有可能加入C++标准。尽管目前没有。\n不幸的是，缺少部分特化就不能解决一个常见代码需求。对于关联容器的排序规则，或者无序容器的hash函数，我们仍然不能简单的传一个lambda：\nstd::set\u0026lt;Cust\u0026gt; coll([](const Cust\u0026amp; x, const Cust\u0026amp; y) { // still ERROR return x.name() \u0026gt; y.name(); }); 我们还是得指定lambda的类型，因此需要像下面这样写：\nauto sortcrit = [](const Cust\u0026amp; x, const Cust\u0026amp; y) { return x.name() \u0026gt; y.name(); }; std::set\u0026lt;Cust, decltype(sortcrit)\u0026gt; coll(sortcrit); // OK 9.1.4 类模板参数推导代替便捷的工具函数。 有了类模板参数推导，我们可以不再使用那些目的仅是推导传的参数的类型的便捷工具函数。\n最明显的是make_pair，他允许我们不指定传的参数的类型。比如，对于v：\nstd::vector\u0026lt;int\u0026gt; v; 我们可以使用:\nauto p = std::make_pair(v.begin(), v.end()); 来代替\nstd::pair\u0026lt;typename std::vector\u0026lt;int\u0026gt;::iterator,typename std::vector\u0026lt;int\u0026gt;::iterator\u0026gt; p(v.begin(), v.end()); 现在，make_pair()不再需要了，可以直接这么写：\nstd::pair p(v.begin(), v.end()); 然而，std::make_pair() 也是一个很好的例子，它证明了有时便利函数不仅仅是推导模板参数。 事实上，std::make_pair() 也会衰减，这尤其意味着传递的字符串文字的类型被转换为 const char *：\nauto q = std::make_pair(\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;); // 一对指针 在这种情况下，q 的类型为 std::pair\u0026lt;const char*, const char*\u0026gt;。 通过使用类模板参数推导，事情变得更加复杂。 让我们看看像 std::pair 这样的简单类声明的相关部分：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair1 { T1 first; T2 second; Pair1(const T1\u0026amp; x, const T2\u0026amp; y) : first{x}, second{y} { } }; 关键是元素是通过引用传递的。 并且根据语言规则，当通过引用传递模板类型的参数时，参数类型不会衰减，这就是 将原始数组类型转换为相应的原始指针类型的机制。 因此，在调用时：\nPair1 p1{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 推导出一对不同大小的数组，但是...... T1 推导出为 char[3]，T2 推导为 char[6]。 原则上，这样的推导是有效的。 但是，我们使用 T1 和 T2 来声明成员 first 和 second。 结果，他们是 声明为：\nchar first[3]; char second[6]; 并且不允许从数组的左值初始化数组。 这就像尝试编译：\nconst char x[3] = \u0026#34;hi\u0026#34;; const char y[6] = \u0026#34;world\u0026#34;; char first[3] {x}; // ERROR char second[6] {y}; // ERROR 请注意，在声明要按值传递的参数时，我们不会遇到这个问题：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair2 { T1 first; T2 second; Pair2(T1 x, T2 y) : first{x}, second{y} { } }; 如果对于这种类型，我们会调用：\nPair2 p2{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 推导出一对指针 T1 和 T2 都将被推导出为 const char*。 因为声明了类 std::pair\u0026lt;\u0026gt; 以便构造函数通过引用获取参数， 您现在可能期望以下初始化不会编译：\nstd::pair p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 似乎推断出一对不同大小的数组，但是...... 但它编译。 原因是我们使用推到。\n9.2 推导指南 您可以定义特定的推导指南以提供额外的类模板参数推导 或修复构造函数定义的现有扣除。 例如，您可以定义每当 推导出 Pair3 的类型，类型推导应该像类型被传递一样操作 价值：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair3 { T1 first; T2 second; Pair3(const T1\u0026amp; x, const T2\u0026amp; y) : first{x}, second{y} { } }; // 构造函数的推导指南： template\u0026lt;typename T1, typename T2\u0026gt; Pair3(T1, T2) -\u0026gt; Pair3\u0026lt;T1, T2\u0026gt;; 在这里，在-\u0026gt;的左边，我们声明我们要推导的东西。在这个例子中，它是由两个任意类型的对象T1和T2通过值创建一个 Pair3，由两个任意类型的T1和T2的对象通过值传递。在\u0026quot;-\u0026gt;\u0026ldquo;的右边，我们 的右边定义了所产生的推理。在这个例子中，Pair3被实例化为两个类型的T1和T2。 你可能会说，这就是构造函数已经做的事情。然而，构造函数采用 参数的引用，这是不一样的。一般来说，即使在模板之外，参数 衰减，而通过引用传递的参数不会衰减。衰减意味着，原始 数组转换为指针，而顶级限定符，如const和引用，则被忽略。 如果没有推导指南，例如，在声明以下内容时：\nPair3 p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 参数 x 的类型，因此 T1 是 const char[3] 和参数 y 的类型，因此 T2 是 const char[6]。 由于推导，模板参数衰减，这意味着传递的数组或 字符串文字衰减为相应的指针类型。 现在，当声明以下内容时：\nPair3 p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 使用推导指南，它按值获取参数，以便两种类型都衰减为 const char*。 声明的效果就好像我们已经声明了：\nPair3\u0026lt;const char*, const char*\u0026gt; p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 请注意，构造函数仍然通过引用获取参数。 推导指南只重要 用于推导模板类型。 这与类型之后的实际构造函数调用无关 推导出 T1 和 T2。\n9.2.1 使用推导引导强制衰减 正如前面的例子所展示的，一般来说，这些重载的一个非常有用的应用 规则是确保模板参数 T 在推导时衰减。考虑一个典型的类模板：\ntemplate\u0026lt;typename T\u0026gt; struct C { C(const T\u0026amp;) { } ... }; 如果我们在这里传递一个字符串字面量“hello”，则推导出 T 为字符串字面量的类型，即 const char[6]：\nC x{\u0026#34;hello\u0026#34;}; // T 推导出为 const char[6] 原因是模板参数推导没有衰减到对应的指针类型，当参数通过引用传递时。 有一个简单的推导指南\ntemplate\u0026lt;typename T\u0026gt; C(T) -\u0026gt; C\u0026lt;T\u0026gt;; 我们解决了这个问题：\nC x{\u0026#34;hello\u0026#34;}; // T 推导出为 const char* 现在，因为推导指南按值接受它，它的类型衰减了，所以\u0026quot;hello\u0026rdquo; 推导出 T 为 const char* 类型。 因此，对于任何类模板，相应的推导指南听起来都非常合理 有一个构造函数通过引用获取其模板参数的对象。 C++ 标准 库提供了 pair 和 tuple 的相应推导指南。\n9.2.2 非模板推导 推导指南不必是模板，也不必适用于构造函数。 例如， 给定以下结构和推导指南：\ntemplate\u0026lt;typename T\u0026gt; struct S { T val; }; S(const char*) -\u0026gt; S\u0026lt;std::string\u0026gt;; // 将字符串文字的 S\u0026lt;\u0026gt; 映射到 S\u0026lt;std::string\u0026gt; 以下声明是可能的，其中 std::string 从 const 推导出为 T 的类型 char* 因为传递的字符串文字隐式转换为它：\nS s1{\u0026#34;hello\u0026#34;}; // OK, 等同于： S\u0026lt;std::string\u0026gt; s1{\u0026#34;hello\u0026#34;}; S s2 = {\u0026#34;hello\u0026#34;}; // OK, 等同于: S\u0026lt;std::string\u0026gt; s2 = {\u0026#34;hello\u0026#34;}; S s3 = S{\u0026#34;hello\u0026#34;}; // OK, 两个 S 都推断为 S\u0026lt;std::string\u0026gt; 请注意，聚合需要列表初始化（推导有效，但不允许初始化）：\nS s4 = \u0026ldquo;hello\u0026rdquo;; // 错误（不能以这种方式初始化聚合）\n9.2.3 推导与构造函数 推导指南与类的构造函数竞争。类模板参数推导使用根据重载决议具有最高优先级的构造函数/指南。如果构造函数和推导指南同样匹配，则优选推导指南。\n考虑我们有以下定义：\ntemplate\u0026lt;typename T\u0026gt; struct C1 { C1(const T\u0026amp;) { } }; C1(int) -\u0026gt; C1\u0026lt;long\u0026gt;; 当传递一个int时，使用推导指南，因为它被重载解析所青睐。 因此，T被推导为long：\nC1 x1{42}; // T 被推导为 long 但是如果我们传递一个char，构造函数是更好的匹配（因为不需要类型转换），所以 我们将 T 推导出为 char：\nC1 x3{\u0026#39;x\u0026#39;}; // T 被推导为 char 因为通过值匹配取参数与通过引用取参数和演绎指南同样适用于同样好的匹配，所以通常让演绎指南取 价值论据（这也有衰减的优势）。\n9.2.4 显式推导 一个推导指南可以被声明为是明确的。然后它只在以下情况下被忽略，即 显式会使初始化或转换失效。例如，鉴于:\ntemplate\u0026lt;typename T\u0026gt; struct S { T val; }; explicit S(const char*) -\u0026gt; S\u0026lt;std::string\u0026gt;; 传递推导指南参数类型的 S 对象的复制初始化（使用 =）忽略 扣除指南。 在这里，这意味着初始化变得无效：\nS s1 = {\u0026#34;hello\u0026#34;}; // ERROR (推导指南被忽略，否则无效) 直接初始化或在右侧进行显式推导仍然是可能的：\nS s2{\u0026#34;hello\u0026#34;}; // OK, same as: S\u0026lt;std::string\u0026gt; s1{\u0026#34;hello\u0026#34;}; S s3 = S{\u0026#34;hello\u0026#34;}; // OK S s4 = {S{\u0026#34;hello\u0026#34;}}; // OK 作为另一个示例，我们可以执行以下操作：\ntemplate\u0026lt;typename T\u0026gt; struct Ptr { Ptr(T) { std::cout \u0026lt;\u0026lt; \u0026#34;Ptr(T)\\n\u0026#34;; } template\u0026lt;typename U\u0026gt; Ptr(U) { std::cout \u0026lt;\u0026lt; \u0026#34;Ptr(U)\\n\u0026#34;; } }; template\u0026lt;typename T\u0026gt; explicit Ptr(T) -\u0026gt; Ptr\u0026lt;T*\u0026gt;; 这将产生以下效果：\nPtr p1{42}; // 由于推导引导推导 Ptr\u0026lt;int*\u0026gt; Ptr p2 = 42; // 由于构造函数推导出 Ptr\u0026lt;int\u0026gt; int i = 42; Ptr p3{\u0026amp;i}; // 由于推导引导推导 Ptr\u0026lt;int**\u0026gt; Ptr p4 = \u0026amp;i; // 由于构造函数推导出 Ptr\u0026lt;int*\u0026gt; 9.2.5 集合体推导 推导指南可用于通用聚合以启用类模板参数推导 那里。 例如，对于：\ntemplate\u0026lt;typename T\u0026gt; struct A { T val; }; 任何没有推导指南的类模板参数推导试验都是错误的：\nA i1{42}; // ERROR A s1(\u0026#34;hi\u0026#34;); // ERROR A s2{\u0026#34;hi\u0026#34;}; // ERROR A s3 = \u0026#34;hi\u0026#34;; // ERROR A s4 = {\u0026#34;hi\u0026#34;}; // ERROR 您必须显式传递类型 T 的参数：\nA\u0026lt;int\u0026gt; i2{42}; A\u0026lt;std::string\u0026gt; s5 = {\u0026#34;hi\u0026#34;}; 但经过推导如：\nA(const char*) -\u0026gt; A\u0026lt;std::string\u0026gt;; 您可以按如下方式初始化聚合：\nA s2{\u0026#34;hi\u0026#34;}; // OK A s4 = {\u0026#34;hi\u0026#34;}; // OK 但是，与聚合一样，您仍然需要花括号。 否则，类型 T 成功 推导出来，但初始化是错误的：\nA s1(\u0026#34;hi\u0026#34;); // 错误：T 是字符串，但没有聚合初始化 A s3 = \u0026#34;hi\u0026#34;; // 错误：T 是字符串，但没有聚合初始化 std::array 的推导指南是聚合推导指南的另一个示例。\n9.2.6 标准推导 C++ 标准库在 C++17 中引入了一些推导指南。 Pairs 和 Tuples 推导指南 正如在推导指南的动机中所介绍的那样，std::pair 需要推导指南来确保 类模板参数推导使用传入参数的衰减类型：\nnamespace std { template\u0026lt;typename T1, typename T2\u0026gt; struct pair { ... constexpr pair(const T1\u0026amp; x, const T2\u0026amp; y); // 引用参数 ... }; template\u0026lt;typename T1, typename T2\u0026gt; pair(T1, T2) -\u0026gt; pair\u0026lt;T1, T2\u0026gt;; // 按值推断参数类型 } 因此，声明\nstd::pair p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 采用 const char[3] 和 const char[6] 等价于: std::pair\u0026lt;const char*, const char*\u0026gt; p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 对于可变参数类模板 std::tuple，使用相同的方法：\nnamespace std { template\u0026lt;typename... Types\u0026gt; class tuple { public: constexpr tuple(const Types\u0026amp;...); // 通过引用获取参数 template\u0026lt;typename... UTypes\u0026gt; constexpr tuple(UTypes\u0026amp;\u0026amp;...); ... }; template\u0026lt;typename... Types\u0026gt; tuple(Types...) -\u0026gt; tuple\u0026lt;Types...\u0026gt;; // 按值推断参数类型 }; 因此，声明：\nstd::tuple t{42, \u0026#34;hello\u0026#34;, nullptr}; 将 t 的类型推导出为 std::tuple\u0026lt;int, const char*, std::nullptr_t\u0026gt;。\n迭代器的推导： 为了能够从定义初始化范围的迭代器中推断出元素的类型， 容器对 std::vector\u0026lt;\u0026gt; 有如下推导指南：\n// let std::vector\u0026lt;\u0026gt; 从初始化迭代器推断元素类型: namespace std { template\u0026lt;typename Iterator\u0026gt; vector(Iterator, Iterator) -\u0026gt; vector\u0026lt;typename iterator_traits\u0026lt;Iterator\u0026gt;::value_type\u0026gt;; } 例如，这允许：\nstd::set\u0026lt;float\u0026gt; s; std::vector v1(s.begin(), s.end()); // OK, 推导出 std::vector\u0026lt;float\u0026gt; 请注意，此处使用带括号的初始化很重要。 如果使用花括号：\nstd::vector v2{s.begin(), s.end()}; // 注意：不推断 std::vector\u0026lt;float\u0026gt; 这两个参数被视为初始化列表的元素（根据 重载决议规则）。 也就是说，相当于：\nstd::vector\u0026lt;std::set\u0026lt;float\u0026gt;::iterator\u0026gt; v2{s.begin(), s.end()}; 这样我们就初始化了一个包含两个元素的向量，第一个引用第一个元素，第二个引用表示最后一个元素后面的位置。 另一方面，考虑：\nstd::vector v3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // OK, 推导std::vector\u0026lt;const char*\u0026gt; std::vector v4(\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;); // OOPS：致命的运行时错误 虽然 v3 的声明还使用两个元素（都是 C 字符串）初始化向量，但 第二个导致致命的运行时错误，这可能会导致核心转储。 问题是那个字符串 文字转换为字符指针，这是有效的迭代器。 因此，我们传递了两个迭代器 不指向同一个对象。 换句话说：我们传递了一个无效的范围。 取决于两者在哪里 文字被存储，你会得到一个带有任意数量元素的 std::vector 。 如果 它太大了你得到一个 bad_alloc 异常，或者你得到一个核心转储，因为没有距离 全部，或者你会得到一些存储在它们之间的未定义字符的范围。 因此，在初始化向量的元素时，使用花括号总是最好的。 唯一的 例外是传递单个向量时（首选复制构造函数）。 通过时 别的东西，使用括号更好。\nstd::array\u0026lt;\u0026gt; 推导 一个更有趣的例子提供了 std::array\u0026lt;\u0026gt; 类：为了能够推导出这两个元素 类型和元素数量：\nstd::array a{42,45,77}; // OK, 推导出 std::array\u0026lt;int,3\u0026gt; 定义了以下推导指南：\n// let std::array\u0026lt;\u0026gt; 推断它们的元素数量（必须具有相同的类型）: namespace std { template\u0026lt;typename T, typename... U\u0026gt; array(T, U...) -\u0026gt; array\u0026lt;enable_if_t\u0026lt;(is_same_v\u0026lt;T,U\u0026gt; \u0026amp;\u0026amp; ...), T\u0026gt;, (1 + sizeof...(U))\u0026gt;; } 演绎指南使用折叠表达式\n(is_same_v\u0026lt;T,U\u0026gt; \u0026amp;\u0026amp; ...) 确保所有传递的参数的类型相同。 因此，以下是不可能的：\nstd::array a{42,45,77.7}; // ERROR: 类型不同 (无序)Map推导 可以证明获得行为正确的演绎指南所涉及的复杂性 通过试验为具有 key/value 对（map、multimap、 unordered_map，unordered_multimap）。 这些容器的元素具有 std::pair\u0026lt;const keytype, valuetype\u0026gt; 类型。 常量 是必要的，因为元素的位置取决于键的值，因此能够 修改密钥可能会在容器内产生不一致。 因此，C++17 标准中用于 std::map 的方法：\nnamespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; class map { ... }; } 例如，为以下构造函数定义：\nmap(initializer_list\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;, const Compare\u0026amp; = Compare(), const Allocator\u0026amp; = Allocator()); 以下推导指南：\nnamespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; map(initializer_list\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;, Compare = Compare(), Allocator = Allocator()) -\u0026gt; map\u0026lt;Key, T, Compare, Allocator\u0026gt;; } 由于所有参数都是按值传递的，因此本推导指南允许传递的比较器或分配器的类型如所讨论的那样衰减。 然而，我们天真地使用了相同的参数类型， 意味着初始化列表采用 const 键类型。 但结果是，以下不起作用 正如 Ville Voutilainen 在 https://wg21.link/lwg3025 中指出的那样：\nstd::pair elem1{1,2}; std::pair elem2{3,4}; ... std::map m1{elem1, elem2}; // 与原始 C++17 指南有关的错误 因为这里的元素被推导为 std::pair\u0026lt;int,int\u0026gt;，这与需要 const 类型作为第一对类型的推导指南不匹配。 因此，您仍然必须编写以下内容：\nstd::map\u0026lt;int,int\u0026gt; m1{elem1, elem2}; // OK, 因此，在推导指南中，应该删除 const： namespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; map(initializer_list\u0026lt;pair\u0026lt;Key, T\u0026gt;\u0026gt;, Compare = Compare(), Allocator = Allocator()) -\u0026gt; map\u0026lt;Key, T, Compare, Allocator\u0026gt;; } 然而，为了仍然支持比较器和分配器的衰减，我们还必须重载 具有 const 键类型的对的推导指南。 否则将使用构造函数，以便 当与 const 和配对时，类模板参数推导的行为会略有不同 非常量键被传递。\n智能指针无推导指南 请注意，C++ 标准库中的某些地方没有推导指南，尽管您可能 期望它们可用。 例如，您可能希望有共享和唯一指针的推导指南，以便 代替：\nstd::shared_ptr\u0026lt;int\u0026gt; sp{new int(7)}; 你可以写：\nstd::shared_ptr sp{new int(7)}; // 不支持 这不会自动工作，因为对应的构造函数是一个模板，所以没有 隐式推导指南适用：\nnamespace std { template\u0026lt;typename T\u0026gt; class shared_ptr { public: ... template\u0026lt;typename Y\u0026gt; explicit shared_ptr(Y* p); ... }; } Y 是与 T 不同的模板参数，因此从构造函数推导出 Y 并不意味着 我们可以推导出类型 T。这是一个能够调用类似以下内容的功能：\nstd::shared_ptr\u0026lt;Base\u0026gt; sp{new Derived(...)}; 相应的推导指南将很容易提供：\nnamespace std{ template\u0026lt;typename Y\u0026gt; shared_ptr(Y*) -\u0026gt; shared_ptr\u0026lt;Y\u0026gt;; } 但是，这也意味着在分配数组时会采用本指南：\nstd::shared_ptr sp{new int[10]}; // OOPS：会推导出 shared_ptr\u0026lt;int\u0026gt; 在 C++ 中，我们经常遇到令人讨厌的 C 问题，即指向一个对象的指针的类型和 对象数组具有或衰减为相同类型。 因为这个问题看起来很危险，所以 C++ 标准委员会决定不支持 (还没完成）。 您仍然需要调用单个对象：\nstd::shared_ptr\u0026lt;int\u0026gt; sp1{new int}; // OK auto sp2 = std::make_shared\u0026lt;int\u0026gt;(); // OK 对于数组：\nstd::shared_ptr\u0026lt;std::string\u0026gt; p(new std::string[10], [](std::string* p) { delete[] p; }); 或者：\nstd::shared_ptr\u0026lt;std::string\u0026gt; p(new std::string[10], std::default_delete\u0026lt;std::string[]\u0026gt;()); 9.3 后记 类模板参数推导由 Michael Spertus 于 2007 年在 https 中首次提出： //wg21.link/n2332。 该提案于 2013 年由 Michael Spertus 和 David Vandevoorde 在 https://wg21.link/n3602 中提出。 最终接受的措辞由迈克尔制定 Spertus、Faisal Vali 和 Richard Smith 在 https://wg21.link/p0091r3 中进行了修改 https://wg21.link/p0512r0 中的 Michael Spertus、Faisal Vali 和 Richard Smith，https://wg21.link/p0620r0 中的 Jason Merrill，以及 Michael Spertus 和 Jason Merrill（作为缺陷报告） 反对 C++17) 在 https://wg21.link/p702r1。 Michael 添加了对标准库中类模板参数推导的支持 Spertus、Walter E. Brown 和 Stephan T. Lavavej 在 https://wg21.link/p0433r2 和（作为 https://wg21.link/p0739r0 中针对 C++17 的缺陷报告。\n10 编译时if 使用 if constexpr(. . . ) 语法，编译器使用编译时表达式在编译时决定是使用 if 语句的 then 部分还是 else 部分（如果有）。 另一部分（如果 any) 被丢弃，因此不会生成任何代码。 这并不意味着它是丢弃的部分. 不过，完全忽略了。 它将像未使用模板的代码一样进行检查。 例如：\n#include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; std::string asString(T x) { if constexpr(std::is_same_v\u0026lt;T, std::string\u0026gt;) { return x; // 语句无效，如果没有转换为字符串 } else if constexpr(std::is_arithmetic_v\u0026lt;T\u0026gt;) { return std::to_string(x); // 声明无效，如果 x 不是数字 } else { return std::string(x); // 语句无效，如果没有转换为字符串 } } 在这里，我们使用这个特性在编译时决定是否只返回一个传递的字符串，调用 std::to_string() 获取传递的整数或浮点值，或尝试将传递的参数转换为 std::string。 因为无效调用被丢弃，下面的代码编译（其中 如果使用常规运行时，则不会出现这种情况）：\n#include \u0026#34;ifcomptime.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; asString(42) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; asString(std::string(\u0026#34;hello\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; asString(\u0026#34;hello\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 10.1 编译时if的时机 如果我们在刚刚介绍的示例中使用运行时 if：\n#include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; std::string asString(T x) { if (std::is_same_v\u0026lt;T, std::string\u0026gt;) { return x; // ERROR, 如果没有转换为字符串 } else if (std::is_numeric_v\u0026lt;T\u0026gt;) { return std::to_string(x); // ERROR, 如果 x 不是数字 } else { return std::string(x); // ERROR, 如果没有转换为字符串 } } 相应的代码永远不会编译。 这是函数模板通常不编译或作为一个整体编译的规则的结果。 if 条件的检查是 运行时功能。 即使在编译时很明显条件必须为假，那么 部分必须能够编译。 因此，当传递 std::string 或字符串文字时，编译失败， 因为对传递的参数调用 std::to_string() 无效。 当通过一个 数值，编译失败，因为第三个和第三个返回语句无效。 现在且仅通过使用编译时 if，无法使用的 then 和 else 部分变成 丢弃的语句：\n当传递一个std::string 值时，第一个if 的else 部分被丢弃。\n当传递一个数值时，第一个if 的then 部分和最后一个else 部分被丢弃。\n当传递一个字符串文字（即类型 const char*）时，第一个和第二个 if 的 then 部分 被丢弃。\n因此，每个无效组合在编译时都不会再出现，代码编译成功。 请注意，丢弃的语句不会被忽略。 效果是它没有被实例化，当 取决于模板参数。 语法必须正确，不依赖模板参数的调用必须有效。 实际上，执行第一个翻译阶段（定义时间）， 它检查正确的语法和所有不依赖于模板参数的名称的使用。 所有 static_asserts 也必须有效，即使在未编译的分支中也是如此。 例如：\ntemplate\u0026lt;typename T\u0026gt; void foo(T t) { if constexpr(std::is_integral_v\u0026lt;T\u0026gt;) { if (t \u0026gt; 0) { foo(t-1); // OK } } else { undeclared(t); // 如果未声明且未丢弃则错误（即 T 不是整数） undeclared(); // 如果未声明则错误（即使已丢弃） static_assert(false, \u0026#34;no integral\u0026#34;); // 总是断言（即使被丢弃） } } 使用符合标准的编译器，此示例永远不会编译，原因有两个：\n即使 T 是整数类型，调用\nundeclared(); // 如果未声明则错误（即使已丢弃） 如果没有声明这样的函数，则丢弃的 else 部分是一个错误，因为这个调用没有 依赖于模板参数\n调用：\nstatic_assert(false, \u0026#34;no integral\u0026#34;); // 总是断言（即使被丢弃） 即使它是被丢弃的 else 部分的一部分，它也总是会下降，因为这个调用再次不依赖于 模板参数。 重复编译时条件的静态断言会很好：\nstatic_assert(!std::is_integral_v\u0026lt;T\u0026gt;, \u0026#34;no integral\u0026#34;); 请注意，某些编译器（例如，Visual C++ 2013 和 2015）没有正确实现或执行模板的两阶段转换。 它们将第一阶段（定义时间）的大部分时间推迟到第二阶段（实例化时间），因此无效的函数调用甚至一些语法错误都可能编译。\n10.2 使用编译时if 原则上，如果条件是 编译时表达式。 在以下情况下，您还可以混合编译时和运行时：\nif constexpr (std::is_integral_v\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt;) { if (val \u0026gt; 10) { if constexpr (std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { ... } else { ... } } else { ... } } else { ... } 请注意，您不能在函数体之外使用 if constexpr。 因此，你不能用它来代替 条件预处理器指令。\n10.2.1 编译时if的注意事项 即使有可能使用 compile-time if ，如果可能有一些后果不是 很明显，这将在以下小节中讨论。\ncompile-time if 影响返回类型 compile-time if可能影响函数的返回类型。例如，下面的代码总是可以编译，但返回类型可能不同:\nauto foo() { if constexpr (sizeof(int) \u0026gt; 4) { return 42; } else { return 42u; } } 在这里，由于我们使用了auto，函数的返回类型取决于返回语句，而返回语句则 取决于int的大小。\n如果大小大于4，只有一个有效的返回语句返回42，所以返回 类型是int。 否则，只有一个返回语句返回42u，所以返回类型变成了 unsigned int.。 这样一来，带有if constexpr的函数的返回类型可能会有更大的差别例如，如果我们跳过else部分，返回类型可能是int或void。\nauto foo() // 返回类型可能是int或void { if constexpr (sizeof(int) \u0026gt; 4) { return 42; } } 请注意，如果这里使用了compile-time if，这段代码永远不会被编译，因为那样的话，两个返回语句都会被考虑在内，这样一来，对返回类型的推断就会变得模糊不清了。\nelse Matters Even if then Returns 对于compile-time if语句，有一种模式不适用于compile-time if语句。如果 代码的then和else部分都有返回语句，你可以跳过compile-time if语句中的else语句。也就是说，不要用:\nif (...) { return a; } else { return b; } 你总是可以写:\nif (...) { return a; } return b; 如果条件为真（int的大小大于4），编译器会推断出两种不同的返回类型，这是不成立的。否则，我们只有一个重要的返回语句，这样代码就可以编译了。\n短回路compile-time条件 考虑以下代码：\ntemplate\u0026lt;typename T\u0026gt; constexpr auto foo(const T\u0026amp; val) { if constexpr (std::is_integral\u0026lt;T\u0026gt;::value) { if constexpr (T{} \u0026lt; 10) { return val * 2; } } return val; } 这里我们有两个compile-time条件来决定是按原样返回传递的值还是加倍。\n这为两者编译：\nconstexpr auto x1 = foo(42); // yields 84 constexpr auto x2 = foo(\u0026#34;hi\u0026#34;); // OK, yields ”hi” 运行时ifs中的条件是短路的（评估带有\u0026amp;\u0026amp;的条件只到第一个false，评估带有||的条件只到第一个true）。这可能会导致人们期望compile-time if也是这种情况:\ntemplate\u0026lt;typename T\u0026gt; constexpr auto bar(const T\u0026amp; val) { if constexpr (std::is_integral\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; T{} \u0026lt; 10) { return val * 2; } return val; } 然而，compile-time if的条件总是被实例化的，并且需要整体有效，因此，传递一个不支持\u0026lt;10的类型不再能编译:\nconstexpr auto x2 = bar(\u0026#34;hi\u0026#34;); // compile-time ERROR 因此，compile-time if不会使实例化short-circuit。 如果编译时条件的有效性依赖于较早的编译时条件，则必须像在 foo() 中那样嵌套它们。 作为另一个例子，你必须写：\nif constexpr (std::is_same_v\u0026lt;MyType, T\u0026gt;) { if constexpr (T::i == 42) { ... } } 而不仅仅是：\nif constexpr (std::is_same_v\u0026lt;MyType, T\u0026gt; \u0026amp;\u0026amp; T::i == 42) { ... } 10.2.2 其他编译时if的例子 编译时的一种应用是返回值的完美转发，当它们必须得到处理才能返回时。 因为 void 不能推导出 decltype(auto) （因为 void 是一个不完整的类型），所以你必须编写如下内容：\n#include \u0026lt;functional\u0026gt; // for std::forward() #include \u0026lt;type_traits\u0026gt; // for std::is_same\u0026lt;\u0026gt; and std::invoke_result\u0026lt;\u0026gt; template\u0026lt;typename Callable, typename... Args\u0026gt; decltype(auto) call(Callable op, Args\u0026amp;\u0026amp;... args) { if constexpr(std::is_void_v\u0026lt;std::invoke_result_t\u0026lt;Callable, Args...\u0026gt;\u0026gt;) { // return type is void: op(std::forward\u0026lt;Args\u0026gt;(args)...); ... // do something before we return return; } else { // return type is not void: decltype(auto) ret{op(std::forward\u0026lt;Args\u0026gt;(args)...)}; ... // do something (with ret) before we return return ret; } } Compile-Time if用于标签调度 编译时 if 的一个典型应用是标签调度。 在 C+17 之前，您必须提供 为您要处理的每种类型设置一个单独的函数的重载。 现在，在编译时 如果，您可以将所有逻辑放在一个函数中。 例如，不要重载 std::advance() 算法：\ntemplate\u0026lt;typename Iterator, typename Distance\u0026gt; void advance(Iterator\u0026amp; pos, Distance n) { using cat = std::iterator_traits\u0026lt;Iterator\u0026gt;::iterator_category; advanceImpl(pos, n, cat); // 迭代器类别上的标签调度 } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::random_access_iterator_tag) { pos += n; } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::bidirectional_iterator_tag) { if (n \u0026gt;= 0) { while (n--) { ++pos; } } else { while (n++) { --pos; } } } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::input_iterator_tag) { while (n--) { ++pos; } } 我们现在可以在一个函数中实现所有行为：\ntemplate\u0026lt;typename Iterator, typename Distance\u0026gt; void advance(Iterator\u0026amp; pos, Distance n) { using cat = std::iterator_traits\u0026lt;Iterator\u0026gt;::iterator_category; if constexpr (std::is_same_v\u0026lt;cat, std::random_access_iterator_tag\u0026gt;) { pos += n; } else if constexpr (std::is_same_v\u0026lt;cat, std::bidirectional_access_iterator_tag\u0026gt;) { if (n \u0026gt;= 0) { while (n--) { ++pos; } } else { while (n++) { --pos; } } } else { // input_iterator_tag while (n--) { ++pos; } } } 所以，在某种程度上，我们现在有一个compile-time切换，不同的情况必须在这里得到 但是，由 if constexpr 子句制定。 但是，请注意一个可能很重要的区别：\n重载函数集为您提供最佳匹配语义。\n编译时if 的实现为您提供了第一个匹配语义。\n标签调度的另一个例子是使用编译时 if for get\u0026lt;\u0026gt;() 重载来实现结构绑定接口。\n第三个例子是通用 lambda 中不同类型的处理，如 std::variant\u0026lt;\u0026gt; visitors。\n10.3 带有初始化的编译时if 请注意，compile-time if 也可以使用新形式的 if with 初始化。 例如，如果 有一个 constexpr 函数 foo()，你可以使用：\ntemplate\u0026lt;typename T\u0026gt; void bar(const T x) { if constexpr (auto obj = foo(x); std::is_same_v\u0026lt;decltype(obj), T\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(x) yields same type\\n\u0026#34;; ... } else { std::cout \u0026lt;\u0026lt; \u0026#34;foo(x) yields different type\\n\u0026#34;; ... } } 如果传递的类型有 constexpr 函数 foo()，您可以使用此代码提供不同的 关于 foo(x) 是否产生与 x 相同类型的行为。 要确定 foo(x) 返回的值，您可以编写：\nconstexpr auto c = ...; if constexpr (constexpr auto obj = foo(c); obj == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;foo() == 0\\n\u0026#34;; ... } 请注意，必须将 obj 声明为 constexpr 才能在条件中使用其值。\n10.4 在模板之外使用编译时if if constexpr 可以在任何函数中使用，而不仅仅是在模板中。 我们只需要一个编译时表达式，它会产生可转换为 bool 的东西。 但是，在那种情况下，在 then 和 the else 部分即使被丢弃，所有语句也必须始终有效。\n例如，下面的代码总是会编译失败，因为 undeclared() 的调用必须是有效的，即使 chars 被签名并且 else 部分被丢弃：\n#include \u0026lt;limits\u0026gt; template\u0026lt;typename T\u0026gt; void foo(T t); int main() { if constexpr(std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { foo(42); // OK } else { undeclared(42); // 如果没有声明总是错误（即使被丢弃） } } 此外，以下代码永远无法成功编译，因为其中一个静态断言将始终失败：\nif constexpr(std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { static_assert(std::numeric_limits\u0026lt;char\u0026gt;::is_signed); } else { static_assert(!std::numeric_limits\u0026lt;char\u0026gt;::is_signed); } 如果在泛型代码之外，编译时的（唯一）好处是被丢弃语句中的代码，尽管它必须是有效的，但不会成为结果程序的一部分，这减少了生成的可执行文件。 例如，在这个程序中：\n#include \u0026lt;limits\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;array\u0026gt; int main() { if (!std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { static std::array\u0026lt;std::string,1000\u0026gt; arr1; ... } else { static std::array\u0026lt;std::string,1000\u0026gt; arr2; ... } } arr1或arr2是最终可执行文件的一部分，但不是两者都是。\n10.5 后记 Compile-time if最初是由Walter Bright, Herb Sutter, 和Andrei Alexandrescu在 https://wg21.link/n3329，以及Ville Voutilainen在https://wg21.link/n4461，提出了静态的if语言特性。 一个静态的if语言特性。在https://wg21.link/p0128r0，Ville Voutilainen提出了这个 该特性首次被称为constexpr_if（该特性的名称由此而来）。最终被接受的 措辞是由Jens Maurer https://wg21.link/p0292r2。\n11 折叠表达式 从C++17开始，有一个功能是计算在一个参数包的所有参数上使用二元运算符的结果（有一个可选的初始值）。 例如，下面的函数返回所有传递参数的总和:\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... args) { return (... + args); // ((arg1 + arg2) + arg3) ... } 注意，返回表达式周围的括号是折叠表达式的一部分，不能省略。\n调用函数时要注意\nfoldSum(47, 11, val, -1); 实例化要执行的模板：\nreturn 47 + 11 + val + -1; 调用它:\nfoldSum(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;); 实例化模板：\nreturn std::string(\u0026#34;hello\u0026#34;) + \u0026#34;world\u0026#34; + \u0026#34;!\u0026#34;; 另请注意，折叠表达式参数的顺序可能不同且很重要（并且可能看起来有点违反直觉）：如所写，\n(... + args) 结果是\n((arg1 + arg2) + arg3) ... 这意味着它会反复“添加”东西。 你也可以写\n(args + ...) 它反复“预添加”事物，因此结果表达式为：\n(arg1 + (arg2 + arg3)) ... 11.1 折叠表达式的动因 折叠表达式避免了递归实例化模板以对参数包的所有参数执行操作的需要。 在 C++17 之前，您必须实现：\ntemplate\u0026lt;typename T\u0026gt; auto foldSumRec (T arg) { return arg; } template\u0026lt;typename T1, typename... Ts\u0026gt; auto foldSumRec (T1 arg1, Ts... otherArgs) { return arg1 + foldSumRec(otherArgs...); } 这样的实现不仅写起来麻烦，而且对 C++ 编译器也有压力。 和\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... args) { return (... + args); // arg1 + arg2 + arg3 ... } 程序员和编译器的工作量都大大减少了。\n11.2 使用折叠表达式 给定参数 args 和运算符 op，C++17 允许我们编写\n要么是一元左折叠\n( ... op args ) 扩展为： ((arg1 op arg2) op arg3) op . . .\n或一元右折叠\n( args op ... ) 扩展为：arg1 op (arg2 op . . . (argN-1 op argN))\n括号是必需的。 但是，括号和省略号 (\u0026hellip;) 不必用空格分隔。 左右折叠之间的差异比预期的更重要。 例如，即使使用 operator + 也可能会有不同的效果。 使用左折叠表达式时：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSumL(T... args){ return (... + args); // ((arg1 + arg2) + arg3) ... } 调用\nfoldSumL(1, 2, 3) 计算结果为：\n(1 + 2) + 3) 这也意味着以下示例可以编译：\nstd::cout \u0026lt;\u0026lt; foldSumL(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 请记住，运算符 + 是为标准字符串定义的，前提是至少有一个操作数是 std::string。 因为使用了左折叠，所以调用首先计算:\nstd::string(\u0026#34;hello\u0026#34;) + \u0026#34;world\u0026#34; 它返回一个 std::string，以便添加字符串文字\u0026quot;!\u0026quot; 那么也是有效的。\n但是，诸如:\nstd::cout \u0026lt;\u0026lt; foldSumL(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, std::string(\u0026#34;!\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // ERROR 不会编译，因为它的计算结果为:\n(\u0026#34;hello\u0026#34; + \u0026#34;world\u0026#34;) + std::string(\u0026#34;!\u0026#34;) 并且不允许添加两个字符串文字。\n但是，如果我们将实现更改为：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSumR(T... args){ return (args + ...); // (arg1 + (arg2 + arg3)) ... } 调用：\nfoldSumR(1, 2, 3) 计算结果为：\n(1 + (2 + 3) 这意味着以下示例不再编译：\nstd::cout \u0026lt;\u0026lt; foldSumR(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // ERROR 而下面的调用现在编译：\nstd::cout \u0026lt;\u0026lt; foldSumR(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, std::string(\u0026#34;!\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 因为在几乎所有情况下，从左到右的评估都是意图，通常应该首选带有参数包的左折叠语法（除非这不起作用）：\n(... + args); // 折叠表达式的首选语法 11.2.1 处理空参数包 如果折叠表达式使用了一个空的参数包，那么以下规则适用。\n如果使用了操作符\u0026amp;\u0026amp;，其值为真。\n如果使用了操作符||，则值为假。\n如果使用了逗号运算符，值是void()。\n对于所有其他的操作符来说，调用是不符合格式的。 对于所有其他情况（以及一般情况下），你可以添加一个初始值。给定一个参数包args，一个初始值值和一个运算符op，C++17还允许我们写出以下两种情况\n或者二元左折叠\n( value op ... op args ) 扩展为： (((value op arg1) op arg2) op arg3) op . . .\n或二元右折叠\n( args op ... op value ) 省略号两边的运算符 op 必须相同。 例如，以下定义允许在添加值时传递一个空参数包：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... s){ return (0 + ... + s); // 如果 sizeof...(s)==0 甚至可以工作 } 从概念上讲，我们是否将 0 添加为第一个或最后一个操作数并不重要：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... s){ return (s + ... + 0); // 如果 sizeof...(s)==0 甚至可以工作 } 但是对于一元折叠表达式，不同的评估顺序比想象的更重要，应该首选二元左折叠：\n(val + ... + args); // 二进制折叠表达式的首选语法 此外，第一个操作数可能是特殊的，例如在此示例中：\ntemplate\u0026lt;typename... T\u0026gt; void print (const T\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 在这里，重要的是第一个调用是第一个传递给 print() 的参数的输出，它返回流以执行其他输出调用。 其他实现可能无法编译甚至做一些意想不到的事情。 例如，与\nstd::cout \u0026lt;\u0026lt; (args \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;); 像 print(1) 这样的调用将编译但打印值 1 左移了 \u0026lsquo;\\n\u0026rsquo; 的值，通常为 10，因此结果输出为 1024。 请注意，在此 print() 示例中，没有空格将参数包的所有元素彼此分开。 诸如 print(\u0026ldquo;hello\u0026rdquo;, 42, \u0026ldquo;world\u0026rdquo;) 之类的调用将打印：\nhello42world 要通过空格分隔传递的元素，您需要一个帮助器来确保除第一个参数之外的任何输出都由前导空格扩展。 例如，这可以使用辅助函数模板 spaceBefore() 来完成：\ntemplate\u0026lt;typename T\u0026gt; const T\u0026amp; spaceBefore(const T\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; } template \u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这里，\n(std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) 是一个折叠表达式，展开为：\nstd::cout \u0026lt;\u0026lt; spaceBefore(arg1) \u0026lt;\u0026lt; spaceBefore(arg2) \u0026lt;\u0026lt; ... 因此，对于参数包 args 中的每个元素，它调用一个辅助函数，在返回传递的参数之前打印出一个空格字符，并将其写入 std::cout。 为了确保这不适用于第一个参数，我们添加了一个不使用 spaceBefore() 的附加第一个参数。 请注意，参数包输出的评估要求左侧的所有输出都在为实际元素调用 spaceBefore() 之前完成。 由于定义了运算符 \u0026laquo; 和函数调用的评估顺序，这保证从 C++17 开始就可以工作。 我们还可以使用 lambda 在 print() 中定义 spaceBefore()：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; auto spaceBefore = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 但是，请注意 lambdas 默认按值返回对象，这意味着这将创建传递参数的不必要副本。 避免这种情况的方法是将 lambda 的返回类型显式声明为 const auto\u0026amp; 或 decltype(auto)：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; auto spaceBefore = [](const auto\u0026amp; arg) -\u0026gt; const auto\u0026amp; { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 如果你不能将这一切结合在一个语句中，C++ 就不会是 C++：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; [](const auto\u0026amp; arg) -\u0026gt; decltype(auto) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 然而，实现 print() 的一种更简单的方法是使用 lambda 打印空间和参数并将其传递给一元折叠：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print(First first, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; first; auto outWithSpace = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; arg; }; (... , outWithSpace(args)); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 通过使用使用 auto 声明的附加模板参数，我们可以使 print() 更加灵活，可以将分隔符参数化为字符、字符串或任何其他可打印类型。\n11.2.2 支持的操作符 您可以将所有二元运算符用于折叠表达式，除了 ., -\u0026gt;, and []。\n折叠函数调用 折叠表达式也可以用于逗号运算符，将多个表达式组合成一个语句。 例如，您可以折叠逗号运算符，它可以执行对可变数量的基类的成员函数的函数调用：\ntmpl/foldcalls.cpp #include \u0026lt;iostream\u0026gt; // template fo ame... Bases\u0026gt; class MultiBase : private Bases... { public: void print() { // call print() of all base classes: (... , Bases::print()); } }; struct A { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;A::print()\\n\u0026#34;; } }; struct B { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;B::print()\\n\u0026#34;; } }; struct C { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;C::print()\\n\u0026#34;; } }; int main() { MultiBase\u0026lt;A,B,C\u0026gt; mb; mb.print(); } 这里，\ntemplate\u0026lt;typename... Bases\u0026gt; class MultiBase : private Bases... { ... }; 允许我们使用可变数量的基类来初始化对象：\nMultiBase\u0026lt;A,B,C\u0026gt; mb; 并与\n(... , Bases::print()); 折叠表达式用于扩展它以调用每个基类的打印。 也就是说，带有折叠表达式的语句扩展为以下内容：\n(A::print() , B::print()) , C::print(); 但是，请注意，由于逗号运算符的性质，我们使用左折叠运算符还是右折叠运算符并不重要。 函数总是从左到右调用。 和\n(Bases::print() , ...); 括号仅对调用进行分组，以便第一个 print() 调用与其他两个 print() 调用的结果组合如下：\nA::print() , (B::print() , C::print()); 但是因为逗号运算符的计算顺序总是从左到右，所以第一个调用发生在括号内的两个调用组之前，其中中间调用仍然发生在右调用之前。 尽管如此，由于左折叠表达式与结果求值顺序匹配，因此在将左折叠表达式用于多个函数调用时，再次建议使用左折叠表达式。\n结合哈希函数 使用逗号运算符的一个示例是组合散列值。 这可以按如下方式完成：\ntemplate\u0026lt;typename T\u0026gt; void hashCombine (std::size_t\u0026amp; seed, const T\u0026amp; val) { seed ^= std::hash\u0026lt;T\u0026gt;()(val) + 0x9e3779b9 + (seed\u0026lt;\u0026lt;6) + (seed\u0026gt;\u0026gt;2); } template\u0026lt;typename... Types\u0026gt; std::size_t combinedHashValue (const Types\u0026amp;... args) { std::size_t seed = 0; // initial seed (... , hashCombine(seed,args)); // chain of hashCombine() calls return seed; } 通过调用\nstd::size_t combinedHashValue (\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, 42,); 中间的语句扩展为：\nhashCombine(seed,\u0026#34;Hello\u0026#34;), (hashCombine(seed,\u0026#34;World\u0026#34;), hashCombine(seed,42); 通过这个定义，我们可以轻松地为诸如 Customer 的类型定义一个新的散列函数对象：\nstruct CustomerHash { std::size_t operator() (const Customer\u0026amp; c) const { return combinedHashValue(c.getFirstname(), c.getLastname(), c.getValue()); } }; 我们可以用它来把客户放在一个无序的集合中：\nstd::unordered_set\u0026lt;Customer, CustomerHash\u0026gt; coll; 折叠路径遍历\n您还可以使用折叠表达式通过运算符 -\u0026gt;* 遍历二叉树中的路径：\ntmpl/foldtraverse.cpp\n// 定义二叉树结构和遍历辅助函数: struct Node { int value; Node* left; Node* right; Node(int i=0) : value(i), left(nullptr), right(nullptr) { } ... }; auto left = \u0026amp;Node::left; auto right = \u0026amp;Node::right; // 遍历树，使用折叠表达式: template\u0026lt;typename T, typename... TP\u0026gt; Node* traverse (T np, TP... paths) { return (np -\u0026gt;* ... -\u0026gt;* paths); // np -\u0026gt;* paths1 -\u0026gt;* paths2 ... } int main() { // 初始化二叉树结构: Node* root = new Node{0}; root-\u0026gt;left = new Node{1}; root-\u0026gt;left-\u0026gt;right = new Node{2}; ... // 遍历二叉树: Node* node = traverse(root, left, right); ... } 这里，\n(np -\u0026gt;* ... -\u0026gt;* paths) 使用折叠表达式来遍历来自 np 的路径的可变参数元素。 调用时\ntraverse(root, left, right); fold 表达式的调用扩展为：\nroot -\u0026gt; left -\u0026gt; right 11.2.3 为类型使用折叠表达式 通过使用类型特征，我们还可以使用折叠表达式来处理模板参数包（作为模板参数传递的任意数量的类型）。 例如，您可以使用折叠表达式来确定类型列表是否是齐次的：\ntmpl/ishomogeneous.hpp\n#include \u0026lt;type_traits\u0026gt; // 检查传递的类型是否是同质的: template\u0026lt;typename T1, typename... TN\u0026gt; struct IsHomogeneous { static constexpr bool value = (std::is_same\u0026lt;T1,TN\u0026gt;::value \u0026amp;\u0026amp; ...); }; // 检查传递的参数是否具有相同的类型: template\u0026lt;typename T1, typename... TN\u0026gt; constexpr bool isHomogeneous(T1, TN...) { return (std::is_same\u0026lt;T1,TN\u0026gt;::value \u0026amp;\u0026amp; ...); } 可以使用类型特征 IsHomogeneous\u0026lt;\u0026gt;，例如，如下所示：\nIsHomogeneous\u0026lt;int, Size, decltype(42)\u0026gt;::value 在这种情况下，初始化成员值的折叠表达式扩展为：\nstd::is_same\u0026lt;int,MyType\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,decltype(42)\u0026gt;::value 可以使用函数模板isHomogeneous\u0026lt;\u0026gt;()，例如如下：\nisHomogeneous(43, -1, \u0026#34;hello\u0026#34;, nullptr) 在这种情况下，初始化成员值的折叠表达式扩展为：\nstd::is_same\u0026lt;int,int\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,const char*\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,std::nullptr_t\u0026gt;::value 像往常一样，操作符\u0026amp;\u0026amp;是短 循环的（在第一个假的之后中止评估）。 std::array\u0026lt;\u0026gt;的推导指南在标准库中使用了这个特性。\n11.3 后记 折叠表达式首先由 Andrew Sutton 和 Richard Smith 在 https://wg21.link/n4191 中提出。 最终接受的措辞由 Andrew Sutton 和 Richard Smith 在 https://wg21.link/n4295 中制定。 后来删除了对运算符 *、+、\u0026amp; 和 | 的空序列支持 正如 Thibaut Le Jehan 在 https://wg21.link/p0036 中提出的那样。\n12 将字符串作为模板参数处理 随着时间的推移，不同版本的 C++ 放宽了可用作模板参数的规则，而在 C++17 中，这种情况再次发生。 现在可以使用模板，而无需在当前范围之外定义它们。\n12.1 在模板中使用字符串 非类型模板参数只能是常量整数值（包括枚举）、指向对象/函数/成员的指针、对对象或函数的左值引用或 std::nullptr_t（nullptr 的类型）。 对于指针，链接是必需的，这意味着您不能直接传递字符串文字。 但是，从 C++17 开始，您可以拥有带有内部链接的指针。 例如：\ntemplate\u0026lt;const char* str\u0026gt; class Message { ... }; extern const char hello[] = \u0026#34;Hello World!\u0026#34;; // 外联 const char hello11[] = \u0026#34;Hello World!\u0026#34;; // 内部链接 void foo() { Message\u0026lt;hello\u0026gt; msg; // OK (all C++ versions) Message\u0026lt;hello11\u0026gt; msg11; // OK since C++11 static const char hello17[] = \u0026#34;Hello World!\u0026#34;; // 无联动 Message\u0026lt;hello17\u0026gt; msg17; // OK since C++17 } 也就是说，从 C++17 开始，您仍然需要两行来将字符串文字传递给模板。 但是您可以将第一行放在与类实例化相同的范围内。 这种能力也解决了一个不幸的限制：虽然你可以将指针传递给自 C++11 以来的类模板：\ntemplate\u0026lt;int* p\u0026gt; struct A { }; int num; A\u0026lt;\u0026amp;num\u0026gt; a; // OK since C++11 您不能使用返回地址的编译时函数，现在支持：\nint num; ... constexpr int* pNum() { return \u0026amp;num; } A\u0026lt;pNum()\u0026gt; b; // ERROR before C++17, now OK 12.2 后记 允许对所有非类型模板参数进行持续评估是由 Richard Smith 在 https://wg21.link/n4198 中首次提出的。 最终接受的措辞由 Richard Smith 在 https://wg21.link/n4268 中制定。\n13 占位符类型（例如 auto）作为模板参数 从 C++17 开始，您可以使用占位符类型（auto 和 decltype(auto)）作为非类型模板参数类型。 这意味着，我们可以为不同类型的非类型参数编写通用代码。\n13.1 使用auto作为模板参数 从 C++17 开始，您可以使用 auto 来声明非类型模板参数。 例如：\ntemplate\u0026lt;auto N\u0026gt; class S { ... }; 这允许我们为不同类型实例化非类型模板参数 N：\nS\u0026lt;42\u0026gt; s1; // OK: S 中 N 的类型是 int S\u0026lt;\u0026#39;a\u0026#39;\u0026gt; s2; // OK: S 中 N 的类型是 char 但是，您不能使用此功能来获取通常不允许作为模板参数的类型的实例化：\nS\u0026lt;2.5\u0026gt; s3； // 错误：模板参数类型仍然不能为双精度 我们甚至可以有一个特定的类型作为部分特化：\ntemplate\u0026lt;int N\u0026gt; class S\u0026lt;N\u0026gt; { ... }; 甚至支持类模板参数推导。 例如：\ntemplate\u0026lt;typename T, auto N\u0026gt; class A { public: A(const std::array\u0026lt;T,N\u0026gt;\u0026amp;) { } A(T(\u0026amp;)[N]) { } ... }; 这个类可以推导出T的类型，N的类型，N的值：\nA a2{\u0026#34;hello\u0026#34;}; // OK, 推导出 A\u0026lt;const char, 6\u0026gt; 其中 N 为 int std::array\u0026lt;double,10\u0026gt; sa1; A a1{sa1}; // OK, 推导出 A\u0026lt;double, 10\u0026gt; 其中 N 为 std::size_t 您还可以限定 auto，例如，要求模板参数的类型是指针：\ntemplate\u0026lt;const auto* P\u0026gt; struct S; 通过使用可变参数模板，您可以参数化模板以使用异构常量模板参数列表：\ntemplate\u0026lt;auto... VS\u0026gt; class HeteroValueList { }; 或同质常量模板参数列表：\ntemplate\u0026lt;auto V1, decltype(V1)... VS\u0026gt; class HomoValueList { }; 例如：\nHeteroValueList\u0026lt;1, 2, 3\u0026gt; vals1; // OK HeteroValueList\u0026lt;1, \u0026#39;a\u0026#39;, true\u0026gt; vals2; // OK HomoValueList\u0026lt;1, 2, 3\u0026gt; vals3; // OK HomoValueList\u0026lt;1, \u0026#39;a\u0026#39;, true\u0026gt; vals4; // ERROR 13.1.1 字符和字符串的参数化模板 此功能的一个应用是允许将字符或字符串作为模板参数传递。 例如，我们可以改进使用折叠表达式输出任意数量参数的方式，如下所示：\n#include \u0026lt;iostream\u0026gt; template\u0026lt;auto Sep = \u0026#39; \u0026#39;, typename First, typename... Args\u0026gt; void print(const First\u0026amp; first, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; first; auto outWithSep = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; Sep \u0026lt;\u0026lt; arg; }; (... , outWithSep(args)); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 尽管如此，我们可以打印带有空格的参数作为模板参数的默认参数 Sep:\ntemplate\u0026lt;auto Sep = \u0026#39; \u0026#39;, typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { ... } 也就是说，我们仍然可以调用：\nstd::string s{\u0026#34;world\u0026#34;}; print(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5 hello world 但是通过为分隔符 Sep 参数化 print()，我们现在可以显式传递一个不同的字符作为第一个模板参数：\nprint\u0026lt;\u0026#39;-\u0026#39;\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5-hello-world 由于使用了 auto，我们甚至可以传递一个字符串文字，我们必须将其声明为没有链接的对象，不过：\nstatic const char sep[] = \u0026#34;, \u0026#34;; print\u0026lt;sep\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5, hello, world 或者我们可以传递可用作模板参数的任何其他类型的分隔符（这比这里更有意义）：\nprint\u0026lt;-11\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5-11hello-11world 13.1.2 定义元编程常量 模板参数自动特性的另一个应用是更容易定义编译时常量。 而不是定义：\ntemplate\u0026lt;typename T, T v\u0026gt; struct constant { static constexpr T value = v; }; using i = constant\u0026lt;int, 42\u0026gt;; using c = constant\u0026lt;char, \u0026#39;x\u0026#39;\u0026gt;; using b = constant\u0026lt;bool, true\u0026gt;; 您现在可以执行以下操作：\ntemplate\u0026lt;auto v\u0026gt; struct constant { static constexpr auto value = v; }; using i = constant\u0026lt;42\u0026gt;; using c = constant\u0026lt;\u0026#39;x\u0026#39;\u0026gt;; using b = constant\u0026lt;true\u0026gt;; 而不是：\ntemplate\u0026lt;typename T, T... Elements\u0026gt; struct sequence { }; using indexes = sequence\u0026lt;int, 0, 3, 4\u0026gt;; 你现在可以实现：\ntemplate\u0026lt;auto... Elements\u0026gt; struct sequence { }; using indexes = sequence\u0026lt;0, 3, 4\u0026gt;; 您现在甚至可以定义表示异构值列表的编译时对象（类似于压缩元组）：\nusing tuple = sequence\u0026lt;0, \u0026#39;h\u0026#39;, true\u0026gt;; 13.2 使用 auto 作为可变模板参数 您还可以将 auto 用作带有变量模板的模板参数。 例如，以下可能出现在头文件中的声明定义了一个变量模板 arr 参数化为元素的类型以及元素数量的磁带和值：\ntemplate\u0026lt;typename T, auto N\u0026gt; std::array\u0026lt;T,N\u0026gt; arr; 在每个翻译单元中， arr\u0026lt;int,10\u0026gt; 的所有用法共享同一个全局对象，而 arr\u0026lt;long,10\u0026gt; 和 arr\u0026lt;int,10u\u0026gt; 将是不同的全局对象（同样，它们都可用于所有翻译单元）。\n作为一个完整的示例，请考虑以下头文件：\ntmpl/vartmplauto.hpp\n#ifndef VARTMPLAUTO_HPP #define VARTMPLAUTO_HPP #include \u0026lt;array\u0026gt; template\u0026lt;typename T, auto N\u0026gt; std::array\u0026lt;T,N\u0026gt; arr{}; void printArr(); #endif // VARTMPLAUTO_HPP 在这里，一个翻译单元可以修改这个变量模板的两个不同实例的值\ntmpl/vartmplauto1.cpp #include \u0026#34;vartmplauto.hpp\u0026#34; int main() { arr\u0026lt;int,5\u0026gt;[0] = 17; arr\u0026lt;int,5\u0026gt;[3] = 42; arr\u0026lt;int,5u\u0026gt;[1] = 11; arr\u0026lt;int,5u\u0026gt;[3] = 33; printArr(); } 另一个翻译单元可以打印这两个变量：\ntmpl/vartmplauto2.cpp #include \u0026#34;vartmplauto.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; void printArr() { std::cout \u0026lt;\u0026lt; \u0026#34;arr\u0026lt;int,5\u0026gt;: \u0026#34;; for (const auto\u0026amp; elem : arr\u0026lt;int,5\u0026gt;) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\narr\u0026lt;int,5u\u0026gt;: \u0026#34;; for (const auto\u0026amp; elem : arr\u0026lt;int,5u\u0026gt;) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 该程序的输出将是：\narr\u0026lt;int,5\u0026gt;: 17 0 0 42 0 arr\u0026lt;int,5u\u0026gt;: 0 11 0 33 0 与声明从其初始值推导出的任意类型的常量变量相同的方式：\ntemplate\u0026lt;auto N\u0026gt; constexpr auto val = N; // OK since C++17 并在以后使用它，例如，如下：\nauto v1 = val\u0026lt;5\u0026gt;; // v1 == 5, v1 is int auto v2 = val\u0026lt;true\u0026gt;; // v2 == true, v2 is bool auto v3 = val\u0026lt;\u0026#39;a\u0026#39;\u0026gt;; // v3 == ’a’, v3 is char 为了澄清这里发生了什么：\nstd::is_same_v\u0026lt;decltype(val\u0026lt;5\u0026gt;), int\u0026gt; // yields false std::is_same_v\u0026lt;decltype(val\u0026lt;5\u0026gt;), const int\u0026gt; // yields true std::is_same_v\u0026lt;decltype(v1), int\u0026gt;; // yields true (because auto decays) 13.3 使用decltype(auto)作为模板参数 您还可以使用 C++14 引入的其他占位符类型 decltype(auto)。 但是请注意，这种类型有非常特殊的规则来推断类型。 根据decltype，如果传递的是表达式而不是名称，它会根据表达式的值类别推导类型：\n纯右值的类型（例如，临时值） type\u0026amp; 用于左值（例如，具有名称的对象） xvalue 的类型\u0026amp;\u0026amp;（例如，转换为右值引用的对象，与 std::move() 一样。 这意味着，您可以轻松地将模板参数推导出为引用，这可能会产生令人惊讶的效果。 例如： tmpl/decltypeauto.cpp #include \u0026lt;iostream\u0026gt; template\u0026lt;decltype(auto) N\u0026gt; struct S { void printN() const { std::cout \u0026lt;\u0026lt; \u0026#34;N: \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; static const int c = 42; static int v = 42; int main() { S\u0026lt;c\u0026gt; s1; // 将 N 推导出为 const int 42 S\u0026lt;(c)\u0026gt; s2; // 将 N 推导出为 const int\u0026amp; 引用 c s1.printN(); s2.printN(); S\u0026lt;(v)\u0026gt; s3; // 将 N 推导出为 int\u0026amp; 引用 v v = 77; s3.printN(); // prints: N: 77 } 13.4 后记 非类型模板参数的占位符类型最早由 James Touton 和 Michael 提出 Spertus 作为 https://wg21.link/n4469 的一部分。 最终接受的措辞是由 https://wg21.link/p0127r2 中的 James Touton 和 Michael Spertus。\n14 扩展Using声明 使用声明被扩展为允许以逗号分隔的声明列表，以允许它们在包扩展中使用。 例如，您现在可以编程：\nclass Base { public: void a(); void b(); void c(); }; class Derived : private Base { public: using Base::a, Base::b, Base::c; }; 在 C++17 之前，您需要三种不同的 using 声明。\n14.1 使用可变参数using声明 使用逗号分隔的声明提供了从基类的可变参数列表中一般派生所有同类操作的能力。 这种技术的一个非常酷的应用是创建一组 lambda 重载。 通过定义以下内容：\ntmpl/overload.hpp\n// ”inherit” all function call operators of passed base types: template\u0026lt;typename... Ts\u0026gt; struct overload : Ts... { using Ts::operator()...; }; // base types are deduced from passed arguments: template\u0026lt;typename... Ts\u0026gt; overload(Ts...) -\u0026gt; overload\u0026lt;Ts...\u0026gt;; 您可以重载两个 lambda，如下所示：\nauto twice = overload { [](std::string\u0026amp; s) { s += s; }, [](auto\u0026amp; v) { v *= 2; } }; 这里我们创建了一个类型重载的对象，我们使用推导指南将 lambdas 的类型推导出为模板类型重载的基类，并使用聚合初始化来初始化具有闭包类型的复制构造函数的基类的子对象 ，每个 lambda 都有。 然后 using 声明使两个函数调用运算符都可用于类型重载。 如果没有 using 声明，基类将具有同一成员的两个不同重载 函数 operator()，这是模棱两可的。 因此，您可以传递一个字符串，它调用第一个重载或传递另一个类型，它（假设运算符 *= 有效）使用第二个重载：\nint i = 42; twice(i); std::cout \u0026lt;\u0026lt; \u0026#34;i: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 84 std::string s = \u0026#34;hi\u0026#34;; twice(s); std::cout \u0026lt;\u0026lt; \u0026#34;s: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: hihi 这种技术的一个应用是 std::variant 访问者。\n14.2 使用声明继承构造函数的可变参数 除了对继承构造函数的一些说明外，现在还可以进行以下操作：您可以声明一个可变参数类模板 Multi，该模板派生自其每个传递的类型的基类：\ntmpl/using2.hpp template\u0026lt;typename T\u0026gt; class Base { T value{}; public: Base() { ... } Base(T v) : value{v} { ... } ... }; template\u0026lt;typename... Types\u0026gt; class Multi : private Base\u0026lt;Types\u0026gt;... { public: // derive all constructors: using Base\u0026lt;Types\u0026gt;::Base...; ... }; 使用所有基类构造函数的 using 声明，您可以为每种类型派生一个对应的构造函数.\n现在，当为三种不同类型的值声明 Multi\u0026lt;\u0026gt; 类型时：\nusing MultiISB = Multi\u0026lt;int,std::string,bool\u0026gt;; 您可以使用每个相应的构造函数来声明对象：\nMultiISB m1 = 42; MultiISB m2 = std::string(\u0026#34;hello\u0026#34;); MultiISB m3 = true; 根据新的语言规则，每次初始化都会为匹配的基类调用相应的构造函数，并为所有其他基类调用默认构造函数。 因此:\nMultiISB m2 = std::string(\u0026#34;hello\u0026#34;); 调用 Base 的默认构造函数、Basestd::string 的字符串构造函数和 Base 的默认构造函数。 原则上，您还可以通过指定启用 Multi\u0026lt;\u0026gt; 中的所有赋值运算符：\ntemplate\u0026lt;typename... Types\u0026gt; class Multi : private Base\u0026lt;Types\u0026gt;... { ... // 导出所有赋值运算符: using Base\u0026lt;Types\u0026gt;::operator=...; } 14.3 后记 逗号分隔的 using 声明由 Robert Haberlach 在 https://wg21.link/p0195r0 中提出。 最终接受的措辞由 Robert Haberlach 和 Richard Smith 在 https://wg21.link/p0195r2 中制定。 各种核心问题要求对继承构造函数进行澄清。 最终接受的修复它们的措辞由 Richard Smith 在 https://wg21.link/n4429 中制定。 Vicente J. Botet Escriba 提出了一个建议，即添加一个泛型重载函数来重载 lambda，以及普通函数和成员函数。 然而，这篇论文并没有进入 C++17。 有关详细信息，请参阅 https://wg21.link/p0051r1。\n","date":"2022-03-19T00:01:14Z","permalink":"https://okokfun.github.io/post/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/","title":"第二部分-模板特性"},{"content":" 此文档来自于👉 QtDocumentCN/QtDocumentCN: Qt中文文档翻译 (github.com)\n并由本人补充了一些文档\n","date":"2022-02-23T23:08:02Z","permalink":"https://okokfun.github.io/post/qt%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/","title":"QT文档翻译"},{"content":" 左值有地址和值，可以出现在赋值运算符左边或者右边。\n右值只有值，只能出现在赋值运算符右边。\n右值只有值，没有地址， 右值是一个优化技巧（C++)，因为右值往往是临时变量的。\n左值代表另一个值，右值是值本身。\n","date":"2022-02-20T16:30:47Z","permalink":"https://okokfun.github.io/post/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/","title":"左值和右值"},{"content":" 并发：\n​\t计算机可以同时执行多个任务；单核处理器可以通过分配时间片的方式 单线程 并行：\n针对多核处理器，不用用过分配时间片方式执行任务，少了线程的上下文切换 同步：\n上一个任务执行完毕后才可以进行下一个任务，所以没有并发和并行概念 多线程同步（资源争抢） 异步：\n不同任务不会相互等待，执行任务A时也可以在执行任务B，当任务A没有算出结果时，不会呆呆的等A，而是会去执行B，也有可能也同时执行C，D\u0026hellip;，等未来的某个时间A的结果返回也没问题。\n同步里面没有并行和异步的概念，异步是一种任务执行序列，其应用可以在多线程并行、单线程并发 多线程的应用场景下，如果有资源竞争的情况，适合使用异步（单线程） ","date":"2022-02-20T16:23:26Z","permalink":"https://okokfun.github.io/post/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/","title":"并发_并行_同步_异步"},{"content":" 此篇是VS添加OpenCV库教程\n1. 创建一个新工程 img img 2. 创建完工程后切到属性管理器 img 3. 添加新项目属性列表 然后切到Debug | x64添加新项目属性列表(P) img 然后双击新建的文件。\n4. 添加库头文件路径和库文件路径 添加库头文件路径 img img 添加库文件路径\nimg 5. 填写要使用的库文件名 img 这里使用debug版\nEnd.\n","date":"2022-02-19T23:13:27Z","permalink":"https://okokfun.github.io/post/visual-studio-2022-pre%E6%B7%BB%E5%8A%A0opencv%E5%BA%93/","title":"Visual_Studio_2022_PRE添加OpenCV库"},{"content":" 采用了linux下编译OpenCV, Visual Studio 2022, QT6.2.3都不成功。\n最终采用在win下编译OpenCV + Clion成功，此文记录踩下的坑。\n1. 下载OpenCV源码 源码地址👇\nGithub:\nhttps://github.com/opencv/opencv/archive/4.5.5.zip\n2. 编译OpenCV源码 解压文件夹 OpenCV源码 解压win下exe文件解压后由两个文件夹，source为源码目录 OpenCV源码 build为已经建好的库文件目录\nOpenCV源码 CMake-gui工具构建\nOpenCV源码 source code选择带有源码的目录，binaries选择一个新创建一个mingw-build目录，然后点击Configure，弹出的窗口选择MinGW Makefiles,第一次可能会失败，失败后再点击Configure，还不行的百度吧。 配置成功后点击Generate cd到mingw-bulid目录执行mingw32-make -j8,根据自己机器性能设置线程数，这里设置8个线程，编译时间较久，等待完成。 然后执行mingw32-make install生成库，在mingw-build生成install保存了生成库库文件和头文件。 3. 后续配置 把C:\\\\Users\\\\用户名\\\\Downloads\\\\opencv\\\\mingw-build\\\\install\\\\x64\\\\mingw\\\\bin路径添加到win的环境变量\n👇此为一个CMakeLists.txt\ncmake_minimum_required(VERSION 3.19) project(opencv_learn) set(CMAKE_CXX_STANDARD 20) include_directories($ENV{CMAKE_INCLUDE_PATH}) set(OpenCV_DIR C:\\\\Users\\\\用户名\\\\Downloads\\\\opencv\\\\mingw-build\\\\install\\\\x64\\\\mingw\\\\bin) #需要的openCV库 FIND_PACKAGE(OpenCV REQUIRED) #显示OpenCV的版本号 MESSAGE(\u0026#34;OpenCV version : ${OpenCV_VERSION}\u0026#34;) MESSAGE(\u0026#34;OpenCV include : ${OpenCV_INCLUDE_DIRS}\u0026#34;) MESSAGE(\u0026#34;OpenCV libs11 : ${OpenCV_LIBS}\u0026#34;) MESSAGE(\u0026#34;OpenCV DIR : ${OpenCV_DIR}\u0026#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) MESSAGE(\u0026#34;OpenCV libs : ${OpenCV_LIBS}\u0026#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) set(SOURCE main.cpp) # 将源代码添加到此项目的可执行文件。 add_executable (${PROJECT_NAME} ${SOURCE}) TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS}) ","date":"2022-02-15T19:21:35Z","permalink":"https://okokfun.github.io/post/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8Aclion%E4%BD%BF%E7%94%A8/","title":"cmake编译opencv及Clion使用"},{"content":"此文来自于👉由UP主神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译 【63】【Cherno C++】【中字】C++的计时_哔哩哔哩_bilibili ，并由我整理。\nC++计时器\nstd::chrono::high_resolution_clock高分辨率时钟在不同标准库有所区别，尽量不要使用。\n对时长度量使用 steady_clock 对壁钟时间使用 system_clock 。 基础计时器\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; int main(void) { auto start = std::chrono::steady_clock::now(); std::this_thread::sleep_for(std::chrono::seconds(1)); auto end = std::chrono::steady_clock::now(); std::chrono::duration\u0026lt;float\u0026gt; time = end - start; std::cout \u0026lt;\u0026lt; time.count() \u0026lt;\u0026lt; \u0026#34;s \\n\u0026#34;; std::cin.get(); } 计算打印hello用时\nstruct Timer { std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; start, end; std::chrono::duration\u0026lt;float\u0026gt; duration; Timer() { start = std::chrono::steady_clock::now(); } ~Timer() { end = std::chrono::steady_clock::now(); duration = end - start; float ms = duration.count() * 1000.0f; std::cout \u0026lt;\u0026lt; \u0026#34;Timer took \u0026#34; \u0026lt;\u0026lt; ms \u0026lt;\u0026lt; \u0026#34;ms \\n\u0026#34;; } }; void Function() { Timer timer; // 计算此函数生命周期耗时 for (int i = 0; i \u0026lt; 100; i++) std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\n\u0026#34;; } ","date":"2022-02-10T17:01:05Z","permalink":"https://okokfun.github.io/post/c++%E8%AE%A1%E6%97%B6%E5%99%A8/","title":"C++计时器"},{"content":" 视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【80】【Cherno C++】【中字】如何让C++字符串更快_哔哩哔哩_bilibili 并由我整理。\n此本不会讲解为什么std::string会很慢和其背后的细节，只有些例子。\nstd::string的主要问题之一是 字符串格式化及字符串操作 时需要分配内存\nbad例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; static uint32_t s_AllocCount = 0; // 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符 void* operator new(size_t size) { s_AllocCount++; std::cout \u0026lt;\u0026lt; \u0026#34;allocating: \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; return malloc(size); } void PrintName(const std::string\u0026amp; name) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { std::string name = \u0026#34;Yan Chernikov\u0026#34;; std::string firstname = name.substr(0, 3); std::string lasttname = name.substr(4, 9); PrintName(firstname); std::cout \u0026lt;\u0026lt; s_AllocCount \u0026lt;\u0026lt; \u0026#34; allocations\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cin.get(); } std::string_views, 它本质上是一个指向内存的指针，就是const char指针，指向其他人拥有的现有字符串，再加上一个size；\n比如一个字符串 \u0026ldquo;hello world\u0026rdquo;,有一个指向第一个字符(h)的指针,大小是3 再比如有一个指针指向h的指针，大小是4个字节，把我带到那个lastname的开头，大小是9 这是在创建一个进入现有内存的小视窗，而不是分配一个新的字符串用substr()创建一个新的字符串，\n我想要的是一个窗口的视图，到一个已有自己内存的字符串\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; static uint32_t s_AllocCount = 0; // 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符 void* operator new(size_t size) { s_AllocCount++; std::cout \u0026lt;\u0026lt; \u0026#34;allocating: \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; return malloc(size); } void PrintName(std::string_virew name) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { std::string name = \u0026#34;Yan Chernikov\u0026#34;; std::string_view firstname(name.c_str(), 3); std::string_view firstname(name.c_str() + 4, 9); PrintName(firstname); std::cout \u0026lt;\u0026lt; s_AllocCount \u0026lt;\u0026lt; \u0026#34; allocations\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cin.get(); } ","date":"2022-02-07T17:25:55Z","permalink":"https://okokfun.github.io/post/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/","title":"让字符串及字符操作更加快速"},{"content":" 视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【79】【Cherno C++】【中字】如何让C++运行得更快_哔哩哔哩_bilibili 并由我整理。\n通过编码方式利用多核或多处理器 ,利用这些线程，不只是让你的程序顺序执行一条条指令，而是把一些东西，推迟到不同的线程，甚至不是推迟，二十把东西分派到不同的线程，让计算机更快地处理这些东西。\n每一个资源，每一个纹理模型，他们通常独立于彼此，意味着这是良好的多线程候选场景。\nstatic std::mutex s_MeshesMutex; static void LoadMesh(std::vector\u0026lt;Ref\u0026lt;Mesh\u0026gt;\u0026gt;* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard\u0026lt;std::mutex\u0026gt; lock(s_MeshesMutex); meshes.push_back(mesh); } void EditLayer::LoadMeshes() { std::ifstream stream(\u0026#34;src/Models.txt\u0026#34;); std::string line; std::vector\u0026lt;std::string\u0026gt; meshFilepaths; while (std::getline(stream, line)) meshFilepaths.push_back(line); #define ASYNC 1 #id ASYNC for (const auto\u0026amp; file : meshFilepaths) // std::launch::async告知std库创建一个线程处理。 // 我们需要保留std::async的返回值，如果不保留的话，因为它会被C++标准库摧毁，在摧毁时，标准库需要确保过程实际已被完成，这基本不是并行了，所以需要创建一个std::future的向量。 m_Futures.push_back(std::async(std::launch::async, LoadMesh, \u0026amp;m_Meshes, file)); #else for (const auto\u0026amp; file : meshFilepaths) m_Meshes.push_back(Mesh::Load(file)); } std::vector\u0026lt;std::future\u0026lt;void\u0026gt; m_Meshes; 通过把任务分派的不同的线程，资源加载速度由6.3s,缩减到600ms，速度快了10倍。\nEnd.\n","date":"2022-02-06T21:27:50Z","permalink":"https://okokfun.github.io/post/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/","title":"让C++程序更快的运行"},{"content":" qt添加第三方库方法\n添加库 选择项目名右击\n选择添加库\n选择外部库，下一步 库文件填写库文件路径和库名字，包含路径是库头文件路径，平台选择一个或全部选择，链接选择动态，点击下一步 汇总将会显示添加到.pro文件中，在项目中可以添加头文件使用此库了 ","date":"2022-02-03T14:14:29Z","permalink":"https://okokfun.github.io/post/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/","title":"qt添加第三方库方法"},{"content":" qt ui区别：\n无ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); }; #endif // MAINWINDOW_H 有ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE // 这个MainWindow和下边的MainWindow没有关系，在不同命名空间内。 class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private: Ui::MainWindow *ui;// ui的指针 }; #endif // MAINWINDOW_H 无ui的mainWindow.cpp #include \u0026#34;mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { } MainWindow::~MainWindow() { } 有ui的mainWindow.cpp #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;./ui_mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)// 实例化ui指针 { ui-\u0026gt;setupUi(this);// 设置ui指针 } MainWindow::~MainWindow() { delete ui;// 删除ui指针 } qt的ui文件实质是xml文件：👇\nqt的ui文件 main.cpp #include \u0026#34;mainwindow.h\u0026#34; #include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWindow w;\t// 实例化mainWindow.h中的类MainWindow w.show();\t// 类MainWindow继承于QMainWindow，所以可以调用show() return a.exec(); } ","date":"2022-02-02T20:07:01Z","permalink":"https://okokfun.github.io/post/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","title":"qt中ui简单介绍"},{"content":" 1. Qt概述 1.1 什么是Qt Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。\n1.2 Qt的发展史 1991年 Qt最早由奇趣科技开发\n1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础\n2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言\n2012年 Qt又被Digia公司收购\n2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。\n截至2022年1月31日Qt最新版本为 6.2.3\n1.3 支持的平台 Windows – XP、Vista、Win7、Win8、Win2008、Win10、Win11\nUinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD/OS、和其他很多X11平台\nMacintosh – Mac OS X\nEmbedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE\n1.4 Qt版本 Qt按照不同的版本发行，分为商业版和开源版\n商业版 为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。\n开源的LGPL版本： 为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。\n1.5 Qt的下载与安装 下载地址： 现在QT有两种安装方式\n在线安装：使用qt的安装器\nhttps://download.qt.io/archive/online_installers/4.2/ 不同系统下载对应安装器,然后安装\n离线安装\nqt最后的一个离线安装版本是5.14.2,超过此版本是在线安装版，不提供整合二进制版本。\nLinux Host 下载链接👉Qt 5.14.2 for Linux 64-bit ( 1.2G )\nOS X Host 下载链接👉Qt 5.14.2 for Mac 64-bit ( 2.6G )\nWindows Host 下载链接👉Qt 5.14.2 for Win 64-bit ( 2.3G )\n安装 默认安装（建议组件全部选中）\n· Qt对不同的平台提供了不同版本的安装包，可根据实际情况自行下载安装，本文档使用qt-opensource-windows-x86-5.14.2 版本进行讲解\n1.6 Qt的优点 跨平台，几乎支持所有的平台\n接口简单，容易上手，学习QT框架对学习其他框架有参考意义。\n一定程度上简化了内存回收机制\n有很好的社区氛围，市场份额在缓慢上升。\n可以进行嵌入式开发。\nimg 1.7 成功案例 Linux桌面环境KDE\nWPS Office 办公软件\nSkype 网络电话\nGoogle Earth 谷歌地图\nVLC多媒体播放器\nVirtualBox虚拟机软件\n2 创建Qt项目 2.1 使用向导创建 打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项\nimg 弹出New Project对话框，选择Qt Widgets Application，\nimg 选择【Choose】按钮，弹出如下对话框\nimg 选择项目构建系统\nimg 向导会默认添加一个继承自MainWindow的类，可以在此修改类的名字和基类。默认的基类有QMainWindow、QWidget以及QDialog三个，我们可以选择QWidget（类似于空窗口），这里我们可以先创建一个不带UI的界面，继续下一步\nimg 语言默认，下一步\nimg 设置项目名称和路径，按照向导进行下一步，选择编译套件\nimg 系统会默认给我们添加main.cpp、mywidget.cpp、 mywidget.h和一个CMakeLists.txt文件，点击完成，即可创建出一个Qt桌面程序。\nimg 2.2 手动创建 添加一个空项目\nimg 选择【choose】进行下一步。设置项目名称和路径 —\u0026gt; 选择编译套件 \u0026ndash;\u0026gt; 修改类信息 \u0026ndash;\u0026gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】\nimg 弹出新建文件对话框\nimg 在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。\n2.3 .pro文件 在使用Qt向导生成的应用程序.pro文件格式如下：\nQT += core gui //包含的模块\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4版本 才包含widget模块\nTARGET = QtFirst //应用程序名 生成的.exe程序名称\nTEMPLATE = app //模板类型 应用程序模板\nSOURCES += main.cpp\\ //源文件\n​ mywidget.cpp\nHEADERS += mywidget.h //头文件\n.pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：\n注释\n从“#”开始，到这一行结束。\n模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE = app\napp -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。\nlib - 建立一个库的makefile。\nvcapp - 建立一个应用程序的VisualStudio项目文件。\nvclib - 建立一个库的VisualStudio项目文件。\nsubdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。\n#指定生成的应用程序名：\nTARGET = QtDemo\n#工程中包含的头文件 HEADERS += include/painter.h\n#工程中包含的.ui设计文件 FORMS += forms/painter.ui\n#工程中包含的源文件 SOURCES += sources/main.cpp sources\n#工程中包含的资源文件 RESOURCES += qrc/painter.qrc\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。\n#配置信息 CONFIG用来告诉qmake关于应用程序的配置信息。\nCONFIG += c++11\t//使用c++11的特性\n在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那样替换已经指定的所有选项更安全。\n2.4 一个最简单的Qt应用程序 main入口函数中\n#include \u0026#34;widget.h\u0026#34; #include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Widget w; w.show(); return a.exec(); } 解释：\nQt系统提供的标准类名声明头文件没有.h后缀\nQt一个类对应一个头文件，类名就是头文件名\nQApplication应用程序类\n管理图形用户界面应用程序的控制流和主要设置。\n是Qt的整个后台管理的命脉它包含主事件循环，在其中来自窗口系统和其它资源的所有事件处理和调度。它也处理应用程序的初始化和结束，并且提供对话管理。\n对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。\na.exec()\n程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。\n3 第一个Qt小程序 3.1 按钮的创建 在Qt程序中，最常用的控件之一就是按钮了，首先我们来看下如何创建一个按钮\n#include \u0026lt;QPushButton\u0026gt; QPushButton * btn = new QPushButton; //设置父亲 btn-\u0026gt;setParent(this); //设置文字 btn-\u0026gt;setText(\u0026#34;德玛西亚\u0026#34;); //移动位置 btn-\u0026gt;move(100,100); //第二种创建 QPushButton * btn2 = new QPushButton(\u0026#34;孙悟空\u0026#34;,this); //重新指定窗口大小 this-\u0026gt;resize(600,400); //设置窗口标题 this-\u0026gt;setWindowTitle(\u0026#34;第一个项目\u0026#34;); //限制窗口大小 this-\u0026gt;setFixedSize(600,400); 上面代码中，一个按钮其实就是一个QPushButton类下的对象，如果只是创建出对象，是无法显示到窗口中的，所以我们需要依赖一个父窗口，也就是指定一个父亲利用setParent函数即可，如果想设置按钮上显示的文字利用setText，移动按钮位置用move\n​\t对于窗口而言，我们可以修改左上角窗口的标题setWindowTitle，重新指定窗口大小：resize，或者设置固定的窗口大小setFixedSize；\n3.2 对象模型（对象树） 在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什么的。\nQObject是以对象树的形式组织起来的。\nparent，也就是父对象指针。\n这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。\n当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！） 这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。\nQWidget是能够在屏幕上显示的一切组件的父类。\nQWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。\n当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。\nQt 引入对象树的概念，在一定程度上解决了内存问题。\n当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。\n任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。\n如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：\n{ QWidget window; QPushButton quit(\u0026#34;Quit\u0026#34;, \u0026amp;window); } 作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。\n但是，如果我们使用下面的代码：\n{ QPushButton quit(\u0026#34;Quit\u0026#34;); QWidget window; quit.setParent(\u0026amp;window); } 情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。\n由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。\n3.3 Qt窗口坐标体系 坐标体系：\n以左上角为原点（0,0），X向右增加，Y向下增加。\nimg 对于嵌套窗口，其坐标是相对于父窗口来说的。\n4 信号和槽机制 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。\n4.1 系统自带的信号和槽 下面我们完成一个小功能，上面我们已经学习了按钮的创建，但是还没有体现出按钮的功能，按钮最大的功能也就是点击后触发一些事情，比如我们点击按钮，就把当前的窗口给关闭掉，那么在Qt中，这样的功能如何实现呢？\n​\t其实无法两行代码就可以搞定了，我们看下面的代码\nQPushButton * quitBtn = new QPushButton(\u0026#34;关闭窗口\u0026#34;,this); connect(quitBtn,\u0026amp;QPushButton::clicked,this,\u0026amp;MyWidget::close); 第一行是创建一个关闭按钮，这个之前已经学过，第二行就是核心了，也就是信号槽的使用方式\nconnect()函数最常用的一般形式：\nconnect(sender, signal, receiver, slot); 参数解释：\nsender：发出信号的对象\nsignal：发送对象发出的信号\nreceiver：接收信号的对象\nslot：接收对象在接收到信号之后所需要调用的函数（槽函数）\n那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个\nimg 这里的clicked就是我们要找到，槽函数的寻找方式和信号一样，只不过他的关键字是slot。\n4.2 自定义信号和槽 使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。\n下面我们看看使用 Qt 的信号槽：\n首先定义一个学生类和老师类：\n​\t老师类中声明信号 饿了 hungry\nsignals: void hungury(); //学生类中声明槽 请客 treat public slots: void treat(); //在窗口中声明一个公共方法下课，这个方法的调用会触发老师饿了这个信号，而响应槽函数学生请客 void MyWidget::ClassIsOver() { //发送信号 emit teacher-\u0026gt;hungury(); } //学生响应了槽函数，并且打印信息 //自定义槽函数 实现 void Student::eat() { qDebug() \u0026lt;\u0026lt; \u0026#34;该吃饭了！\u0026#34;; } 在窗口中连接信号槽\nteacher = new Teacher(this); student = new Student(this); connect(teacher,\u0026amp;Teacher::hungury,student,\u0026amp;Student::treat); 并且调用下课函数，测试打印出 “该吃饭了”\n自定义的信号 hungry带参数，需要提供重载的自定义信号和 自定义槽\nvoid hungury(QString name); // 自定义信号 void treat(QString name ); // 自定义槽 但是由于有两个重名的自定义信号和自定义的槽，直接连接会报错，所以需要利用函数指针来指向函数地址， 然后在做连接\nvoid (Teacher:: * teacherSingal)(QString) = \u0026amp;Teacher::hungury; void (Student:: * studentSlot)(QString) = \u0026amp;Student::treat; connect(teacher,teacherSingal,student,studentSlot); 自定义信号槽需要注意的事项：\n发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；\n信号和槽函数返回值是 void\n信号只需要声明，不需要实现\n槽函数需要声明也需要实现\n槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；\n使用 emit 在恰当的位置发送信号；\n使用connect()函数连接信号和槽。\n任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数\n信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。\n如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。\n4.3信号槽的拓展 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。\n多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。\n一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。\n槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。\n信号槽可以断开 利用disconnect关键字是可以断开信号槽的\n使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。\n​\t在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。后面我们会详细介绍什么是Lambda表达式\n4.4 Qt4版本的信号槽写法 connect(zt, SIGNAL(hungry(QString)), st, SLOT(treat(QString)));\n这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。\nQt5在语法上完全兼容Qt4，而反之是不可以的。\n4.5 Lambda表达式 C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成：\n[capture](parameters) mutable -\u0026gt;return-type { statement } [函数对象参数](操作符重载函数参数)mutable -\u0026gt;返回值{函数体}\n① 函数对象参数；\n[]，标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：\n空。没有使用任何函数对象参数。\n=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。\n\u0026amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。\nthis。函数体内可以使用Lambda所在类中的成员变量。\na。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。\n\u0026amp;a。将a按引用进行传递。\na, \u0026amp;b。将a按值进行传递，b按引用进行传递。\n=，\u0026amp;a, \u0026amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。\n\u0026amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。\n② 操作符重载函数参数；\n标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(\u0026amp;a,\u0026amp;b)）两种方式进行传递。\n③ 可修改标示符；\nmutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。\nQPushButton * myBtn = new QPushButton (this); QPushButton * myBtn2 = new QPushButton (this); myBtn2-\u0026gt;move(100,100); int m = 10; connect(myBtn,\u0026amp;QPushButton::clicked,this,[m] ()mutable { m = 20; qDebug() \u0026lt;\u0026lt; m; }); connect(myBtn2,\u0026amp;QPushButton::clicked,this,[=] () { qDebug() \u0026lt;\u0026lt; m; }); qDebug() \u0026lt;\u0026lt; m; ④ 函数返回值；\n-\u0026gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n⑤ 是函数体；\n​\t{}，标识函数的实现，这部分不能省略，但函数体可以为空。\n5 QMainWindow QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。\nimg 5.1 菜单栏 一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。\n创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针 QMenuBar *\tmenuBar() const; 创建菜单，调用QMenu的成员函数addMenu来添加菜单 QAction* addMenu(QMenu * menu) QMenu* addMenu(const QString \u0026amp; title) QMenu* addMenu(const QIcon \u0026amp; icon, const QString \u0026amp; title) 创建菜单项，调用QMenu的成员函数addAction来添加菜单项 QAction* activeAction() const QAction* addAction(const QString \u0026amp; text) QAction* addAction(const QIcon \u0026amp; icon, const QString \u0026amp; text) QAction* addAction(const QString \u0026amp; text, const QObject * receiver, const char * member, const QKeySequence \u0026amp; shortcut = 0) QAction* addAction(const QIcon \u0026amp; icon, const QString \u0026amp; text, const QObject * receiver, const char * member, const QKeySequence \u0026amp; shortcut = 0) Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。\n5.2 工具栏 主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。\n直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。\n插入属于工具条的动作，即在工具条上添加操作。\n通过QToolBar类的addAction函数添加。\n工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：\nQt::LeftToolBarArea\t停靠在左侧\nQt::RightToolBarArea\t停靠在右侧\nQt::TopToolBarArea\t停靠在顶部\nQt::BottomToolBarArea 停靠在底部\nQt::AllToolBarAreas\t以上四个位置都可停靠\n使用setAllowedAreas（）函数指定停靠区域：\nsetAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea） 使用setMoveable（）函数设定工具栏的可移动性：\nsetMoveable（false）//工具条不可移动, 只能停靠在初始化的位置上\n5.3 状态栏 派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：\n状态栏也只能最多有一个\n// 添加小部件\nvoid addWidget(QWidget * widget, int stretch = 0) // 插入小部件\nint\tinsertWidget(int index, QWidget * widget, int stretch = 0) // 删除小部件\nvoid removeWidget(QWidget * widget) 5.4 铆接部件 铆接部件 QDockWidget，也称浮动窗口，可以有多个。\nQDockWidget * dock = new QDockWidget(\u0026#34;标题\u0026#34;,this); addDockWidget(Qt::LeftDockWidgetArea,dock); dock-\u0026gt;setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea | Qt::TopDockWidgetArea); //设置区域范围 5.5 核心部件（中心部件） 除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit做核心部件\nQTextEdit * edit = new QTextEdit(this); setCentralWidget(edit); 5.6 资源文件 Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。\n使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”：\nimg 点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：\nimg 点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件：\nimg 右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：\nimg 接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 /images，文件是 document-open.png，那么就可以使用:/images/document-open.png找到这个文件。\n这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：\nimg 这样，我们可以直接使用:/images/doc-open引用到这个资源，无需关心图片的真实文件名。\n如果我们使用文本编辑器打开 res.qrc 文件，就会看到一下内容：\n\u0026lt;RCC\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images\u0026#34;\u0026gt; \u0026lt;file alias=\u0026#34;doc-open\u0026#34;\u0026gt;document-open.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images/fr\u0026#34; lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;file alias=\u0026#34;doc-open\u0026#34;\u0026gt;document-open-fr.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 我们可以对比一下，看看 Qt Creator 帮我们生成的是怎样的 qrc 文件。当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。\n6 对话框QDialog 6.1 基本概念 对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。\nQt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。\n对话框分为模态对话框和非模态对话框。\n模态对话框，就是会阻塞同一应用程序中其它窗口的输入。 模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。\n与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。 6.2 标准对话框 所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。\nQt 的内置对话框大致分为以下几类：\nQColorDialog：\t选择颜色；\nQFileDialog：\t选择文件或者目录；\nQFontDialog：\t选择字体；\nQInputDialog：\t允许用户输入一个值，并将其值返回；\nQMessageBox：\t模态对话框，用于显示信息、询问问题等；\nQPageSetupDialog：\t为打印机提供纸张相关的选项；\nQPrintDialog：\t打印机配置；\nQPrintPreviewDialog：打印预览；\nQProgressDialog：\t显示操作过程。\n6.3 自定义消息框 Qt 支持模态对话框和非模态对话框。\n模态与非模态的实现：\n使用QDialog::exec()实现应用程序级别的模态对话框\n使用QDialog::open()实现窗口级别的模态对话框\n使用QDialog::show()实现非模态对话框。\n模态对话框 Qt 有两种级别的模态对话框： 应用程序级别的模态 当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。\n窗口级别的模态 该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。\n一般默认是应用程序级别的模态。\n在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。\nQDialog dialog; dialog.setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog.exec(); 非模态对话框 下面我们试着将exec()修改为show()，看看非模态对话框：\nQDialog dialog(this); dialog.setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog.show(); 是不是事与愿违？对话框竟然一闪而过！这是因为，show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：\nQDialog *dialog = new QDialog; dialog-\u0026gt;setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog-\u0026gt;show(); 如果你足够细心，应该发现上面的代码是有问题的：dialog 存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？\n不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：\nQDialog *dialog = new QDialog; dialog-\u0026gt;setAttribute(Qt::WA_DeleteOnClose); dialog-\u0026gt;setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog-\u0026gt;show(); setAttribute()函数设置对话框关闭时，自动销毁对话框。\n6.4 消息对话框 QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：\n显示关于对话框。 void about(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text) 这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。\n显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。 void aboutQt(QWidget * parent, const QString \u0026amp; title = QString()) 显示严重错误对话框。 StandardButton critical(QWidget * parent,\nconst QString \u0026amp; title,\nconst QString \u0026amp; text,\nStandardButtons buttons = Ok,\nStandardButton defaultButton = NoButton)：\n这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。\n与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。 StandardButton information(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton) 与QMessageBox::critical ()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。 StandardButton question(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton) 与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。 StandardButton warning(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton) 我们可以通过下面的代码来演示下如何使用QMessageBox。\nif (QMessageBox::Yes == QMessageBox::question(this, tr(\u0026#34;Question\u0026#34;), tr(\u0026#34;Are you OK?\u0026#34;), QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes)) { QMessageBox::information(this, tr(\u0026#34;Hmmm...\u0026#34;), tr(\u0026#34;I\u0026#39;m glad to hear that!\u0026#34;)); } else { QMessageBox::information(this, tr(\u0026#34;Hmmm...\u0026#34;), tr(\u0026#34;I\u0026#39;m sorry!\u0026#34;)); } 我们使用QMessageBox::question()来询问一个问题。\n这个对话框的父窗口是 this。 QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。\n第二个参数是对话框的标题。\n第三个参数是我们想要显示的内容。\n第四个参数是关联的按键类型，我们可以使用或运算符（|）指定对话框应该出现的按钮。比如我们希望是一个 Yes 和一个 No。\n最后一个参数指定默认选择的按钮。\n这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。\nQMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：\nQMessageBox msgBox; msgBox.setText(tr(\u0026#34;The document has been modified.\u0026#34;)); msgBox.setInformativeText(tr(\u0026#34;Do you want to save your changes?\u0026#34;)); msgBox.setDetailedText(tr(\u0026#34;Differences here...\u0026#34;)); msgBox.setStandardButtons(QMessageBox::Save; QMessageBox::Discard; QMessageBox::Cancel); msgBox.setDefaultButton(QMessageBox::Save); int ret = msgBox.exec(); switch (ret) { case QMessageBox::Save: qDebug() \u0026lt;\u0026lt; \u0026#34;Save document!\u0026#34;; break; case QMessageBox::Discard: qDebug() \u0026lt;\u0026lt; \u0026#34;Discard changes!\u0026#34;; break; case QMessageBox::Cancel: qDebug() \u0026lt;\u0026lt; \u0026#34;Close document!\u0026#34;; break; } msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为“The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。\n6.5 标准文件对话框 QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。\n首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：\nopenAction = new QAction(QIcon(\u0026#34;:/images/file-open\u0026#34;),tr(\u0026#34;\u0026amp;Open...\u0026#34;), this); openAction-\u0026gt;setStatusTip(tr(\u0026#34;Open an existing file\u0026#34;)); saveAction = new QAction(QIcon(\u0026#34;:/images/file-save\u0026#34;), tr(\u0026#34;\u0026amp;Save...\u0026#34;), this); saveAction-\u0026gt;setStatusTip(tr(\u0026#34;Save a new file\u0026#34;)); QMenu *file = menuBar()-\u0026gt;addMenu(tr(\u0026#34;\u0026amp;File\u0026#34;)); file-\u0026gt;addAction(openAction); file-\u0026gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(\u0026#34;\u0026amp;File\u0026#34;)); toolBar-\u0026gt;addAction(openAction); toolBar-\u0026gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); 我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。\n我们使用connect()函数，为这两个QAction对象添加响应的动作：\nconnect(openAction, \u0026amp;QAction::triggered, this, \u0026amp;MainWindow::openFile); connect(saveAction, \u0026amp;QAction::triggered, this, \u0026amp;MainWindow::saveFile); 下面是最主要的openFile()和saveFile()这两个函数的代码：\n//打开文件 void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(\u0026#34;Open File\u0026#34;), \u0026#34;.\u0026#34;, tr(\u0026#34;Text Files(*.txt)\u0026#34;)); if(!path.isEmpty()) { QFile file(path); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { QMessageBox::warning(this, tr(\u0026#34;Read File\u0026#34;), tr(\u0026#34;Cannot open file:\\n%1\u0026#34;).arg(path)); return; } QTextStream in(\u0026amp;file); textEdit-\u0026gt;setText(in.readAll()); file.close(); } else { QMessageBox::warning(this, tr(\u0026#34;Path\u0026#34;), tr(\u0026#34;You did not select any file.\u0026#34;)); } } //保存文件 void MainWindow::saveFile() { QString path = QFileDialog::getSaveFileName(this, tr(\u0026#34;Open File\u0026#34;), \u0026#34;.\u0026#34;, tr(\u0026#34;Text Files(*.txt)\u0026#34;)); if(!path.isEmpty()) { QFile file(path); if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) { QMessageBox::warning(this, tr(\u0026#34;Write File\u0026#34;), tr(\u0026#34;Cannot open file:\\n%1\u0026#34;).arg(path)); return; } QTextStream out(\u0026amp;file); out \u0026lt;\u0026lt; textEdit-\u0026gt;toPlainText(); file.close(); } else { QMessageBox::warning(this, tr(\u0026#34;Path\u0026#34;), tr(\u0026#34;You did not select any file.\u0026#34;)); } } 在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：\nQString getOpenFileName(QWidget * parent = 0, const QString \u0026amp; caption = QString(), const QString \u0026amp; dir = QString(), const QString \u0026amp; filter = QString(), QString * selectedFilter = 0, Options options = 0) 不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：\nparent：父窗口。 Qt 的标准对话框提供静态函数，用于返回一个模态对话框；\ncaption：对话框标题；\ndir：对话框打开时的默认目录\n“.” 代表程序运行目录\n“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\\”等；\nfilter：过滤器。\n我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。过滤器就是用于过滤特定的后缀名。如果我们使用“Image Files(.jpg .png)”，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如“JPEG Files(.jpg);;PNG Files(.png)”；\nselectedFilter：默认选择的过滤器；\noptions：对话框的一些参数设定\n比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。\nQFileDialog::getOpenFileName()返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。\n在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。\n7 布局管理器 所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。\nQt 提供了两种组件定位机制：绝对定位和布局定位。\n绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。 这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。\n布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。 布局定位完美的解决了使用绝对定位的缺陷。\nQt 提供的布局中以下三种是我们最常用的：\nQHBoxLayout：按照水平方向从左到右布局；\nQVBoxLayout：按照竖直方向从上到下布局；\nQGridLayout：在一个网格中进行布局，类似于 HTML 的 table；\n7.1 系统提供的布局控件 img 这4个为系统给我们提供的布局的控件，但是使用起来不是非常的灵活，这里就不详细介绍了。\n7.2 利用widget做布局 第二种布局方式是利用控件里的widget来做布局，在Containers中\nimg 在widget中的控件可以进行水平、垂直、栅格布局等操作，比较灵活。\n再布局的同时我们需要灵活运用弹簧的特性让我们的布局更加的美观，下面是一个登陆窗口，利用widget可以搭建出如下登陆界面：\nimg 8 常用控件 Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用一些控件，所有控件的使用方法我们都可以通过帮助文档获取。\n8.1 QLabel控件使用 QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。\n显示文字 （普通文本、html） 通过QLabel类的setText函数设置显示的内容:\nvoid\tsetText(const QString \u0026amp;); 可以显示普通文本字符串 QLable *label = new QLable; label-\u0026gt;setText(“Hello, World!”); 可以显示HTML格式的字符串 比如显示一个链接:\nQLabel * label = new QLabel(this); label -\u0026gt;setText(\u0026#34;Hello, World\u0026#34;); label -\u0026gt;setText(\u0026#34;\u0026lt;h1\u0026gt;\u0026lt;a href=\\\u0026#34;https://www.baidu.com\\\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34;); label -\u0026gt;setOpenExternalLinks(true); 其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，如果参数指定为true则会自动打开。\n显示图片 可以使用QLabel的成员函数setPixmap设置图片\nvoid setPixmap(const QPixmap \u0026amp;) 首先定义QPixmap对象\nQPixmap pixmap; 然后加载图片\npixmap.load(\u0026#34;:/Image/boat.jpg\u0026#34;); 最后将图片设置到QLabel中\nQLabel *label = new QLabel; label.setPixmap(pixmap); 显示动画 可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件\nvoid\tsetMovie(QMovie * movie) 首先定义QMovied对象，并初始化:\nQMovie *movie = new QMovie(\u0026#34;:/Mario.gif\u0026#34;); 播放加载的动画：\nmovie-\u0026gt;start(); 将动画设置到QLabel中：\nQLabel *label = new QLabel； label-\u0026gt;setMovie(movie); 8.2 QLineEdit Qt提供的单行文本编辑框。\n设置/获取内容 获取编辑框内容使用text（），函数声明如下： QString\ttext() const 设置编辑框内容 void\tsetText(const QString \u0026amp;); 设置显示模式 使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:\nvoid\tsetEchoMode(EchoMode mode) EchoMode是一个枚举类型,一共定义了四种显示模式:\nQLineEdit::Normal\t模式显示方式，按照输入的内容显示。\nQLineEdit::NoEcho\t不显示任何内容，此模式下无法看到用户的输入。\nQLineEdit::Password\t密码模式，输入的字符会根据平台转换为特殊字符。\nQLineEdit::PasswordEchoOnEdit\t编辑时显示字符否则显示字符作为密码。\n另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么，就可以使用QLineEdit给我们提供的setTextMargins函数：\nvoid setTextMargins(int left, int top, int right, int bottom) 用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数。\n8.3 其他控件 Qt中控件的使用方法可参考Qt提供的帮助文档。\n8.4 自定义控件 在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。\n在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？\n例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，\n// smallwidget.h class SmallWidget : public QWidget { Q_OBJECT public: explicit SmallWidget(QWidget *parent = 0); signals: public slots: private: QSpinBox* spin; QSlider* slider; }; // smallwidget.cpp SmallWidget::SmallWidget(QWidget *parent) : QWidget(parent) { spin = new QSpinBox(this); slider = new QSlider(Qt::Horizontal, this); // 创建布局对象 QHBoxLayout* layout = new QHBoxLayout; // 将控件添加到布局中 layout-\u0026gt;addWidget(spin); layout-\u0026gt;addWidget(slider); // 将布局设置到窗口中 setLayout(layout); // 添加消息响应 connect(spin, static_cast\u0026lt;void (QSpinBox::*)(int)\u0026gt;(\u0026amp;QSpinBox::valueChanged), slider, \u0026amp;QSlider::setValue); connect(slider, \u0026amp;QSlider::valueChanged, spin, \u0026amp;QSpinBox::setValue); } img 那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：\n打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键\nimg 弹出提升窗口部件对话框\nimg 添加要提升的类的名字,然后选择 添加\nimg 添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.\n我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget\nimg 再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.\n9 Qt消息机制和事件 9.1 事件 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。\n在前面我们也曾经简单提到，Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler），关于这一点，会在后边详细说明。\n在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如\nkeyPressEvent()\nkeyReleaseEvent()\nmouseDoubleClickEvent()\nmouseMoveEvent()\nmousePressEvent()\nmouseReleaseEvent() 等。\n这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：\nclass EventLabel : public QLabel { protected: void mouseMoveEvent(QMouseEvent *event); void mousePressEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); }; void EventLabel::mouseMoveEvent(QMouseEvent *event) { this-\u0026gt;setText(QString(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Move: (%1, %2) \u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;).arg(QString::number(event-\u0026gt;x()), QString::number(event-\u0026gt;y()))); } void EventLabel::mousePressEvent(QMouseEvent *event) { this-\u0026gt;setText(QString(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Press:(%1, %2) \u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;).arg(QString::number(event-\u0026gt;x()), QString::number(event-\u0026gt;y()))); } void EventLabel::mouseReleaseEvent(QMouseEvent *event) { QString msg; msg.sprintf(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Release: (%d, %d)\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;, event-\u0026gt;x(), event-\u0026gt;y()); this-\u0026gt;setText(msg); } int main(int argc, char *argv[]) { QApplication a(argc, argv); EventLabel *label = new EventLabel; label-\u0026gt;setWindowTitle(\u0026#34;MouseEvent Demo\u0026#34;); label-\u0026gt;resize(300, 200); label-\u0026gt;show(); return a.exec(); } EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。\nQString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。\nQString(\u0026#34;[%1, %2]\u0026#34;).arg(x).arg(y); 语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。\n在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。 运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。\nimg 为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？\n这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。\n知道了这一点，我们就可以在main()函数中添加如下代码：\nlabel-\u0026gt;setMouseTracking(true); 在运行程序就没有这个问题了。\n9.2 event（） 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。\n如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。\n如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。\n我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：\nbool CustomTextEdit::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return false; } CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。\n通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：\n//!!! Qt5 bool QObject::event(QEvent *e) { switch (e-\u0026gt;type()) { case QEvent::Timer: timerEvent((QTimerEvent*)e); break; case QEvent::ChildAdded: case QEvent::ChildPolished: case QEvent::ChildRemoved: childEvent((QChildEvent*)e); break; // ... default: if (e-\u0026gt;type() \u0026gt;= QEvent::User) { customEvent(e); break; } return false; } return true; } 这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-\u0026gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：\nswitch (event-\u0026gt;type()) { case QEvent::MouseMove: mouseMoveEvent((QMouseEvent*)event); break; // ... } 事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。\n由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。\n9.3 事件过滤器 有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。\n通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。\nQObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：\nvirtual bool QObject::eventFilter ( QObject * watched, QEvent * event ); 这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。\n我们来看一段简单的代码：\nclass MainWindow : public QMainWindow { public: MainWindow(); protected: bool eventFilter(QObject *obj, QEvent *event); private: QTextEdit *textEdit; }; MainWindow::MainWindow() { textEdit = new QTextEdit; setCentralWidget(textEdit); textEdit-\u0026gt;installEventFilter(this); } bool MainWindow::eventFilter(QObject *obj, QEvent *event) { if (obj == textEdit) { if (event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); qDebug() \u0026lt;\u0026lt; \u0026#34;Ate key press\u0026#34; \u0026lt;\u0026lt; keyEvent-\u0026gt;key(); return true; } else { return false; } } else { // pass the event on to the parent class return QMainWindow::eventFilter(obj, event); } } MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。\neventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：\nvoid QObject::installEventFilter ( QObject * filterObj ) 这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。\n我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。 还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } 现在，我们可以给出一个使用事件过滤器的版本：\nbool FilterObject::eventFilter(QObject *object, QEvent *event) { if (object == target \u0026amp;\u0026amp; event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } else { return false; } } return false; } 事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。\n注意，\n事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。\n9.4 总结 Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。\nQt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：\nl 所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); 在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：\nswitch(message) { case WM_PAINT: // ... break; case WM_DESTROY: // ... break; ... } 每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制： mouseEvent()\nkeyPressEvent()\n…\nQt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是event()。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。\nevent()函数会有两个问题：\nevent()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？\nevent()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？\n这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意QObject类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。\n事件过滤器可以解决刚刚我们提出的event()函数的两点不足：\n首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；\n其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。\n事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，最大的控制权实际上是重写QCoreApplication::notify()。这个函数的声明是：\nvirtual bool QCoreApplication::notify ( QObject * receiver, QEvent * event ); 该函数会将event发送给receiver，也就是调用receiver-\u0026gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。\n现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：\n重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。\n重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。\n在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。\n在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。\n重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。\n10 绘图和绘图设备 10.1 QPainter Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。\nQPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。\n下图给出了这三个类之间的层次结构:\nimg 上面的示意图告诉我们，Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。\n下面我们通过一个实例来介绍QPainter的使用：\nclass PaintedWidget : public QWidget { Q_OBJECT public: PaintedWidget(QWidget *parent = 0); protected: void paintEvent(QPaintEvent *); } 注意我们重写了QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：\nPaintedWidget::PaintedWidget(QWidget *parent) : QWidget(parent) { resize(800, 600); setWindowTitle(tr(\u0026#34;Paint Demo\u0026#34;)); } void PaintedWidget::paintEvent(QPaintEvent *) { QPainter painter(this); painter.drawLine(80, 100, 650, 500); painter.setPen(Qt::red); painter.drawRect(10, 10, 100, 400); painter.setPen(QPen(Qt::green, 5)); painter.setBrush(Qt::blue); painter.drawEllipse(50, 150, 400, 200); } 在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，这一点可能会引发某些细节问题：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。\nQPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。\nQPainter有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的drawLine()，drawRect()以及drawEllipse()等。当绘制轮廓线时，使用QPainter的pen()属性。比如，我们调用了painter.setPen(Qt::red)将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。\n10.2 绘图设备 绘图设备是指继承QPainterDevice的子类。Qt提供了很多这样的类，例如QPixmap、QBitmap、QImage和 QPicture。其中，\nQPixmap专门为图像在屏幕上的显示做了优化\nQBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。\nQImage专门为图像的像素级访问做了优化。\nQPicture则可以记录和重现QPainter的各条命令。\n10.2.1 QPixmap、QBitmap、QImage QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。\nQBitmap继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像。QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，QBitmap实际上是只有黑白两色的图像数据。\n由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。\n下面我们来看同一个图像文件在QPixmap和QBitmap下的不同表现：\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPixmap pixmap(\u0026#34;:/Image/butterfly.png\u0026#34;); QPixmap pixmap1(\u0026#34;:/Image/butterfly1.png\u0026#34;); QBitmap bitmap(\u0026#34;:/Image/butterfly.png\u0026#34;); QBitmap bitmap1(\u0026#34;:/Image/butterfly1.png\u0026#34;); QPainter painter(this); painter.drawPixmap(0, 0, pixmap); painter.drawPixmap(200, 0, pixmap1); painter.drawPixmap(0, 130, bitmap); painter.drawPixmap(200, 130, bitmap1); } img 这里我们给出了两张png图片。butterfly1.png是没有透明色的纯白背景，而butterfly.png是具有透明色的背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。\nQPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。\n我们声明了一个QImage对象，大小是300 x 300，颜色模式是RGB32，即使用32位数值表示一个颜色的RGB值，也就是说每种颜色使用8位。然后我们对每个像素进行颜色赋值，从而构成了这个图像。我们可以把QImage想象成一个RGB颜色的二维数组，记录了每一像素的颜色。\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPainter painter(this); QImage image(300, 300, QImage::Format_RGB32); QRgb value; //将图片背景填充为白色 image.fill(Qt::white); //改变指定区域的像素点的值 for(int i=50; i\u0026lt;100; ++i) { for(int j=50; j\u0026lt;100; ++j) { value = qRgb(255, 0, 0); // 红色 image.setPixel(i, j, value); } } //将图片绘制到窗口中 painter.drawImage(QPoint(0, 0), image); } img QImage与QPixmap的区别:\nQPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I/O、图片访问和像素修改而设计的\nQPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果\n由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。\nQImage可通过setPixpel()和pixel()等方法直接存取指定的像素。\nQImage与QPixmap之间的转换:\nQImage转QPixmap 使用QPixmap的静态成员函数: fromImage()\nQPixmap\tfromImage(const QImage \u0026amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor) QPixmap转QImage: 使用QPixmap类的成员函数: toImage()\nQImage toImage() cons 10.2.2 QPicture 最后一个需要说明的是QPicture。这是一个可以记录和重现QPainter命令的绘图设备。 QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。这种格式有时候会是“元文件(meta- files)”。Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。\nQPicture是平台无关的，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。\n如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPicture pic; QPainter painter; //将图像绘制到QPicture中,并保存到文件 painter.begin(\u0026amp;pic); painter.drawEllipse(20, 20, 100, 50); painter.fillRect(20, 100, 100, 100, Qt::red); painter.end(); pic.save(\u0026#34;D:\\\\drawing.pic\u0026#34;); //将保存的绘图动作重新绘制到设备上 pic.load(\u0026#34;D:\\\\drawing.pic\u0026#34;); painter.begin(this); painter.drawPicture(200, 200, pic); painter.end(); } 11 文件系统 文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图（Qt5）：\nimg QIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；\nQFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。\nQFlie：访问本地文件或者嵌入资源；\nQTemporaryFile：创建和访问本地文件系统的临时文件；\nQBuffer：读写QbyteArray, 内存文件；\nQProcess：运行外部程序，处理进程间通讯；\nQAbstractSocket：所有套接字类的父类；\nQTcpSocket：TCP协议网络数据传输；\nQUdpSocket：传输 UDP 报文；\nQSslSocket：使用 SSL/TLS 传输数据；\n文件系统分类:\n顺序访问设备: 是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节，这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。\n随机访问设备: 可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFile和QBuffer是随机访问设备，\n11.1 基本文件操作 文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。在所有的 I/O 设备中，文件 I/O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。QFile提供了从文件中读取和写入数据的能力。\n我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改。QFile需要使用 / 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:/windows 这样的路径在 Windows 平台下同样是可以的。\nQFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。\n下面我们使用一段代码来看看QFile的有关操作：\nint main(int argc, char *argv[]) { QApplication app(argc, argv); QFile file(\u0026#34;in.txt\u0026#34;); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { qDebug() \u0026lt;\u0026lt; \u0026#34;Open file failed.\u0026#34;; return -1; } else { while (!file.atEnd()) { qDebug() \u0026lt;\u0026lt; file.readLine(); } } QFileInfo info(file); qDebug() \u0026lt;\u0026lt; info.isDir(); qDebug() \u0026lt;\u0026lt; info.isExecutable(); qDebug() \u0026lt;\u0026lt; info.baseName(); qDebug() \u0026lt;\u0026lt; info.completeBaseName(); qDebug() \u0026lt;\u0026lt; info.suffix(); qDebug() \u0026lt;\u0026lt; info.completeSuffix(); return app.exec(); } 我们首先使用QFile创建了一个文件对象。 这个文件名字是 in.txt。如果你不知道应该把它放在哪里，可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。\n使用open()函数打开这个文件，打开形式是只读方式，文本格式。 这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。\n可以使用QFileInfo获取有关该文件的信息。 QFileInfo有很多类型的函数，我们只举出一些例子。比如：\nisDir()检查该文件是否是目录； isExecutable()\t检查该文件是否是可执行文件等。 baseName()\t可以直接获得文件名； completeBaseName() 获取完整的文件名 suffix()\t则直接获取文件后缀名。 completeSuffix() 获取完整的文件后缀 我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：\nQFileInfo fi(\u0026#34;/tmp/archive.tar.gz\u0026#34;); QString base = fi.baseName(); // base = \u0026#34;archive\u0026#34; QString base = fi.completeBaseName(); // base = \u0026#34;archive.tar\u0026#34; QString ext = fi.suffix(); // ext = \u0026#34;gz\u0026#34; QString ext = fi.completeSuffix(); // ext = \u0026#34;tar.gz\u0026#34; 11.2 二进制文件读写 QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。\nQDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。\n结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::WriteOnly); QDataStream out(\u0026amp;file); out \u0026lt;\u0026lt; QString(\u0026#34;the answer is\u0026#34;); out \u0026lt;\u0026lt; (qint32)42; 在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向\u0026laquo;运算符。后面的代码就很简单了：将“the answer is”和数字 42 输出到数据流。由于我们的 out 对象建立在file之上，因此相当于将问题和答案写入file。\n需要指出一点：最好使用 Qt 整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。\n如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：\nfile.close(); // 如果不想关闭文件，可以使用 file.flush();\n接下来我们将存储到文件中的答案取出来\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadOnly); QDataStream in(\u0026amp;file); QString str; qint32 a; in \u0026gt;\u0026gt; str \u0026gt;\u0026gt; a; 唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。\n那么，既然QIODevice提供了read()、readLine()之类的函数，为什么还要有QDataStream呢？QDataStream同QIODevice有什么区别？区别在于，QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。我们通过下面一段代码看看什么是流的形式：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadWrite); QDataStream stream(\u0026amp;file); QString str = \u0026#34;the answer is 42\u0026#34;; stream \u0026lt;\u0026lt; str; 11.3 文本文件读写 上一节我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用QTextStream类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。\nQTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。QTextStream使用 16 位的QChar作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。\nQTextStream同QDataStream的使用基本一致，例如下面的代码将把“The answer is 42”写入到 file.txt 文件中：\nQFile data(\u0026#34;file.txt\u0026#34;); if (data.open(QFile::WriteOnly | QIODevice::Truncate)) { QTextStream out(\u0026amp;data); out \u0026lt;\u0026lt; \u0026#34;The answer is \u0026#34; \u0026lt;\u0026lt; 42; } 这里，我们在open()函数中增加了QIODevice::Truncate打开方式。我们可以从下表中看到这些打开方式的区别：\n枚举值 描述 QIODevice::NotOpen 未打开 QIODevice::ReadOnly 以只读方式打开 QIODevice::WriteOnly 以只写方式打开 QIODevice::ReadWrite 以读写方式打开 QIODevice::Append 以追加的方式打开,新增加的内容将被追加到文件末尾 QIODevice::Truncate 以重写的方式打开，在写入新的数据时会将原有数据全部清除，游标设置在文件开头。 QIODevice::Text 在读取时，将行结束符转换成 \\n；在写入时，将行结束符转换成本地格式，例如 Win32 平台上是 \\r\\n QIODevice::Unbuffered 忽略缓存 我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。\n虽然QTextStream的写入内容与QDataStream一致，但是读取时却会有些困难：\nQFile data(\u0026#34;file.txt\u0026#34;); if (data.open(QFile::ReadOnly)) { QTextStream in(\u0026amp;data); QString str; int ans = 0; in \u0026gt;\u0026gt; str \u0026gt;\u0026gt; ans; } 在使用QDataStream的时候，这样的代码很方便，但是使用了QTextStream时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为当使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而以文本形式写入数据，是没有数据之间的分隔的。因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如使用：\nQTextStream::readLine()\t读取一行\nQTextStream::readAll()读取所有文本\n这种函数之后再对获得的QString对象进行处理。\n默认情况下，QTextStream的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用：\nstream.setCodec(\u0026quot;UTF-8\u0026quot;);\n这样的函数进行设置。\n","date":"2022-02-01T17:40:05Z","permalink":"https://okokfun.github.io/post/qt%E6%A6%82%E8%BF%B0/","title":"Qt概述"},{"content":" 最终目的：高内聚，低耦合 1. 开放封闭原则 (OCP,Open For Extension, Closed For Modification Principle) 😎类的改动是通过增加代码进行的，而不是修改源代码。\n2. 单一职责原则 (SRP,Single Responsibility Principle) 类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。\n3. 依赖倒置原则 (DIP,Dependence Inversion Principle) 😎依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。\n4. 接口隔离原则 (ISP,Interface Segegation Principle) 不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。\n5. 里氏替换原则 (LSP, Liskov Substitution Principle) 任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。\n6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle) 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。 如果使用对象组合，就降低了这种依赖关系。\n7. 迪米特法则(LOD,Law of Demeter) 😎一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。(黑盒原理)\n","date":"2022-01-31T18:56:20Z","permalink":"https://okokfun.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/","title":"设计模式准则"},{"content":" 三段式for循环 // 变量声明在for里面，自增在里面 for (int i = 0; i \u0026lt; 10; ++i) { //... } // 变量声明在外面,自增在里面 int i = 0; for (; i \u0026lt; 10; ) { //... ++i; } bool condition = true; int i = 0; for (; condition; ) { //... ++i; if (!(i \u0026lt; 5)) condition = false; } 无限循环版本\nbool condition = true; int i = 0; for (; ; ) { //... ++i; if (!(i \u0026lt; 5)) condition = false; } 范围for循环 std::vector\u0026lt;int\u0026gt; l{1,2,3,4,5,6,7,8,9}; for (const auto\u0026amp; it : l) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; std::endl; } while 普通条件while,循环五次退出while\nint i = 0; do { ++i; } while ( i \u0026lt; 5 ) 循环一次推出while\ndo { } while ( false ) ","date":"2022-01-30T21:10:45Z","permalink":"https://okokfun.github.io/post/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/","title":"for和while的几种用法"},{"content":" 用微软家的Visual Studio 2022创建项目，为了避免文件混乱，可以采用下边的设置方法,当然也可以使用默认的设置。\n点击解决方案下的项目名，例如sendbox👇\n在弹出的对话窗中点击属性👇\n然后在弹出的对话框中👇，选择所有配置,平台选择所有平台\n上图有一个错误去掉bin前面的\\.\n配置属性-\u0026gt;常规，\n在常规属性-\u0026gt;输出目录填写$(SolutionDir)bin\\$(Platform)\\$(Configuration)\\\n在常规属性-\u0026gt;中间目录填写$(SolutionDir)bin\\intermediates\\$(Platform)\\$(Configuration)\\\n其中Platform根据平台选择不同而不同，比如选择x64,那么Platform就是Win64，还有Win32\n设置完点击项目，选择清理，然后重新生成\n编译器语言标准\n配置属性-\u0026gt;常规-\u0026gt;C++语言标准\nC++标准 配置属性-\u0026gt;常规-\u0026gt;C语言标准\nC标准 End.\n","date":"2022-01-30T19:14:50Z","permalink":"https://okokfun.github.io/post/visual-studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","title":"Visual-Studio-2022基本设置"},{"content":" 此文来源于👉 【77】【Cherno C++】【中字】单一变量存放多种类型的数据_哔哩哔哩_bilibili\n用来处理可能存在也可能不存在的数据，也可能是与我们预期不同的类型。当然也不一定，而是让我们存储不同的数据。 std::variant的作用是让我们不用担心处理的确切类型，指定一个std::variant的东西，然后列出他可能的数据类型。 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;variant\u0026gt; int main(void) { std::variant\u0026lt;std::string, int\u0026gt; data; data = \u0026#34;Cherno\u0026#34;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; data = 2;// data被重新赋值为2 std::cout \u0026lt;\u0026lt; std::get\u0026lt;int\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; data.index();// index函数会告诉你类型的索引， 此时会打印1。 if (auto value = std::get_if\u0026lt;int\u0026gt;(\u0026amp;data)) { std::string\u0026amp;v = *value; } else { //... } /* std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 错误的访问方法，在data被置为int后依旧按照std::string访问，会抛出一个 bad variant access异常 */ std::cin.get(); return 0; } ","date":"2022-01-29T22:33:43Z","permalink":"https://okokfun.github.io/post/c-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/","title":"C++单一变量存放多种类型的数据"},{"content":" 此文来源于👉 【76】【Cherno C++】【中字】如何处理OPTIONAL数据_哔哩哔哩_bilibili\n有一个返回的函数， 比如正在读取一个文件，但是如果这个文件不能被读取，会发生什么，虽然读取失败，但我们仍然需要从函数中返回一些东西，返回一个空字符串没有意义。\n如果文件是空的，应有办法看到数据存在或不存在，而std::optional可以给我们一些帮助，此特性在C++17加入。\n非std::optional版本\n例子：\n#incldue \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; std::string ReadStringFromFile(const std::\u0026amp;string filepath, bool\u0026amp; outSuccess) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); outSuccess = true; return result; } outSuccess = false; return {}; } int main(void) { bool fileOpenedSuccessfully; std::string data = ReadStringFromFile(\u0026#34;data.txt\u0026#34;, fileOpenedSuccessfully); if (fileOpenedSuccessfully) { //... } else { //... } return 0; } std::optional版本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;optional\u0026gt; std::optional\u0026lt;std::string\u0026gt; ReadStringFromFile(const std::string\u0026amp; filepath) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); return result; } return {}; } int main(void) { std::optional\u0026lt;std::string\u0026gt; data = ReadStringFromFile(\u0026#34;data.txt\u0026#34;); std::string value = data.value_or(\u0026#34;Not present\u0026#34;);// 如果数据确实存在std::optional中，它将返回给我们那个字符串。如果不存在，它将返回我们传入的任何值，比如\u0026#34; Not present \u0026#34; std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (data.has_value()) { std::cout \u0026lt;\u0026lt; \u0026#34;File read successfully!\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;File could not be opend!\\n\u0026#34;; } std::cin.get(); return 0; } ","date":"2022-01-29T21:22:58Z","permalink":"https://okokfun.github.io/post/c-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","title":"C++数据存在或不存在处理方法"},{"content":" 来自于👉 tuple - C++ Reference (cplusplus.com) 并整理\n一个元组std::tuple是一个能够容纳 元素集合 的对象。每个元素都可以是 不同的类型。\nstd::make_pair()可以构建一个配对对象，其第一个元素设置为x，第二个元素设置为y，并返回。\nstd::tie可以绑定std::tuple\u0026lt;T,T,T,...\u0026gt;的实例，并分别给这些元素起别名\nstd::tuple 所在头文件 \u0026lt;tuple\u0026gt;\n例子：\n// tuple example #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;tuple\u0026gt; // std::tuple, std::get, std::tie, std::ignore int main () { std::tuple\u0026lt;int,char\u0026gt; foo (10,\u0026#39;x\u0026#39;); auto bar = std::make_tuple (\u0026#34;test\u0026#34;, 3.1, 14, \u0026#39;y\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#34;bar has \u0026#34;\u0026lt;\u0026lt;std::tuple_size\u0026lt;decltype(bar)\u0026gt;::value \u0026lt;\u0026lt; elements\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::tuple_element\u0026lt;0,decltype(bar)\u0026gt;::type first = std::get\u0026lt;0\u0026gt;(bar); std::cout \u0026lt;\u0026lt; \u0026#34;bar contains: \u0026#34; \u0026lt;\u0026lt; first \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::get\u0026lt;2\u0026gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get\u0026lt;3\u0026gt;(bar); std::get\u0026lt;0\u0026gt;(foo) = std::get\u0026lt;2\u0026gt;(bar); std::get\u0026lt;1\u0026gt;(foo) = mychar; std::cout \u0026lt;\u0026lt; \u0026#34;foo contains: \u0026#34;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 答案：\nbar has 4 elements bar contains: test foo contains: 100 y std::tie 所在头文件 \u0026lt;tuple\u0026gt;\n例子：\n// packing/unpacking tuples #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;tuple\u0026gt; // std::tuple, std::make_tuple, std::tie int main () { std::tuple\u0026lt;int,float,char\u0026gt; mytuple; mytuple = std::make_tuple (10, 2.6, \u0026#39;a\u0026#39;); // packing values into tuple int myint; char mychar; std::tie (myint, std::ignore, mychar) = mytuple; // unpacking tuple into variables std::cout \u0026lt;\u0026lt; \u0026#34;myint contains: \u0026#34; \u0026lt;\u0026lt; myint \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;mychar contains: \u0026#34; \u0026lt;\u0026lt; mychar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\nmyint contains: 10 mychar contains: a std::pair 所在头文件 \u0026lt;utility\u0026gt;\n例子：\n// make_pair example #include \u0026lt;utility\u0026gt; // std::pair #include \u0026lt;iostream\u0026gt; // std::cout int main () { std::pair \u0026lt;int,int\u0026gt; foo; std::pair \u0026lt;int,int\u0026gt; bar; foo = std::make_pair (10,20); bar = std::make_pair (10.5,\u0026#39;A\u0026#39;); // ok: implicit conversion from pair\u0026lt;double,char\u0026gt; std::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; foo.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; bar.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout\u0026lt;\u0026lt; \u0026#34;foo contains: \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\nfoo: 10, 20 bar: 10, 65 foo contains: 50 and x End.\n","date":"2022-01-29T17:41:10Z","permalink":"https://okokfun.github.io/post/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/","title":"C++元组与对组"},{"content":" 此文总结与👉 神经元猫的个人空间_哔哩哔哩_bilibili 的 【75】【Cherno C++】【中字】C++的结构化绑定_哔哩哔哩_bilibili\n在如何处理C++多返回值得问题，返回的数据可以是结构体实例，也可以是元组或对组 从C++17引入的结构化绑定可以改善此项，\n以前忒麻烦的版本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, int\u0026gt; CreatPerson() { return { \u0026#34;Cherno\u0026#34;, 24 }; } int main(void) { auto person = CreatPerson(); std::string\u0026amp;name = std::get\u0026lt;0\u0026gt;(person); int age = std::get\u0026lt;1\u0026gt;(person); std::string name; int age; std::tie(name, age) = CreatPerson(); return 0; } 从C++17引入了结构化绑定解决了上诉问题\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, int\u0026gt; CreatPerson() { return { \u0026#34;Cherno\u0026#34;, 24 }; } int main(void) { auto[name, age] = CreatPerson(); // 简单，美观 std::cout \u0026lt;\u0026lt; name; return 0; } ","date":"2022-01-29T17:40:33Z","permalink":"https://okokfun.github.io/post/c-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/","title":"C++结构化绑定"},{"content":" 此文来自于👉 C++ / typeinfo — DevDocs ，并整理\n判断数据是哪种数据类型 头文件\u0026lt;typeinfo\u0026gt;\nstd::type_info::name() 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; struct Base { virtual ~Base() = default; }; struct Derived : Base {}; int main() { Base b1; Derived d1; const Base *pb = \u0026amp;b1; std::cout \u0026lt;\u0026lt; typeid(*pb).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pb = \u0026amp;d1; std::cout \u0026lt;\u0026lt; typeid(*pb).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int i; int * pi; std::cout \u0026lt;\u0026lt; \u0026#34;int is: \u0026#34; \u0026lt;\u0026lt; typeid(int).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; i is: \u0026#34; \u0026lt;\u0026lt; typeid(i).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; pi is: \u0026#34; \u0026lt;\u0026lt; typeid(pi).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;*pi is: \u0026#34; \u0026lt;\u0026lt; typeid(*pi).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\n4Base 7Derived int is: int i is: int pi is: int * *pi is: int 判断数据是否是对应的数据类型 头文件\u0026lt;type_traits\u0026gt;\n主要类型类别 Primary type categories is_array\nIs array (class template )\n// is_array example #include \u0026lt;iostream\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;type_traits\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_array:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int[3]: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;int[3]\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;array\u0026lt;int,3\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::array\u0026lt;int,3\u0026gt;\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;string[3]: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::string[3]\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } 结果：\nis_array: int: false int[3]: true array\u0026lt;int,3\u0026gt;: false string: false string[3]: true is_class\nIs non-union class (class template )\nis_enum\nIs enum (class template )\nis_floating_point\nIs floating point (class template )\nis_function\nIs function (class template )\nis_integral\nIs integral (class template )\nis_lvalue_reference\nIs lvalue reference (class template )\nis_member_function_pointer\nIs member function pointer (class template )\nis_member_object_pointer\nIs member object pointer (class template )\nis_pointer\nIs pointer (class template )\nis_rvalue_reference\nIs rvalue reference (class template )\nis_union\nIs union (class template )\nis_void\nIs void (class template )\n复合类型范畴 Composite type categories is_arithmetic\nIs arithmetic type (class template )\n// is_arithmetic example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;complex\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_arithmetic:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;char\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;float: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;float\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;float*: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;float*\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;complex\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output: bash is_arithmetic: char: true float: true float*: false complex\u0026lt;double\u0026gt;: false is_compound\nIs compound type (class template )\nis_fundamental\nIs fundamental type (class template )\nis_member_pointer\nIs member pointer type (class template )\nis_object\nIs object type (class template )\nis_reference\nIs reference type (class template )\nis_scalar\nIs scalar type (class template )\n类型属性 Type properties is_abstract\nIs abstract class (class template )\n// is_abstract example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A { }; struct B { virtual void fn() = 0; // pure virtual function }; struct C : B { }; struct D : C { virtual void fn(){} }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_abstract:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;C: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;C\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;D: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;D\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } 结果：\nis_abstract: A: false B: true C: true D: false is_const\nIs const-qualified (class template )\nis_empty\nIs empty class (class template )\nis_literal_type\nIs literal type (class template )\nis_pod\nIs POD type (class template )\nis_polymorphic\nIs polymorphic (class template )\nis_signed\nIs signed type (class template )\nis_standard_layout\nIs standard-layout type (class template )\nis_trivial\nIs trivial type (class template )\nis_trivially_copyable\nIs trivially copyable (class template )\nis_unsigned\nIs unsigned type (class template )\nis_volatile\nIs volatile-qualified (class template )\n类型特征 Type features has_virtual_destructor\nHas virtual destructor (class template )\n// has_virtual_destructor example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A { }; struct B { virtual ~B(){} }; struct C : B { }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;has_virtual_destructor:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;C: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;C\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output:\nhas_virtual_destructor: int: false A: false B: true C: true is_assignable\nIs assignable (class template )\nis_constructible\nIs constructible (class template )\nis_copy_assignable\nIs copy assignable (class template )\nis_copy_constructible\nIs copy constructible (class template )\nis_destructible\nIs destructible (class template )\nis_default_constructible\nIs default constructible (class template )\nis_move_assignable\nIs move assignable (class template )\nis_move_constructible\nIs move constructible (class template )\nis_trivially_assignable\nIs trivially assignable (class template )\nis_trivially_constructible\nIs trivially constructible (class template )\nis_trivially_copy_assignable\nIs trivially copy assignable (class template )\nis_trivially_copy_constructible\nIs trivially copy constructible (class template )\nis_trivially_destructible\nIs trivially destructible (class template )\nis_trivially_default_constructible\nIs trivially default constructible (class template )\nis_trivially_move_assignable\nIs trivially move assignable (class template )\nis_trivially_move_constructible\nIs trivially move constructible (class template )\nis_nothrow_assignable\nIs assignable throwing no exceptions (class template )\nis_nothrow_constructible\nIs constructible throwing no exceptions (class template )\nis_nothrow_copy_assignable\nIs copy assignable throwing no exceptions (class template )\nis_nothrow_copy_constructible\nIs copy constructible throwing no exceptions (class template )\nis_nothrow_destructible\nIs nothrow destructible (class template )\nis_nothrow_default_constructible\nIs default constructible throwing no exceptions (class template )\nis_nothrow_move_assignable\nIs move assignable throwing no exception (class template )\nis_nothrow_move_constructible\nIs move constructible throwing no exceptions (class template )\n类型关系 Type relationships is_base_of\nIs base class of (class template )\n// is_base_of example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A {}; struct B : A {}; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_base_of:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int, int: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;int,int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, A: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, B: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, const B: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,const B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A\u0026amp;, B\u0026amp;: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A\u0026amp;,B\u0026amp;\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B, A: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;B,A\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output:\nis_base_of: int, int: false A, A: true A, B: true A, const B: true A\u0026amp;, B\u0026amp;: false B, A: false is_convertible\nIs convertible (class template )\nis_same\nIs same type (class template )\n","date":"2022-01-28T17:51:19Z","permalink":"https://okokfun.github.io/post/%E8%8E%B7%E5%8F%96c-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/","title":"获取C++中数据的类型的方法"},{"content":" 文章emoji支持\nnpm install hexo-filter-github-emojis --save 文章加密访问插件\nnpm install hexo-blog-encrypt --save 使用方法\n将 \u0026ldquo;password\u0026rdquo; 字段添加到您文章信息头就像这样. --- title: Hello World tags: - 作为日记加密 date: 2016-03-30 21:12:21 password: mikemessi abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. --- password下边几行可加可不加。\n编辑_config.yml 加入下列几行\n# Security encrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码, 请点击本文字. tags: - {name: tagName, password: 密码A} - {name: tagName, password: 密码B} wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 卸载对应的插件把install换为un\n","date":"2022-01-28T14:14:03Z","permalink":"https://okokfun.github.io/post/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/","title":"本人使用的hexo插件列表"},{"content":" 1. Variadic Templates 数量不定的模板参数\n...代表任意个数据\nvoid print(){} template \u0026lt;typename T, typename... Types\u0026gt; void print(const T\u0026amp; firstArg, const Types\u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } void print(const T\u0026amp; firstArg, const Types\u0026amp;...args){}中...代表任意个数据，Types任意类型的数据,\n表示接受任意个任意类型的数据\n例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;bitset\u0026gt; void print() {} template \u0026lt;typename T, typename... Types\u0026gt; void print(const T \u0026amp;firstArg, const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, \u0026#34;hello\u0026#34;, std::bitset\u0026lt;16\u0026gt;(377), 42); return 0; } 结果：\n7.5 hello 0000000101111001 42 解释：print(7.5, \u0026quot;hello\u0026quot;, bitset\u0026lt;16\u0026gt;(377), 42);,\n分解方式为递归\n第一次7.5和它右边会分成两部分放进void print(const T\u0026amp; firstArg, const Types\u0026amp;...args), 第一部分的是firstArg，第二部分会放进...args;\n第二次hello和它右边两部分放进firstArg,...args;\n特化比泛化权值更高，也即是更加倾向于选择特化\ntemplate \u0026lt;typename T, typename... Types\u0026gt; void print(const T \u0026amp;firstArg, const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } template \u0026lt;typename... Types\u0026gt; void print(const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, \u0026#34;hello\u0026#34;, std::bitset\u0026lt;16\u0026gt;(377), 42); // 倾向于选择print(const T \u0026amp;firstArg, const Types \u0026amp;...args) return 0; } 2. nullptr and nullptr_t and auto nullptr C++改为使用nullptr为空指针，代替NULL或0;\n例子：\nvoid f(int); void f(void*); f(0);\t// 选择f(int) f(NULL);\t// 选择f(int) f(nullptr);\t// 选择f(void*) auto 数据类型自动推导\nauto是根据=右边的数据推导出变量的数据类型\nauto i = 42; // i has type int double f(); auto d = f(); // d has type double auto 用在容器中比较多\nlist\u0026lt;string\u0026gt; c; ... list\u0026lt;string\u0026gt;::iterator ite; ite = find(c.begin, c.end(), target); 变为\nlist\u0026lt;string\u0026gt; c; ... auto ite = find(c.begin, c.end(), target); 用在for循环中\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; int main(void) { std::vector\u0026lt;int\u0026gt; vec{1,2,3,4,5,6,7,8,9}; for (const auto\u0026amp;it : vec) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 3. Uniform Initialization 统一的初始化{}\nint i; // 初始值未定 int j{}; // 初始值为0 int* p;\t// 初始值未定义 int* q{};\t// 初始值为 nullptr int x1(5.3); // OK, 但初始值被设为5； int x2 = 5.3;// OK, 但初始值被设为5； int x3{5.0};\t// ERROR int values[] {1,2,3}; std::vector\u0026lt;int\u0026gt; v{1,2,3,4,5,6,7,8,9}; std::vector\u0026lt;string\u0026gt; cities{ \u0026#34;Beijing\u0026#34;, \u0026#34;xinjiang\u0026#34;, \u0026#34;henan\u0026#34;, \u0026#34;London\u0026#34; }; complex\u0026lt;double\u0026gt; c{4.0, 3.0}; 都是用{}来初始化；\n4. bind()和function\u0026lt;\u0026gt; 函数模板 bind 生成 f 的转发调用包装器。调用此包装器等价于以一些绑定到 args 的参数调用 f 。\n类模板 std::function 是通用多态函数封装器。 std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。\nstd::function\u0026lt;\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;iostream\u0026gt; struct Foo { Foo(int num) : num_(num) {} void print_add(int i) const { std::cout \u0026lt;\u0026lt; num_+i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int num_; }; void print_num(int i) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } struct PrintNum { void operator()(int i) const { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { // 存储自由函数 std::function\u0026lt;void(int)\u0026gt; f_display = print_num; f_display(-9); // 存储 lambda std::function\u0026lt;void()\u0026gt; f_display_42 = []() { print_num(42); }; f_display_42(); // 存储到 std::bind 调用的结果 std::function\u0026lt;void()\u0026gt; f_display_31337 = std::bind(print_num, 31337); f_display_31337(); // 存储到成员函数的调用 std::function\u0026lt;void(const Foo\u0026amp;, int)\u0026gt; f_add_display = \u0026amp;Foo::print_add; const Foo foo(314159); f_add_display(foo, 1); f_add_display(314159, 1); // 存储到数据成员访问器的调用 std::function\u0026lt;int(Foo const\u0026amp;)\u0026gt; f_num = \u0026amp;Foo::num_; std::cout \u0026lt;\u0026lt; \u0026#34;num_: \u0026#34; \u0026lt;\u0026lt; f_num(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 存储到成员函数及对象的调用 using std::placeholders::_1; std::function\u0026lt;void(int)\u0026gt; f_add_display2 = std::bind( \u0026amp;Foo::print_add, foo, _1 ); f_add_display2(2); // 存储到成员函数和对象指针的调用 std::function\u0026lt;void(int)\u0026gt; f_add_display3 = std::bind( \u0026amp;Foo::print_add, \u0026amp;foo, _1 ); f_add_display3(3); // 存储到函数对象的调用 std::function\u0026lt;void(int)\u0026gt; f_display_obj = PrintNum(); f_display_obj(18); } std::bind() #include \u0026lt;random\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;functional\u0026gt; void f(int n1, int n2, int n3, const int\u0026amp; n4, int n5) { std::cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n4 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n5 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int g(int n1) { return n1; } struct Foo { void print_sum(int n1, int n2) { std::cout \u0026lt;\u0026lt; n1+n2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int data = 10; }; int main() { using namespace std::placeholders; // 对于 _1, _2, _3... // 演示参数重排序和按引用传递 int n = 7; // （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数） auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n); n = 10; f1(1, 2, 1001); // 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001 // 进行到 f(2, 42, 1, n, 7) 的调用 // 嵌套 bind 子表达式共享占位符 auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5); f2(10, 11, 12); // 进行到 f(12, g(12), 12, 4, 5); 的调用 // 常见使用情况：以分布绑定 RNG std::default_random_engine e; std::uniform_int_distribution\u0026lt;\u0026gt; d(0, 10); std::function\u0026lt;int()\u0026gt; rnd = std::bind(d, e); // e 的一个副本存储于 rnd for(int n=0; n\u0026lt;10; ++n) std::cout \u0026lt;\u0026lt; rnd() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 绑定指向成员函数指针 Foo foo; auto f3 = std::bind(\u0026amp;Foo::print_sum, \u0026amp;foo, 95, _1); f3(5); // 绑定指向数据成员指针 auto f4 = std::bind(\u0026amp;Foo::data, _1); std::cout \u0026lt;\u0026lt; f4(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 智能指针亦能用于调用被引用对象的成员 std::cout \u0026lt;\u0026lt; f4(std::make_shared\u0026lt;Foo\u0026gt;(foo)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; f4(std::make_unique\u0026lt;Foo\u0026gt;(foo)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2022-01-24T17:02:47Z","permalink":"https://okokfun.github.io/post/c-%E6%96%B0%E7%89%B9%E6%80%A7/","title":"C++新特性"},{"content":" QT组件库第1-31 QT组件库第32-56 Layouts 布局组件库 1号 Vertical Layout 垂直布局\n2号 Horizontal Layout 水平布局\n3号 Grid Layout 网格布局\n4号 Form Layout 表单布局\nSpacers 空间间隔组(弹簧) 5号 Horizontal Spacer 水平间隔\n6号 Vertical Spacer 垂直间隔\nButtons 按钮 7号 Push Button 8号 Tool Button 9号 Radio Button 10号 Check Box 11号 Command Link Button 12号 Dialog Button Box Item Views (Model-Based) 清单视图组 13号 List View 清单视图\n14号 Tree View 树视图\n15号 Table View 表视图\n16号 Column View 列视图\n17号 Undo View 撤消视图\nItem Widgets (Item-Based) 清单控件组 18号 List Widget 清单控件\n19号 Tree Widget 树控件\n20号 Table Widget 表控件\nContainers 容器组 21号 Group Box 组框\n22号 Scroll Area 滚动区域\n23号 Tool Box 工具箱\n24号 Tab Widget 标签小部件\n25号 Stacked Widget 堆叠部件\n26号 Frame 帧\n27号 Widget 小部件\n28号 MDI Area MDI区域\n29号 Dock Widget 停靠窗口不见\n30号 QAx Widget 封装Flash的AciveX控件\nInput Widgets 输入部件组 31号 Combo Box 组合框\n32号 Font Combo Box 字体组合框\n33号 Line Edit 行编辑\n34号 Text Edit 文本编辑\n35号 Plain Text Edit 纯文本编辑\n36号 Spin Box 数字显示框\n37号 Double Spin Box 双数字显示框\n38号 Time Edit 时间编辑\n39号 Date Edit 日期编辑\n40号 Date/Time Edit 日期或时间编辑\n41号 Dial 拨号\n42号 Horizontal Scroll Bar 水平滚动条\n43号 Vertical Scroll Bar 垂直滚动条\n44号 Horizontal Slider 水平滑块\n45号 Vertical Slider 垂直滑块\n46号 Key Sequence Edit 按键序列编辑\nDisplay Widgets 显示控件组 47号 Label 标签\n48号 text Browser 文本浏览器\n49号 Graphics View 图形视图\n50号 Calendar Widget 日历\n51号 Lcd Number 液晶数字\n52号 Progress Bar 进度条\n53号 Horizontal Line 水平线\n54号 Vertical Line 垂直线\n55号 OpenGL Widget 开放式图形工具\n56号 QQuick Widget 嵌入QML工具\n","date":"2022-01-24T14:33:42Z","permalink":"https://okokfun.github.io/post/qt-ui%E7%BB%84%E4%BB%B6%E5%BA%93/","title":"QT_UI组件库"},{"content":" 安乐死是对人最后的仁慈，让人可以有尊严和最后无痛苦的离开这个世界，当然前提是有病痛且无法医治，比如物理学家霍金的 肌萎缩性脊髓侧索硬化症（ALS）。\n","date":"2022-01-24T13:37:38Z","image":"https://okokfun.github.io/Me_logo.png","permalink":"https://okokfun.github.io/post/me/","title":"Me"},{"content":" 本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用\n1 模板 1.1 模板的概念 模板就是建立通用的模具，大大提高复用性\n模板的特点：\n模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板\nC++提供两种模板机制:函数模板和类模板\n1.2.1 函数模板语法 函数模板作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\ntemplate\u0026lt;typename T\u0026gt; 函数声明或定义 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n//交换整型函数 void swapInt(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b; b = temp; } //交换浮点型函数 void swapDouble(double\u0026amp; a, double\u0026amp; b) { double temp = a; a = b; b = temp; } //利用模板提供通用的交换函数 template\u0026lt;typename T\u0026gt; void mySwap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap\u0026lt;int\u0026gt;(a, b); cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项 注意事项：\n自动类型推导，必须推导出一致的数据类型T,才可以使用\n模板必须要确定出T的数据类型，才可以使用\n示例：\n//利用模板提供通用的交换函数 template\u0026lt;class T\u0026gt; void mySwap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } // 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型 } // 2、模板必须要确定出T的数据类型，才可以使用 template\u0026lt;class T\u0026gt; void func() { cout \u0026lt;\u0026lt; \u0026#34;func 调用\u0026#34; \u0026lt;\u0026lt; endl; } void test02() { //func(); //错误，模板不能独立使用，必须确定出T的类型 func\u0026lt;int\u0026gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例 案例描述：\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例：\n//交换的函数模板 template\u0026lt;typename T\u0026gt; void mySwap(T \u0026amp;a, T\u0026amp;b) { T temp = a; a = b; b = temp; } template\u0026lt;class T\u0026gt; // 也可以替换成typename //利用选择排序，进行对数组从大到小的排序 void mySort(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { int max = i; //最大数的下标 for (int j = i + 1; j \u0026lt; len; j++) { if (arr[max] \u0026lt; arr[j]) { max = j; } } if (max != i) //如果最大数的下标不是i，交换两者 { mySwap(arr[max], arr[i]); } } } template\u0026lt;typename T\u0026gt; void printArray(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { //测试char数组 char charArr[] = \u0026#34;bdcfeagh\u0026#34;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num); } void test02() { //测试int数组 int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：模板可以提高代码复用，需要熟练掌握\n1.2.4 普通函数与函数模板的区别 普通函数与函数模板区别：\n普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例：\n//普通函数 int myAdd01(int a, int b) { return a + b; } //函数模板 template\u0026lt;class T\u0026gt; T myAdd02(T a, T b) { return a + b; } //使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; cout \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl; //正确，将char类型的\u0026#39;c\u0026#39;隐式转换为int类型 \u0026#39;c\u0026#39; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02\u0026lt;int\u0026gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n1.2.5 普通函数与函数模板的调用规则 调用规则如下：\n如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例：\n//普通函数与函数模板调用规则 void myPrint(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用的普通函数\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void myPrint(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;调用的模板\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void myPrint(T a, T b, T c) { cout \u0026lt;\u0026lt; \u0026#34;调用重载的模板\u0026#34; \u0026lt;\u0026lt; endl; } void test01() { //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint\u0026lt;\u0026gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = \u0026#39;a\u0026#39;; char c2 = \u0026#39;b\u0026#39;; myPrint(c1, c2); //调用函数模板 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n1.2.6 模板的局限性 局限性：\n模板的通用性并不是万能的 例如：\ntemplate\u0026lt;class T\u0026gt; void f(T a, T b) { a = b; } 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\ntemplate\u0026lt;class T\u0026gt; void f(T a, T b) { if(a \u0026gt; b) { ... } } 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n示例：\n#include\u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; //普通函数模板 template\u0026lt;class T\u0026gt; bool myCompare(T\u0026amp; a, T\u0026amp; b) { if (a == b) { return true; } else { return false; } } //具体化，显示具体化的原型和定意思以template\u0026lt;\u0026gt;开头，并通过名称来指出类型 //具体化优先于常规模板 template\u0026lt;\u0026gt; bool myCompare(Person \u0026amp;p1, Person \u0026amp;p2) { if ( p1.m_Name == p2.m_Name \u0026amp;\u0026amp; p1.m_Age == p2.m_Age) { return true; } else { return false; } } void test01() { int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;a == b \u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a != b \u0026#34; \u0026lt;\u0026lt; endl; } } void test02() { Person p1(\u0026#34;Tom\u0026#34;, 10); Person p2(\u0026#34;Tom\u0026#34;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;p1 == p2 \u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;p1 != p2 \u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板 1.3.1 类模板语法 类模板作用：\n建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法：\ntemplate\u0026lt;typename T\u0026gt; 类 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; void test01() { // 指定NameType 为string类型，AgeType 为 int类型 Person\u0026lt;string, int\u0026gt;P1(\u0026#34;孙悟空\u0026#34;, 999); P1.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n1.3.2 类模板与函数模板区别 类模板与函数模板区别主要有两点：\n类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; //1、类模板没有自动类型推导的使用方式 void test01() { // Person p(\u0026#34;孙悟空\u0026#34;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson(); } //2、类模板在模板参数列表中可以有默认参数 void test02() { Person \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson(); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机 类模板中成员函数和普通类中成员函数创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例：\nclass Person1 { public: void showPerson1() { cout \u0026lt;\u0026lt; \u0026#34;Person1 show\u0026#34; \u0026lt;\u0026lt; endl; } }; class Person2 { public: void showPerson2() { cout \u0026lt;\u0026lt; \u0026#34;Person2 show\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;class T\u0026gt; class MyClass { public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() { obj.showPerson1(); } void fun2() { obj.showPerson2(); } }; void test01() { MyClass\u0026lt;Person1\u0026gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n1.3.4 类模板对象做函数参数 学习目标：\n类模板实例化出的对象，向函数传参的方式 一共有三种传入方式：\n指定传入的类型 \u0026mdash; 直接显示对象的数据类型 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型模板化进行传递 示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; //1、指定传入的类型 void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p) { p.showPerson(); } void test01() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template \u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p) { p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } void test03() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承 当类模板碰到继承时，需要注意一下几点：\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例：\ntemplate\u0026lt;class T\u0026gt; class Base { T m; }; //class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 class Son :public Base\u0026lt;int\u0026gt; //必须指定一个类型 { }; void test01() { Son c; } //类模板继承类模板 ,可以用T2指定父类中的T类型 template\u0026lt;class T1, class T2\u0026gt; class Son2 :public Base\u0026lt;T2\u0026gt; { public: Son2() { cout \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } }; void test02() { Son2\u0026lt;int, char\u0026gt; child1; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果父类是类模板，子类需要指定出父类中T的数据类型\n1.3.6 类模板成员函数类外实现 学习目标：能够掌握类模板中的成员函数类外实现\n示例：\n#include \u0026lt;string\u0026gt; //类模板中成员函数类外实现 template\u0026lt;class T1, class T2\u0026gt; class Person { public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //成员函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } void test01() { Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 20); p.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板中成员函数类外实现时，需要加上模板参数列表\n1.3.7 类模板分文件编写 学习目标：\n掌握类模板成员函数分文件编写产生的问题以及解决方式 问题：\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决：\n解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例：\nperson.hpp中代码：\n#pragma once #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;string\u0026gt; template\u0026lt;class T1, class T2\u0026gt; class Person { public: Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //成员函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } 类模板分文件编写.cpp中代码\n#include\u0026lt;iostream\u0026gt; using namespace std; //#include \u0026#34;person.h\u0026#34; #include \u0026#34;person.cpp\u0026#34; //解决方式1，包含cpp源文件 //解决方式2，将声明和实现写到一起，文件后缀名改为.hpp #include \u0026#34;person.hpp\u0026#34; void test01() { Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 10); p.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\n1.3.8 类模板与友元 学习目标：\n掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n示例：\n#include \u0026lt;string\u0026gt; //2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 template\u0026lt;class T1, class T2\u0026gt; class Person; //如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 //template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;类外实现 ---- 姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } template\u0026lt;class T1, class T2\u0026gt; class Person { //1、全局函数配合友元 类内实现 friend void printPerson(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } //全局函数配合友元 类外实现 friend void printPerson2\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); public: Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } private: T1 m_Name; T2 m_Age; }; //1、全局函数在类内实现 void test01() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;Tom\u0026#34;, 20); printPerson(p); } //2、全局函数在类外实现 void test02() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;Jerry\u0026#34;, 30); printPerson2(p); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n1.3.9 类模板案例 案例描述: 实现一个通用的数组类，要求如下：\n可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例：\nmyArray.hpp中代码\n#pragma once #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; class MyArray { public: //构造函数 MyArray(int capacity) { this-\u0026gt;m_Capacity = capacity; this-\u0026gt;m_Size = 0; pAddress = new T[this-\u0026gt;m_Capacity]; } //拷贝构造 MyArray(const MyArray \u0026amp; arr) { this-\u0026gt;m_Capacity = arr.m_Capacity; this-\u0026gt;m_Size = arr.m_Size; this-\u0026gt;pAddress = new T[this-\u0026gt;m_Capacity]; for (int i = 0; i \u0026lt; this-\u0026gt;m_Size; i++) { //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-\u0026gt;pAddress[i] = arr.pAddress[i]; } } //重载= 操作符 防止浅拷贝问题 MyArray\u0026amp; operator=(const MyArray\u0026amp; myarray) { if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;m_Capacity = 0; this-\u0026gt;m_Size = 0; } this-\u0026gt;m_Capacity = myarray.m_Capacity; this-\u0026gt;m_Size = myarray.m_Size; this-\u0026gt;pAddress = new T[this-\u0026gt;m_Capacity]; for (int i = 0; i \u0026lt; this-\u0026gt;m_Size; i++) { this-\u0026gt;pAddress[i] = myarray[i]; } return *this; } //重载[] 操作符 arr[0] T\u0026amp; operator [](int index) { return this-\u0026gt;pAddress[index]; //不考虑越界，用户自己去处理 } //尾插法 void Push_back(const T \u0026amp; val) { if (this-\u0026gt;m_Capacity == this-\u0026gt;m_Size) { return; } this-\u0026gt;pAddress[this-\u0026gt;m_Size] = val; this-\u0026gt;m_Size++; } //尾删法 void Pop_back() { if (this-\u0026gt;m_Size == 0) { return; } this-\u0026gt;m_Size--; } //获取数组容量 int getCapacity() { return this-\u0026gt;m_Capacity; } //获取数组大小 int getSize() { return this-\u0026gt;m_Size; } //析构 ~MyArray() { if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;pAddress = NULL; this-\u0026gt;m_Capacity = 0; this-\u0026gt;m_Size = 0; } } private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小 }; 类模板案例—数组类封装.cpp中\n#include \u0026#34;myArray.hpp\u0026#34; #include \u0026lt;string\u0026gt; void printIntArray(MyArray\u0026lt;int\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.getSize(); i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //测试内置数据类型 void test01() { MyArray\u0026lt;int\u0026gt; array1(10); for (int i = 0; i \u0026lt; 10; i++) { array1.Push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;array1打印输出：\u0026#34; \u0026lt;\u0026lt; endl; printIntArray(array1); cout \u0026lt;\u0026lt; \u0026#34;array1的大小：\u0026#34; \u0026lt;\u0026lt; array1.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;array1的容量：\u0026#34; \u0026lt;\u0026lt; array1.getCapacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;--------------------------\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; array2(array1); array2.Pop_back(); cout \u0026lt;\u0026lt; \u0026#34;array2打印输出：\u0026#34; \u0026lt;\u0026lt; endl; printIntArray(array2); cout \u0026lt;\u0026lt; \u0026#34;array2的大小：\u0026#34; \u0026lt;\u0026lt; array2.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;array2的容量：\u0026#34; \u0026lt;\u0026lt; array2.getCapacity() \u0026lt;\u0026lt; endl; } //测试自定义数据类型 class Person { public: Person() {} Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } public: string m_Name; int m_Age; }; void printPersonArray(MyArray\u0026lt;Person\u0026gt;\u0026amp; personArr) { for (int i = 0; i \u0026lt; personArr.getSize(); i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; personArr[i].m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; personArr[i].m_Age \u0026lt;\u0026lt; endl; } } void test02() { //创建数组 MyArray\u0026lt;Person\u0026gt; pArray(10); Person p1(\u0026#34;孙悟空\u0026#34;, 30); Person p2(\u0026#34;韩信\u0026#34;, 20); Person p3(\u0026#34;妲己\u0026#34;, 18); Person p4(\u0026#34;王昭君\u0026#34;, 15); Person p5(\u0026#34;赵云\u0026#34;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout \u0026lt;\u0026lt; \u0026#34;pArray的大小：\u0026#34; \u0026lt;\u0026lt; pArray.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pArray的容量：\u0026#34; \u0026lt;\u0026lt; pArray.getCapacity() \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n能够利用所学知识点实现通用的数组\n2 STL初识 2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器 **容器：**置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n**算法：**问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n**迭代器：**容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、==、！= 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、\u0026ndash;， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、\u0026ndash;、[n]、-n、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;= 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n2.5 容器算法迭代器初识 了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力\nSTL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器\n2.5.1 vector存放内置数据类型 容器： vector\n算法： for_each\n迭代器： vector::iterator\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; void MyPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } void test01() { //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector\u0026lt;int\u0026gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector\u0026lt;int\u0026gt;::iterator 拿到vector\u0026lt;int\u0026gt;这种容器的迭代器类型 vector\u0026lt;int\u0026gt;::iterator pBegin = v.begin(); vector\u0026lt;int\u0026gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) { cout \u0026lt;\u0026lt; *pBegin \u0026lt;\u0026lt; endl; pBegin++; } //第二种遍历方式： for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.2 Vector存放自定义数据类型 学习目标：vector中存放自定义数据类型，并打印输出\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; //自定义数据类型 class Person { public: Person(string name, int age) { mName = name; mAge = age; } public: string mName; int mAge; }; //存放对象 void test01() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); Person p5(\u0026#34;eee\u0026#34;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; (*it).mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it).mAge \u0026lt;\u0026lt; endl; } } //放对象指针 void test02() { vector\u0026lt;Person*\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); Person p5(\u0026#34;eee\u0026#34;, 50); v.push_back(\u0026amp;p1); v.push_back(\u0026amp;p2); v.push_back(\u0026amp;p3); v.push_back(\u0026amp;p4); v.push_back(\u0026amp;p5); for (vector\u0026lt;Person*\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { Person * p = (*it); cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it)-\u0026gt;mAge \u0026lt;\u0026lt; endl; } } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.3 Vector容器嵌套容器 学习目标：容器中嵌套容器，我们将所有数据进行遍历输出\n示例：\n#include \u0026lt;vector\u0026gt; //容器嵌套容器 void test01() { vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; v; vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; vector\u0026lt;int\u0026gt; v3; vector\u0026lt;int\u0026gt; v4; for (int i = 0; i \u0026lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3 STL- 常用容器 3.1 string容器 3.1.1 string基本概念 本质：\nstring是C++风格的字符串，而string本质上是一个类 string和char * 区别：\nchar * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点：\nstring 类内部封装了很多成员方法\n例如：查找find，拷贝copy，删除delete 替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n3.1.2 string构造函数 构造函数原型：\nstring(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化 string(const string\u0026amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化 示例：\n#include \u0026lt;string\u0026gt; //string构造 void test01() { string s1; //创建空字符串，调用无参构造函数 cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; const char* str = \u0026#34;hello world\u0026#34;; string s2(str); //把c_string转换成了string cout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; string s3(s2); //调用拷贝构造函数 cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; string s4(10, \u0026#39;a\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：string的多种构造方式没有可比性，灵活使用即可\n3.1.3 string赋值操作 功能描述：\n给string字符串进行赋值 赋值的函数原型：\nstring\u0026amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s); //把字符串s赋给当前的字符串 string\u0026amp; operator=(char c); //字符赋值给当前的字符串 string\u0026amp; assign(const char *s); //把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s); //把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c); //用n个字符c赋给当前字符串 示例：\n//赋值 void test01() { string str1; str1 = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2; str2 = str1; cout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; string str3; str3 = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; string str4; str4.assign(\u0026#34;hello c++\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str4 = \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; string str5; str5.assign(\u0026#34;hello c++\u0026#34;,5); cout \u0026lt;\u0026lt; \u0026#34;str5 = \u0026#34; \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; string str6; str6.assign(str5); cout \u0026lt;\u0026lt; \u0026#34;str6 = \u0026#34; \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; string str7; str7.assign(5, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;str7 = \u0026#34; \u0026lt;\u0026lt; str7 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nstring的赋值方式很多，operator= 这种方式是比较实用的\n3.1.4 string字符串拼接 功能描述：\n实现在字符串末尾拼接字符串 函数原型：\nstring\u0026amp; operator+=(const char* str); //重载+=操作符 string\u0026amp; operator+=(const char c); //重载+=操作符 string\u0026amp; operator+=(const string\u0026amp; str); //重载+=操作符 string\u0026amp; append(const char *s); //把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s); //同operator+=(const string\u0026amp; str) string\u0026amp; append(const string \u0026amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 示例：\n//字符串拼接 void test01() { string str1 = \u0026#34;我\u0026#34;; str1 += \u0026#34;爱玩游戏\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; str1 += \u0026#39;:\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2 = \u0026#34;LOL DNF\u0026#34;; str1 += str2; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str3 = \u0026#34;I\u0026#34;; str3.append(\u0026#34; love \u0026#34;); str3.append(\u0026#34;game abcde\u0026#34;, 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：字符串拼接的重载版本很多，初学阶段记住几种即可\n3.1.5 string查找和替换 功能描述：\n查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型：\nint find(const string\u0026amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string\u0026amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string\u0026amp; replace(int pos, int n, const string\u0026amp; str); //替换从pos开始n个字符为字符串str string\u0026amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s 示例：\n//查找和替换 void test01() { //查找 string str1 = \u0026#34;abcdefgde\u0026#34;; int pos = str1.find(\u0026#34;de\u0026#34;); if (pos == -1) { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } pos = str1.rfind(\u0026#34;de\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } void test02() { //替换 string str1 = \u0026#34;abcdefgde\u0026#34;; str1.replace(1, 3, \u0026#34;1111\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; } int main() { //test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nfind查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较 功能描述：\n字符串之间的比较 比较方式：\n字符串比较是按字符的ASCII码进行对比 = 返回 0\n\u0026gt; 返回 1\n\u0026lt; 返回 -1\n函数原型：\nint compare(const string \u0026amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 示例：\n//字符串比较 void test01() { string s1 = \u0026#34;hello\u0026#34;; string s2 = \u0026#34;aello\u0026#34;; int ret = s1.compare(s2); if (ret == 0) { cout \u0026lt;\u0026lt; \u0026#34;s1 等于 s2\u0026#34; \u0026lt;\u0026lt; endl; } else if (ret \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;s1 大于 s2\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;s1 小于 s2\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n3.1.7 string字符存取 string中单个字符存取方式有两种\nchar\u0026amp; operator[](int n); //通过[]方式取字符 char\u0026amp; at(int n); //通过at方法获取字符 示例：\nvoid test01() { string str = \u0026#34;hello world\u0026#34;; for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //字符修改 str[0] = \u0026#39;x\u0026#39;; str.at(1) = \u0026#39;x\u0026#39;; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at\n3.1.8 string插入和删除 功能描述：\n对string字符串进行插入和删除字符操作 函数原型：\nstring\u0026amp; insert(int pos, const char* s); //插入字符串 string\u0026amp; insert(int pos, const string\u0026amp; str); //插入字符串 string\u0026amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string\u0026amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 示例：\n//字符串插入和删除 void test01() { string str = \u0026#34;hello\u0026#34;; str.insert(1, \u0026#34;111\u0026#34;); cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**插入和删除的起始下标都是从0开始\n3.1.9 string子串 功能描述：\n从字符串中获取想要的子串 函数原型：\nstring substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 示例：\n//子串 void test01() { string str = \u0026#34;abcdefg\u0026#34;; string subStr = str.substr(1, 3); cout \u0026lt;\u0026lt; \u0026#34;subStr = \u0026#34; \u0026lt;\u0026lt; subStr \u0026lt;\u0026lt; endl; string email = \u0026#34;hello@sina.com\u0026#34;; int pos = email.find(\u0026#34;@\u0026#34;); string username = email.substr(0, pos); cout \u0026lt;\u0026lt; \u0026#34;username: \u0026#34; \u0026lt;\u0026lt; username \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息\n3.2 vector容器 3.2.1 vector基本概念 功能：\nvector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别：\n不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展：\n并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 clip_image002 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数 功能描述：\n创建vector容器 函数原型：\nvector v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector \u0026amp;vec); //拷贝构造函数。 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt; v1; //无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); printVector(v2); vector\u0026lt;int\u0026gt; v3(10, 100); printVector(v3); vector\u0026lt;int\u0026gt; v4(v3); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**vector的多种构造方式没有可比性，灵活使用即可\n3.2.3 vector赋值操作 功能描述：\n给vector容器进行赋值 函数原型：\nvector\u0026amp; operator=(const vector \u0026amp;vec);//重载等号操作符\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem); //将n个elem拷贝赋值给本身。\n示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test01() { vector\u0026lt;int\u0026gt; v1; //无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt;v2; v2 = v1; printVector(v2); vector\u0026lt;int\u0026gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector\u0026lt;int\u0026gt;v4; v4.assign(10, 100); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： vector赋值方式比较简单，使用operator=，或者assign都可以\n3.2.4 vector容量和大小 功能描述：\n对vector容器的容量和大小操作 函数原型：\nempty(); //判断容器是否为空\ncapacity(); //容器的容量\nsize(); //返回容器中元素的个数\nresize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除\n示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;v1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;v1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的容量 = \u0026#34; \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的大小 = \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; } //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 返回容器容量 \u0026mdash; capacity 重新指定大小 \u0026mdash; resize 3.2.5 vector插入和删除 功能描述：\n对vector容器进行插入、删除操作 函数原型：\npush_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { vector\u0026lt;int\u0026gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n尾插 \u0026mdash; push_back 尾删 \u0026mdash; pop_back 插入 \u0026mdash; insert (位置迭代器) 删除 \u0026mdash; erase （位置迭代器） 清空 \u0026mdash; clear 3.2.6 vector数据存取 功能描述：\n对vector中的数据的存取操作 函数原型：\nat(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例：\n#include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的第一个元素为： \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的最后一个元素为： \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n除了用迭代器获取vector容器中元素， 和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器 功能描述：\n实现两个容器内元素进行互换 函数原型：\nswap(vec); // 将vec与本身的元素互换 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt;v2; for (int i = 10; i \u0026gt; 0; i--) { v2.push_back(i); } printVector(v2); //互换容器 cout \u0026lt;\u0026lt; \u0026#34;互换后\u0026#34; \u0026lt;\u0026lt; endl; v1.swap(v2); printVector(v1); printVector(v2); } void test02() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; v.resize(3); cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; //收缩内存 vector\u0026lt;int\u0026gt;(v).swap(v); //匿名对象 cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果\n3.2.8 vector预留空间 功能描述：\n减少vector在动态扩展容量时的扩展次数 函数原型：\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 示例：\n#include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (p != \u0026amp;v[0]) { p = \u0026amp;v[0]; num++; } } cout \u0026lt;\u0026lt; \u0026#34;num:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果数据量较大，可以一开始利用reserve预留空间\n3.3 deque容器 3.3.1 deque容器基本概念 功能：\n双端数组，可以对头端进行插入删除操作 deque与vector区别：\nvector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 clip_image002-1547547642923 deque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\nclip_image002-1547547896341 deque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数 功能描述：\ndeque容器构造 函数原型：\ndeque deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque \u0026amp;deq); //拷贝构造函数 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //deque构造 void test01() { deque\u0026lt;int\u0026gt; d1; //无参构造函数 for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque\u0026lt;int\u0026gt; d2(d1.begin(),d1.end()); printDeque(d2); deque\u0026lt;int\u0026gt;d3(10,100); printDeque(d3); deque\u0026lt;int\u0026gt;d4 = d3; printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可\n3.3.3 deque赋值操作 功能描述：\n给deque容器进行赋值 函数原型：\ndeque\u0026amp; operator=(const deque \u0026amp;deq); //重载等号操作符\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem); //将n个elem拷贝赋值给本身。\n示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test01() { deque\u0026lt;int\u0026gt; d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque\u0026lt;int\u0026gt;d2; d2 = d1; printDeque(d2); deque\u0026lt;int\u0026gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque\u0026lt;int\u0026gt;d4; d4.assign(10, 100); printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：deque赋值操作也与vector相同，需熟练掌握\n3.3.4 deque大小操作 功能描述：\n对deque容器的大小进行操作 函数原型：\ndeque.empty(); //判断容器是否为空\ndeque.size(); //返回容器中元素的个数\ndeque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\n示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小操作 void test01() { deque\u0026lt;int\u0026gt; d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); //判断容器是否为空 if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;d1为空!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;d1不为空!\u0026#34; \u0026lt;\u0026lt; endl; //统计大小 cout \u0026lt;\u0026lt; \u0026#34;d1的大小为：\u0026#34; \u0026lt;\u0026lt; d1.size() \u0026lt;\u0026lt; endl; } //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\ndeque没有容量的概念 判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 重新指定个数 \u0026mdash; resize 3.3.5 deque 插入和删除 功能描述：\n向deque容器中插入和删除数据 函数原型：\n两端插入操作：\npush_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作：\ninsert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //两端操作 void test01() { deque\u0026lt;int\u0026gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d); } //插入 void test02() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque\u0026lt;int\u0026gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d); } //删除 void test03() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n插入和删除提供的位置是迭代器！ 尾插 \u0026mdash; push_back 尾删 \u0026mdash; pop_back 头插 \u0026mdash; push_front 头删 \u0026mdash; pop_front 3.3.6 deque 数据存取 功能描述：\n对deque 中的数据的存取操作 函数原型：\nat(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //数据存取 void test01() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i \u0026lt; d.size(); i++) { cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; d.size(); i++) { cout \u0026lt;\u0026lt; d.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front:\u0026#34; \u0026lt;\u0026lt; d.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;back:\u0026#34; \u0026lt;\u0026lt; d.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n除了用迭代器获取deque容器中元素， 和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序 功能描述：\n利用算法实现对deque容器进行排序 算法：\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序 示例：\n#include \u0026lt;deque\u0026gt; #include \u0026lt;algorithm\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：sort算法非常实用，使用时包含头文件 algorithm即可\n3.4 案例-评委打分 3.4.1 案例描述 有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码：\n//选手类 class Person { public: Person(string name, int score) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Score = score; } string m_Name; //姓名 int m_Score; //平均分 }; void createPerson(vector\u0026lt;Person\u0026gt;\u0026amp;v) { string nameSeed = \u0026#34;ABCDE\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { string name = \u0026#34;选手\u0026#34;; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); } } //打分 void setScore(vector\u0026lt;Person\u0026gt;\u0026amp;v) { for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { //将评委的分数 放入到deque容器中 deque\u0026lt;int\u0026gt;d; for (int i = 0; i \u0026lt; 10; i++) { int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); } //cout \u0026lt;\u0026lt; \u0026#34;选手： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 打分： \u0026#34; \u0026lt;\u0026lt; endl; //for (deque\u0026lt;int\u0026gt;::iterator dit = d.begin(); dit != d.end(); dit++) //{ // cout \u0026lt;\u0026lt; *dit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //} //cout \u0026lt;\u0026lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque\u0026lt;int\u0026gt;::iterator dit = d.begin(); dit != d.end(); dit++) { sum += *dit; //累加每个评委的分数 } int avg = sum / d.size(); //将平均分 赋值给选手身上 it-\u0026gt;m_Score = avg; } } void showScore(vector\u0026lt;Person\u0026gt;\u0026amp;v) { for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 平均分： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Score \u0026lt;\u0026lt; endl; } } int main() { //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector\u0026lt;Person\u0026gt;v; //存放选手容器 createPerson(v); //测试 //for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) //{ // cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; (*it).m_Name \u0026lt;\u0026lt; \u0026#34; 分数： \u0026#34; \u0026lt;\u0026lt; (*it).m_Score \u0026lt;\u0026lt; endl; //} //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 选取不同的容器操作数据，可以提升代码的效率\n3.5 stack容器 3.5.1 stack 基本概念 概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\nclip_image002-1547604555425 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n栈中进入数据称为 \u0026mdash; 入栈 push\n栈中弹出数据称为 \u0026mdash; 出栈 pop\n3.5.2 stack 常用接口 功能描述：栈容器常用的对外接口\n构造函数：\nstack stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack \u0026amp;stk); //拷贝构造函数 赋值操作：\nstack\u0026amp; operator=(const stack \u0026amp;stk); //重载等号操作符 数据存取：\npush(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 大小操作：\nempty(); //判断堆栈是否为空 size(); //返回栈的大小 示例：\n#include \u0026lt;stack\u0026gt; //栈容器常用接口 void test01() { //创建栈容器 栈容器必须符合先进后出 stack\u0026lt;int\u0026gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) { //输出栈顶元素 cout \u0026lt;\u0026lt; \u0026#34;栈顶元素为： \u0026#34; \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; //弹出栈顶元素 s.pop(); } cout \u0026lt;\u0026lt; \u0026#34;栈的大小为：\u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n入栈 \u0026mdash; push 出栈 \u0026mdash; pop 返回栈顶 \u0026mdash; top 判断栈是否为空 \u0026mdash; empty 返回栈大小 \u0026mdash; size 3.6 queue 容器 3.6.1 queue 基本概念 概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\nclip_image002-1547606475892 队列容器允许从一端新增元素，从另一端移除元素\n队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n队列中进数据称为 \u0026mdash; 入队 push\n队列中出数据称为 \u0026mdash; 出队 pop\n3.6.2 queue 常用接口 功能描述：栈容器常用的对外接口\n构造函数：\nqueue que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue \u0026amp;que); //拷贝构造函数 赋值操作：\nqueue\u0026amp; operator=(const queue \u0026amp;que); //重载等号操作符 数据存取：\npush(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 大小操作：\nempty(); //判断堆栈是否为空 size(); //返回栈的大小 示例：\n#include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; void test01() { //创建队列 queue\u0026lt;Person\u0026gt; q; //准备数据 Person p1(\u0026#34;唐僧\u0026#34;, 30); Person p2(\u0026#34;孙悟空\u0026#34;, 1000); Person p3(\u0026#34;猪八戒\u0026#34;, 900); Person p4(\u0026#34;沙僧\u0026#34;, 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) { //输出队头元素 cout \u0026lt;\u0026lt; \u0026#34;队头元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.front().m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34;\u0026lt;\u0026lt; q.front().m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;队尾元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.back().m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; q.back().m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; //弹出队头元素 q.pop(); } cout \u0026lt;\u0026lt; \u0026#34;队列大小为：\u0026#34; \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n入队 \u0026mdash; push 出队 \u0026mdash; pop 返回队头元素 \u0026mdash; front 返回队尾元素 \u0026mdash; back 判断队是否为空 \u0026mdash; empty 返回队列大小 \u0026mdash; size 3.7 list容器 3.7.1 list基本概念 **功能：**将数据进行链式存储\n链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的\n链表的组成：链表由一系列结点组成\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\nSTL中的链表是一个双向循环链表\nclip_image002-1547608564071 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nlist的优点：\n采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点：\n链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。\n总结：STL中List和vector是两个最常被使用的容器，各有优缺点\n3.7.2 list构造函数 功能描述：\n创建list容器 函数原型：\nlist lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list \u0026amp;lst); //拷贝构造函数。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list\u0026lt;int\u0026gt;L2(L1.begin(),L1.end()); printList(L2); list\u0026lt;int\u0026gt;L3(L2); printList(L3); list\u0026lt;int\u0026gt;L4(10, 1000); printList(L4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：list构造方式同其他几个STL常用容器，熟练掌握即可\n3.7.3 list 赋值和交换 功能描述：\n给list容器进行赋值，以及交换list容器 函数原型：\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list\u0026amp; operator=(const list \u0026amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值和交换 void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list\u0026lt;int\u0026gt;L2; L2 = L1; printList(L2); list\u0026lt;int\u0026gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list\u0026lt;int\u0026gt;L4; L4.assign(10, 100); printList(L4); } //交换 void test02() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list\u0026lt;int\u0026gt;L2; L2.assign(10, 100); cout \u0026lt;\u0026lt; \u0026#34;交换前： \u0026#34; \u0026lt;\u0026lt; endl; printList(L1); printList(L2); cout \u0026lt;\u0026lt; endl; L1.swap(L2); cout \u0026lt;\u0026lt; \u0026#34;交换后： \u0026#34; \u0026lt;\u0026lt; endl; printList(L1); printList(L2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：list赋值和交换操作能够灵活运用即可\n3.7.4 list 大小操作 功能描述：\n对list容器的大小进行操作 函数原型：\nsize(); //返回容器中元素的个数\nempty(); //判断容器是否为空\nresize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\nresize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小操作 void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;L1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;L1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;L1的大小为： \u0026#34; \u0026lt;\u0026lt; L1.size() \u0026lt;\u0026lt; endl; } //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 重新指定个数 \u0026mdash; resize 3.7.5 list 插入和删除 功能描述：\n对list容器进行数据的插入和删除 函数原型：\npush_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (const auto\u0026amp;it : L) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { list\u0026lt;int\u0026gt; L; //尾插 L.emplace_back(10); L.emplace_back(20); L.emplace_back(30); //头插 L.emplace_front(100); L.emplace_front(200); L.emplace_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list\u0026lt;int\u0026gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.pop_back(); L.pop_back(); L.pop_back(); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n尾插 \u0026mdash; push_back 尾部原位创造 \u0026mdash; emplace_back 尾删 \u0026mdash; pop_back 头插 \u0026mdash; push_front 头删 \u0026mdash; pop_front 插入 \u0026mdash; insert 删除 \u0026mdash; erase 移除 \u0026mdash; remove 清空 \u0026mdash; clear 3.7.6 list 数据存取 功能描述：\n对list容器中数据进行存取 函数原型：\nfront(); //返回第一个元素。 back(); //返回最后一个元素。 示例：\n#include \u0026lt;list\u0026gt; //数据存取 void test01() { list\u0026lt;int\u0026gt;L1; L1.emplace_back(10); L1.emplace_back(20); L1.emplace_back(30); L1.emplace_back(40); //cout \u0026lt;\u0026lt; L1.at(0) \u0026lt;\u0026lt; endl;//错误 不支持at访问数据 //cout \u0026lt;\u0026lt; L1[0] \u0026lt;\u0026lt; endl; //错误 不支持[]方式访问数据 cout \u0026lt;\u0026lt; \u0026#34;第一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;最后一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.back() \u0026lt;\u0026lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list\u0026lt;int\u0026gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nlist容器中不可以通过[]或者at方式访问数据 返回第一个元素 \u0026mdash; front 返回最后一个元素 \u0026mdash; back 3.7.7 list 反转和排序 功能描述：\n将容器中的元素反转，以及将容器中的数据进行排序 函数原型：\nreverse(); //反转链表 sort(); //链表排序 示例：\nvoid printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } bool myCompare(int val1 , int val2) { return val1 \u0026gt; val2; } //反转和排序 void test01() { list\u0026lt;int\u0026gt; L; L.emplace_back(90); L.emplace_back(30); L.emplace_back(20); L.emplace_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n反转 \u0026mdash; reverse 排序 \u0026mdash; sort （成员函数） 3.7.8 排序案例 案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\n示例：\n#include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age , int height) { m_Name = name; m_Age = age; m_Height = height; } public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高 }; bool ComparePerson(Person\u0026amp; p1, Person\u0026amp; p2) { if (p1.m_Age == p2.m_Age) { return p1.m_Height \u0026gt; p2.m_Height; } else { return p1.m_Age \u0026lt; p2.m_Age; } } void test01() { list\u0026lt;Person\u0026gt; L; Person p1(\u0026#34;刘备\u0026#34;, 35 , 175); Person p2(\u0026#34;曹操\u0026#34;, 45 , 180); Person p3(\u0026#34;孙权\u0026#34;, 40 , 170); Person p4(\u0026#34;赵云\u0026#34;, 25 , 190); Person p5(\u0026#34;张飞\u0026#34;, 35 , 160); Person p6(\u0026#34;关羽\u0026#34;, 35 , 200); L.emplace_back(move(p1)); L.emplace_back(move(p2)); L.emplace_back(move(p3)); L.emplace_back(move(p4)); L.emplace_back(move(p5)); L.emplace_back(move(p6)); for (list\u0026lt;Person\u0026gt;::iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Height \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;---------------------------------\u0026#34; \u0026lt;\u0026lt; endl; L.sort(ComparePerson); //排序 for (list\u0026lt;Person\u0026gt;::iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Height \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序\n高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂\n3.8 set/ multiset 容器 3.8.1 set基本概念 简介：\n所有元素都会在插入时自动被排序 本质：\nset/multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别：\nset不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值 功能描述：创建set容器以及赋值\n构造：\nset st; //默认构造函数： set(const set \u0026amp;st); //拷贝构造函数 赋值：\nset\u0026amp; operator=(const set \u0026amp;st); //重载等号操作符 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //构造和赋值 void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); printSet(s1); //拷贝构造 set\u0026lt;int\u0026gt;s2(s1); printSet(s2); //赋值 set\u0026lt;int\u0026gt;s3; s3 = s2; printSet(s3); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nset容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换 功能描述：\n统计set容器大小以及交换set容器 函数原型：\nsize(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小 void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); if (s1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;s1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;s1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1的大小为： \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } } //交换 void test02() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); set\u0026lt;int\u0026gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); s2.emplace(500); cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; printSet(s1); printSet(s2); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; s1.swap(s2); printSet(s1); printSet(s2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n统计大小 \u0026mdash; size 判断是否为空 \u0026mdash; empty 交换容器 \u0026mdash; swap 3.8.4 set插入和删除 功能描述：\nset容器进行插入数据和删除数据 函数原型：\ninsert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { set\u0026lt;int\u0026gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n插入 \u0026mdash; insert 删除 \u0026mdash; erase 清空 \u0026mdash; clear 3.8.5 set查找和统计 功能描述：\n对set容器进行查找数据以及统计数据 函数原型：\nfind(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例：\n#include \u0026lt;set\u0026gt; //查找和统计 void test01() { set\u0026lt;int\u0026gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); //查找 set\u0026lt;int\u0026gt;::iterator pos = s1.find(30); if (pos != s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到了元素 ： \u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; } //统计 int num = s1.count(30); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n查找 \u0026mdash; find （返回的是迭代器） 统计 \u0026mdash; count （对于set，结果为0或者1） 3.8.6 set和multiset区别 学习目标：\n掌握set和multiset的区别 区别：\nset不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例：\n#include \u0026lt;set\u0026gt; //set和multiset区别 void test01() { set\u0026lt;int\u0026gt; s; pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, bool\u0026gt; ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第一次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; } ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第二次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; } //multiset multiset\u0026lt;int\u0026gt; ms; ms.insert(10); ms.insert(10); ms.emplace(50); for (multiset\u0026lt;int\u0026gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建 功能描述：\n成对出现的数据，利用对组可以返回两个数据 两种创建方式：\npair p ( value1, value2 ); pair p = make_pair( value1, value2 ); 示例：\n#include \u0026lt;string\u0026gt; //对组创建 void test01() { pair\u0026lt;string, int\u0026gt; p(string(\u0026#34;Tom\u0026#34;), 20); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; pair\u0026lt;string, int\u0026gt; p2 = make_pair(\u0026#34;Jerry\u0026#34;, 10); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n两种方式都可以创建对组，记住一种即可\n3.8.8 set容器排序 学习目标：\nset容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点：\n利用仿函数，可以改变排序规则 示例一 set存放内置数据类型\n#include \u0026lt;set\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); s1.emplace(60); //默认从小到大 for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //指定排序规则 set\u0026lt;int,MyCompare\u0026gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); s1.emplace(60); for (set\u0026lt;int, MyCompare\u0026gt;::iterator it = s2.begin(); it != s2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：利用仿函数可以指定set容器的排序规则\n示例二 set存放自定义数据类型\n#include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; class comparePerson { public: bool operator()(const Person\u0026amp; p1, const Person \u0026amp;p2) { //按照年龄进行排序 降序 return p1.m_Age \u0026gt; p2.m_Age; } }; void test01() { set\u0026lt;Person, comparePerson\u0026gt; s; Person p1(\u0026#34;刘备\u0026#34;, 23); Person p2(\u0026#34;关羽\u0026#34;, 27); Person p3(\u0026#34;张飞\u0026#34;, 25); Person p4(\u0026#34;赵云\u0026#34;, 21); Person p5(\u0026#34;刘德华\u0026#34;, 51); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); s.emplace(p5); for (set\u0026lt;Person, comparePerson\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n对于自定义数据类型，set必须指定排序规则才可以插入数据\n3.9 map/ multimap容器 3.9.1 map基本概念 简介：\nmap中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质：\nmap/multimap属于关联式容器，底层结构是用二叉树实现。 优点：\n可以根据key值快速找到value值 map和multimap区别：\nmap不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值 功能描述：\n对map容器进行构造和赋值操作 函数原型：\n构造：\nmap mp; //map默认构造函数: map(const map \u0026amp;mp); //拷贝构造函数 赋值：\nmap\u0026amp; operator=(const map \u0026amp;mp); //重载等号操作符 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int,int\u0026gt;m; //默认构造 m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); printMap(m); map\u0026lt;int, int\u0026gt;m2(m); //拷贝构造 printMap(m2); map\u0026lt;int, int\u0026gt;m3; m3 = m2; //赋值 printMap(m3); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：map中所有元素都是成对出现，插入数据时候要使用对组\n3.9.3 map大小和交换 功能描述：\n统计map容器大小以及交换map容器 函数原型：\nsize(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); if (m.empty()) { cout \u0026lt;\u0026lt; \u0026#34;m为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;m不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;m的大小为： \u0026#34; \u0026lt;\u0026lt; m.size() \u0026lt;\u0026lt; endl; } } //交换 void test02() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); map\u0026lt;int, int\u0026gt;m2; m2.insert(pair\u0026lt;int, int\u0026gt;(4, 100)); m2.insert(pair\u0026lt;int, int\u0026gt;(5, 200)); m2.insert(pair\u0026lt;int, int\u0026gt;(6, 300)); cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; printMap(m); printMap(m2); cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; m.swap(m2); printMap(m); printMap(m2); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n统计大小 \u0026mdash; size 判断是否为空 \u0026mdash; empty 交换容器 \u0026mdash; swap 3.9.4 map插入和删除 功能描述：\nmap容器进行插入数据和删除数据 函数原型：\ninsert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { //插入 map\u0026lt;int, int\u0026gt; m; //第一种插入方式 m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map\u0026lt;int, int\u0026gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nmap插入方式很多，记住其一即可\n插入 \u0026mdash; insert\n删除 \u0026mdash; erase\n清空 \u0026mdash; clear\n3.9.5 map查找和统计 功能描述：\n对map容器进行查找数据以及统计数据 函数原型：\nfind(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例：\n#include \u0026lt;map\u0026gt; //查找和统计 void test01() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); //查找 map\u0026lt;int, int\u0026gt;::iterator pos = m.find(3); if (pos != m.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到了元素 key = \u0026#34; \u0026lt;\u0026lt; (*pos).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; (*pos).second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; } //统计 int num = m.count(3); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n查找 \u0026mdash; find （返回的是迭代器） 统计 \u0026mdash; count （对于map，结果为0或者1） 3.9.6 map容器排序 学习目标：\nmap容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点:\n利用仿函数，可以改变排序规则 示例：\n#include \u0026lt;map\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { //默认从小到大排序 //利用仿函数实现从大到小排序 map\u0026lt;int, int, MyCompare\u0026gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map\u0026lt;int, int, MyCompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组 3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;ctime\u0026gt; /* - 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 - 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 - 随机给10名员工分配部门和工资 - 通过multimap进行信息的插入 key(部门编号) value(员工) - 分部门显示员工信息 */ #define CEHUA 0 #define MEISHU 1 #define YANFA 2 class Worker { public: string m_Name; int m_Salary; }; void createWorker(vector\u0026lt;Worker\u0026gt;\u0026amp;v) { string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for (int i = 0; i \u0026lt; 10; i++) { Worker worker; worker.m_Name = \u0026#34;员工\u0026#34;; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); } } //员工分组 void setGroup(vector\u0026lt;Worker\u0026gt;\u0026amp;v,multimap\u0026lt;int,Worker\u0026gt;\u0026amp;m) { for (vector\u0026lt;Worker\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); } } void showWorkerByGourp(multimap\u0026lt;int,Worker\u0026gt;\u0026amp;m) { // 0 A B C 1 D E 2 F G ... cout \u0026lt;\u0026lt; \u0026#34;策划部门：\u0026#34; \u0026lt;\u0026lt; endl; multimap\u0026lt;int,Worker\u0026gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++ , index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;美术部门： \u0026#34; \u0026lt;\u0026lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++, index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;研发部门： \u0026#34; \u0026lt;\u0026lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++, index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } } int main() { srand((unsigned int)time(NULL)); //1、创建员工 vector\u0026lt;Worker\u0026gt;vWorker; createWorker(vWorker); //2、员工分组 multimap\u0026lt;int, Worker\u0026gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector\u0026lt;Worker\u0026gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //{ // cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Salary \u0026lt;\u0026lt; endl; //} system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n当数据以键值对形式存在，可以考虑用map 或 multimap 3.11 unordered_map/unordered_multimap容器 unordered_map(C++11 起) 键值对的集合，按照键生成散列，键是唯一的\nunordered_multimap(C++11 起)键值对的集合，按照键生成散列\nC++无序容器 - txt1994s\n3.12 unordered_set/unordered_multiset容器 unordered_set(C++11 起) 唯一键的集合，按照键生成散列\nunordered_multiset(C++11 起) 键的集合，按照键生成散列\nC++无序容器 - txt1994s\n4 STL- 函数对象 4.1 函数对象 4.1.1 函数对象概念 概念：\n重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质：\n函数对象(仿函数)是一个类，不是一个函数\n4.1.2 函数对象使用 特点：\n函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例:\n#include \u0026lt;string\u0026gt; //1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 class MyAdd { public : int operator()(int v1,int v2) { return v1 + v2; } }; void test01() { MyAdd myAdd; cout \u0026lt;\u0026lt; myAdd(10, 10) \u0026lt;\u0026lt; endl; } //2、函数对象可以有自己的状态 class MyPrint { public: MyPrint() { count = 0; } void operator()(string test) { cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; count++; //统计使用次数 } int count; //内部自己的状态 }; void test02() { MyPrint myPrint; myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;myPrint调用次数为： \u0026#34; \u0026lt;\u0026lt; myPrint.count \u0026lt;\u0026lt; endl; } //3、函数对象可以作为参数传递 void doPrint(MyPrint \u0026amp;mp , string test) { mp(test); } void test03() { MyPrint myPrint; doPrint(myPrint, \u0026#34;Hello C++\u0026#34;); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词 4.2.1 谓词概念 概念：\n返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; //1.一元谓词 struct GreaterFive{ bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：参数只有一个的谓词，称为一元谓词\n4.2.3 二元谓词 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; //二元谓词 class MyCompare { public: bool operator()(int num1, int num2) { return num1 \u0026gt; num2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.emplace_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------------------------\u0026#34; \u0026lt;\u0026lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：参数只有两个的谓词，称为二元谓词\n4.3 内建函数对象 4.3.1 内建函数对象意义 概念：\nSTL内建了一些函数对象 分类:\n算术仿函数 关系仿函数 逻辑仿函数 用法：\n这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include 4.3.2 算术仿函数 功能描述：\n实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型：\ntemplate T plus //加法仿函数 template T minus //减法仿函数 template T multiplies //乘法仿函数 template T divides //除法仿函数 template T modulus //取模仿函数 template T negate //取反仿函数 示例：\n#include \u0026lt;functional\u0026gt; //negate void test01() { negate\u0026lt;int\u0026gt; n; cout \u0026lt;\u0026lt; n(50) \u0026lt;\u0026lt; endl; } //plus void test02() { plus\u0026lt;int\u0026gt; p; cout \u0026lt;\u0026lt; p(10, 20) \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：使用内建函数对象时，需要引入头文件 #include 4.3.3 关系仿函数 功能描述：\n实现关系对比 仿函数原型：\ntemplate bool equal_to //等于 template bool not_equal_to //不等于 template bool greater //大于 template bool greater_equal //大于等于 template bool less //小于 template bool less_equal //小于等于 示例：\n#include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class MyCompare { public: bool operator()(int v1,int v2) { return v1 \u0026gt; v2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：关系仿函数中最常用的就是greater\u0026lt;\u0026gt;大于\n4.3.4 逻辑仿函数 功能描述：\n实现逻辑运算 函数原型：\ntemplate bool logical_and //逻辑与 template bool logical_or //逻辑或 template bool logical_not //逻辑非 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;algorithm\u0026gt; void test01() { vector\u0026lt;bool\u0026gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector\u0026lt;bool\u0026gt;::iterator it = v.begin();it!= v.end();it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector\u0026lt;bool\u0026gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not\u0026lt;bool\u0026gt;()); for (vector\u0026lt;bool\u0026gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：逻辑仿函数实际应用较少，了解即可\n5 STL- 常用算法 概述:\n算法主要是由头文件 ``组成。\n``是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等\n``体积很小，只包括几个在序列上面进行简单数学运算的模板函数\n``定义了一些模板类,用以声明函数对象。\n5.1 常用遍历算法 学习目标：\n掌握常用的遍历算法 算法简介：\nfor_each //遍历容器 transform //搬运容器到另一个容器中 5.1.1 for_each 功能描述：\n实现遍历容器 函数原型：\nfor_each(iterator beg, iterator end, _func);\n// 遍历算法 遍历容器元素\n// beg 开始迭代器\n// end 结束迭代器\n// _func 函数或者函数对象\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; //普通函数 void print01(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } //函数对象 class print02 { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; //for_each算法基本用法 void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //遍历算法 for_each(v.begin(), v.end(), print01); cout \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), print02()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握\n5.1.2 transform 功能描述：\n搬运容器到另一个容器中 函数原型：\ntransform(iterator beg1, iterator end1, iterator beg2, _func); //beg1 源容器开始迭代器\n//end1 源容器结束迭代器\n//beg2 目标容器开始迭代器\n//_func 函数或者函数对象\n示例：\n#include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; //常用遍历算法 搬运 transform class TransForm { public: int operator()(int val) { return val; } }; class MyPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint()); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运\n5.2 常用查找算法 学习目标：\n掌握常用的查找算法 算法简介：\nfind //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 5.2.1 find 功能描述：\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型：\nfind(iterator beg, iterator end, value);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// value 查找的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i + 1); } //查找容器中是否有 5 这个元素 vector\u0026lt;int\u0026gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //重载== bool operator==(const Person\u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } return false; } public: string m_Name; int m_Age; }; void test02() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } 总结： 利用find可以在容器中找指定的元素，返回值是迭代器\n5.2.2 find_if 功能描述：\n按条件查找元素 函数原型：\nfind_if(iterator beg, iterator end, _Pred);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 函数或者谓词（返回bool类型的仿函数）\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; //内置数据类型 class GreaterFive { public: bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i + 1); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到大于5的数字:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } public: string m_Name; int m_Age; }; class Greater20 { public: bool operator()(Person \u0026amp;p) { return p.m_Age \u0026gt; 20; } }; void test02() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略\n5.2.3 adjacent_find 功能描述：\n查找相邻重复元素 函数原型：\nadjacent_find(iterator beg, iterator end);\n// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n// beg 开始迭代器\n// end 结束迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector\u0026lt;int\u0026gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;找不到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到相邻重复元素为:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法\n5.2.4 binary_search 功能描述：\n查找指定元素是否存在 函数原型：\nbool binary_search(iterator beg, iterator end, value);\n// 查找指定的元素，查到 返回true 否则false\n// 注意: 在无序序列中不可用\n// beg 开始迭代器\n// end 结束迭代器\n// value 查找的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;找到了\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列\n5.2.5 count 功能描述：\n统计元素个数 函数原型：\ncount(iterator beg, iterator end, value);\n// 统计元素出现次数\n// beg 开始迭代器\n// end 结束迭代器\n// value 统计的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; //内置数据类型 void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout \u0026lt;\u0026lt; \u0026#34;4的个数为： \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } bool operator==(const Person \u0026amp; p) { if (this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age; }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;, 35); Person p2(\u0026#34;关羽\u0026#34;, 35); Person p3(\u0026#34;张飞\u0026#34;, 35); Person p4(\u0026#34;赵云\u0026#34;, 30); Person p5(\u0026#34;曹操\u0026#34;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(\u0026#34;诸葛亮\u0026#34;,35); int num = count(v.begin(), v.end(), p); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 统计自定义数据类型时候，需要配合重载 operator==\n5.2.6 count_if 功能描述：\n按条件统计元素个数 函数原型：\ncount_if(iterator beg, iterator end, _Pred);\n// 按条件统计元素出现次数\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 谓词\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class Greater4 { public: bool operator()(int val) { return val \u0026gt;= 4; } }; //内置数据类型 void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout \u0026lt;\u0026lt; \u0026#34;大于4的个数为： \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; class AgeLess35 { public: bool operator()(const Person \u0026amp;p) { return p.m_Age \u0026lt; 35; } }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;, 35); Person p2(\u0026#34;关羽\u0026#34;, 35); Person p3(\u0026#34;张飞\u0026#34;, 35); Person p4(\u0026#34;赵云\u0026#34;, 30); Person p5(\u0026#34;曹操\u0026#34;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout \u0026lt;\u0026lt; \u0026#34;小于35岁的个数：\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**按值统计用count，按条件统计用count_if\n5.3 常用排序算法 学习目标：\n掌握常用的排序算法 算法简介：\nsort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 5.3.1 sort 功能描述：\n对容器内元素进行排序 函数原型：\nsort(iterator beg, iterator end, _Pred);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 谓词\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void myPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**sort属于开发中最常用的算法之一，需熟练掌握\n5.3.2 shuffle 功能描述：\n洗牌 指定范围内的元素随机调整次序 函数原型：\n`shuffle(iterator beg, iterator end, std::mt19937{std::random_device{}()});\n// 指定范围内的元素随机调整次序\n// beg 开始迭代器\n// end 结束迭代器\n// std::mt19937{std::random_device{}()}随机数生成器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;ctime\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { srand((unsigned int)time(NULL)); vector\u0026lt;int\u0026gt; v; for(int i = 0 ; i \u0026lt; 10;i++) { v.push_back(i); } for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //打乱顺序 shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()}); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**shuffle洗牌算法比较实用，使用时记得加随机数种子\n5.3.3 merge 功能描述：\n两个容器元素合并，并存储到另一容器中 函数原型：\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 容器元素合并，并存储到另一容器中\n// 注意: 两个容器必须是有序的\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10 ; i++) { v1.push_back(i); v2.push_back(i + 1); } vector\u0026lt;int\u0026gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**merge合并的两个容器必须的有序序列\n5.3.4 reverse 功能描述：\n将容器内元素进行反转 函数原型：\nreverse(iterator beg, iterator end);\n// 反转指定范围的元素\n// beg 开始迭代器\n// end 结束迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout \u0026lt;\u0026lt; \u0026#34;反转前： \u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;反转后： \u0026#34; \u0026lt;\u0026lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**reverse反转区间内元素，面试题可能涉及到\n5.4 常用拷贝和替换算法 学习目标：\n掌握常用的拷贝和替换算法 算法简介：\ncopy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 5.4.1 copy 功能描述：\n容器内指定范围的元素拷贝到另一容器中 函数原型：\ncopy(iterator beg, iterator end, iterator dest);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// dest 目标起始迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i + 1); } vector\u0026lt;int\u0026gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间\n5.4.2 replace 功能描述：\n将容器内指定范围的旧元素修改为新元素 函数原型：\nreplace(iterator beg, iterator end, oldvalue, newvalue);\n// 将区间内旧元素 替换成 新元素\n// beg 开始迭代器\n// end 结束迭代器\n// oldvalue 旧元素\n// newvalue 新元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前：\u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中的20 替换成 2000 cout \u0026lt;\u0026lt; \u0026#34;替换后：\u0026#34; \u0026lt;\u0026lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**replace会替换区间内满足条件的元素\n5.4.3 replace_if 功能描述:\n将区间内满足条件的元素，替换成指定元素 函数原型：\nreplace_if(iterator beg, iterator end, _pred, newvalue);\n// 按条件替换元素，满足条件的替换成指定元素\n// beg 开始迭代器\n// end 结束迭代器\n// _pred 谓词\n// newvalue 替换的新元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; class ReplaceGreater30 { public: bool operator()(int val) { return val \u0026gt;= 30; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前：\u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中大于等于的30 替换成 3000 cout \u0026lt;\u0026lt; \u0026#34;替换后：\u0026#34; \u0026lt;\u0026lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n5.4.4 swap 功能描述：\n互换两个容器的元素 函数原型：\nswap(container c1, container c2);\n// 互换两个容器的元素\n// c1容器1\n// c2容器2\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+100); } cout \u0026lt;\u0026lt; \u0026#34;交换前： \u0026#34; \u0026lt;\u0026lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后： \u0026#34; \u0026lt;\u0026lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**swap交换容器时，注意交换的容器要同种类型\n5.5 常用算术生成算法 学习目标：\n掌握常用的算术生成算法 注意：\n算术生成算法属于小型算法，使用时包含的头文件为 #include 算法简介：\naccumulate // 计算容器元素累计总和 fill // 向容器中添加元素 iota // 向容器中填充元素 5.5.1 accumulate 功能描述：\n计算区间内 容器元素累计总和 函数原型：\naccumulate(iterator beg, iterator end, value);\n// 计算容器元素累计总和\n// beg 开始迭代器\n// end 结束迭代器\n// value 起始值\n示例：\n#include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt;= 100; i++) { v.push_back(i); } int total = accumulate(v.begin(), v.end(), 0); cout \u0026lt;\u0026lt; \u0026#34;total = \u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**accumulate使用时头文件注意是 numeric，这个算法很实用\n5.5.2 fill 功能描述：\n向容器中填充指定的元素 函数原型：\nfill(iterator beg, iterator end, value);\n// 向容器中填充元素\n// beg 开始迭代器\n// end 结束迭代器\n// value 填充的值\n示例：\n#include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**利用fill可以将容器区间内元素填充为 指定的值\n5.5.3 iota 功能描述：\n用从起始值开始连续递增的值填充一个范围 函数原型：\niota(ForwardIterator first, ForwardIterator last, T value)\n// 以value为起始值，填充以[first, last);\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::list\u0026lt;int\u0026gt; l(10); std::iota(l.begin(), l.end(), -4); std::vector\u0026lt;std::list\u0026lt;int\u0026gt;::iterator\u0026gt; v(l.size()); std::iota(v.begin(), v.end(), l.begin()); std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()}); std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list: \u0026#34;; for(auto n: l) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list, shuffled: \u0026#34;; for(auto i: v) std::cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 总结：\n以value为起始值，填充以[first, last); 5.6 常用集合算法 学习目标：\n掌握常用的集合算法 算法简介：\nset_intersection // 求两个容器的交集 set_union // 求两个容器的并集 set_difference // 求两个容器的差集 5.6.1 set_intersection 功能描述：\n求两个容器的交集 函数原型：\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的交集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union 功能描述：\n求两个集合的并集 函数原型：\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的并集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference 功能描述：\n求两个集合的差集 函数原型：\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的差集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout \u0026lt;\u0026lt; \u0026#34;v1与v2的差集为： \u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v2与v1的差集为： \u0026#34; \u0026lt;\u0026lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置 5.7 常用比较算法 学习目标：\n掌握常用的比较算法 算法简介：\nmax // 求各给定值中的较大者 min // 求范围中的最大元素 equal // 求两个元素集合是否是相同的 5.7.1 max 功能描述：\n求各给定值中的较大者 函数原型：\nmax( const T\u0026amp; a, const T\u0026amp; b ); // 求各给定值中的较大者\n// a为第一个元素， b为第一个元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;larger of 1 and 9999: \u0026#34; \u0026lt;\u0026lt; std::max(1, 9999) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;larger of \u0026#39;a\u0026#39;, and \u0026#39;b\u0026#39;: \u0026#34; \u0026lt;\u0026lt; std::max(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;longest of \\\u0026#34;foo\\\u0026#34;, \\\u0026#34;bar\\\u0026#34;, and \\\u0026#34;hello\\\u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::max( { \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34; }, [](const std::string\u0026amp; s1, const std::string\u0026amp; s2) { return s1.size() \u0026lt; s2.size(); }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 总结：\n返回两个元素中最大的那一个 5.7.2 min 功能描述：\n求范围中的最小元素 函数原型：\nmin( const T\u0026amp; a, const T\u0026amp; b ); // 求范围中的最小元素\n// a为第一个元素， b为第一个元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;smaller of 1 and 9999 is \u0026#34; \u0026lt;\u0026lt; std::min(1, 9999) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;smaller of \u0026#39;a\u0026#39;, and \u0026#39;b\u0026#39; is \u0026#39;\u0026#34; \u0026lt;\u0026lt; std::min(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;shortest of \\\u0026#34;foo\\\u0026#34;, \\\u0026#34;bar\\\u0026#34;, and \\\u0026#34;hello\\\u0026#34; is \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; std::min({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34; }, [](const std::string_view s1, const std::string_view s2) { return s1.size() \u0026lt; s2.size(); }) \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } 总结：\n返回两个元素中最小的那一个 5.7.3 equal 功能描述：\n求两个容器的元素是否相等 函数原型：\nequal(iterator beg1, iterator end1, iterator beg2, iterator end2); // 求两个容器的元素是否相等\n// beg1为第一个迭代器，end2为第一个迭代器， beg2为第一个迭代器， end2为第一个迭代器，\n示例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; void test(const std::string\u0026amp; s) { if(std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin())) { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a palindrome\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is not a palindrome\\n\u0026#34;; } } int main() { test(\u0026#34;radar\u0026#34;); test(\u0026#34;hello\u0026#34;); } 总结：\n求两个容器的元素是否相等 ","date":"2022-01-23T19:49:07Z","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%9D%BF/","title":"模板"},{"content":" 由于大家都知道原因，国内使用github下载源码和Releases文件时都慢如龟速 下边根据我所使用的方法介绍几种方法\n1. 通过命令行克隆源码 通过添加.cnpmjs.org 在\ngit clone https://github.com/MistEO/MeoAssistantArknights.git 的.com后边添加.cnpmjs.org\ngit clone https://github.com.cnpmjs.org/MistEO/MeoAssistantArknights.git 通过替换为hub.fastgit.org 喜欢的话请他喝杯茶捐赠相关 | FastGit UK Document\n在\ngit clone https://github.com/MistEO/MeoAssistantArknights.git 中把github.com替换为hub.fastgit.org\ngit clone https://hub.fastgit.org/MistEO/MeoAssistantArknights.git 2. 通过浏览器下载资源 下载例如源码zip包，releases文件。\n下载源码zip包 把\nhttps://github.com/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 中的github.com替换为download.fastgit.org\nhttps://download.fastgit.org/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 下载二进制releases文件 此为个人项目喜欢的话请他喝杯茶GitHub Proxy 代理加速 (ghproxy.com)\n通过添加https://ghproxy.com/ 把\nhttps://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip 在https://github添加https://ghproxy.com/\nhttps://ghproxy.com/https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip ","date":"2022-01-19T23:46:32Z","permalink":"https://okokfun.github.io/post/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/","title":"github资源资源下载加速"},{"content":" 容器适配器提供顺序容器的不同接口\nstd::stack 定义于头文件 \u0026lt;stack\u0026gt; std::stack 类是容器适配器，它给予程序员栈的功能——特别是 FILO （先进后出）数据结构。\n该类模板表现为底层容器的包装器——只提供特定函数集合。栈从被称作栈顶的容器尾部推弹元素。\n元素访问 top 访问栈顶元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向栈顶插入元素 (公开成员函数) emplace(C++11) 在顶部原位构造元素 (公开成员函数) pop 删除栈顶元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::queue 适配一个容器以提供队列（FIFO 数据结构） 定义于头文件 \u0026lt;queue\u0026gt;\nstd::queue 类是容器适配器，它给予程序员队列的功能——尤其是 FIFO （先进先出）数据结构。\n类模板表现为底层容器的包装器——只提供特定的函数集合。 queue 在底层容器尾端推入元素，从首端弹出元素。\n元素访问 front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向队列尾部插入元素 (公开成员函数) emplace(C++11) 在尾部原位构造元素 (公开成员函数) pop 删除首个元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::priority_queue 定义于头文件 \u0026lt;queue\u0026gt; priority_queue 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与释出。\n可用用户提供的 Compare 更改顺序，例如，用 std::greater 将导致最小元素作为 top() 出现。\n用 priority_queue 工作类似管理某些随机访问容器中的堆，优势是不可能突然把堆非法化。\n元素访问 top 访问栈顶元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 插入元素，并对底层容器排序 (公开成员函数) emplace(C++11) 原位构造元素并排序底层容器 (公开成员函数) pop 删除队首元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) ","date":"2022-01-19T16:53:19Z","permalink":"https://okokfun.github.io/post/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/","title":"容器适配器"},{"content":" 此文整理与👉容器库 - cppreference.com\n关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。\nstd::set 定义于头文件 \u0026lt;set\u0026gt;\nstd::set 是关联容器，含有 Key 类型对象的已排序集并去重。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。\n返回指向 set 首元素的迭代器。\n若 set 为空，则返回的迭代器将等于 end() 。\n返回值\n指向首元素的迭代器。\n复杂度 常数。\nstd::set\u0026lt;\u0026gt;::begin,std::set\u0026lt;\u0026gt;::cbegin #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; int main() { std::set\u0026lt;int\u0026gt; set = { 3, 1, 4, 1, 5, 9, 2, 6, 5 }; std::for_each(set.cbegin(), set.cend(), [](int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::set\u0026lt;Key,Compare,Allocator\u0026gt;::empty 检查容器是否无元素\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::size 返回容器中的元素数\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::clear 从容器擦除所有元素。此调用后 size() 返回零\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::insert 插入元素到容器，若容器未含拥有等价关键的元素。\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::emplace 若容器中无拥有该关键的元素，则插入以给定的 args 原位构造的新元素到容器。\n细心地使用 emplace 允许在构造新元素的同时避免不必要的复制或移动操作\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::erase 擦除元素\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::find 寻找键等于 key 的的元素。\n#include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::set\u0026lt;int\u0026gt; numbers; std::cout \u0026lt;\u0026lt; \u0026#34;Initially, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; numbers.insert(13317); numbers.insert(3); numbers.insert(2); std::cout \u0026lt;\u0026lt; \u0026#34;After adding elements, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::for_each(numbers.cbegin(), numbers.cend(), [](int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); numbers.emplace(1); numbers.erase(1); uint32_t size = numbers.size(); std::cout \u0026lt;\u0026lt; \u0026#34;nums contains \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; elements.\\n\u0026#34;; auto search = numbers.find(2); if (search != numbers.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; (*search) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } numbers.clear(); return 0; } std::map 键值对的集合，按照键排序，键是唯一的\nstd::map 是有序键值对容器，它的元素的键是唯一的。\n用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。\nmap 通常实现为红黑树。\n元素访问\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::at 返回到拥有等于 key 的关键的元素被映射值的引用。\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::empty 检查容器是否为空\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::size 返回容纳的元素数\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::clear 清除内容\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::insert 插入元素或结点 (C++17 起)\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::insert_or_assign 插入元素，或若键已存在则赋值给当前元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::emplace 原位构造元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::emplace_hint 使用提示原位构造元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::try_emplace 若键不存在则原位插入，若键存在则不做任何事\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::erase 擦除元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::find 寻找带有特定键的元素\nstd::erase_if (std::map) 擦除所有满足特定判别标准的元素\n#include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; int main(void) { std::map\u0026lt;int,int\u0026gt; numbers; numbers.emplace(42, 13); numbers.emplace_hint(41, 12); numbers.insert(std::make_pair(13317, 123)); std::cout \u0026lt;\u0026lt; \u0026#34;After adding elements, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;After elements, numbers.size(): \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; numbers.try_emplace(40, 10); numbers.erase(40); const auto count = std::erase_if(data, [](const auto\u0026amp; item) { auto const\u0026amp; [key, value] = item; return (key \u0026amp; 1) == 1; }); std::cout \u0026lt;\u0026lt; \u0026#34;Erase items with odd keys:\\n\u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; items removed.\\n\u0026#34;; myMap.insert_or_assign(\u0026#34;a\u0026#34;, \u0026#34;apple\u0026#34;); numbers.find(42); std::cout \u0026lt;\u0026lt; \u0026#34;After elements, numbers.clear(): \u0026#34; \u0026lt;\u0026lt; numbers.clear() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } std::multiset 键的集合，按照键排序\n迭代器 begin cbegin(C++11) 返回指向起始的迭代器 (公开成员函数) end cend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegin crbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rend crend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素或结点 (C++17 起) (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) emplace_hint(C++11) 使用提示原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) swap 交换内容 (公开成员函数) extract(C++17) 从另一容器释出结点 (公开成员函数) merge(C++17) 从另一容器接合结点 (公开成员函数) 查找 count 返回匹配特定键的元素数量 (公开成员函数) find 寻找带有特定键的元素 (公开成员函数) contains(C++20) 检查容器是否含有带特定键的元素 (公开成员函数) equal_range 返回匹配特定键的元素范围 (公开成员函数) lower_bound 返回指向首个不小于给定键的元素的迭代器 (公开成员函数) upper_bound 返回指向首个大于给定键的元素的迭代器 erase_if(std::multiset)(C++20) 擦除所有满足特定判别标准的元素 std::multimap 键值对的集合，按照键排序\n迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素或结点 (C++17 起) (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) emplace_hint(C++11) 使用提示原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) swap 交换内容 (公开成员函数) extract(C++17) 从另一容器释出结点 (公开成员函数) merge(C++17) 从另一容器接合结点 (公开成员函数) 查找 count 返回匹配特定键的元素数量 (公开成员函数) find 寻找带有特定键的元素 (公开成员函数) contains(C++20) 检查容器是否含有带特定键的元素 (公开成员函数) equal_range 返回匹配特定键的元素范围 (公开成员函数) lower_bound 返回指向首个不小于给定键的元素的迭代器 (公开成员函数) upper_bound 返回指向首个大于给定键的元素的迭代器 (公开成员函数) 观察器 key_comp 返回用于比较键的函数 (公开成员函数) value_comp 返回用于在value_type类型的对象中比较键的函数。 erase_if(std::multimap)(C++20) 擦除所有满足特定判别标准的元素 ","date":"2022-01-19T16:53:07Z","permalink":"https://okokfun.github.io/post/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","title":"关联容器"},{"content":" 顺序容器实现能按顺序访问的数据结构。\nstd::array 静态的连续数组\n定义于头文件 \u0026lt;array\u0026gt;\nstd::array 是封装 固定大小数组 的容器。 隐式定义的成员函数 (构造函数)(隐式声明) 遵循聚合初始化的规则初始化 array （注意默认初始化可以导致非类的 T 的不确定值） (公开成员函数) (析构函数)(隐式声明) 销毁 array 的每个元素 (公开成员函数) operator=(隐式声明) 以来自另一 array 的每个元素重写 array 的对应元素 (公开成员函数) 元素访问 at(C++11) 访问指定的元素，同时进行越界检查 (公开成员函数) [operator](C++11) 访问指定的元素 (公开成员函数) front(C++11) 访问第一个元素 (公开成员函数) back(C++11) 访问最后一个元素 (公开成员函数) data(C++11) 直接访问底层数组 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty(C++11) 检查容器是否为空 (公开成员函数) size(C++11) 返回容纳的元素数 (公开成员函数) max_size(C++11) 返回可容纳的最大元素数 (公开成员函数) 操作 fill(C++11) 以指定值填充容器 (公开成员函数) swap(C++11) 交换内容 std::vector 定义于头文件 \u0026lt;vector\u0026gt;\nstd::vector 是封装 动态数组 的顺序容器。 at 访问指定的元素，同时进行越界检查 (公开成员函数) [operator] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) data 直接访问底层数组 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) reserve 预留存储空间 (公开成员函数) capacity 返回当前存储空间能够容纳的元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数 (构造函数) 构造 vector (公开成员函数) (析构函数) 析构 vector (公开成员函数) operator= 赋值给容器 (公开成员函数) assign 将值赋给容器 (公开成员函数) get_allocator 返回相关的分配器 (公开成员函数) 元素访问 at 访问指定的元素，同时进行越界检查 (公开成员函数) operator[] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) data 直接访问底层数组 (公开成员函数) 迭代器 begin cbegin(C++11) 返回指向起始的迭代器 (公开成员函数) end cend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegin crbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rend crend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) reserve 预留存储空间 (公开成员函数) capacity 返回当前存储空间能够容纳的元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数\nstd::swap(std::vector)(C++20) 特化std::swap 算法 (函数模板) erase(std::vector) erase_if(std::vector)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::deque 定义于头文件 双端队列\nstd::deque （ double-ended queue ，双端队列）是有 下标顺序容器，它允许在其首尾两端快速插入及删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。\n与 std::vector 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。\ndeque 的存储按需自动扩展及收缩。扩张 deque 比扩张 std::vector 更优，因为它不涉及到复制既存元素到新内存位置。另一方面， deque 典型地拥有较大的最小内存开销；只保有一个元素的 deque 必须分配其整个内部数组（例如 64 位 libstdc++ 上为对象大小 8 倍； 64 位 libc++ 上为对象大小 16 倍或 4096 字节的较大者）。\ndeque 上常见操作的复杂度（效率）如下：\n随机访问——常数 O(1) 在结尾或起始插入或移除元素——常数 O(1) 插入或移除元素——线性 O(n) 元素访问 at 访问指定的元素，同时进行越界检查 (公开成员函数) [operator] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) push_front 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front 移除首元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数\nstd::swap(std::deque) 特化 std::swap 算法 (函数模板) erase(std::deque) erase_if(std::deque)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::forward_list 定义于头文件 \u0026lt;forward_list\u0026gt;\n单链表 std::forward_list 是支持从容器中的任何位置快速插入和移除元素的容器。不支持快速随机访问。它实现为单链表，且实质上与其在 C 中实现相比无任何开销。与 std::list 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。\n在链表内或跨数个链表添加、移除和移动元素，不会非法化当前指代链表中其他元素的迭代器。然而，在从链表移除元素（通过 erase_after ）时，指代对应元素的迭代器或引用会被非法化。\n元素访问 front(C++11) 访问第一个元素 (公开成员函数) 迭代器 before_begincbefore_begin(C++11) 返回指向第一个元素之前迭代器 (公开成员函数) begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) 容量 empty(C++11) 检查容器是否为空 (公开成员函数) max_size(C++11) 返回可容纳的最大元素数 (公开成员函数) 修改器 clear(C++11) 清除内容 (公开成员函数) insert_after(C++11) 在某个元素后插入新元素 (公开成员函数) emplace_after(C++11) 在元素后原位构造元素 (公开成员函数) erase_after(C++11) 擦除元素后的元素 (公开成员函数) push_front(C++11) 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front(C++11) 移除首元素 (公开成员函数) resize(C++11) 改变容器中可存储元素的个数 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) 操作 merge(C++11) 合并二个已排序列表 (公开成员函数) splice_after(C++11) 从另一 forward_list 移动元素 (公开成员函数) removeremove_if(C++11) 移除满足特定标准的元素 (公开成员函数) reverse(C++11) 将该链表的所有元素的顺序反转 (公开成员函数) unique(C++11) 删除连续的重复元素 (公开成员函数) sort(C++11) 对元素进行排序 (公开成员函数) std::swap(std::forward_list)(C++11) 特化 std::swap 算法 (函数模板) erase(std::forward_list) erase_if(std::forward_list)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::list 定义于头文件 \u0026lt;list\u0026gt;\n双链表\nstd::list 是支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。与 std::forward_list 相比，此容器提供双向迭代但在空间上效率稍低。\n在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。\n元素访问 front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) push_front 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front 移除首元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 操作 merge 合并二个已排序列表 (公开成员函数) splice 从另一个list中移动元素 (公开成员函数) removeremove_if 移除满足特定标准的元素 (公开成员函数) reverse 将该链表的所有元素的顺序反转 (公开成员函数) unique 删除连续的重复元素 (公开成员函数) sort 对元素进行排序 (公开成员函数) std::swap(std::list) 特化 std::swap 算法 (函数模板) erase(std::list)erase_if(std::list)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) ","date":"2022-01-19T16:52:52Z","permalink":"https://okokfun.github.io/post/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","title":"顺序容器"},{"content":" 此文来源于👉日期和时间工具 - cppreference.com\n日期和时间工具 std::chrono 库 时钟 时长 时间点 时钟 system_clock(C++11) 来自系统范畴实时时钟的挂钟时间 (类) steady_clock(C++11) 决不会调整的单调时钟 (类) high_resolution_clock(C++11) 拥有可用的最短嘀嗒周期的时钟 (类) is_clockis_clock_v(C++20) 确定类型是否为时钟 (Clock) (类模板) (变量模板) utc_clock(C++20) 协调世界时 (UTC) 的时钟 (Clock) (类) tai_clock(C++20) 国际原子时 (TAI) 的时钟 (Clock) (类) gps_clock(C++20) GPS 时间的时钟 (Clock) (类) file_clock(C++20) 用于文件时间的时钟 (Clock) (typedef) local_t(C++20) 表示本地时间的伪时钟 时间点 时间点是从特定时钟的纪元开始经过的时间时长。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono time_point(C++11) 时间中的点 (类模板) clock_time_conversion(C++20) 定义如何转换一个时钟的时间点为另一个的特性类 (类模板) clock_cast(C++20) 转换一个时钟的时间点为另一个 (函数模板) 时长 时长由时间跨度组成，定义为某时间单位的某个计次数。例如，“ 42 秒”可表示为由 42 个 1 秒时间点位的计次所组成的时长。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono duration(C++11) 时间区间 (类模板) 当天时刻 hh_mm_ss 只要可能就将表示自午夜起经过时间的时长分割成时、分、秒和秒的小数部分。它主要是格式化工具。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono hh_mm_ss(C++20) 表示当天时刻 (类模板) is_am is_pm make12 make24(C++20) 在 12 时和 24 时格式当天时刻之间翻译 (函数) 日历 定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono last_spec(C++20) 指示一个月中最后日期或星期的标签类 (类) day(C++20) 表示月之日期 (类) month(C++20) 表示年之月份 (类) year(C++20) 表示格里高利历中的年 (类) weekday(C++20) 表示格里高利历中星期之日 (类) weekday_indexed(C++20) 表示月份的第 n 个 weekday (类) weekday_last(C++20) 表示月份的最后一个 weekday (类) month_day(C++20) 表示特定 month 的特定 day (类) month_day_last(C++20) 表示特定 month 的最后一日 (类) month_weekday(C++20) 表示特定 month 的第 n 个 weekday (类) month_weekday_last(C++20) 表示特定 month 的最后一个 weekday (类) year_month(C++20) 表示特定 year 的特定 month (类) year_month_day(C++20) 表示特定的 year 、 month 和 day (类) year_month_day_last(C++20) 表示特定 year 和 month 的最后一日 (类) year_month_weekday(C++20) 表示特定 year 和 month 的第 n 个 weekday (类) year_month_weekday_last(C++20) 表示特定 year 和 month 的最后一个 weekday (类) operator/(C++20) 创建格里高利历日期的约定语法 (函数) 时区 定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono tzdb(C++20) 描述 IANA 时区数据库的副本 (类) tzdb_list(C++20) 表示 tzdb 的链表 (类) get_tzdbget_tzdb_listreload_tzdbremote_version(C++20) 访问和控制全球时区数据库信息 (函数) locate_zone(C++20) 定位基于其名称的 time_zone (函数) current_zone(C++20) 返回当前的 time_zone (函数) time_zone(C++20) 表示时区 (类) sys_info(C++20) 表示在特定时间点的关于时区的信息 (类) local_info(C++20) 表示关于从本地时间转换到 UNIX 时间的信息 (类) choose(C++20) 选择应如何解析歧义的本地时间 (枚举) zoned_traits(C++20) zoned_time 所用的时区指针的特性类 (类模板) zoned_time(C++20) 表示时区和时间点 (类) leap_second(C++20) 含有关于插入闰秒的信息 (类) time_zone_link(C++20) 表示时区的替用名 (类) nonexistent_local_time(C++20) 抛出以报告本地时间不存在的异常 (类) ambiguous_local_time(C++20) 抛出以报告本地时间有歧义的异常 (类) 时钟 std::chrono::system_clock::now() 返回表示当前时间的时间点。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;chrono\u0026gt; volatile int sink; int main() { for (auto size = 1ull; size \u0026lt; 1000000000ull; size *= 100) { // 记录开始时间 auto start = std::chrono::system_clock::now(); // 做一些工作 std::vector\u0026lt;int\u0026gt; v(size, 42); sink = std::accumulate(v.begin(), v.end(), 0u); // 确保其副效应 // 记录结束时间 auto end = std::chrono::system_clock::now(); std::chrono::duration\u0026lt;double\u0026gt; diff = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Time to fill and iterate a vector of \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; ints : \u0026#34; \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34; s\\n\u0026#34;; } } std::chrono::steady_clock::now() 返回表示当前时间的时间点。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;chrono\u0026gt; volatile int sink; int main() { for (auto size = 1ull; size \u0026lt; 1000000000ull; size *= 100) { // 记录开始时间 auto start = std::chrono::steady_clock::now(); // 做一些工作 std::vector\u0026lt;int\u0026gt; v(size, 42); sink = std::accumulate(v.begin(), v.end(), 0u); // 确保其副效应 // 记录结束时间 auto end = std::chrono::steady_clock::now(); std::chrono::duration\u0026lt;double\u0026gt; diff = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Time to fill and iterate a vector of \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; ints : \u0026#34; \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34; s\\n\u0026#34;; } } 对时长度量使用 steady_clock ，对壁钟时间使用 system_clock 。\nstd::chrono::utc_clock::now() 返回表示当前时间的时间点\nstd::chrono::tai_clock::now() 返回表示当前时间的时间点。\nstd::chrono::gps_clock::now() 返回表示当前时间的时间点。\nstd::chrono::file_clock::now() 返回表示当前时间的时间点。\n时间点 时间点是从特定时钟的纪元开始经过的时间时长。\nstd::chrono::time_point\u0026lt;std::chrono::system_clock\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;chrono\u0026gt; void slow_motion() { static int a[] {1,2,3,4,5,6,7,8,9,10,11,12}; while (std::ranges::next_permutation(a).found) { } // 生成 12! 个排列 } int main() { using namespace std::literals; // 允许用 24h 、 1ms 、 1s 代替对应的 // std::chrono::hours(24) 等待 const std::chrono::time_point\u0026lt;std::chrono::system_clock\u0026gt; now = std::chrono::system_clock::now(); // “生产代码”可以简化为： // const auto now = std::chrono::system_clock::now(); const std::time_t t_c = std::chrono::system_clock::to_time_t(now - 24h); std::cout \u0026lt;\u0026lt; \u0026#34;24 hours ago, the time was \u0026#34; \u0026lt;\u0026lt; std::put_time(std::localtime(\u0026amp;t_c), \u0026#34;%F %T.\\n\u0026#34;) \u0026lt;\u0026lt; std::flush; const std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; start = std::chrono::steady_clock::now(); // “现实生活”的替用写法会是： // const auto start = std::chrono::steady_clock::now(); slow_motion(); const auto end = std::chrono::steady_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;Slow calculations took \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34;µs ≈ \u0026#34; \u0026lt;\u0026lt; (end - start) / 1ms \u0026lt;\u0026lt; \u0026#34;ms ≈ \u0026#34; // 几乎等价于以上形式， \u0026lt;\u0026lt; (end - start) / 1s \u0026lt;\u0026lt; \u0026#34;s.\\n\u0026#34;; // 但分别使用毫秒和秒 } 时长 摘录自MSVC标准库\nusing nanoseconds = duration\u0026lt;long long, nano\u0026gt; 纳秒 std::chrono::nanoseconds using microseconds = duration\u0026lt;long long, micro\u0026gt; 微秒 std::chrono::microseconds using milliseconds = duration\u0026lt;long long, milli\u0026gt; 毫秒 std::chrono::milliseconds using seconds = duration 秒 std::chrono::seconds using minutes = duration\u0026lt;int, ratio\u0026lt;60\u0026raquo; 分钟 std::chrono::minutes using hours = duration\u0026lt;int, ratio\u0026lt;3600\u0026raquo; 小时 std::chrono::hours using days = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;24\u0026gt;, hours::period\u0026raquo; 天 std::chrono::days using weeks = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;7\u0026gt;, days::period\u0026raquo; 周 std::chrono::weeks using years = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;146097, 400\u0026gt;, days::period\u0026raquo; 年 std::chrono::years using months = duration\u0026lt;int, ratio_divide\u0026lt;years::period, ratio\u0026lt;12\u0026raquo;\u0026gt; 月 std::chrono::months 注意：到 hours 为止的每个预定义时长类型至少涵盖 ±292 年的范围。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; constexpr auto year = 31556952ll; // 格里高利历年的平均秒数 int main() { using shakes = std::chrono::duration\u0026lt;int, std::ratio\u0026lt;1, 100000000\u0026gt;\u0026gt;; using jiffies = std::chrono::duration\u0026lt;int, std::centi\u0026gt;; using microfortnights = std::chrono::duration\u0026lt;float, std::ratio\u0026lt;14*24*60*60, 1000000\u0026gt;\u0026gt;; using nanocenturies = std::chrono::duration\u0026lt;float, std::ratio\u0026lt;100*year, 1000000000\u0026gt;\u0026gt;; std::chrono::seconds sec(1); std::cout \u0026lt;\u0026lt; \u0026#34;1 second is:\\n\u0026#34;; // 无精度损失的整数尺度转换：无转型 std::cout \u0026lt;\u0026lt; std::chrono::microseconds(sec).count() \u0026lt;\u0026lt; \u0026#34; microseconds\\n\u0026#34; \u0026lt;\u0026lt; shakes(sec).count() \u0026lt;\u0026lt; \u0026#34; shakes\\n\u0026#34; \u0026lt;\u0026lt; jiffies(sec).count() \u0026lt;\u0026lt; \u0026#34; jiffies\\n\u0026#34;; // 有精度损失的整数尺度转换：需要转型 std::cout \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::minutes\u0026gt;(sec).count() \u0026lt;\u0026lt; \u0026#34; minutes\\n\u0026#34;; // 浮点尺度转换：无转型 std::cout \u0026lt;\u0026lt; microfortnights(sec).count() \u0026lt;\u0026lt; \u0026#34; microfortnights\\n\u0026#34; \u0026lt;\u0026lt; nanocenturies(sec).count() \u0026lt;\u0026lt; \u0026#34; nanocenturies\\n\u0026#34;; } ","date":"2022-01-18T19:17:29Z","permalink":"https://okokfun.github.io/post/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/","title":"日期和时间工具"},{"content":" 此文来自👉容器库 - cppreference.com\n容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作\n无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。\n1. std::unordered_set 唯一键的集合，按照键生成散列\nunordered_set 是含有 Key 类型唯一对象集合的关联容器。搜索、插入和移除拥有平均常数时间复杂度。\n在内部，元素并 不以任何特别顺序排序，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。\n不可修改容器元素（即使通过非 const 迭代器），因为修改可能 更改元素的哈希，并破坏容器。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_set\u0026gt; int main() { // 创建三个 string 的 unordered_set（映射到 string ） std::unordered_set\u0026lt;std::string\u0026gt; u = { \u0026#34;RED\u0026#34;, \u0026#34;GREEN\u0026#34;, \u0026#34;BLUE\u0026#34; }; // 迭代并打印 unordered_set 的关键和值 for (const auto \u0026amp;n : u) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // // 添加新入口到 unordered_set // \u0026#34;BLACK\u0026#34;; // \u0026#34;WHITE\u0026#34;; u.emplace(\u0026#34;BLACK\u0026#34;); u.emplace(\u0026#34;WHITE\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;-----------------------------------------------\\n\u0026#34;; for (const auto \u0026amp;n : u) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 用关键输出值 for (const auto \u0026amp;n : {\u0026#34;BLACK\u0026#34;, \u0026#34;WHITE\u0026#34;}) { if (u.find(n) != u.end()) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;: Found\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;NOT found\\n\u0026#34;; } } return 0; } 2. std::unordered_map 键值对的集合，按照键生成散列，键是唯一的\nunordered_map 是关联容器，含有带唯一键的键-值 pair 。搜索、插入和元素移除拥有平均常数时间复杂度。\n元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; int main() { // 创建三个 string 的 unordered_map （映射到 string ） std::unordered_map\u0026lt;std::string, std::string\u0026gt; u = { {\u0026#34;RED\u0026#34;,\u0026#34;#FF0000\u0026#34;}, {\u0026#34;GREEN\u0026#34;,\u0026#34;#00FF00\u0026#34;}, {\u0026#34;BLUE\u0026#34;,\u0026#34;#0000FF\u0026#34;} }; // 迭代并打印 unordered_map 的关键和值 for( const auto\u0026amp; n : u ) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:[\u0026#34; \u0026lt;\u0026lt; n.first \u0026lt;\u0026lt; \u0026#34;] Value:[\u0026#34; \u0026lt;\u0026lt; n.second \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; } // 添加新入口到 unordered_map u[\u0026#34;BLACK\u0026#34;] = \u0026#34;#000000\u0026#34;; u[\u0026#34;WHITE\u0026#34;] = \u0026#34;#FFFFFF\u0026#34;; // 用关键输出值 std::cout \u0026lt;\u0026lt; \u0026#34;The HEX of color RED is:[\u0026#34; \u0026lt;\u0026lt; u[\u0026#34;RED\u0026#34;] \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;The HEX of color BLACK is:[\u0026#34; \u0026lt;\u0026lt; u[\u0026#34;BLACK\u0026#34;] \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; return 0; } 3. std::unordered_multiset 键的集合，按照键生成散列\nunordered_multiset 是关联容器，含有可能非唯一 Key 类型对象的集合。搜索、插入和移除拥有平均常数时间复杂度。\n元素在内部并不以任何顺序排序，只是被组织到桶中。元素被放入哪个桶完全依赖其值的哈希。这允许快速访问单独的元素，因为一旦计算哈希，它就指代放置该元素的准确的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_set\u0026gt; int main() { // 简单比较演示 std::unordered_multiset\u0026lt;int\u0026gt; example = {1, 2, 3, 4}; auto search = example.find(2); if (search != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; (*search) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } return 0; } 4. std::unordered_multimap 键值对的集合，按照键生成散列\nunordered_multimap 是无序关联容器，支持等价的关键（一个 unordered_multimap 可含有每个关键值的多个副本）和将关键与另一类型的值关联。 unordered_multimap 类支持向前迭代器。搜索、插入和移除拥有平均常数时间复杂度。\n元素在内部不以任何特定顺序排序，而是组织到桶中。元素被放进哪个桶完全依赖于其关键的哈希。这允许到单独元素的快速访问，因为哈希一旦计算，则它指代元素被放进的准确的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; int main() { // 简单比较演示 std::unordered_multimap\u0026lt;int,char\u0026gt; example = {{1,\u0026#39;a\u0026#39;},{2,\u0026#39;b\u0026#39;}}; auto search = example.find(2); if (search != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; search-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; search-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } return 0; } ","date":"2022-01-18T16:54:33Z","permalink":"https://okokfun.github.io/post/c-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/","title":"C++无序容器"},{"content":" 此文取自于👉动态内存管理 - cppreference.com\nstd::unique_ptr 拥有独有对象所有权语义的智能指针\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;functional\u0026gt; struct B { virtual void bar() { std::cout \u0026lt;\u0026lt; \u0026#34;B::bar\\n\u0026#34;; } virtual ~B() = default; }; struct D : B { D() { std::cout \u0026lt;\u0026lt; \u0026#34;D::D\\n\u0026#34;; } ~D() { std::cout \u0026lt;\u0026lt; \u0026#34;D::~D\\n\u0026#34;; } void bar() override { std::cout \u0026lt;\u0026lt; \u0026#34;D::bar\\n\u0026#34;; } }; // 消费 unique_ptr 的函数能以值或以右值引用接收它 std::unique_ptr\u0026lt;D\u0026gt; pass_through(std::unique_ptr\u0026lt;D\u0026gt; p) { p-\u0026gt;bar(); return p; } void close_file(std::FILE* fp) { std::fclose(fp); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;unique ownership semantics demo\\n\u0026#34;; { auto p = std::make_unique\u0026lt;D\u0026gt;(); // p 是占有 D 的 unique_ptr auto q = pass_through(std::move(p)); assert(!p); // 现在 p 不占有任何内容并保有空指针 q-\u0026gt;bar(); // 而 q 占有 D 对象 } // ~D 调用于此 std::cout \u0026lt;\u0026lt; \u0026#34;Runtime polymorphism demo\\n\u0026#34;; { std::unique_ptr\u0026lt;B\u0026gt; p = std::make_unique\u0026lt;D\u0026gt;(); // p 是占有 D 的 unique_ptr // 作为指向基类的指针 p-\u0026gt;bar(); // 虚派发 std::vector\u0026lt;std::unique_ptr\u0026lt;B\u0026gt;\u0026gt; v; // unique_ptr 能存储于容器 v.push_back(std::make_unique\u0026lt;D\u0026gt;()); v.push_back(std::move(p)); v.emplace_back(new D); for(auto\u0026amp; p: v) p-\u0026gt;bar(); // 虚派发 } // ~D called 3 times std::cout \u0026lt;\u0026lt; \u0026#34;Custom deleter demo\\n\u0026#34;; std::ofstream(\u0026#34;demo.txt\u0026#34;) \u0026lt;\u0026lt; \u0026#39;x\u0026#39;; // 准备要读的文件 { std::unique_ptr\u0026lt;std::FILE, void (*)(std::FILE*) \u0026gt; fp(std::fopen(\u0026#34;demo.txt\u0026#34;, \u0026#34;r\u0026#34;), close_file); if(fp) // fopen 可以打开失败；该情况下 fp 保有空指针 std::cout \u0026lt;\u0026lt; (char)std::fgetc(fp.get()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // fclose() 调用于此，但仅若 FILE* 不是空指针 // （即 fopen 成功） std::cout \u0026lt;\u0026lt; \u0026#34;Custom lambda-expression deleter demo\\n\u0026#34;; { std::unique_ptr\u0026lt;D, std::function\u0026lt;void(D*)\u0026gt;\u0026gt; p(new D, [](D* ptr) { std::cout \u0026lt;\u0026lt; \u0026#34;destroying from a custom deleter...\\n\u0026#34;; delete ptr; }); // p 占有 D p-\u0026gt;bar(); } // 调用上述 lambda 并销毁 D std::cout \u0026lt;\u0026lt; \u0026#34;Array form of unique_ptr demo\\n\u0026#34;; { std::unique_ptr\u0026lt;D[]\u0026gt; p{new D[3]}; } // 调用 ~D 3 次 } std::shared_ptr 拥有共享对象所有权语义的智能指针\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Sample { public: Sample() { std::cout \u0026lt;\u0026lt; \u0026#34;This is Sample.\u0026#34; \u0026lt;\u0026lt; std::endl; } void smartpointer() { std::cout \u0026lt;\u0026lt; \u0026#34;This is smartpointer.\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Sample() { std::cout \u0026lt;\u0026lt; \u0026#34;Destory Sample.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { auto pointer = std::make_shared\u0026lt;Sample\u0026gt;(); // pointer-\u0026gt;smartpointer(); // std::shared_ptr\u0026lt;Sample\u0026gt; sample1(new Sample()); std::shared_ptr\u0026lt;Sample\u0026gt; sample1 = pointer; sample1-\u0026gt;smartpointer(); std::shared_ptr\u0026lt;Sample\u0026gt; sample12(std::make_shared\u0026lt;Sample\u0026gt;()); sample12-\u0026gt;smartpointer(); return 0; } std::weak_ptr 到 std::shared_ptr 所管理对象的弱引用\nstd::weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少\nstd::shared_ptr依然存在着资源无法释放的问题，比如class A中有class B成员变量，class B中有class A成员变量，这种情况就存在引用计数不为0的问题。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; struct A; struct B; struct A { //std::shared_ptr\u0026lt;B\u0026gt; pointer; std::weak_ptr\u0026lt;B\u0026gt; ptr; std::shared_ptr\u0026lt;B\u0026gt; ptr_ = ptr.lock(); ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A 被销毁\u0026#34; \u0026lt;\u0026lt; std::endl; } }; struct B { //std::shared_ptr\u0026lt;A\u0026gt; pointer; std::weak_ptr\u0026lt;A\u0026gt; ptr; std::shared_ptr\u0026lt;A\u0026gt; ptr_ = ptr.lock(); ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;B 被销毁\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { auto a = std::make_shared\u0026lt;A\u0026gt;(); //std::weak_ptr\u0026lt;A\u0026gt; ptr_a(a); auto b = std::make_shared\u0026lt;B\u0026gt;(); //std::weak_ptr\u0026lt;B\u0026gt; ptr_b(b); a-\u0026gt;ptr = b; //a-\u0026gt;pointer = b; b-\u0026gt;ptr = a; //b-\u0026gt;pointer = a; } 结果： End.\n","date":"2022-01-18T13:20:39Z","permalink":"https://okokfun.github.io/post/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"动态内存管理"},{"content":" 此文来源于👉文件系统库 - cppreference.com，并整理。\n库范畴定义 文件：持有数据的文件系统对象，能被写入或读取，或二者皆可。文件拥有名称及属性，属性之一是文件类型： 目录：表现为目录条目的容器的文件，目录条目标识其他文件（其中一些可以是另外的嵌套的目录）。讨论到具体文件时，包含该文件目录条目的目录是其父目录。父目录能以相对路径名 \u0026ldquo;..\u0026rdquo; 表示。 硬链接：关联一个名字到一个既存文件的目录条目。若支持多重硬链接，则文件在最后一个到它的硬链接被移除后才被移除。 符号链接：关联一个名词到一个路径的目录条目，路径可以存在亦可不存在。 常规文件：不是其他文件类型的文件。 文件名：命名一个文件的字符串。容许字符、大小写区别、最大长度以及被禁止名称是实现定义的。名称 \u0026ldquo;.\u0026rdquo; （点）与 \u0026ldquo;..\u0026rdquo; （双点）在库层次拥有特殊含义。 路径：标识一个文件的元素序列。它以可选的 根名 （例如 Windows 上的 \u0026ldquo;C:\u0026rdquo; 或 \u0026ldquo;//server\u0026rdquo; ）开始，后随可选的 根目录 （例如 Unix 上的 \u0026ldquo;/\u0026rdquo; ），后随零或更多个文件名（除了最后一个都必须是目录或到目录的链接）的序列。表示路径的字符串（路径名）的原生格式（如哪些字符被用作分隔符）与字符编码是实现定义的，库提供路径的可移植表示。 绝对路径：无歧义地标识一个文件位置的路径。 规范路径：不包含符号链接、 \u0026ldquo;.\u0026rdquo; 或 \u0026ldquo;..\u0026rdquo; 元素的绝对路径。 相对路径：标识相对于文件系统中某位置的文件位置的路径。特殊路径名 \u0026ldquo;.\u0026rdquo; （点，“当前目录”）和 \u0026ldquo;..\u0026rdquo; （双点、“父目录”）是相对路径。 类 定义于头文件 \u0026lt;filesystem\u0026gt; 定义于命名空间 std::filesystem path(C++17) 表示路径 (类) filesystem_error(C++17) 文件系统错误时抛出的异常 (类) directory_entry(C++17) 目录条目 (类) directory_iterator(C++17) 指向目录内容的迭代器 (类) recursive_directory_iterator(C++17) 指向一个目录及其子目录的内容的迭代器 (类) file_status(C++17) 表示文件类型及权限 (类) space_info(C++17) 关于文件系统上空闲及可用空间的信息 (类) file_type(C++17) 文件的类型 (枚举) perms(C++17) 标识文件系统权限 (枚举) perm_options(C++17) 指定权限操作的语义 (枚举) copy_options(C++17) 指定复制操作的语义 (枚举) directory_options(C++17) 用于迭代目录内容的选项 (枚举) file_time_type(C++17) 表示文件时间值 (typedef) 非成员函数 定义于头文件 \u0026lt;filesystem\u0026gt; 定义于命名空间 std::filesystem absolute(C++17) 组成一个绝对路径 (函数) canonicalweakly_canonical(C++17) 组成一个规范路径 (函数) relativeproximate(C++17) 组成一个相对路径 (函数) copy(C++17) 复制文件或目录 (函数) copy_file(C++17) 复制文件内容 (函数) copy_symlink(C++17) 复制一个符号链接 (函数) create_directory create_directories(C++17)(C++17) 创建新目录 (函数) create_hard_link(C++17) 创建一个硬链接 (函数) create_symlink create_directory_symlink(C++17)(C++17) 创建一个符号链接 (函数) current_path(C++17) 返回或设置当前工作目录 (函数) exists(C++17) 检查路径是否指代既存的文件系统对象 (函数) equivalent(C++17) 检查两个路径是否指代同一文件系统对象 (函数) file_size(C++17) 返回文件的大小 (函数) hard_link_count(C++17) 返回指代特定文件的硬链接数 (函数) last_write_time(C++17) 获取或设置最近一次数据修改的时间 (函数) permissions(C++17) 修改文件访问权限 (函数) read_symlink(C++17) 获得符号链接的目标 (函数) remove remove_all(C++17)(C++17) 移除一个文件或空目录 移除一个文件或递归地移除一个目录及其所有内容 (函数) rename(C++17) 移动或重命名一个文件或目录 (函数) resize_file(C++17) 以截断或填充零更改一个常规文件的大小 (函数) space(C++17) 确定文件系统上的可用空闲空间 (函数) status symlink_status(C++17)(C++17) 确定文件属性 确定文件属性，检查符号链接目标 (函数) temp_directory_path(C++17) 返回一个适用于临时文件的目录 (函数) 文件类型 is_block_file(C++17) 检查给定的路径是否表示块设备 (函数) is_character_file(C++17) 检查给定的路径是否表示字符设备 (函数) is_directory(C++17) 检查给定的路径是否表示一个目录 (函数) is_empty(C++17) 检查给定的路径是否表示一个空文件或空目录 (函数) is_fifo(C++17) 检查给定的路径是否表示一个命名管道 (函数) is_other(C++17) 检查参数是否表示一个其他文件 (函数) is_regular_file(C++17) 检查参数是否表示一个常规文件 (函数) is_socket(C++17) 检查参数是否表示一个具名 IPC 套接字 (函数) is_symlink(C++17) 检查参数是否表示一个符号链接 (函数) status_known(C++17) 检查参数是否表示一个符号链接 (函数) ","date":"2022-01-16T15:16:11Z","permalink":"https://okokfun.github.io/post/c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/","title":"C++文件系统库"},{"content":" 此文章来源于👉正则表达式库 - cppreference.com,并整理\n正则表达式库提供表示正则表达式的类，正则表达式是一种用于在字符串中匹配模式的微型语言。\n定义于头文件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string s = \u0026#34;Some people, when confronted with a problem, think \u0026#34; \u0026#34;\\\u0026#34;I know, I\u0026#39;ll use regular expressions.\\\u0026#34; \u0026#34; \u0026#34;Now they have two problems.\u0026#34;; std::regex self_regex(\u0026#34;REGULAR EXPRESSIONS\u0026#34;, std::regex_constants::ECMAScript | std::regex_constants::icase); if (std::regex_search(s, self_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;Text contains the phrase \u0026#39;regular expressions\u0026#39;\\n\u0026#34;; } std::regex word_regex(\u0026#34;(\\\\w+)\u0026#34;); auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex); auto words_end = std::sregex_iterator(); std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; std::distance(words_begin, words_end) \u0026lt;\u0026lt; \u0026#34; words\\n\u0026#34;; const int N = 6; std::cout \u0026lt;\u0026lt; \u0026#34;Words longer than \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; characters:\\n\u0026#34;; for (std::sregex_iterator i = words_begin; i != words_end; ++i) { std::smatch match = *i; std::string match_str = match.str(); if (match_str.size() \u0026gt; N) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; match_str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } std::regex long_word_regex(\u0026#34;(\\\\w{7,})\u0026#34;); std::string new_s = std::regex_replace(s, long_word_regex, \u0026#34;[$\u0026amp;]\u0026#34;); std::cout \u0026lt;\u0026lt; new_s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 算法 regex_match(C++11) 尝试匹配一个正则表达式到整个字符序列 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { // 简单正则表达式匹配 std::string fnames[] = {\u0026#34;foo.txt\u0026#34;, \u0026#34;bar.txt\u0026#34;, \u0026#34;baz.dat\u0026#34;, \u0026#34;zoidberg\u0026#34;}; std::regex txt_regex(\u0026#34;[a-z]+\\\\.txt\u0026#34;); for (const auto \u0026amp;fname : fnames) { std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::regex_match(fname, txt_regex) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 提取子匹配 std::regex base_regex(\u0026#34;([a-z]+)\\\\.txt\u0026#34;); std::smatch base_match; for (const auto \u0026amp;fname : fnames) { if (std::regex_match(fname, base_match, base_regex)) { // 首个 sub_match 是整个字符串；下个 // sub_match 是首个有括号表达式。 if (base_match.size() == 2) { std::ssub_match base_sub_match = base_match[1]; std::string base = base_sub_match.str(); std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#34; has a base of \u0026#34; \u0026lt;\u0026lt; base \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } // 提取几个子匹配 std::regex pieces_regex(\u0026#34;([a-z]+)\\\\.([a-z]+)\u0026#34;); std::smatch pieces_match; for (const auto \u0026amp;fname : fnames) { if (std::regex_match(fname, pieces_match, pieces_regex)) { std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (size_t i = 0; i \u0026lt; pieces_match.size(); ++i) { std::ssub_match sub_match = pieces_match[i]; std::string piece = sub_match.str(); std::cout \u0026lt;\u0026lt; \u0026#34; submatch \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; piece \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } } regex_search(C++11) 尝试匹配一个正则表达式到字符序列的任何部分 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string lines[] = {\u0026#34;Roses are #ff0000\u0026#34;, \u0026#34;violets are #0000ff\u0026#34;, \u0026#34;all of my base are belong to you\u0026#34;}; std::regex color_regex(\u0026#34;#([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34;); // 简单匹配 for (const auto \u0026amp;line : lines) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::regex_search(line, color_regex) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 展示每个匹配中有标记子表达式的内容 std::smatch color_match; for (const auto\u0026amp; line : lines) { if(std::regex_search(line, color_match, color_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;matches for \u0026#39;\u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Prefix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.prefix() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; for (size_t i = 0; i \u0026lt; color_match.size(); ++i) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; color_match[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Suffix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.suffix() \u0026lt;\u0026lt; \u0026#34;\\\u0026#39;\\n\\n\u0026#34;; } } // 重复搜索（参阅 std::regex_iterator ） std::string log(R\u0026#34;( Speed:\t366 Mass:\t35 Speed:\t378 Mass:\t32 Speed:\t400 Mass:\t30)\u0026#34;); std::regex r(R\u0026#34;(Speed:\\t\\d*)\u0026#34;); std::smatch sm; while(regex_search(log, sm, r)) { std::cout \u0026lt;\u0026lt; sm.str() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; log = sm.suffix(); } // C 风格字符串演示 std::cmatch cm; if(std::regex_search(\u0026#34;this is a test\u0026#34;, cm, std::regex(\u0026#34;test\u0026#34;))) std::cout \u0026lt;\u0026lt; \u0026#34;\\nFound \u0026#34; \u0026lt;\u0026lt; cm[0] \u0026lt;\u0026lt; \u0026#34; at position \u0026#34; \u0026lt;\u0026lt; cm.prefix().length(); } regex_replace(C++11) 以格式化的替换文本来替换正则表达式匹配的出现位置 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string text = \u0026#34;Quick brown fox\u0026#34;; std::regex vowel_re(\u0026#34;a|e|i|o|u\u0026#34;); // 写结果到输出迭代器 std::regex_replace(std::ostreambuf_iterator\u0026lt;char\u0026gt;(std::cout), text.begin(), text.end(), vowel_re, \u0026#34;*\u0026#34;); // 构造保有结果的字符串 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; std::regex_replace(text, vowel_re, \u0026#34;[$\u0026amp;]\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 迭代器 regex_iterator 用于遍历在序列中找到的匹配正则表达式的整个集合。\nregex_iterator(C++11) 迭代一个字符序列中的所有正则表达式匹配 (类模板)\n#include \u0026lt;regex\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { const std::string s = \u0026#34;Quick brown fox.\u0026#34;; std::regex words_regex(\u0026#34;[^\\\\s]+\u0026#34;); auto words_begin = std::sregex_iterator(s.begin(), s.end(), words_regex); auto words_end = std::sregex_iterator(); std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; std::distance(words_begin, words_end) \u0026lt;\u0026lt; \u0026#34; words:\\n\u0026#34;; for (std::sregex_iterator i = words_begin; i != words_end; ++i) { std::smatch match = *i; std::string match_str = match.str(); std::cout \u0026lt;\u0026lt; match_str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } regex_token_iterator(C++11) 迭代给定字符串中的所有正则表达式匹配中的指定子表达式，或迭代未匹配的子字符串 (类模板)\n#include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string text = \u0026#34;Quick brown fox.\u0026#34;; // 记号化（非匹配碎片） // 注意仅匹配二次 regex ：在获得第三值时迭代器为后缀迭代器。 std::regex ws_re(\u0026#34;\\\\s+\u0026#34;); // 空白符 std::copy( std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1), std::sregex_token_iterator(), std::ostream_iterator\u0026lt;std::string\u0026gt;(std::cout, \u0026#34;\\n\u0026#34;)); // 迭代首个子匹配 std::string html = \u0026#34;\u0026lt;p\u0026gt;\u0026lt;a href=\\\u0026#34;http://google.com\\\u0026#34;\u0026gt;google\u0026lt;/a\u0026gt; \u0026#34; \u0026#34;\u0026lt; a HREF =\\\u0026#34;http://cppreference.com\\\u0026#34;\u0026gt;cppreference\u0026lt;/a\u0026gt;\\n\u0026lt;/p\u0026gt;\u0026#34;; std::regex url_re(\u0026#34;\u0026lt;\\\\s*A\\\\s+[^\u0026gt;]*href\\\\s*=\\\\s*\\\u0026#34;([^\\\u0026#34;]*)\\\u0026#34;\u0026#34;, std::regex::icase); std::copy( std::sregex_token_iterator(html.begin(), html.end(), url_re, 1), std::sregex_token_iterator(), std::ostream_iterator\u0026lt;std::string\u0026gt;(std::cout, \u0026#34;\\n\u0026#34;)); } ","date":"2022-01-16T14:45:25Z","permalink":"https://okokfun.github.io/post/c-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"C++正则表达式"},{"content":" 此文来自于👉线程支持库 - cppreference.com\n线程支持库 thread(C++11) std::thread 类与支持函数 stop_token(C++20) std::jthread 的停止记号 mutex(C++11) 互斥元件 shared_mutex(C++14) 共享互斥元件 future(C++11) 异步计算元件 condition_variable(C++11) 线程等待条件 semaphore(C++20) 信号量 latch(C++20) 闩 barrier(C++20) 屏障 #include \u0026lt;thread\u0026gt; std::thread thread类 表示单个执行线程。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { std::thread th1; } std:🧵:id thread::id类 是轻量的可频繁复制类，它作为 std::thread 对象的唯一标识符工作。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; typedef unsigned long long ULL; std::string getThreadIdOfString(const std:🧵:id \u0026amp; id) { std::stringstream sin; sin \u0026lt;\u0026lt; id; return sin.str(); } ULL getThreadIdOfULL(const std:🧵:id \u0026amp; id) { return std::stoull(getThreadIdOfString(id)); } int main() { std:🧵:id id = std::this_thread::get_id(); std::cout \u0026lt;\u0026lt; \u0026#34;cout ----- id : \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;getThreadIdOfString ----- id : \u0026#34; \u0026lt;\u0026lt; getThreadIdOfString(id) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;getThreadIdOfULL ----- id : \u0026#34; \u0026lt;\u0026lt; getThreadIdOfULL(id) \u0026lt;\u0026lt; std::endl; return 0; } std:🧵:hardware_concurrency() 返回处理器支持的并发线程数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { unsigned int n = std:🧵:hardware_concurrency(); std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; concurrent threads are supported.\\n\u0026#34;; return 0; } std:🧵:native_handle() 返回实现定义的底层线程柄。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;pthread.h\u0026gt; std::mutex iomutex; void f(int num) { std::this_thread::sleep_for(std::chrono::seconds(1)); sched_param sch; int policy; pthread_getschedparam(pthread_self(), \u0026amp;policy, \u0026amp;sch); std::lock_guard\u0026lt;std::mutex\u0026gt; lk(iomutex); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; is executing at priority \u0026#34; \u0026lt;\u0026lt; sch.sched_priority \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::thread t1(f, 1), t2(f, 2); sched_param sch; int policy; pthread_getschedparam(t1.native_handle(), \u0026amp;policy, \u0026amp;sch); sch.sched_priority = 20; if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, \u0026amp;sch)) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to setschedparam: \u0026#34; \u0026lt;\u0026lt; std::strerror(errno) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } t1.join(); t2.join(); return 0; } std:🧵:join() 等待线程完成其执行\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void foo() { // 模拟耗费大量资源的操作 std::this_thread::sleep_for(std::chrono::seconds(1)); } void bar() { // 模拟耗费大量资源的操作 std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;starting first helper...\\n\u0026#34;; std::thread helper1(foo); std::cout \u0026lt;\u0026lt; \u0026#34;starting second helper...\\n\u0026#34;; std::thread helper2(bar); std::cout \u0026lt;\u0026lt; \u0026#34;waiting for helpers to finish...\u0026#34; \u0026lt;\u0026lt; std::endl; helper1.join(); helper2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;done!\\n\u0026#34;; return 0; } std:🧵:detach() 容许线程从线程句柄独立开来执行\n从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; void independentThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Starting concurrent thread.\\n\u0026#34;; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Exiting concurrent thread.\\n\u0026#34;; } void threadCaller() { std::cout \u0026lt;\u0026lt; \u0026#34;Starting thread caller.\\n\u0026#34;; std::thread t(independentThread); t.detach(); std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Exiting thread caller.\\n\u0026#34;; } int main() { threadCaller(); std::this_thread::sleep_for(std::chrono::seconds(5)); return 0; } std:🧵:swap 交换二个 thread 对象的底层柄。\n交换二个 thread 对象\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void foo() { std::this_thread::sleep_for(std::chrono::seconds(1)); } void bar() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::thread t1(foo); std::thread t2(bar); std::cout \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::swap(t1, t2); std::cout \u0026lt;\u0026lt; \u0026#34;after std::swap(t1, t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t1.swap(t2); std::cout \u0026lt;\u0026lt; \u0026#34;after t1.swap(t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t1.join(); t2.join(); return 0; } std::this_thread::yield() 建议实现重新调度各执行线程\n提供提示给实现，以重调度线程的执行，允许其他线程运行\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; // 建议其他线程运行一小段时间的“忙睡眠” void little_sleep(std::chrono::microseconds us) { auto start = std::chrono::high_resolution_clock::now(); auto end = start + us; do { std::this_thread::yield(); } while (std::chrono::high_resolution_clock::now() \u0026lt; end); } int main() { auto start = std::chrono::high_resolution_clock::now(); little_sleep(std::chrono::microseconds(100)); auto elapsed = std::chrono::high_resolution_clock::now() - start; std::cout \u0026lt;\u0026lt; \u0026#34;waited for \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(elapsed).count() \u0026lt;\u0026lt; \u0026#34; microseconds\\n\u0026#34;; return 0; } std::this_thread::get_id() 返回当前线程的线程 id\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex g_display_mutex; void foo() { std:🧵:id this_id = std::this_thread::get_id(); g_display_mutex.lock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; this_id \u0026lt;\u0026lt; \u0026#34; sleeping...\\n\u0026#34;; g_display_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::thread t1(foo); std::thread t2(foo); t1.join(); t2.join(); return 0; } std::this_thread::sleep_for() 使当前线程的执行停止指定的时间段\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; int main() { using namespace std::chrono_literals; std::cout \u0026lt;\u0026lt; \u0026#34;Hello waiter\\n\u0026#34; \u0026lt;\u0026lt; std::flush; auto start = std::chrono::high_resolution_clock::now(); std::this_thread::sleep_for(2000ms); auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; elapsed = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Waited \u0026#34; \u0026lt;\u0026lt; elapsed.count() \u0026lt;\u0026lt; \u0026#34; ms\\n\u0026#34;; return 0; } std::this_thread::sleep_until() 使当前线程的执行停止直到指定的时间点\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;thread\u0026gt; #pragma warning(disable:4996)//加上可去掉unsafe 请使用localtime_s的编译报错 int main() { using std::chrono::system_clock; std::time_t tt = system_clock::to_time_t(system_clock::now()); struct std::tm *ptm = std::localtime(\u0026amp;tt); std::cout \u0026lt;\u0026lt; \u0026#34;Current time: \u0026#34; \u0026lt;\u0026lt; std::put_time(ptm, \u0026#34;%X\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //必须大写X，若小写x，输出的为日期 std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for the next minute to begin...\\n\u0026#34;; ++ptm-\u0026gt;tm_min; ptm-\u0026gt;tm_sec = 0; std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm))); std::cout \u0026lt;\u0026lt; std::put_time(ptm, \u0026#34;%X\u0026#34;) \u0026lt;\u0026lt; \u0026#34;reached!\\n\u0026#34;; return 0; } 互斥 #include \u0026lt;mutex\u0026gt; std::mutex::lock() 锁定互斥。若另一线程已锁定互斥，则到 lock 的调用将阻塞执行，直至获得锁。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::mutex::try_lock() 尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (mutex.try_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; mutex.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::mutex::unlock() 解锁互斥\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex timed_mutex 类是能用于保护数据免受多个线程同时访问的同步原语。\nstd::timed_mutex::lock() 锁定互斥。若另一线程已锁定互斥，则到 lock 的调用将阻塞执行，直至获得锁。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex::unlock() 解锁互斥。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex::try_lock() 尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。\nstd::timed_mutex::try_lock_for() 尝试锁定互斥，若互斥在指定的时限时期中不可用则返回\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;sstream\u0026gt; std::mutex cout_mutex; // 控制到 std::cout 的访问 std::timed_mutex mutex; void job(int id) { using Ms = std::chrono::milliseconds; std::ostringstream stream; for (int i = 0; i \u0026lt; 3; ++i) { if (mutex.try_lock_for(Ms(100))) { stream \u0026lt;\u0026lt; \u0026#34;success \u0026#34;; std::this_thread::sleep_for(Ms(100)); mutex.unlock(); } else { stream \u0026lt;\u0026lt; \u0026#34;failed \u0026#34;; } std::this_thread::sleep_for(Ms(100)); } std::lock_guard\u0026lt;std::mutex\u0026gt; lock(cout_mutex); std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;] \u0026#34; \u0026lt;\u0026lt; stream.str() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; for (int i = 0; i \u0026lt; 4; ++i) { threads.emplace_back(job, i); } for (auto\u0026amp; i: threads) { i.join(); } } std::timed_mutex::try_lock_until() 尝试锁定互斥，若直至抵达指定时间点互斥不可用则返回\n尝试所互斥。阻塞直至抵达指定的 timeout_time 或得到锁，取决于何者先到来。成功获得锁时返回 true ，否则返回 false 。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; std::timed_mutex test_mutex; void f() { auto now=std::chrono::steady_clock::now(); test_mutex.try_lock_until(now + std::chrono::seconds(10)); std::cout \u0026lt;\u0026lt; \u0026#34;hello world\\n\u0026#34;; } int main() { std::lock_guard\u0026lt;std::timed_mutex\u0026gt; l(test_mutex); std::thread t(f); t.join(); return 0; } std::lock_guard\u0026lt;std::mutex\u0026gt; 实现严格基于作用域的互斥体所有权包装器\n创建 lock_guard 对象时，它试图接收给定互斥的所有权。控制离开创建 lock_guard 对象的作用域时，销毁 lock_guard 并释放互斥。\nlock_guard 类不可复制。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; int g_i = 0; std::mutex g_i_mutex; // 保护 g_i void safe_increment() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(g_i_mutex); ++g_i; std::cout \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // g_i_mutex 在锁离开作用域时自动释放 } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;main: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::thread t1(safe_increment); std::thread t2(safe_increment); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;main: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } std::unique_lock\u0026lt;Mutex\u0026gt;::lock 等效地调用 mutex()-\u0026gt;lock()\n#include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { int counter = 0; std::mutex counter_mutex; std::vector\u0026lt;std::thread\u0026gt; threads; auto worker_task = [\u0026amp;](int id) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(counter_mutex); ++counter; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, initial counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lock.unlock(); // 我们模拟昂贵操作时不保有锁 std::this_thread::sleep_for(std::chrono::seconds(1)); lock.lock(); // 可以不解锁，因为是智能锁 ++counter; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, final counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; for (int i = 0; i \u0026lt; 10; ++i) threads.emplace_back(worker_task, i); for (auto \u0026amp;thread : threads) thread.join(); return 0; } std::unique_lock\u0026lt;std::mutex\u0026gt; 类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用\n类 unique_lock 可移动，但不可复制\n#include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; struct Box { explicit Box(int num) : num_things{num} {} int num_things; std::mutex m; }; void transfer(Box \u0026amp;from, Box \u0026amp;to, int num) { // 仍未实际取锁 std::unique_lock\u0026lt;std::mutex\u0026gt; lock1(from.m, std::defer_lock); std::unique_lock\u0026lt;std::mutex\u0026gt; lock2(to.m, std::defer_lock); // 锁两个 unique_lock 而不死锁 std::lock(lock1, lock2); from.num_things -= num; to.num_things += num; // \u0026#39;from.m\u0026#39; 与 \u0026#39;to.m\u0026#39; 互斥解锁于 \u0026#39;unique_lock\u0026#39; 析构函数 } int main() { Box acc1(100); Box acc2(50); std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10); std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5); t1.join(); t2.join(); return 0; } std::unique_lock\u0026lt;Mutex\u0026gt;::try_lock 尝试锁定关联互斥，若互斥不可用则返回\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (std::unique_lock\u0026lt;std::mutex\u0026gt;::try_lock lk(mutex)) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; lk.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::unique_lock\u0026lt;Mutex\u0026gt;::try_lock_for 试图锁定关联的可定时锁定 (TimedLockable) 互斥，若互斥在给定时长中不可用则返回\nbool try_lock_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration );\ntimeout_duration - 要阻塞的最大时长\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (std::unique_lock\u0026lt;std::mutex\u0026gt;::try_lock_for lk(mutex)) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; lk.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::call_once 仅调用函数一次，即使从多个线程调用\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::once_flag flag1, flag2; void simple_do_once() { std::call_once(flag1, [](){ std::cout \u0026lt;\u0026lt; \u0026#34;Simple example: called once\\n\u0026#34;; }); } void may_throw_function(bool do_throw) { if (do_throw) { std::cout \u0026lt;\u0026lt; \u0026#34;throw: call_once will retry\\n\u0026#34;; // 这会出现多于一次 throw std::exception(); } std::cout \u0026lt;\u0026lt; \u0026#34;Didn\u0026#39;t throw, call_once will not attempt again\\n\u0026#34;; // 保证一次 } void do_once(bool do_throw) { try { std::call_once(flag2, may_throw_function, do_throw); } catch (...) { } } int main() { std::thread st1(simple_do_once); std::thread st2(simple_do_once); std::thread st3(simple_do_once); std::thread st4(simple_do_once); st1.join(); st2.join(); st3.join(); st4.join(); std::thread t1(do_once, true); std::thread t2(do_once, true); std::thread t3(do_once, false); std::thread t4(do_once, true); t1.join(); t2.join(); t3.join(); t4.join(); return 0; } 结果\nSimple example: called once throw: call_once will retry 条件变量 条件变量是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥。\n定义于头文件 \u0026lt;condition_variable\u0026gt;\nstd::condition_variable 提供与 std::unique_lock 关联的条件变量\ncondition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex m; std::condition_variable cv; std::string data; bool ready = false; bool processed = false; void worker_thread() { // 等待直至 main() 发送数据 std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m); cv.wait(lk, []{return ready;}); // 等待后，我们占有锁。 std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is processing data\\n\u0026#34;; data += \u0026#34; after processing\u0026#34;; // 发送数据回 main() processed = true; std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread signals data processing completed\\n\u0026#34;; // 通知前完成手动解锁，以避免等待线程才被唤醒就阻塞（细节见 notify_one ） lk.unlock(); cv.notify_one(); } int main() { std::thread worker(worker_thread); data = \u0026#34;Example data\u0026#34;; // 发送数据到 worker 线程 { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); ready = true; std::cout \u0026lt;\u0026lt; \u0026#34;main() signals data ready for processing\\n\u0026#34;; } cv.notify_one(); // 等候 worker { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m); cv.wait(lk, []{return processed;}); } std::cout \u0026lt;\u0026lt; \u0026#34;Back in main(), data = \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker.join(); } std::condition_variable::notify_all() 解阻塞全部当前等待于 *this 的线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; // 此互斥用于三个目的： // 1) 同步到 i 的访问 // 2) 同步到 std::cerr 的访问 // 3) 为条件变量 cv int i = 0; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cerr \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; } cv.notify_all(); std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; } cv.notify_all(); } int main() { std::thread t1(waits), t2(waits), t3(waits), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } std::condition_variable::notify_one() 若任何线程在 *this 上等待，则调用 notify_one 会解除一个阻塞等待线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; int i = 0; bool done = false; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cout \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; done = true; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Notifying falsely...\\n\u0026#34;; cv.notify_one(); // 等待线程被通知 i == 0. // cv.wait 唤醒，检查 i ，再回到等待 std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; while (!done) { std::cout \u0026lt;\u0026lt; \u0026#34;Notifying true change...\\n\u0026#34;; lk.unlock(); cv.notify_one(); // 等待线程被通知 i == 1 ， cv.wait 返回 std::this_thread::sleep_for(std::chrono::seconds(1)); lk.lock(); } } int main() { std::thread t1(waits), t2(signals); t1.join(); t2.join(); } std::condition_variable::wait() wait 导致当前线程阻塞直至条件变量被通知，或虚假唤醒发生，可选地循环直至满足某谓词。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; // 此互斥用于三个目的： // 1) 同步到 i 的访问 // 2) 同步到 std::cerr 的访问 // 3) 为条件变量 cv int i = 0; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cerr \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; } cv.notify_all(); std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; } cv.notify_all(); } int main() { std::thread t1(waits), t2(waits), t3(waits), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } std::condition_variable::wait_for() 阻塞当前线程，直到条件变量被唤醒，或到指定时限时长后\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std::chrono_literals; std::condition_variable cv; std::mutex cv_m; std::atomic\u0026lt;int\u0026gt; i{0}; void waits(int idx) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); auto now = std::chrono::system_clock::now(); if(cv.wait_until(lk, now + idx*100ms, [](){return i == 1;})) std::cerr \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; finished waiting. i == \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cerr \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; timed out. i == \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void signals() { std::this_thread::sleep_for(120ms); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; cv.notify_all(); std::this_thread::sleep_for(100ms); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; cv.notify_all(); } int main() { std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } 信号量 信号量 (semaphore) 是一种轻量的同步原件，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率。\n定义于头文件 \u0026lt;semaphore\u0026gt;\nstd::counting_semaphore, std::binary_semaphore \\1) counting_semaphore 是一个轻量同步元件，能控制对共享资源的访问。\n\\2) binary_semaphore 是 std::counting_semaphore 的特化的别名，其 LeastMaxValue 为 1 。实现可能将 binary_semaphore 实现得比 std::counting_semaphore 的默认实现更高效。\nstd::counting_semaphore #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;semaphore\u0026gt; using namespace std::literals; // 全局二元信号量实例 // 设置对象计数为零 // 对象在未被发信状态 std::binary_semaphore smphSignal(0); void ThreadProc() { // 通过尝试减少信号量的计数等待来自主程序的信号 smphSignal.acquire(); // 此调用阻塞直至信号量的计数被从主程序增加 std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Got the signal\u0026#34; \u0026lt;\u0026lt; std::endl; // 回应消息 // 等待 3 秒以模仿某种线程正在进行的工作 std::this_thread::sleep_for(3s); std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Send the signal\\n\u0026#34;; // 消息 // 对主程序回复发信 smphSignal.release(); } int main() { // 创建某个背景工作线程，它将长期存在 std::jthread thrWorker(ThreadProc); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Send the signal\\n\u0026#34;; // 消息 // 通过增加信号量的计数对工作线程发信以开始工作 smphSignal.release(); // release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟： std::this_thread::sleep_for(50ms); // 通过试图减少信号量的计数等待直至工作线程完成工作 smphSignal.acquire(); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Got the signal\\n\u0026#34;; // 回应消息 } std::binary_semaphore #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;semaphore\u0026gt; using namespace std::literals; // 全局二元信号量实例 // 设置对象计数为零 // 对象在未被发信状态 std::binary_semaphore smphSignal(0); void ThreadProc() { // 通过尝试减少信号量的计数等待来自主程序的信号 smphSignal.acquire(); // 此调用阻塞直至信号量的计数被从主程序增加 std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Got the signal\u0026#34; \u0026lt;\u0026lt; std::endl; // 回应消息 // 等待 3 秒以模仿某种线程正在进行的工作 std::this_thread::sleep_for(3s); std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Send the signal\\n\u0026#34;; // 消息 // 对主程序回复发信 smphSignal.release(); } int main() { // 创建某个背景工作线程，它将长期存在 std::jthread thrWorker(ThreadProc); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Send the signal\\n\u0026#34;; // 消息 // 通过增加信号量的计数对工作线程发信以开始工作 smphSignal.release(); // release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟： std::this_thread::sleep_for(50ms); // 通过试图减少信号量的计数等待直至工作线程完成工作 smphSignal.acquire(); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Got the signal\\n\u0026#34;; // 回应消息 } Future 标准库提供了一些工具来获取异步任务（即在单独的线程中启动的函数）的返回值，并捕捉其所抛出的异常。这些值在共享状态中传递，其中异步任务可以写入其返回值或存储异常，而且可以由持有该引用该共享态的 std::future 或 std::shared_future 实例的线程检验、等待或是操作这个状态。\n定义于头文件 \u0026lt;future\u0026gt;\n异步线程 Classes 承诺 std::promise 允诺结果\nstd::promise\u0026lt;T\u0026gt; std::promise\u0026lt;T\u0026gt;::set_value() std::promise\u0026lt;T\u0026gt;::get_future() #include \u0026lt;vector\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; void accumulate(std::vector\u0026lt;int\u0026gt;::iterator first, std::vector\u0026lt;int\u0026gt;::iterator last, std::promise\u0026lt;int\u0026gt; accumulate_promise) { int sum = std::accumulate(first, last, 0); accumulate_promise.set_value(sum); // Notify future } void do_work(std::promise\u0026lt;void\u0026gt; barrier) { std::this_thread::sleep_for(std::chrono::seconds(1)); barrier.set_value(); } int main() { // Demonstrate using promise\u0026lt;int\u0026gt; to transmit a result between threads. std::vector\u0026lt;int\u0026gt; numbers = { 1, 2, 3, 4, 5, 6 }; std::promise\u0026lt;int\u0026gt; accumulate_promise; std::future\u0026lt;int\u0026gt; accumulate_future = accumulate_promise.get_future(); std::thread work_thread(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise)); accumulate_future.wait(); // wait for result std::cout \u0026lt;\u0026lt; \u0026#34;result=\u0026#34; \u0026lt;\u0026lt; accumulate_future.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; work_thread.join(); // wait for thread completion // Demonstrate using promise\u0026lt;void\u0026gt; to signal state between threads. std::promise\u0026lt;void\u0026gt; barrier; std::future\u0026lt;void\u0026gt; barrier_future = barrier.get_future(); std::thread new_work_thread(do_work, std::move(barrier)); barrier_future.wait(); new_work_thread.join(); } std::packaged_task template\u0026lt; class R, class ...Args \u0026gt; class packaged_task\u0026lt;R(Args...)\u0026gt;; std::packaged_task\u0026lt;R(Args...)\u0026gt;::get_future std::packaged_task\u0026lt;R(Args...)\u0026gt;::reset 类模板包装任何可调用目标（函数、lambda 表达式、绑定表达式或其他函数对象），以便可以异步调用它。其返回值或引发的异常存储在可通过对象访问的共享状态中。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;functional\u0026gt; // unique function to avoid disambiguating the std::pow overload set int f(int x, int y) { return std::pow(x,y); } void task_lambda() { std::packaged_task\u0026lt;int(int,int)\u0026gt; task([](int a, int b) { return std::pow(a, b); }); std::future\u0026lt;int\u0026gt; result = task.get_future(); task(2, 9); std::cout \u0026lt;\u0026lt; \u0026#34;task_lambda:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void task_bind() { std::packaged_task\u0026lt;int()\u0026gt; task(std::bind(f, 2, 11)); std::future\u0026lt;int\u0026gt; result = task.get_future(); task(); std::cout \u0026lt;\u0026lt; \u0026#34;task_bind:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void task_thread() { std::packaged_task\u0026lt;int(int,int)\u0026gt; task(f); std::future\u0026lt;int\u0026gt; result = task.get_future(); std::thread task_td(std::move(task), 2, 10); task_td.join(); std::cout \u0026lt;\u0026lt; \u0026#34;task_thread:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { task_lambda(); task_bind(); task_thread(); } 未来 std::future 等待一个值\nstd::future\u0026lt;T\u0026amp;\u0026gt; std::future\u0026lt;T\u0026amp;\u0026gt;::get() std::future\u0026lt;T\u0026amp;\u0026gt;::wait() #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; int main() { // future from a packaged_task std::packaged_task\u0026lt;int()\u0026gt; task([]{ return 7; }); // wrap the function std::future\u0026lt;int\u0026gt; f1 = task.get_future(); // get a future std::thread t(std::move(task)); // launch on a thread // future from an async() std::future\u0026lt;int\u0026gt; f2 = std::async(std::launch::async, []{ return 8; }); // future from a promise std::promise\u0026lt;int\u0026gt; p; std::future\u0026lt;int\u0026gt; f3 = p.get_future(); std::thread( [\u0026amp;p]{ p.set_value_at_thread_exit(9); }).detach(); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting...\u0026#34; \u0026lt;\u0026lt; std::flush; f1.wait(); f2.wait(); f3.wait(); std::cout \u0026lt;\u0026lt; \u0026#34;Done!\\nResults are: \u0026#34; \u0026lt;\u0026lt; f1.get() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f2.get() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f3.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t.join(); } std::future_error 返回错误代码，和 返回特定于错误代码 的解释性字符串\nstd::future_error::code() std::future_error::what() #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::future\u0026lt;int\u0026gt; empty; try { int n = empty.get(); // The behavior is undefined, but // some implementations throw std::future_error } catch (const std::future_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught a future_error with code \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.code() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\nMessage: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } std::shared_future 等待一个值 (possibly referenced by other futures）\nstd::shared_future\u0026lt;T\u0026amp;\u0026gt; std::shared_future::get() std::shared_future::wait() #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { std::promise\u0026lt;void\u0026gt; ready_promise, t1_ready_promise, t2_ready_promise; std::shared_future\u0026lt;void\u0026gt; ready_future(ready_promise.get_future()); std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; auto fun1 = [\u0026amp;, ready_future]() -\u0026gt; std::chrono::duration\u0026lt;double, std::milli\u0026gt; { t1_ready_promise.set_value(); ready_future.wait(); // waits for the signal from main() return std::chrono::high_resolution_clock::now() - start; }; auto fun2 = [\u0026amp;, ready_future]() -\u0026gt; std::chrono::duration\u0026lt;double, std::milli\u0026gt; { t2_ready_promise.set_value(); ready_future.wait(); // waits for the signal from main() return std::chrono::high_resolution_clock::now() - start; }; auto fut1 = t1_ready_promise.get_future(); auto fut2 = t2_ready_promise.get_future(); auto result1 = std::async(std::launch::async, fun1); auto result2 = std::async(std::launch::async, fun2); // wait for the threads to become ready fut1.wait(); fut2.wait(); // the threads are ready, start the clock start = std::chrono::high_resolution_clock::now(); // signal the threads to go ready_promise.set_value(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread 1 received the signal \u0026#34; \u0026lt;\u0026lt; result1.get().count() \u0026lt;\u0026lt; \u0026#34; ms after start\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Thread 2 received the signal \u0026#34; \u0026lt;\u0026lt; result2.get().count() \u0026lt;\u0026lt; \u0026#34; ms after start\\n\u0026#34;; } Functions 异步 std::async async( Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ) async( std::launch policy, Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex m; struct X { void foo(int i, const std::string\u0026amp; str) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void bar(const std::string\u0026amp; str) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int operator()(int i) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return i + 10; } }; template \u0026lt;typename RandomIt\u0026gt; int parallel_sum(RandomIt beg, RandomIt end) { auto len = end - beg; if (len \u0026lt; 1000) return std::accumulate(beg, end, 0); RandomIt mid = beg + len/2; auto handle = std::async(std::launch::async, parallel_sum\u0026lt;RandomIt\u0026gt;, mid, end); int sum = parallel_sum(beg, mid); return sum + handle.get(); } int main() { std::vector\u0026lt;int\u0026gt; v(10000, 1); std::cout \u0026lt;\u0026lt; \u0026#34;The sum is \u0026#34; \u0026lt;\u0026lt; parallel_sum(v.begin(), v.end()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; X x; // Calls (\u0026amp;x)-\u0026gt;foo(42, \u0026#34;Hello\u0026#34;) with default policy: // may print \u0026#34;Hello 42\u0026#34; concurrently or defer execution auto a1 = std::async(\u0026amp;X::foo, \u0026amp;x, 42, \u0026#34;Hello\u0026#34;); // Calls x.bar(\u0026#34;world!\u0026#34;) with deferred policy // prints \u0026#34;world!\u0026#34; when a2.get() or a2.wait() is called auto a2 = std::async(std::launch::deferred, \u0026amp;X::bar, x, \u0026#34;world!\u0026#34;); // Calls X()(43); with async policy // prints \u0026#34;43\u0026#34; concurrently auto a3 = std::async(std::launch::async, X(), 43); a2.wait(); // prints \u0026#34;world!\u0026#34; std::cout \u0026lt;\u0026lt; a3.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#34;53\u0026#34; } // if a1 is not done at this point, destructor of a1 prints \u0026#34;Hello 42\u0026#34; here 可能的结果：\n上边程序打印顺序不确定，\nThe sum is 10000 43 world! 53 Hello 42 ","date":"2022-01-15T17:13:05Z","permalink":"https://okokfun.github.io/post/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/","title":"线程支持库"},{"content":" 此文章来自👉C++ 参考手册\nC++关键词： alignas (C++11 起) default(1) register(C++17弃用)(2) alignof (C++11 起) delete(1) reinterpret_cast and do requires (C++20 起) and_eq double return asm dynamic_cast short atomic_cancel (TM TS) else signed atomic_commit (TM TS) enum sizeof(1) atomic_noexcept (TM TS) explicit static auto(1) export(1)(3) static_assert (C++11 起) bitand extern(1) static_cast bitor false struct(1) bool float switch break for synchronized (TM TS) case friend template catch goto this char if thread_local (C++11 起) char8_t (C++20 起) inline(1) throw(C++17中移除) char16_t (C++11 起) int true char32_t (C++11 起) long try class(1) mutable(1) typedef compl namespace typeid concept (C++20 起) new typename const noexcept (C++11 起) union consteval (C++20 起) not unsigned constexpr (C++11 起) not_eq using(1) constinit (C++20 起) nullptr (C++11 起) virtual const_cast operator void continue or volatile co_await (C++20 起) or_eq wchar_t co_return (C++20 起) private while co_yield (C++20 起) protected xor decltype (C++11 起) public xor_eq reflexpr (反射 TS) override (C++11) final (C++11) import (C++20) module (C++20) transaction_safe (TM TS) transaction_safe_dynamic (TM TS) ","date":"2022-01-15T15:31:05Z","permalink":"https://okokfun.github.io/post/c++%E5%85%B3%E9%94%AE%E8%AF%8D/","title":"C++关键词"},{"content":" 本文介绍的HTTP库👉libcpr/cpr: C++ Requests: Curl for People, a spiritual port of Python Requests. (github.com)\nHttpServer Url Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/hello.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic.json\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/error.html\u0026#34;}; Url url{\u0026#34;http://bad_host/\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/empty_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/check_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/v1_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/check_v1_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic_auth.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/bearer_token.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/digest_auth.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/header_reflect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/temporary_redirect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/permanent_redirect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/body_get.html\u0026#34;}; Get Response response = cpr::Get(url) Response response = cpr::Get(url, iface); Response response = cpr::Get(url, Timeout{0L}); Response response = cpr::Get(url, cookies); Response response = cpr::Get(url, parameters{}); Response response = cpr::Get(url, Authentication{}); Response response = cpr::Get(url, Header{}); Response response = cpr::Get(url, Bearer{}); Response response = cpr::Get(url, Digest{}); Response response = cpr::Get(url, Authentication{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Authentication{}); Response response = cpr::Get(url, Authentication{}, Header{}); Response response = cpr::Get(url, Authentication{}, Header{}); Response response = cpr::Get(url, Header{}, Authentication{}); Response response = cpr::Get(url, Header{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{}, Parameters{}, Header{}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{}); Response response = cpr::Get(url, Header{}, Authentication{}, Parameters{}); Response response = cpr::Get(url, Authentication{}, Header{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Authentication{}, Header{}); Response response = cpr::Get(url, Redirect(false)); Response response = cpr::Get(url, Redirect(0L)); Response response = cpr::Get(url, Authentication{}, Header{}, Redirect(true, true)); Response response = cpr::Get(url, body); Response response = cpr::Get(url, LimitRate(1024, 1024)); Response response = cpr::Get(url); Response response = cpr::Get(url, iface); Response response = cpr::Get(url, Timeout{0L}); Response response = cpr::Get(url, cookies); Response response = cpr::Get(url, parameters); Response response = cpr::Get(url, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer the_token\u0026#34;}}); Response response = cpr::Get(url, Bearer{\u0026#34;the_token\u0026#34;}); Response response = cpr::Get(url, Digest{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;}}); Response = session.Get(); cpr::Response response = session-\u0026gt;Post(); Response response = session.Get(); Response response = cpr::Get(url, Header{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;HeLlO\u0026#34;, \u0026#34;wOrLd\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;HeLlO\u0026#34;, \u0026#34;wOrLd\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Redirect(false)); Response response = cpr::Get(url, Redirect(0L)); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;basic_auth.html\u0026#34;}}, Redirect(true, true)); Response response = cpr::Get(url, body); Response response = cpr::Get(url, LimitRate(1024, 1024)); cpr::Post Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}); Payload payload{{\u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;}}; payload.Add({\u0026#34;y\u0026#34;, \u0026#34;2\u0026#34;}); Response response = cpr::Post(url, payload); std::vector\u0026lt;Pair\u0026gt; payloadData; payloadData.emplace_back(\u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;); payloadData.emplace_back(\u0026#34;y\u0026#34;, \u0026#34;2\u0026#34;); Response response = cpr::Post(url, Payload(payloadData.begin(), payloadData.end())); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;hello world!!~\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}, {\u0026#34;y\u0026#34;, \u0026#34;13\u0026#34;}}); Url url{\u0026#34;http://bad_host/\u0026#34;}; Response response = cpr::Post(url, Payload{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, File{filename}}}); Multipart multipart{{\u0026#34;x\u0026#34;, File{filename}}}; Response response = cpr::Post(url, multipart); cpr::Response response = cpr::Post(url, cpr::Header{{\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;}}, cpr::Body{body}, cpr::ConnectTimeout{3000}, cpr::Timeout{3000}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{content.begin(), content.end(), \u0026#34;test_file\u0026#34;}}}); Multipart multipart{{\u0026#34;x\u0026#34;, Buffer{content.begin(), content.end(), \u0026#34;test_file\u0026#34;}}}; Response response = cpr::Post(url, multipart); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{content, 11 + content, \u0026#34;test_file\u0026#34;}}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{std::begin(content), std::end(content) - 1, \u0026#34;test_file\u0026#34;}}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5}, {\u0026#34;y\u0026#34;, 13}}); Response response = cpr::Post(url, multipart); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5, \u0026#34;application/number\u0026#34;}}); Multipart multipart{{\u0026#34;x\u0026#34;, 5, \u0026#34;application/number\u0026#34;}}; Response response = cpr::Post(url, multipart); Response response = cpr::Post(cpr::Url(uri), cpr::Header{{\u0026#34;content-type\u0026#34;, contentType}, {\u0026#34;Authorization\u0026#34;, signature}, {\u0026#34;log-type\u0026#34;, logType}, {\u0026#34;x-ms-date\u0026#34;, date}, {\u0026#34;content-length\u0026#34;, std::to_string(body.length())}}, cpr::Body(body)); cpr::Payload payload = cpr::Payload{{\u0026#34;email\u0026#34;, \u0026#34;\u0026#34;}, {\u0026#34;password\u0026#34;, \u0026#34;\u0026#34;}, {\u0026#34;devicetoken\u0026#34;, \u0026#34;\u0026#34;}}; cpr::Response response = cpr::Post(cpr::Url(uri), cpr::Timeout{10000}, payload); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}, Redirect(PostRedirectFlags::NONE)); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}, Redirect(PostRedirectFlags::NONE)); std::string expected_text{\u0026quot;\u0026quot;}; std::string expected_text{\u0026#34;Hello world!\u0026#34;}; std::string expected_text{ \u0026#34;[\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;first_key\\\u0026#34;: \\\u0026#34;first_value\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;second_key\\\u0026#34;: \\\u0026#34;second_value\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34;]\u0026#34;}; std::string expected_text{\u0026#34;Not Found\u0026#34;}; std::string expected_text{\u0026#34;Header reflect GET\u0026#34;}; EXPECT_EQ() EXPECT_EQ(expected_text, response.text); EXPECT_EQ(std::string{}, response.text); EXPECT_EQ(\u0026#34;Unauthorized\u0026#34;, response.text); EXPECT_EQ(std::string{\u0026#34;Header reflect POST\u0026#34;}, response.text); EXPECT_EQ(std::string{\u0026#34;Header reflect POST\u0026#34;}, response.text); EXPECT_EQ(url, response.url); EXPECT_EQ(\u0026#34;text/plain\u0026#34;, response.header[\u0026#34;content-type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;text/html\u0026#34;}, response.header[\u0026#34;content-type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;application/json\u0026#34;}, response.header[\u0026#34;Content-Type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;Value1\u0026#34;}, response.header[\u0026#34;Header1\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;Value2\u0026#34;}, response.header[\u0026#34;Header2\u0026#34;]); EXPECT_EQ(std::string{}, response.header[\u0026#34;Header2\u0026#34;]); cookies = response.cookies; EXPECT_EQ(cookies[\u0026#34;cookie\u0026#34;], response.cookies[\u0026#34;cookie\u0026#34;]); EXPECT_EQ(cookies[\u0026#34;icecream\u0026#34;], response.cookies[\u0026#34;icecream\u0026#34;]); EXPECT_EQ(cookies[\u0026#34;expires\u0026#34;], response.cookies[\u0026#34;expires\u0026#34;]); EXPECT_EQ(\u0026#34;\u0026#34;, response.cookies[\u0026#34;cookie\u0026#34;]); EXPECT_EQ(\u0026#34;\u0026#34;, response.cookies[\u0026#34;icecream\u0026#34;]); EXPECT_EQ(200, response.status_code); EXPECT_EQ(401, response.status_code); EXPECT_EQ(ErrorCode::OK, response.error.code); ","date":"2022-01-13T20:43:31Z","permalink":"https://okokfun.github.io/post/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/","title":"cpr请求库"},{"content":" 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n20190623_tcp_termination.png (925×613) (linuxblogs.cn) 此库是一个简单的TCP库👉sockpp\nTCP TCP Clien IPV4:tcp_clien sockpp::socket_initializer sockpp环境初始化 sockpp::tcp_connector conn({host, port}) // 初始化一个连接器，并尝试连接到{host, port} !conn.read_timeout(seconds(5)) // 读超时 conn.address() // 连接成功打印地址 conn.connect(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port)) // 链接{localhost, port} sockpp::inet_address(host, port) // 返回一个默认的端口号和地址 conn.clone() // clone一个sockpp::tcp_socket conn.last_error_str() // 返回根据平台各自的错误字符串 conn.last_error() conn.write(s) // 通过coon把字符串s写过去 conn.write_n(buf, n) // 从buf中取n个字节的数据并通过tcp写过去 conn.read(buf, sizeof(buf))) // 读sizeof(buf)个字节到buf中，并返回读到的字节数 conn.read_n() // conn.address() // 服务器的地址 conn.peer_address() conn.shutdown(SHUT_WR) 例子- 单线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/tcp_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; using namespace std::chrono; int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample TCP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; // Implicitly creates an inet_address from {host,port} // and then tries the connection. sockpp::tcp_connector conn({host, port}); if (!conn) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; sockpp::inet_address(host, port) \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection from \u0026#34; \u0026lt;\u0026lt; conn.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; endl; // Set a timeout for the responses if (!conn.read_timeout(seconds(5))) { cerr \u0026lt;\u0026lt; \u0026#34;Error setting timeout on TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; } string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } IPV6:tcp6_clien sockpp::tcp6_connector conn({host, port}); sockpp::inet6_address(host, port); conn.last_error_str(); conn.read_timeout(seconds(5)); conn.last_error_str(); conn.write(s); 例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/tcp6_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; using namespace std::chrono; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 TCP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; std::string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;::1\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; // Implicitly creates an inet6_address from {host,port} // and then tries the connection. sockpp::tcp6_connector conn({host, port}); if (!conn) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; sockpp::inet6_address(host, port) \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection from \u0026#34; \u0026lt;\u0026lt; conn.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; endl; // Set a timeout for the responses if (!conn.read_timeout(seconds(5))) { cerr \u0026lt;\u0026lt; \u0026#34;Error setting timeout on TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; } string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } TCP Server IPV4:tcp_server sockpp::tcp_acceptor acc(port) // 绑定port,并创建一个sockpp::tcp_socket的acc sockpp::tcp_socket sock = acc.accept(\u0026amp;peer) // 接受一个tcp连接并返回sockpp::tcp_socket 例子-多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/tcp_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::tcp_socket sock) { ssize_t n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed from \u0026#34; \u0026lt;\u0026lt; sock.peer_address() \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the TCP port acceptor. Each time a connection is // made, a new thread is spawned to handle it, leaving this main thread to // immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample TCP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp_acceptor acc(port); if (!acc) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } //cout \u0026lt;\u0026lt; \u0026#34;Acceptor bound to address: \u0026#34; \u0026lt;\u0026lt; acc.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Awaiting connections on port \u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { sockpp::inet_address peer; // Accept a new client connection sockpp::tcp_socket sock = acc.accept(\u0026amp;peer); cout \u0026lt;\u0026lt; \u0026#34;Received a connection request from \u0026#34; \u0026lt;\u0026lt; peer \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } IPV6:tcp6_server sockpp::tcp6_acceptor acc(port); sockpp::inet6_address peer; acc.accept(\u0026amp;peer); 例子 - 多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/tcp6_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::tcp6_socket sock) { ssize_t n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed from \u0026#34; \u0026lt;\u0026lt; sock.peer_address() \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the TCP port acceptor. Each time a connection is // made, a new thread is spawned to handle it, leaving this main thread to // immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 TCP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp6_acceptor acc(port); if (!acc) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Awaiting connections on port \u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { sockpp::inet6_address peer; // Accept a new client connection sockpp::tcp6_socket sock = acc.accept(\u0026amp;peer); cout \u0026lt;\u0026lt; \u0026#34;Received a connection request from \u0026#34; \u0026lt;\u0026lt; peer \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } UDP UDP Clien IPV4:udp_clien sockpp::socket_initializer sockInit; sockpp::udp_socket sock; sock.connect(sockpp::inet_address(host, port)); sock.last_error_str(); sockpp::inet_address addr(\u0026#34;localhost\u0026#34;, 12345); sock.send(s); sock.send_to(msg, addr); char buf[16]; ssize_t n = sock.recv(buf, sizeof(buf), \u0026amp;srcAddr); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/udp_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp_socket sock; if (!sock.connect(sockpp::inet_address(host, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; host \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created UDP socket at: \u0026#34; \u0026lt;\u0026lt; sock.address() \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (sock.send(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = sock.recv(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!sock) ? 1 : 0; } IPV6:udp6_clien sockpp::socket_initializer sockInit; sockpp::udp6_socket sock; sock.connect(sockpp::inet6_address(host, port)); sock.last_error_str(); sock.address(); sock.send(s); sock.recv(\u0026amp;sret[0], s.length()); 例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/udp6_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 UDP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp6_socket sock; if (!sock.connect(sockpp::inet6_address(host, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; host \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created UDP socket at: \u0026#34; \u0026lt;\u0026lt; sock.address() \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (sock.send(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = sock.recv(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!sock) ? 1 : 0; } UDP Server IPV4:udp_server sockpp::socket_initializer sockInit; sockpp::udp_socket\tudpsock; udpsock.bind(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port)); udpsock.last_error_str(); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/udp_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. template \u0026lt;typename UDPSOCK\u0026gt; void run_echo(UDPSOCK sock) { ssize_t n; char buf[512]; // Each UDP socket type knows its address type as `addr_t` typename UDPSOCK::addr_t srcAddr; // Read some data, also getting the address of the sender, // then just send it back. while ((n = sock.recv_from(buf, sizeof(buf), \u0026amp;srcAddr)) \u0026gt; 0) sock.send_to(buf, n, srcAddr); } // -------------------------------------------------------------------------- // The main thread creates the two UDP sockets (one each for IPv4 and IPv6), // and then starts them running the echo function each in a separate thread. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp_socket\tudpsock; if (!udpsock) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the UDP v4 socket: \u0026#34; \u0026lt;\u0026lt; udpsock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } if (!udpsock.bind(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error binding the UDP v4 socket: \u0026#34; \u0026lt;\u0026lt; udpsock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } // Spin up a thread to run the IPv4 socket. thread thr(run_echo\u0026lt;sockpp::udp_socket\u0026gt;, std::move(udpsock)); thr.detach(); return 0; } IPV6:udp6_server sockpp::socket_initializer sockInit; sockpp::udp6_socket\tudp6sock; udp6sock.last_error_str(); udp6sock.bind(sockpp::inet6_address(\u0026#34;localhost\u0026#34;, port)); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/udp6_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. template \u0026lt;typename UDPSOCK\u0026gt; void run_echo(UDPSOCK sock) { ssize_t n; char buf[512]; // Each UDP socket type knows its address type as `addr_t` typename UDPSOCK::addr_t srcAddr; // Read some data, also getting the address of the sender, // then just send it back. while ((n = sock.recv_from(buf, sizeof(buf), \u0026amp;srcAddr)) \u0026gt; 0) sock.send_to(buf, n, srcAddr); } // -------------------------------------------------------------------------- // The main thread creates the two UDP sockets (one each for IPv4 and IPv6), // and then starts them running the echo function each in a separate thread. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp6_socket\tudp6sock; if (!udp6sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the UDP v6 socket: \u0026#34; \u0026lt;\u0026lt; udp6sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } if (!udp6sock.bind(sockpp::inet6_address(\u0026#34;localhost\u0026#34;, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error binding the UDP v6 socket: \u0026#34; \u0026lt;\u0026lt; udp6sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } // Spin up a thread to run the IPv4 socket. thread thr(run_echo\u0026lt;sockpp::udp6_socket\u0026gt;, std::move(udp6sock)); thr.detach(); return 0; } UNIX UNIX Clien sockpp::socket_initializer sockInit; sockpp::unix_connector conn; conn.connect(sockpp::unix_address(path)); conn.last_error_str(); conn.peer_address(); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/unix_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample Unix-domain echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string path = (argc \u0026gt; 1) ? argv[1] : \u0026#34;/tmp/unechosvr.sock\u0026#34;; sockpp::socket_initializer sockInit; sockpp::unix_connector conn; bool ok = conn.connect(sockpp::unix_address(path)); if (!ok) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to UNIX socket at \u0026#34; \u0026lt;\u0026lt; path \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#39;\u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != (int) s.length()) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UNIX stream\u0026#34; \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); int n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != (int) s.length()) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UNIX stream\u0026#34; \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } UNIX Server sockpp::socket_initializer sockInit; sockpp::unix_acceptor acc; acc.open(sockpp::unix_address(path)); acc.last_error_str(); acc.address(); acc.accept(); 例子 - 多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/unix_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::unix_socket sock) { int n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed\u0026#34; \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the UNIX acceptor. // Each time a connection is made, a new thread is spawned to handle it, // leaving this main thread to immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample Unix-domain echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string path = \u0026#34;/tmp/unechosvr.sock\u0026#34;; if (argc \u0026gt; 1) { path = argv[1]; } sockpp::socket_initializer sockInit; sockpp::unix_acceptor acc; bool ok = acc.open(sockpp::unix_address(path)); if (!ok) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Acceptor bound to address: \u0026#39;\u0026#34; \u0026lt;\u0026lt; acc.address() \u0026lt;\u0026lt; \u0026#34;\u0026#39;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { // Accept a new client connection auto sock = acc.accept(); cout \u0026lt;\u0026lt; \u0026#34;Received a connection\u0026#34; \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } ","date":"2022-01-13T20:28:16Z","permalink":"https://okokfun.github.io/post/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Socket_Cpp库的使用"},{"content":" 数据库介绍 什么是数据库?\n​\t数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.\n​\t举个例子来说明这个问题：每个人都有很多亲戚和朋友，为了保持与他们的联系，\n​\t我们常常用一个笔记本将他们的姓名、地址、电话等信息都记录下来，\n​\t这样要査谁的电话或地址就很方便了。\n​\t这个“通讯录”就是一个最简单的“数据库”，每个人的姓名、地址、电话等信息就是这个数据库中的“数据”。\n​\t我们可以在笔记本这个“数据库”中添加新朋友的个人信息，也可以由于某个朋友的电话变动而修改他的电话号码这个“数据”。\n​\t不过说到底，我们使用笔记本这个“数据库”还是为了能随时査到某位亲戚或朋友的地址、邮编或电话号码这些“数据”。\n数据库是干什么用的?\n存储和管理数据,便于程序开发.\noracle简介:\nOracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。\nOracle公司成立与1977年，总部位于美国加州；\nOracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。\nOracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。\n2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。\n2008年1月16日 sun公司收购了mysql 。\n2009年4月20日 oracle收购了sun 。\n常见的数据库有哪些？\noracle公司的oracle数据库\nIBM公司的DB2数据库\nInformix公司的Informix数据库\nsysbase公司的sysbase数据库\nMicrosoft公司的SQL Server\noracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）\nMongoDB数据库\nMariadb数据库 (由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发,MariaDB名称来自Michael Widenius的女儿Maria的名字)\nSQLite (设计目标是嵌入式)\n1 Oracle的体系结构 Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。\nimg 1.1 表空间和数据文件 逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。\n物理概念：数据文件，在磁盘上（/home/oracle_11/app/oradata/orcl目录中的.DBF文件）；\n​ 一个表空间包含一个或者多个数据文件。\n1.2 段、区、块 img 段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。\n图请看讲义部分。\n1.3 DBA 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。从时间开销上看：安装占用6%，创建和配置占用12%，装载和存档数据占6%, 软件维护占6%，管理数据库系统占55%，可见，管理数据库系统占用了大部分的时间开销。\n1.4 如何启动数据库服务 Windows启动oracle数据库服务：\n启动服务：services.msc，找到下列两个服务，并启动。\nOracleServiceORCL： oracle数据库服务系统\nhome1TNSListene： 监听服务，用于远程连接的侦听\n注意：若把数据库默认设置为自启动，则开机时间会延长。\nLinux启动oracle数据库服务步骤(oracle数据库系统安装到linux系统上)\n​\t1. 执行sqlplus / as sysdba或sqlplus sys/sys as sysdba进入到命令行界面\n​\t2. 执行startup启动数据库服务\n​\t3. 执行exit退出sqlplus命令行界面\n​\t4. 执行lsnrctl start启动监听服务\n注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。\n1.5 如何登陆数据库服务 在本机登陆：\n普通用户身份登陆\nsqlplus ↙ 用户名 ↙\t密码 ↙\nsqlplus 用户名/密码，如sqlplus scott/tiger\n以管理员身份登陆 sqlplus / as sysdba（此处不用输入密码，在安装的时候已经输入密码） sqlplus sys/sys as sysdba 通过网络使用客户端远程登陆 远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。\n注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。\nD:\\oracle\\app\\HGUANG\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora，下面是经过Net Manager进行配置后得到的一个文件内容：\nimg 客户端安装完成之后进行远程登陆之前最好先进行测试：\n首先测试网络是否是通的： ping IP ， 然后tnsping IP 或者 tnsping oracle_orcl。\n普通用户登陆\nsqlplus 用户名/密码@连接字符串，如sqlplus scott/tiger@oracle_orcl\n管理员用户登陆\nsqlplus sys/sys@oracle_orcl as sysdba 此外：还可以执行： sqlplus scott/tiger@//IP地址/实例名 进行登陆。\n使用scott用户或者sys用户登陆完之后，可以使用show user测试一下，如果显示用户名就表明已经登陆成功了，或者是执行select * from tab;进行一次查询, 有结果显示就表名已经登陆成功了.\n解锁用户：alter user scott account unlock (管理员身份登陆，给scott用户解锁。用户默认锁定)\n锁定用户：alter user scott account lock，（必须用管理员用户登陆）\n修改用户密码：alter user scott identified by 新密码 (管理员身份登陆，给scott用户修改密码)\n查看当前语言环境：select userenv('language') from dual;\n1.6 贯穿这门课程的方案 请看oracle讲义。\nscott用户的emp表, dept表和salgrade表.\nimg 2基本的SQL select语句 2.1 sqlplus的基本操作 显示当前用户： show user;\n查看当前用户下的表：select * from tab;\n​\ttab:\t数据字典（记录数据库和应用程序源数据的目录），包含当前用户下的表。\n查看员工表的结构：desc emp;\n设置行宽：set linesize 120;\n设置页面：set pagesize 100;\n​\t或者将上述两行写入如下两个配置文件，可永久设置：\nC:\\app\\Administrator\\product\\11.2.0\\client_1\\sqlplus\\admin\\glogin.sql\nC:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\sqlplus\\admin\\glogin.sql\n设置员工名列宽：col ename for a20\t(a表示字符串)\n设置薪水列为4位数子：col sal for 9999\t(一个9表示一位数字)\n2.2 基本的select语句 Select语句的整体形式：\nSELECT col1, col2… FROM table_name WHERE condition GROUP BY col… HAVING condtion ORDER BY col… 其语法格式为：\nSELECT *|{[DISTINCT] *column|*expression [*alias],\u0026hellip;} FROM *table;\n案例\n1查询所有员工的所有记录\nSELECT * FROM emp; SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno FROM emp; 说明：尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)\n2 查询员工号、姓名、薪水\nSELECT empno, ename, sal FROM emp; 3 查询员工号、姓名、薪水和年薪\nSELECT empno, ename, sal, sal*12 FROM emp; 说明：select语句中可以使用表达式\n注意：在执行sql语句的时候，执行 / 会执行上一次执行的语句。\n若在写sql语句的时候, 写错了, 可以使用c（change）命令来修改. 默认, 光标闪烁位置指向上一条SQL语句的第一行。输入 2 则定位到第二行。\nc /错误关键字/正确关键字 ↙\n使用“/”来执行修改过的SQL语句\n例如：错误输入:\n`select empno, ename, sal, sal * 12\n​\tform emp`; （“from”书写错误，该错误位于整条SQL语句的第二行）\n（1） 输入：2↙ 终端提示：2* from emp\n（2） 输入：c /form/from ↙\t终端提示：2* from emp (意为改正后的sql语句样子)\n（3） 输入：/↙\n也可以使用ed(或者edit)命令来修改\ned ↙弹出系统默认的文本编辑器，(如记事本)\n修改、保存、退出、执行“/”。\n使用edit打开文件编辑sql语句:\n如果sql语句很长, 可以分行编写或者用ed命令打开一个文件,\n然后在文件中编写sql语句, 注意, sql语句末尾不要加; , 然后换行加上/表示结束.\n若想将显示结果保存到文件中:\nspool命令:\nspool d:\\result.txt; select * from emp; spool off; 使用别名：\n别名：as\n案例：查询员工号，姓名，月薪，年薪\nSELECT empno AS \u0026#34;员工号\u0026#34;, ename \u0026#34;姓名\u0026#34;, sal 月薪, sal*12 年薪 FROM emp; 说明：关键字as写与不写没有区别； \u0026ldquo;\u0026ldquo;有与没有取决于别名中是否有空格，建议在用别名的时候加上\u0026rdquo;\u0026quot;。\nDISTINCT\u0026mdash;à重复记录只取一次\n案例：\nSELECT deptno FROM emp; SELECT DISTINCT deptno FROM emp; SELECT job FROM emp; SELECT DISTINCT job FROM emp; SELECT DISTINCT deptno, job FROM emp; 说明: DISTINCT的作用范围不是距离它最近的列, 而是后面的所有的列。\n2.3 SQL语句使用注意事项 SQL 语言大小写不敏感。\nsql语句对关键字的大小写不敏感, 如SELECT和select一样, 但是对于内容敏感。\nSQL可以写在一行或者多行\n关键字不能被缩写也不能分行\n各子句一般要分行写。\n使用缩进提高语句的可读性\n2.4 算数运算 + - * / 乘除的优先级高于加减\n优先级相同时, 按照从左至右运算\n可以使用括号改变优先级\n查询: 员工号、姓名、月薪、年薪、奖金、年收入。\nSELECT deptno, ename, sal, sal*12, comm, comm+sal*12 FROM emp; ​\t结果不正确, 没有奖金的员工, 年收入不正确。\n说明： 在程序开发过程中, 数据是核心. 程序再正确也没有用, 必须保证数据不能丢, 且正确, 对于上面的结果, 有对有错的情况是最危险的.\n解决这个问题需要正确认识NULL值。\n2.5 NULL值 NULL值问题：\n包含NULL值的表达式都为空.\nNULL不等于NULL\nselect * from emp where NULL=NULL; 查不到任何记录。\n解决：滤空函数：nvl(a, b) 如果a为NULL，返回b；\n所以：使用sal * 12 + nvl(comm, 0) 表示年收入。\n在SQL中, 判断一值是否等于NULL不用“=” 和“!=”而使用is和is not 查询奖金为NULL的员工信息：\nselect * from emp where comm = NULL; (SQL中不使用==)\n​\t应该使用：select * from emp where comm is NULL;\n查询奖金不为NULL的员工信息：\nselect * from emp where comm is not NULL;\n总结: 空值是无效的, 未指定的, 未知的或不可预知的值, 空值不是空格或者0.\n2.6 连接符 ​\t在oracle中使用 || 连接字符串\n例如：\nSELECT ename || \u0026#39; is a \u0026#39; || job FROM emp; 若要显示hello world字符串应该怎么办呢?\noracle中语法规定：select后面必须接from关键字，所有需要有一个表名用来满足oracle的SQL99语法规定，为此定义了一个伪表dual。\nSELECT concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;) FROM dual; 若要连接三个字符串呢？\nSELECT concat(concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;), \u0026#39; i love you\u0026#39;) FROM dual; 注意：concat函数只支持两个参数，不支持三个参数形式。\n​\t也可以使用||连接三个以上的字符串：\nSELECT \u0026#39;hello \u0026#39; || \u0026#39;world \u0026#39; || \u0026#39;i love you\u0026#39; FROM dual; 说明：使用||比concat函数要灵活，其实||就是用来替换concat函数的。\n2.7 SQL和sqlplus 我们已经学习使用了select，应该知道还有update、delete、insert、create…\n同时，我们学习了ed、c、set、col、desc….\nSQL是语言，关键字不能缩写。\nsqlplus是oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。\nSQL\n一种语言\nANSI 标准\n关键字不能缩写\n使用语句控制数据库中的表的定义信息和表中的数据\nSQL*Plus\n一种环境\nOracle 的特性之一\n关键字可以缩写\n命令不能改变数据库中的数据的值\n集中运行\n3 过滤和排序数据 3.1 where条件过滤 在where条件中使用的列的值对大小写是敏感的, 如是字符串需要用单引号引起来, 如KING和king是不同的字符串。\n如select * from emp where ename= 'KiNg '；未选定行\nselect * from emp where ename= 'KING '； 正确\n说明： 对于列的值来说，大小写是敏感的。\n​ [未选定行]不是发生了错误，而是查不到记录。\n3.1.1 日期格式 查询入职日期为1981年11月17日的员工\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 会报错，ORA-01861: 文字与格式字符串不匹配。\n首先查询一下emp使用的日期格式：\nSELECT * FROM emp; 使用sysdate函数获取当前系统的日期：\nSELECT sysdate FROM dual; 查询得出格式为： DD-MON-RR\n应该使用当前系统指定的日期格式来查询：\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 如何获取当前系统的日期格式?\nSELECT * FROM v$nls_parameters; 若格式不太好看，可以执行col parameter for a30设置列的宽度。\n如何修改日期格式?\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd \u0026#39;; 查看修改结果：\nSELECT * FROM v$nls_parameters; 验证：再次查询emp表：\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 修改日期格式到秒\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;; 执行select sysdate from dual;验证修改结果.\n将日期格式改回默认设置\nalter session SET NLS_DATE_FORMAT = \u0026#39;DD-MON-RR\u0026#39;; 说明:\n字符和日期要包含在单引号中。\n字符大小写敏感, 日期格式敏感。\n默认的日期格式是DD-MON-RR\n3.1.2 比较运算 l 普通比较运算符：\n= 等于(不是==)\t\u0026gt; 大于\n\u0026gt;= 大于等于\t\u0026lt; 小于\n\u0026lt;= 小于等于\t\u0026lt;\u0026gt;\t不等于(也可以是!=)\n案例:\n1 查询薪水不等于1250的员工信息\nSELECT * FROM emp WHERE sal \u0026lt;\u0026gt; 1250; SELECT * FROM emp WHERE sal != 1250; between…and:介于两值之间,闭区间,包含两边的值.\n案例:\n查询工资在1000-2000之间的员工：\nSELECT * FROM emp WHERE sal \u0026gt;=1000 AND sal\u0026lt;=2000; SELECT * FROM emp WHERE sal BETWEEN 1000 AND 2000; ​\t注意：1.包含边界 2. 小值在前，大值在后。 (对于日期也是如此)\n2 查询81年2月至82年2月(不含2月)入职的员工信息：\nSELECT * FROM emp WHERE hiredate BETWEEN \u0026#39;1-2月-81\u0026#39; AND \u0026#39;30-1月-82\u0026#39;; in：在集合中, not in 不在集合中\n案例\n查询部门号为10和20的员工信息： SELECT * FROM emp WHERE deptno=10 OR deptno=20; SELECT * FROM emp WHERE deptno IN (10, 20); 查询部门号不是10和20的员工(除了10和20以外的部门) SELECT * FROM emp WHERE deptno NOT IN (10, 20); 使用比较运算符该怎么写呢？\rSELECT * FROM emp WHERE deptno!=10 AND deptno!=20; 如果是 ….. not in (10, 20, NULL) 可不可以呢?\n☆NULL空值:如果结果中含有NULL,不能使用not in 操作符,但可以使用in操作符。\r课后思考为什么???\r因为: not in (10, 20, NULL)相当于:\ndeptno!=10 and deptno!=20 and deptno!=NULL包含NULL的表达式都为空.\nlike：模糊查询\n%匹配任意多个字符, _匹配一个字符, 使用escape表示转义字符\n案例:\n查询名字以S开头的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;S% \u0026#39;; (注意：S小写、大写不同)\n查询名字是4个字的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;_ _ _ _\u0026#39;; 增加测试例子：向表中插入员工：\ninsert into emp(empno, ename, sal, deptno) values(1001, \u0026#39; TOM_ABC \u0026#39;, 3000, 10); 查询名字中包含_的员工：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;% _ % \u0026#39;; 查不到记录.\n转义字符：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;%\\_% \u0026#39; escape \u0026#39;\\\u0026#39;; 转义单引号本身使用两个单引号来完成转义\nSELECT \u0026#39;hello \u0026#39;\u0026#39; world\u0026#39; FROM dual; 3.1.3 逻辑运算 逻辑运算符\nAND\t逻辑并\nOR 逻辑或\nNOT\t逻辑非\n如果…..where 表达式1 and/or 表达式2;\n…..where 表达式2 and/or 表达式1;\t这两句SQL语句功能一样吗？效率一样吗？\n※SQL优化：\nSQL在解析where的时候，是从右至左解析的。\n所以： and时应该将易假的值放在右侧;\nor时应该将易真的值放在右侧.\r这样的话可以提高效率.\n案例:\n查询部门为30且工种为SALESMAN的员工 SELECT * FROM emp WHERE deptno=30 AND job=\u0026#39;SALESMAN\u0026#39;; 查询部门为10或者工资大于2000的员工 SELECT * FROM emp WHERE deptno=10 OR sal\u0026gt;2000; 查询工种不是MANAGER或者PRISIDENT的员工 SELECT * FROM emp WHERE job!=\u0026#39;MANAGER\u0026#39; AND job!=\u0026#39;PRISIDENT\u0026#39;; SELECT * FROM emp WHERE job NOT IN (\u0026#39;MANAGER\u0026#39;, \u0026#39;PRESIDENT\u0026#39;); 3.1.4 order by 排序 使用 ORDER BY 子句排序\nASC（ascend）: 升序。默认采用升序方式。\nDESC（descend）: 降序\nORDER BY子句在SELECT语句的最末尾, 是对select查询的最后的结果进行排序.\n案例:\n查询emp表, 按照入职日期先后排序 SELECT * FROM emp ORDER BY hiredate; 查询员工信息, 按月薪排序 SELECT * FROM emp ORDER BY sal; # ---从小到大排序, 默认方式.\tSELECT * FROM emp ORDER BY sal desc; # ---从大到小排序 order by 之后可以跟那些内容呢？\norder by + 列名, 序号, 表达式, 别名,\n注意：语法要求order by子句应放在select的结尾。\n案例:\n查询员工信息, 按月薪排序\u0026mdash;-à使用列名排序的情况 SELECT * FROM emp ORDER BY sal; 按照工资进行排序\u0026ndash;à使用序号进行排序的情况 SELECT ename, sal, sal*12, FROM emp ORDER BY 2 desc; 序号: 按照select后面列名出现的先后顺序, ename→1, sal→2, sal*12→3\n按照员工的年薪进行排序\u0026mdash;-à使用表达式排序的情况 SELECT ename, sal, sal*12 FROM emp ORDER BY sal * 12 desc; 按照员工的年薪进行排序\u0026mdash;-à使用别名进行排序的情况 SELECT ename, sal, sal*12 \u0026#34;年薪\u0026#34; FROM emp ORDER BY \u0026#34;年薪\u0026#34; desc; 按照两列或者多列进行排序\n案例:\n按照部门和工资进行排序 SELECT * FROM emp ORDER BY deptno, sal; order by后有多列时, 列名之间用逗号隔分, order by会同时作用于多列。上例的运行结果会在同一部门内升序, 部门间再升序。\nSELECT * FROM emp ORDER BY deptno, sal desc; 注意: desc只作用于最近的一列, 两列都要降序排, 则需要两个desc。即：\nSELECT * FROM emp ORDER BY deptno desc, sal desc; 查询员工信息, 按奖金由高到低排序： SELECT * FROM emp ORDER BY comm desc; 结果前面的值为NULL, 数据在后面, 如果是一个100页的报表，这样显示肯定不\n正确。较为人性化的显示应该将空值放在最后, 即：\nSELECT * FROM emp ORDER BY comm DESC nulls last; (注意：是 nulls 而不是null)\n排序的规则\n可以按照select语句中的列名排序\n可以按照别名排序\n可以按照表达式排序,如order by sal*12+nvl(comm, 0)\n可以按照select语句中的列名的顺序值(序号)排序\n如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推\ndesc和asc只作用于最近的一列.\n4 单行函数 单行函数:只对一行进行变换, 产生一个结果。函数可以没有参数, 但必须要有返回值。如：concat、nvl\n操作数据对象\n接受参数返回一个结果\n只对一行进行变换\n每行返回一个结果\n可以转换数据类型\n可以嵌套\n参数可以是一列或一个值\n4.1 字符函数 操作对象是字符串。\n大致可分为两大类: 一类是大小写控制函数, 主要有lower、upper、initcap:\n案例:\n大小写转换lower和upper, 首字母大写initcap函数测试\nSELECT lower(\u0026#39;HeLlo, WORld\u0026#39;) 转小写, upper(\u0026#39;HellO, woRld\u0026#39;) 转大写, initcap(\u0026#39;hello, world\u0026#39;) 首字母大写 FROM dual; 另一类是字符控制函数: 有CONCAT、SUBSTR、LENGTH/LENGTHB、INSTR、LPAD | RPAD、TRIM、REPLACE\nsubstr(a, b)：在字符串a中，从第b位开始取(计数从1开始)，取到结尾\n案例:\n从helloworld字符串中的第3位开始后面的所有字符\nselect substr('helloworld', 3) from dual; \u0026mdash;à得到lloworld\nsubstr(a, b, c)：从a中，第b位开始，向右取c位。\n案例:\n从hello world字符串中, 从第3位开始取连续取5个字符\nSELECT substr(\u0026#39;helloworld\u0026#39;, 3, 5) FROM dual; length:字符数, lengthb:字节数：\n案例:\nSELECT length(\u0026#39;hello world\u0026#39;) 字符数, lengthb(\u0026#39;hello world\u0026#39;) 字节数 FROM dual; SELECT length(\u0026#39;哈喽我的\u0026#39;) 字符数, lengthb(\u0026#39;哈喽我的\u0026#39;) 字节数 FROM dual; 注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,\n这两个函数对于普通字符串没有什么区别.\ninstr: 在母串中查找子串, 找到返回下标, 计数从1开始, 没有返回0\n案例\n查找hello world字符串中, llo子串首次出现的下标位置\nSELECT instr(\u0026#39;hello world\u0026#39;, \u0026#39;llo\u0026#39;), instr(\u0026#39;hello world\u0026#39;, \u0026#39;www\u0026#39;) FROM dual; 注意: 下标是从1开始的.\nlpad：左填充，\n参1: 待填充的字符串，\n参2: 填充后字符串的总长度(字节)，\n参3: 填充什么\nrpad: 右填充, 参数同lpad.\n案例\nselect lpad('abcd', 10, '*') 左, rpad('abcd', 10, '#') 右 from dual; 结果显示: ******abcd abcd######\nselect lpad('abcd', 15, '你')左填充, rpad('abcd', 16, '我') 右填充 from dual; 结果显示: 你你你你你abcd abcd我我我我我我\n注意: lpad(\u0026lsquo;abcd\u0026rsquo;, 15, \u0026lsquo;你\u0026rsquo;)由于abcd本身占4个字节, 需要填充11个字节才能\n够15个字节, 但是一个汉字占两个字节, 所以填充了1个空格+5个汉字.\ntrim:去掉前后指定的字符(不去掉中间的)\n案例\n去掉\u0026rsquo; hello world \u0026lsquo;两端的空格\nSELECT trim(\u0026#39; hello world \u0026#39;) FROM dual; 去掉Hello worldH字符串前后的H字符\nSELECT trim(\u0026#39;H\u0026#39; FROM \u0026#39;Hello worldH\u0026#39;) FROM dual; replace:替换\n案例\n将hello world字符串中的l替换成*\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;*\u0026#39;) FROM dual; 删除字符串\u0026rsquo;hello world\u0026rsquo;中的字符\u0026rsquo;l\u0026rsquo;\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;\u0026#39;) FROM dual; 4.2 数值函数 ROUND: 四舍五入\nROUND(45.926, 2)\t45.93\nTRUNC:\t截断\nTRUNC(45.926, 2)\t45.92\nMOD: 求余\nMOD(1600, 300)\t100\n案例: round(45.926, 2) :2表达的含义是小数点向右保留两位并四舍五入，第二个参数如果是0可以省略.\nSELECT round(45.926, 2), round(45.926, 1), round(45.926, 0) , round(45.926), round(45.926, -1) , round(45.926, -2) FROM dual; trunc函数, 正数表示小数点之后, 负数表示小数点之前的位数, 0可以不写. SELECT trunc(45.926, 2), trunc(45.926, 1), trunc(45.926, 0), trunc(45.926), trunc(45.926, -1) , trunc(45.926, -2) FROM dual; mod函数: 求余数 select mod(1600, 600) from dual; \u0026ndash;à结果为100\nceil函数:向上取整 floor函数:向下取整\nselect ceil(19.23), floor(19.23) from dual;\n4.3 时间函数 在Oracle中日期型的数据，既有日期部分，也有时间部分.\n案例:\nselect sysdate from dual; 这里没有时间部分，因为系统默认的格式中不显示时间\nselect to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual; 显示日期到秒\nselect to_char(sysdate, 'day') from dual ; 可以显示当前日期星期几\n日期加、减数字得到的结果仍为日期。单位：天\n显示 昨天、今天、明天\nSELECT (sysdate-1) 昨天, (sysdate) 今天, (sysdate + 1) 明天 FROM dual; SELECT to_char(sysdate-1, \u0026#39;yyyy-mm-dd\u0026#39;) 昨天, to_char(sysdate, \u0026#39;yyyy-mm-dd\u0026#39;) 今天, to_char(sysdate+1, \u0026#39;yyyy-mm-dd\u0026#39;) 明天 FROM dual; à转换日期格式; 既然一个日期型的数据加上或者减去一个数字得到的结果仍为日期，两个日期相减，得到的就是相差的天数。\n计算员工的工龄, 显示从入职以来的总天数, 星期数, 总月数, 总年数\nSELECT ename, hiredate, (sysdate - hiredate) 天, (sysdate - hiredate)/7 星期, (sysdate - hiredate)/30 月, (sysdate - hiredate)/365 年 FROM emp; 日期和日期可以相减表示相隔多少天, 但是不允许相加, 两个日期相加没有意义, 日期只能和数字相加\u0026mdash;-à类似于两个指针相加没有意义一样.\n​\tselect sysdate+hiredate from emp; 报错: ORA-00975: 不允许日期 + 日期\n4.4 日期函数 上面求取员工工龄的结果不精确，如果想将其算准确，可以使用日期函数来做。\nmonths_between\n两个日期值相差的月数(精确值)\nSELECT ename, hiredate, (sysdate-hiredate)/30 一, months_between(sysdate, hiredate) 二 FROM emp; months_between函数更精确, 在表示月份差的时候要使用months_between函数.\nadd_months\n在某个日期值上，加上多少的月，正数向后计算，负数向前计算。\n计算95个月以后是哪年、哪月、那天：\nselect add_months(sysdate, 95) 哪一天 from dual;\n结果是: 2025/10/11\nlast_day\n日期所在月的最后一天, 要么30, 31或者28\nSELECT last_day(sysdate) FROM dual; 上个月的最后一天\nSELECT last_day(add_months(sysdate, -1)) FROM dual; 下一个月的最后一天\nSELECT last_day(add_months(sysdate, 1)) FROM dual; next_day:指定日期的下一个日期\n从当前时间算起, 下一个星期一的日期\nSELECT next_day(sysdate, \u0026#39;星期一\u0026#39;) FROM dual; 从特定日期得到之后的第一个星期几的日期\nSELECT next_day(to_date(\u0026#39;2017-11-11\u0026#39;, \u0026#39;yyyy-mm-dd\u0026#39;), \u0026#39;星期三\u0026#39;) FROM dual; round、trunc 对日期型数据进行四舍五入和截断\nSELECT round(sysdate, \u0026#39;month\u0026#39;), round(sysdate, \u0026#39;year\u0026#39;) FROM dual; SELECT trunc (sysdate, \u0026#39;month\u0026#39;), trunc(sysdate, \u0026#39;year\u0026#39;) FROM dual; 4.5 转换函数 在不同的数据类型之间完成转换, 如将\u0026quot;123\u0026quot;转换为123, 有隐式转换和显示转换之分。\n隐式转换(由oracle数据库来完成)\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 若是显示转换:\nSELECT * FROM emp WHERE to_char(hiredate, \u0026#39;DD-MON-RR\u0026#39;) = \u0026#39;17-11月-81\u0026#39;; 或者\nSELECT * FROM emp WHERE hiredate = to_date(\u0026#39;17-11月-81\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;); 显示转换(通过转换函数来完成)\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;) FROM dual; 注意: 隐式转换，前提条件是：被转换的对象是可以转换的。（ABC→625 可以吗？）\nimg 显示转换：借助to_char(数据，格式)、to_number、to_date函数来完成转换。\nimg ​\n格式 说明 举例 YYYY Full year in numbers 2011 YEAR Year spelled out(年的英文全称) twenty eleven MM Two-digit value of month 月份（两位数字） 04 MONTH Full name of the month（月的全称） 4月 DY Three-letter abbreviation of the day of the week(星期几) 星期一 DAY Full name of the day of the week 星期一 DD Numeric day of the month 02 如果隐式转换和显示转换都可以使用，应该首选哪个呢？\n注意：如果隐式、显示都可以使用，应该首选显示，这样可以省去oracle的解析过程。\n练习：在屏幕上显示如下字符串：\n2015-05-11 16:17:06 今天是 星期一\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; 说明: 在固定的格式里加入自定义的格式，是可以的，必须要加””。\n反向操作：已知字符串'2015-05-11 15:17:06 今天是 星期一\u0026rsquo;转化成日期.\n使用to_date函数将字符串转换成date类型\nSELECT to_date(\u0026#39;2015-05-11 15:17:06 今天是 星期一\u0026#39;, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; img 案例:\n查询员工的薪水: 使用2位小数, 本地货币代码, 千位符 SELECT to_char(sal, \u0026#39;L9,999.99\u0026#39;) FROM emp; 特别注意:\u0026lsquo;L9,999.99\u0026rsquo;之间没有空格\n将￥2,975.00转化成数字： SELECT to_number(\u0026#39;￥2,975.00\u0026#39;, \u0026#39;L9,999.99\u0026#39;) 转成数字 FROM dual; 4.6 通用函数(了解) 这些函数适用于任何数据类型，同时也适用于空值：\nNVL (expr1, expr2)\nNVL2 (expr1, expr2, expr3)\nNULLIF (expr1, expr2)\nCOALESCE (expr1, expr2, \u0026hellip;, exprn)\nnvl2:是nvl函数的增强版。\tnvl2(a, b, c) 当a = null 返回 c, 否则返回b\n使用nvl2求员工的年收入：\nSELECT empno, ename, sal, sal*12, sal * 12 + nvl2(comm, comm, 0) 年薪 FROM emp; nullif: nullif(a, b) 当 a = b 时返回null, 不相等的时候返回a值。\nselect nullif('hello', 'hello') from dual; 返回空\nselect nullif('hello', 'world') from dual; 返回hello\nselect ename, nullif(comm, null) from emp;\ncoalesce:coalesce(a, b, c, …, n) 从左向右找参数中第一个不为空的值。\nSELECT comm, sal, coalesce(comm, sal) 结果值 FROM emp; 4.7 条件表达式 例子：老板打算给员工涨工资, 要求：\n总裁(PRESIDENT)涨1000, 经理(MANAGER)涨800, 其他人涨400. 请将涨前, 涨后的薪水列出。\n涨后的薪水是根据job来判断的\n思路：\tif 是总裁(\u0026lsquo;PRESIDENT\u0026rsquo;) then + 1000\nelse if 是经理(\u0026#39;MANAGER\u0026#39;) then + 800 else + 400\t但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode\ncase:是一个表达式，其语法为：\nCASE *expr WHEN *comparison_expr1 THEN *return_expr1 [WHEN *comparison_expr2 THEN *return_expr2 WHEN *comparison_exprn THEN *return_exprn ELSE *else_expr] END SQL\u0026gt;SELECT ename, job, sal 涨前薪水, CASE job WHEN \u0026#39;PRESIDENT\u0026#39; THEN sal+1000 WHEN \u0026#39;MANAGER\u0026#39; THEN sal+800 ELSE sal + 400 END 涨后薪水 FROM emp; 注意语法：when then 与下一个when then以及end之间没有“,”分割符, 可以将when当成if.\ndecode：是一个函数，其语法为：\nDECODE(*col|expression, search1, result1\n[*, search2, result2,...,]\r[*, default])\r除第一个和最后一个参数之外，中间的参数都是成对呈现的 (参1, 条件, 值, 条件, 值, …, 条件, 值, 尾参)\nSELECT ename, job, sal 涨前薪水, decode(job, \u0026#39;PRESIDENT\u0026#39;, sal + 1000, \u0026#39;MANAGER\u0026#39;, sal + 800, sal + 400) AS 涨后薪水 FROM emp; 5 分组函数 5.1分组函数 多行函数也叫组函数，本章学习目标:\n了解组函数。\n描述组函数的用途。\n使用GROUP BY 子句数据分组。\n使用HAVING 子句过滤分组结果集。\n分组函数作用于一组数据，并对一组数据返回一个值\n常用的有5个函数: avg、count、max、min、sum操作的是一组数据，返回一个结果。\n案例\n求员工的工资总额 SELECT sum(sal) FROM emp; 求员工人数 SELECT count(*) FROM emp; 平均工资 SELECT sum(sal)/count(*) 方式一, avg(sal) 方式二 FROM emp; 方式一和方式二结果一样, 当有空值得时候结果有可能不一样。如：奖金。\n求员工的平均奖金 SELECT sum(comm)/count(*) 方式一, sum(comm)/count(comm) 方式二, avg(comm) 方式三 FROM emp; 结果：方式一结果不同，方式二 和 方式三结果一样。\n说明: avg(comm)是求comm有值的几个的平均值, 跟方式二是相同的.\nNULL空值：组函数都有自动滤空功能(忽略空值)，所以：\nselect count(*), count(comm) from emp; 执行结果不相同。\n说明: count(comm)返回不为空的comm的总个数\n如何屏蔽组函数的滤空功能?\nSELECT count(*), count(nvl(comm, 0)) FROM emp; 但是实际应用中, 结果为14和结果为4都有可能对，看问题本身是否要求统计空值。\n5 count函数\n求emp表的部门总个数, 如果要求不重复的个数, 使用distinct。\nSELECT count(distinct deptno) FROM emp; 求emp表中的工种的总个数\nSELECT count(distinct job) FROM emp; 5.2 分组数据 分组数据使用group by关键字.\n按照group by 后给定的表达式，将from后面的table进行分组。针对每一组，使用组函数, 即先分组, 再分组统计.\n案例\n查询“部门”的平均工资： 分析: 结合select * from emp order by deptno; 结果分析分组\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno; 上SQL语句可以抽象成：select a, 组函数(x) from 表 group by a; 这样的格式。\r如果select a, b, 组函数(x) …… group by 应该怎么写？\n注意: 在select列表中所有没有包含在组函数中的列, 都必须在group by的后面出现.所以上面的问题应该写成group by a, b; 没有b就会出错, 不会执行sql语句。但, 反之可以。group by a，b，c; c可以不出现在select语句中。\ngroup by后面有多列的情况：\n查询部门内部不同职位的平均工资: SELECT deptno, job, avg(sal) FROM emp GROUP BY deptno, job ORDER BY 1; 分析该SQL的作用：\n因为`deptno, job` 两列没有在组函数里面，所以必须同时在group by后面。\r该SQL的语义:按部门, 不同的职位统计平均工资。先按第一列分组, 如果第一列相同, 再按第二列分组, 所以查询结果中，同一部门中没有重复的职位。\n关于分组函数常见的问题:\n在select后面出现的列, 该列没有出现在分组函数中, 但是未出现在group by子句中. 如: select deptno, job, avg(sal) from emp group by deptno;\n\u0026mdash;-job未出现在group by子句中\n报错: ORA-00979: 不是 GROUP BY 表达式.\nselect count(*) from emp; 分析: count是分组函数, 但是select后面没有其他列, 所以不必非出现group by子句,\n该sql语句意思是统计emp表中员工总数;\n当然: `select count(*) from emp group by deptno; 也对, 但是查询出来的结果并不知道是\n哪个组的总数.\n5.3 Having 使用 HAVING 过滤分组:\n行已经被分组。\n使用了组函数。\n满足HAVING 子句中条件的分组将被显示。\n其语法：\nSELECT\tcolumn, group_function\nFROM\ttable\n[WHERE\tcondition]\n[GROUP BY\tgroup_by_expression]\n[HAVING\tgroup_condition]\n[ORDER BY\tcolumn];\n查询平均薪水大于2000的部门 ：\n分析：该问题实际上是在分组的基础上过滤分组。\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal)\u0026gt;2000; 注意：having后面不能使用别名, 可以使用函数\n​\n特别注意: 不能在 WHERE 子句中使用组函数.\n可以在 HAVING 子句中使用组函数。\n从功能上讲，where和having都是将满足条件的结果进行过滤。但是差别是where子句中不能使用组函数, 所以上句中的having不可以使用where代替。\r求10号部门的平均工资：\n分析：在上一条的基础上，having deptno=10;\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING deptno=10; 使用where也可以做这件事\nSELECT deptno, avg(sal) FROM emp WHERE deptno=10 GROUP BY deptno; 在子句中没有使用组函数的情况下，where、having都可以，应该怎么选择？\nSQL优化： 尽量采用where。\n如果有分组的话，where是先过滤再分组，而having是先分组再过滤。当数据量庞大如1亿条，where优势明显。\n6 多表查询 理论基础：——笛卡尔集\n笛卡尔集的行数 = table1的行数 x table2的行数\n笛卡尔集的列数 = table1的列数 + table2的列数\n在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。\n多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。\n根据连接条件的不同可以划分为：等值链接、不等值链接、外链接、自连接\nOracle 连接:\nEquijoin：等值连接\nNon-equijoin：不等值连接\nOuter join：外连接\nSelf join：自连接\nSQL: 1999\nCross joins\nNatural joins\nUsing clause\nFull or two sided outer joins\n6.1 等值连接： ​\t从概念上，区分等值连接和不等值连接非常简单，只需要辨别where子句后面的条件，是“=”为等值连接。不是“=”为不等值连接。\n查询员工信息：员工号 姓名 月薪和部门名称\n​\t分析：这个问题涉及emp(员工号，姓名，月薪) 和dept(部门名称)两张表 ——即为多表查询。\n​\t通常在进行多表查询的时，会给表起一个别名，使用“别名.列名”的方式来获取数据，直接使用“表名.列名”语法上是允许的，但是实际很少这样用。\n如果：select e.empno, e.ename, e.sal, e.deptno, d.dname, d.deptno from emp e, dept d; 直接得到的是笛卡尔全集。其中有错误结果。所以应该加 where 条件进行过滤.\nSELECT e.empno, e.ename, e.sal, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno; 如果有N个表，where后面的条件至少应该有N-1个, 才会不产生笛卡尔积.\n6.2 不等值连接： 将上面的问题稍微调整下，查询员工信息：员工号 姓名 月薪 和 薪水级别(salgrade表)\nSELECT * FROM salgrade; 看到员工总的薪水级别，共有5级，员工的薪水级别应该满足 \u0026gt;=当前级别的下限，\u0026lt;=该级别的上限：\n过滤子句应该：\twhere e.sal \u0026gt;= s.losal and e.sal \u0026lt;= s.hisal;\nSELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal \u0026gt;= s.losal AND e.sal \u0026lt;= s.hisal; 更好的写法应该使用between…and:\nSELECT s.grade, e.empno, e.ename, e.sal, e.job FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ORDER BY 1; 6.3 外链接： l 按部门统计员工人数，显示： 部门号 部门名称 人数\n分析:\n​\t人数：一定是在emp表中，使用count()函数统计emp表中任一非空列均可。\n​\t部门名称：在dept表dname中, 直接读取即可。\n​\t部门号：任意，两张表都有, 两个表的联系是deptno.\n所以:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno=d.deptno GROUP BY d.deptno, d.dname; 注意：由于使用了组函数count()，所以组函数外的d.deptno和d.dname必须放到group by后。\n得到查询结果，但是select * from dept发现40号部门没有显示出来，原因是40号部门没有员工，where没满足。结果不对，40号部门没有员工，应该在40号部门位置显示0。\n我们希望： 在最后的结果中，包含某些对于where条件来说不成立的记录 （外链接的作用）\nl 左外链接：当 where e.deptno=d.deptno 不成立的时候，=左边所表示的信息，仍然被包含。\n​\t写法：与叫法相反：where e.deptno=d.deptno(+)\nl 右外链接：当 where e.deptno=d.deptno 不成立的时候，=右边所表示的信息，仍然被包含。\n​\t写法：依然与叫法相反：where e.deptno(+)=d.deptno\n以上我们希望将没有员工的部门仍然包含到查询的结果当中。因此应该使用外链接的语法。\n写法1:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno(+)=d.deptno GROUP BY d.deptno, d.dname; 写法2:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE d.deptno = e.deptno(+) GROUP BY d.deptno, d.dname; 这样就可以将40号部门包含到整个查询结果中。人数是0\n注意：不能使用count(e.*), 应该是某个表的具体的列.\n思考: 能否使用count(), count()与count(e.empno)有什么不同???\n6.4 自连接： 核心，通过表的别名，将同一张表视为多张表。\n例如: 查询员工信息：xxx的老板是 yyy\n分析：执行select * from emp; 发现，员工的老板也在员工表之中，是一张表。要完成多表查询我们可以假设，有两张表，一张表e(emp)只存员工、另一张表b(boss)只存员工的老板。—— from e, b;\n老板和员工之间的关系应该是：where e.mgr=b.empno (即:员工表的老板 = 老板表的员工)\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || b.ename FROM emp e, emp b WHERE e.mgr=b.empno; 执行, 发现结果正确了, 但是KING没有显示出来. KING的老板是他自己. 应该怎么显示呢?\n使用外连接:\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || nvl(b.ename, \u0026#39;他自己\u0026#39; ) FROM emp e, emp b WHERE e.mgr=b.empno(+); 使用concat函数应该怎么做呢??\nSELECT concat(e.ename, concat(\u0026#39; 的老板是 \u0026#39;, nvl(b.ename, \u0026#39;他自己\u0026#39; ))) FROM emp e, emp b WHERE e.mgr = b.empno(+); 7 子查询 子查询语法很简单，就是select 语句的嵌套使用, 即sql嵌套sql。\n查询工资比SCOTT高的员工信息.\n分析：两步即可完成\r查出SCOTT的工资 SELECT ename, sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;; # 结果为3000 查询比3000高的员工 SELECT * FROM emp WHERE sal\u0026gt;3000; 通过两步可以将问题结果得到。子查询，可以将两步合成一步。\n——子查询解决的问题：问题本身不能一步求解的情况。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;); 子查询语法格式：\nSELECT *select_list FROM *table WHERE *expr operator (SELECT *select_list FROM *table); 本章学习目标:\n描述子查询可以解决的问题\n定义子查询(子查询的语法)\n列出子查询的类型。\n书写单行子查询和多行子查询。\n7.1 定义子查询 需要注意的问题 合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩 进)\n小括号( )\n主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可\n可以在主查询的where、select、having、from后都可以放置子查询\n不可以在主查询的group by后面放置子查询 (SQL语句的语法规范)\n强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)\n一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外\n一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by\n单行子查询只能使用单行操作符；多行子查询只能使用多行操作符\n子查询中的null值\n7.2 主、子查询在不同表间进行。 查询部门名称是“SALES”的员工信息\n主查询：查询员工信息。select * from emp;\n子查询：负责根据部门名称(在dept表中)得到部门号。\nSELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;; SELECT * FROM emp WHERE deptno= (SELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;); 主查询, 查询的是员工表emp, 子查询, 查询的是部门表dept。是两张不同的表。\r将该问题使用“多表查询”解决\nSELECT e.* FROM emp e, dept d WHERE e.deptno=d.deptno AND d.dname=\u0026#39;SALES\u0026#39;; 两种方式哪种好呢？\nSQL优化: 理论上，既可以使用子查询，也可以使用多表查询，尽量使用“多表查询”。子查询有2次from, 与数据库服务的交互多.\n不同数据库处理数据的方式不尽相同，如Oracle数据库中，子查询地位比较重要，做了深入的优化。有可能实际看到结果是子查询快于多表查询。\n7.3 在主查询的where select having from 放置子查询 子查询可以放在select后，但，要求该子查询必须是单行子查询：(该子查询本身只返回一条记录，2+叫多行子查询)\nSELECT empno, ename, (SELECT dname FROM dept) 部门 FROM emp; 注意：SQL中没有where是不可以的，那样是多行子查询。\u0026ndash;但这是不符合实际情况的.\n应该:\nSELECT empno, ename, (SELECT dname FROM dept WHERE deptno = 10) 部门 FROM emp WHERE deptno = 10; 进一步理解查询语句，实际上是在表或集合中通过列名来得到行数据，子查询如果是多行，select无法做到这一点。\n在 having 后 和 where 类似。但需注意在where后面不能使用组函数。\n在having后面使用子查询的例子:\n查询部门平均工资高于30号部门平均工资的部门和平均工资\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal) \u0026gt; (SELECT avg(sal) FROM emp WHERE deptno = 30); 7.4 在from后面放置的子查询(***) 表, 代表一个数据集合、查询结果(SQL)语句本身也代表一个集合, 把查询结果看成一个表.\n查询员工的姓名、薪水和年薪：\n说明：该问题不用子查询也可以完成。但如果是一道填空题：\rselect * from ___________________\n因为显示的告诉了，要使用select *, 所以只能:\nSELECT * FROM (SELECT ename, sal, sal*12 年薪 FROM emp); 将select 语句放置到from后面，表示将select语句的结果，当成表来看待. 这种查询方式在Oracle语句中使用比较频繁.\n7.5 单行子查询只能使用单行操作符；多行子查询只能使用多行操作符 7.5.1单行子查询： 单行子查询就是该条子查询执行结束时, 只返回一条记录(一行数据)。\n使用单行操作符:\n=、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=\n单行子查询:\n单行子查询, 只能使用单行操作符\n在一个主查询中可以有多个子查询。\n子查询里面可以嵌套多层子查询。\n子查询也可以使用组函数。子查询也是查询语句，适用于前面所有知识。\n案例:\n查询emp表部门编号为10且高于本部门的平均工资的员工信息 SELECT * FROM emp WHERE sal\u0026gt; (SELECT avg(sal) FROM emp WHERE deptno=10) AND deptno=10; 查询emp表中与SMITH职位相同的员工信息 SELECT * FROM emp WHERE job = (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询薪水低于本公司的平均薪水且职位与SMITH职位相同的所有员工信息 SELECT * FROM emp WHERE sal\u0026lt; (SELECT avg(sal) FROM emp) AND job= (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询emp表中最低工资员工和最高工资员工的信息 SELECT * FROM emp WHERE sal= (SELECT max(sal) FROM emp) OR sal= (SELECT min(sal) FROM emp); 5 思考??,下列sql语句正确吗?\nSELECT * FROM emp WHERE sal= (SELECT min(sal) FROM emp GROUP BY deptno); 注意: =、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=是单行操作符, 而后面的子查询会返回多条记录,所以会报错, 要解决这个问题要使用多行子查询.\n7.5.2多行子查询： 子查询返回2条记录以上就叫多行。\n多行操作符有：\nIN\t等于列表中的任意一个\nANY\t和子查询返回的任意一个值比较\nALL\t和子查询返回的所有值比较\nIN(表示在集合中)：\n解决上面的那个问题?\nSELECT * FROM emp WHERE sal IN (SELECT min(sal) FROM emp GROUP BY deptno); 查询部门名称为SALES和ACCOUNTING的员工信息。\n分析：部门名称在dept表中，员工信息在emp表中,子查询应先去dept表中将SALES和ACCOUNTING的部门号得到，交给主查询得员工信息.\nSELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept WHERE dname IN (\u0026#39;SALES\u0026#39;, \u0026#39;ACCOUNTING\u0026#39;)); 也可以使用多表查询来解决该问题：\rSELECT e.* FROM emp e, dept d WHERE e.deptno = d.deptno AND (d.dname = \u0026#39;SALES\u0026#39; OR d.dname = \u0026#39;ACCOUNTING\u0026#39;); 红色语句也可以用 d.dname in ('SALES ', 'ACCOUNTING ')\n这种解决方式，注意使用()来控制优先级。 如果查询不是这两个部门的员工，只要把in → not in就可以了，注意不能含有空值。\nANY(表示和集合中的任意一个值比较)：\n查询薪水比30号部门任意一个员工高的员工信息：\n分析：首先查出30号部门的员工薪水的集合，然后\u0026gt;它就得到了该员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE deptno=30); # 正确吗？ 这样是错的，子句返回多行结果。而‘\u0026gt;’是单行操作符。——应该将‘\u0026gt;’替换成‘\u0026gt; any’\n实际上\u0026gt;集合的任意一个值，就是大于集合的最小值。\nSELECT * FROM emp WHERE sal \u0026gt; any (SELECT sal FROM emp WHERE deptno=30); 若将这条语句改写成单行子查询应该怎么写呢？\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT min(sal) FROM emp WHERE deptno=30); ALL(表示和集合中的所有值比较)：\n查询薪水比30号部门所有员工高的员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; ALL (SELECT sal FROM emp WHERE deptno=30); 同样，将该题改写成单行子句查询：\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT max(sal) FROM emp WHERE deptno=30); 对于any 和 all 来说，究竟取最大值还是取最小值，不一定。将上面的两个例子中的“高”换成“低”，any和all就各自取相反的值了。\n子查询中null 判断一个值等于、不等于空，不能使用=和!=号，而应该使用is 和 not。\n如果集合中有NULL值，不能使用not in。如： not in (10， 20， NULL)，但是可以使用in。为什么呢？\n先看一个例子：\n查询不是老板的员工信息：\n分析：不是老板就是树上的叶子节点。在emp表中有列mgr，该列表示该员工的老板的员工号是多少。那么，如果一个员工的员工号在这列中，那么说明这员工是老板，如果不在，说明他不是老板。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp); 但是运行没有结果，因为有NULL\n查询是老板的员工信息：只需要将not去掉。\nSELECT * FROM emp WHERE empno IN (SELECT mgr FROM emp ); 还是我们之前null的结论：in (10, 20, null) 可以，not in (10, 20, null) 不可以\nselect * from emp where deptno in (10, 20, null);\u0026mdash;\u0026ndash;可以\nSELECT * FROM emp WHERE deptno NOT IN (10, 20, null);# -----不可以 例如：a not in(10, 20, NULL) 等价于 (a != 10) and (a != 20) and (a != NULL)\n因为, not in操作符等价于 !=All，最后一个表达式为假，整体假;\n而a in (10, 20, NULL)等价于(a = 10) or (a = 20) or (a = null)只要有一个为真即为真。\nin 操作符等价于 = Any SELECT * FROM emp WHERE deptno = any(10, 20, null);\t# 等价于 SELECT * FROM emp WHERE deptno IN (10, 20, null); 继续，查询不是老板的员工信息, 只要将空值去掉即可。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp WHERE mgr is NOT null); 注意: not in 后面的结合中不能有null\n一般不在子查询中使用order by 一般情况下，子查询使用order by或是不使用order by对主查询来说没有什么意义。子查询的结果给主查询当成集合来使用，所以没有必要将子查询order by。\n但，在Top-N分析问题中，必须使用order by\n一般先执行子查询，再执行主查询 含有子查询的SQL语句执行的顺序是，先子后主。\n但，相关子查询例外.\n8 集合运算 l 查询部门号是10和20的员工信息?\t有三种方法\nSELECT * FROM emp WHERE deptno in(10, 20); SELECT * FROM emp WHERE deptno=10 OR deptno=20; n 集合运算：\nSELECT * FROM emp WHERE deptno=10;\t# 加上 SELECT * FROM emp WHERE deptno=20; 集合运算所操作的对象是两个或者多个集合，而不再是表中的列(select一直在操作表中的列)\n8.1 集合运算符 集合运算的操作符。A∩B、A∪ B、A - B\nimg SELECT * FROM emp WHERE deptno=10 UNION SELECT * FROM emp WHERE deptno=20; union和union all的区别: union会去掉重复的, 而union all会全部显示\n注意：这是一条SQL语句。\n8.2 集合运算需要注意的问题： 参与运算的各个集合必须列数相同，且对应每个列的类型一致。\n采用第一个集合的表头作为最终使用的表头.\n可以使用括号()先执行后面的语句。\n问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出：\nimg 分析SQL执行结果。\n第一部分数据是按照deptno和job进行分组；select 查询deptno、job、sum(sal)\n第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal)\n第三部分数据不按照任何条件分组，即group by null；select 查询sum(sal)\n所以，整体查询结果应该= group by deptno,job + group by deptno + group by null\n按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!\nSELECT deptno, job, sum(sal) FROM emp GROUP BY deptno,job UNION SELECT deptno, to_char(null), sum(sal) FROM emp GROUP BY deptno UNION SELECT to_number(null), to_char(null), sum(sal) FROM emp; 交集和差集与并集类似，也要注意以上三点。只不过算法不同而已。\n需要注意:集合运算的性能一般较差.\nSQL的执行时间：\n`set timing on/off`\t默认是off 9 数据处理 SQL语言的类型： 数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵 语言)，就是指代：insert、update、delete、select这四个操作。\nDDL语句。(Data Definition Language 数据定义语言)。 如：truncate table(截断/清空 一张表)\ncreate table(表)、create view(视图)、create index(索引)、create sequence(序列)、 create synonym(同义词)、alter table、drop table。 DCL语句。DCL（Data Control Language数据控制语言）如：\ncommit(提交)、rollback(回滚)\n插入数据insert： l 使用 INSERT 语句向表中插入数据。其语法为：\nINSERT INTO\t*table [(column [, column\u0026hellip;])]\nVALUES\t(value [, value\u0026hellip;]);\nl 如果：values后面的值，涵盖了表中的所有列，那么table的列名可以省略不写。\ndesc emp; 查看员工表的结构，得到所有的列名。\ninsert into emp values (1001, \u0026#39;Tom\u0026#39;, \u0026#39;Engineer\u0026#39;, 7839, sysdate, 5000, 200, 10 ); insert into emp values (1005, \u0026#39;Bone\u0026#39;, \u0026#39;Raphealy\u0026#39;, 7829, to_date(\u0026#39;17-12月-82\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;), NULL, 300, 20); l 如果:插入的时候没有插入所有的列, 就必须显式的写出这些列的名字。\ninsert into emp(empno, ename, sal, deptno) values(1002, \u0026#39;Marry\u0026#39;, 6000, 20); 注意：字符串和日期都应该使用 \u0026rsquo; \u0026lsquo;号引用起来.\nl 没有写出的列自动填NULL, 这种方式称之为“隐式插入空值”。\nl 显示插入空值: insert into emp(empno, ename, sal) values(1003, \u0026lsquo;Jim\u0026rsquo;, null);\n“\u0026amp;” 地址符： l 在insert语句中使用\u0026amp;可以让用户输入值:\ninsert into emp(empno, ename, sal, deptno) values(\u0026amp;empno, \u0026amp;ename, \u0026amp;sal, \u0026amp;deptno); 理论上“\u0026amp;”后面的变量名任意，习惯上一般与前面的列名相同，赋值的时候清楚在给谁赋值。\n当再次需要插入新员工的时候直接输入“/”就可以继续输入新员工的值, /表示重复刚刚执行过的sql语句.\nl 可以在DML的任意一个语句中输入“\u0026amp;”,\nSELECT empno, ename, sal, \u0026amp;t FROM emp ; 执行时，会提示你输入要查询的列名。当输入不同的列名时，显示不同的执行结果。\nselect * from \u0026amp;t; 修改t的值，可以查看不同表。\n总结: \u0026amp;类似于c语言中的宏替换, 只是进行简单的字符串替换操作, 但是select关键字不能用\u0026amp;指代. 如 \u0026amp;t * from emp; 而from, 表名, where 是可以用\u0026amp;指代的, 如: select * \u0026amp;t emp; select * from \u0026amp;t; select * from emp \u0026amp;t sal\u0026gt;2000;但是通常情况都是替换值.\n批处理： 一次插入多条数据, 使用一个新创建的表用来测试.\n创建一张与emp完全相同的表，用于测试。\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; SELECT * FROM tab; SELECT * FROM emp10; desc emp10; 一次性将emp表中所有10号部门的员工, 放到新表emp10中来。\ninsert into emp10SELECT * FROM emp WHERE deptno=10; 一次性将emp表中的指定列插入到表emp10中。\n注意：insert的列名, 要和select的列名一致\rinsert into emp10(empno, ename, sal, deptno); SELECT empno, ename, sal, deptno FROM emp WHERE deptno=10; 注意没有values关键字了, 但列名必须一一对应.\n总结: 子查询可以出现在DML的任何语句中.\n更新数据update 格式: update 表名 set col=值 where condtion\n对于更新操作来说，一般会有一个“where”条件，如果没有这限制条件，更新的就是整张表。\nUPDATE emp10 SET sal=4000, comm=300 WHERE ename = \u0026#39;CLARK\u0026#39;; 注意：若没有where限定，会将所有的员工的sal都设置成4000，comm设置成300；\n能否将某一列的值设置为null呢?\nUPDATE emp10 SET comm = null WHERE empno=1000; # ----可以 能否在查询的时候where条件中指定列的值为null吗?\nSELECT * FROM emp WHERE comm = null; # ----不可以 10 删除数据delete 格式: delete from 表名 where condtion\ndelete FROM emp10 WHERE empno=7782; 注意: 如不加\u0026quot;where\u0026quot;会将整张表的数据删除。\n“from”关键字在Oracle中可以省略不写，但MySQL中不可以;\r但在使用的时候建议还是加上from.\ndelete 和 truncate的区别： delete 逐条删除表“内容”，truncate 先摧毁表再重建。\n(由于delete使用频繁，Oracle对delete优化后delete快于truncate)\ndelete 是DML语句，truncate 是DDL语句。\nDML语句可以闪回(flashback)，DDL语句不可以闪回。\n（闪回： 做错了一个操作并且commit了，对应的撤销行为。了解）\n由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。\n（同样是由于Oracle对delete进行了优化，让delete不产生碎片）。\n两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动\ndelete不会释放空间，truncate 会释放空间\n用delete删除一张10M的表，空间不会释放。而truncate会。所以当确定表不再\n使用，应truncate\ndelete可以回滚rollback, truncate不可以回滚rollback。 delete和truncate的时效性 【做实验sql.sql】：验证delete和truncate的时效性。\t终端里@c:\\sql.sql\t可以执行脚本sql.sql\n语句执行时间记录开关：set timing on/off\r回显开关：set feedback on/off\r【测试步骤】：\t1. 关闭开关：\tSQL\u0026gt; set timing off;\tSQL\u0026gt; set feedback off; 2. 使用脚本创建表：\tSQL\u0026gt; @c:\\sql.sql 3. 打开时间开关：\tSQL\u0026gt; `set timing on; ` 4. 使用delete删除表内容：\tSQL\u0026gt; `delete from testdelete; ` 5. 删除表：\tSQL\u0026gt;`drop table testdelete purge;` 6. 关闭时间开关：\tSQL\u0026gt; `set timing off;` 7. 使用脚本创建表：\tSQL\u0026gt; `@c:\\sql.sql ` 8. 打开时间开关：\tSQL\u0026gt; `set timing on; `\r9. 使用truncate删除表内容：\tSQL\u0026gt; `truncate table testdelete;` 事务 联想现实生活中的银行转账业务, 从A账户把钱转给B账户.\n数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。\nn 数据库事务由以下的部分组成:\nØ 一个或多个DML 语句\nØ 一个 DDL(Data Definition Language – 数据定义语言) 语句\nØ 一个 DCL(Data Control Language – 数据控制语言) 语句\n事务的特点：要么都成功，要么都失败。\n事务的特性 l 事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。\n原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n一致性 (Consistency)：几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致。\n隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。\n持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。\n事务的起始标志：oracle中自动开启事务，以DML语句为开启标志。\n执行一个增删改查语句, 只要没有提交commit和回滚rollback, 操作都在一个事务中.\n事务的结束标志: 提交、回滚都是事务的结束标志。\n提交:\nØ 显示提交: commit\nØ 隐式提交\n有DDL语句，如：create table除了创建表之外还会隐式提交Create 之前所有没有提交的DML语句。\n正常退出(exit / quit) u 回滚:\nØ 显示回滚: rollback\nØ 隐式回滚: 掉电、宕机、非正常退出。\n控制事务 l 保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。\nimg 【示例】：1. create table testsp ( tid number, tname varchar2(20)); DDL语句会隐式commit之前操作.\n2. `set feedback on; ` 打开回显\r3. `insert into testsp values(1, 'Tom');`\r4. `insert into testsp values(2, 'Mary');`\r5. `savepoint aaa;`\r6. `insert into testsp values(3, 'Moke');`\t故意将“Mike”错写成“Moke”。\r7. `select * from testsp; `\t三条数据都显示出来。\r8.` rollback to savepoint aaa;`\t回滚到保存点aaa\r9. `select * from testsp;` 发现表中的数据保存到第二条操作结束的位置\r需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。\nsavepoint主要用于在事务上下文中声明一个中间标记, 将一个长事务分隔为多个较小的部分, 和我们编写文档时, 习惯性保存一下一样, 都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一但commit之后，所有的savepoint将失效。\n隔离级别 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n脏读: 对于两个事物T1, T2, T1读取了已经被T2更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的\n不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.\n幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.\n​\nSQL99定义4中隔离级别：\nRead Uncommitted\t读未提交数据。\nRead Commited\t读已提交数据。\t（Oracle默认）\nRepeatable Read\t可重复读。\t（MySQL默认）\nSerializable\t序列化、串行化。 （查询也要等前一个事务结束）\nOracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。\nRead Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。\n11 创建和管理表 常见的数据库对象 数据库的对象: 经常使用的数据库对象有 表、视图、索引、序列、同义词等.\n表\t基本的数据存储集合，由行和列组成。\n视图\t从表中抽出的逻辑上相关的数据集合。\n序列\t提供有规律的数值。\n索引\t提高查询的效率\n同义词\t给对象起别名\n表的基本操作 基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：\n必须以字母开头\n必须在 1–30 个字符之间\n必须只能包含 A–Z, a–z, 0–9, _, $, 和 #\n必须不能和用户定义的其他对象重名\n必须不能是Oracle 的保留字\nOracle默认存储是都存为大写\n数据库名只能是1~8位, datalink可以是128位, 和其他一些特殊字符\n创建表 创建一张表必须具备：1. Create Table的权限 2. 存储空间。我们使用的scott/hr用户都具备这两点。\ncreate table test1 (tid number, tname varchar2(20), hiredate date default sysdate); default的作用是, 当向表中插入数据的时候, 没有指定时间的时候, 使用默认值sysdate。insert into test1(tid, tname) values(11, 'wangwu');\n插入时没有指定Hiredate列，取当前时间。\n创建表时， 列所使用的数据类型：\nrowid：行地址 ——伪列\nSELECT rowid, empno, deptno FROM emp; 看到该列存储的是一系列的地址(指针), 创建索引用.\n分析，之前我们使用过的创建表的语句：\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; 在这条语句中，“where 1=2”一定为假。所以是不能select到结果的，但是将这条子查询放到Create语句中，可以完成拷贝表结构的效果。最终emp10和emp有相同的结构。\n如果, “where”给定的是一个有效的条件, 就会在创建表的同时拷贝数据。如:\ncreate table emp20 ASSELECT * FROM emp WHERE deptno=20; 这样emp20在创建之初就有5条数据。\n创建一张表，要求包含：员工号 姓名 月薪 年薪 年收入 部门名称\n分析：[员工号 姓名 月薪 年薪 年收入]在emp表中, 部门名称在dept表中, 两个表是通过deptno部门编号联系起来的.\n根据要求，涉及emp和dept两张表(至少有一个where条件)，并且要使用表达式来计算年收入和年薪。\ncreate table empincome AS ↓SELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 必须要给表达式取别名(语法要求) 由于此时的“where”条件是有效的条件，就会在创建表的同时拷贝数据。\n创建“视图”的语法与上边表的语法、顺序几乎完全一样，只是将“table”→“view”即可。\n修改表 ALTER TABLE\n追加一列: 向test1表中加入新列 image 类型是blob\nalter table test1 add image blob; desc test1; 修改一列: 将tname列的大小有20→40.\nalter table test1 modify tname varchar2(40); 删除一列: 将刚加入的新列image删除.\nalter table test1 drop column image; 重命名一列: 将列tname重命名为username.\nalter table test1 rename column tname to username;\t注意: 若是修改表的字段的长度, 若是增加长度没有问题, 若是减少字段的长度, 有可能会报错.\n删除表 当表被删除：\n数据和结构都被删除\n所有正在运行的相关事物被提交\n所有相关索引被删除\nDROP TABLE 语句不能回滚，但是可以闪回\nselect * from tab; 查看当前用户下有哪些表, 拷贝保存表名。\ndrop table testsp; 将测试保存点的表删除。\nselect * from tab; 再次查询跟刚刚保存的表名比对，少了testsp，但多了另外一张命名复杂的表。\nOracle的回收站：\n查看回收站：show recyclebin (sqlplus 命令)那个复杂的命名即是testsp在回收站中的名字。 select * from testsp; 这样是不能访问的。\nselect * from \u0026ldquo;BIN$+vu2thd8TiaX5pA3GKHsng==$0\u0026rdquo; 要使用“回收站中的名字”\n清空回收站：purge recyclebin\ndrop table test1 purge 表示直接删除表，不经过回收站。\n将表从回收站里恢复，涉及“闪回”的知识，作为了解性知识点。\n将表从回收站闪回\nflashback table t2 to before drop; 清空回收站\npurge recyclebin; 注意：并不是所有的用户都有“回收站”，对于没有回收站的用户（管理员）来说，删除操作是不可逆的.\n重命名表 rename test1 to test8;\tTruncate Table：DDL语句\t——注意：不能回滚(rollback)\n约束： 约束的种类 Not Null\t非空约束\n例如：人的名字，不允许为空。\rUnique\t唯一性约束\n例如：电子邮件地址，不可以重复。\rPrimary Key\t主键约束\n通过这个列的值可以唯一的确认一行记录，主键约束隐含Not null + Unique\rForeign Key\t外键约束\n​\n例如：部门表dept和员工表emp，不应该存在不属于任何一个部门的员工。用来约束两张表的关系。\n注意：如果父表的记录被子表引用的话，父表的记录默认不能删除。解决方法：\n1）\t先将子表的内容删除，然后在删除父表。\r2）\t将子表外键一列设置为NULL值，断开引用关系，然后删除父表。\r无论哪种方法，都要在两个表进行操作。所以定义外键时，可以通过references指定如下参数：\nON DELETE CASCADE：当删除父表时，如发现父表内容被子表引用，级联删除子表引用记录。\nON DELETE SET NULL：当发现上述情况，先把子表中对应外键值置空，再删除父表。\n多数情况下，使用SET NULL方法，防止子表列被删除，数据出错。\nCheck检查性约束\n如：教室中所有人的性别；工作后薪水满足的条件。\r新建一个测试表: test7\ncreate table test7 (tid number, tname varchar2(20), gender varchar(6) check (gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)),\tsal number check (sal \u0026gt; 0)\t); 说明:\ncheck (gender in (\u0026lsquo;男\u0026rsquo;, \u0026lsquo;女\u0026rsquo;)) 检查插入的性别是不是‘男’或‘女’（单引号）。\ncheck (sal \u0026gt; 0)\t检查薪水必须是一个正数。\r测试: insert into test7 values(1, 'Tom', '男', 1000); 没有问题.\n如果插入: insert into test7 values(2, \u0026lsquo;Mary\u0026rsquo;, \u0026lsquo;啊\u0026rsquo;, 2000); 会报错.\nORA-02290：违反检查约束条件SCOTT.SYS_C005523, gender的值只能取’男’或者’女’.\n其中的“SYS_C005523”是约束的名字，由于在定义约束时没有显式指定，系统默认给起了这样一个名称。所以我们建议，创建约束的时候，自定义一个见名知意的约束名。\nconstraint: 使用该关键字，来给约束起别名。\n约束举例 【约束举例】：\ncreate table student ( sid number constraint student_PK primary key, # --学生Id主键约束 sname varchar2(20) constraint student_name_notnull not null, # --学生姓名非空约束 email varchar2(20) constraint student_email_unique unique\t# --学生邮件唯一约束 constraint student_email_notnull not null,\t# --同时邮件可再设非空，没有, age number constraint student_age_min check(age \u0026gt; 10),\t# --学生年龄设置check约束 gender varchar2(6) constraint gender_female_or_male check(gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)), deptno number constraint student_FK references dept (deptno) ON DELETE SET NULL ); 在定义学生deptno列的时候，引用部门表的部门号一列作为外键，同时使用references设置级联操作\n——当删除dept表的deptno的时候，将student表的deptno置空。\r查看student表各列的约束\ndesc student; student的建表语句:\nSELECT dbms_metadata.get_ddl(\u0026#39;TABLE\u0026#39;, \u0026#39;STUDENT\u0026#39;) FROM dual; 测试用例：\ninsert into student values(1, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 20, \u0026#39;男\u0026#39;, 10); # 正确插入表数据。 insert into student values(2, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 15, \u0026#39;男\u0026#39;, 10); 违反student_email_unique约束。\rinsert into student values(3, \u0026#39;Tom3\u0026#39;, \u0026#39;tom3@126.com\u0026#39;, 14, \u0026#39;男\u0026#39;,100 ); 违反完整约束条件 (SCOTT.STUDENT_FK) - 未找到父项关键字\r问题：是不是父表的所有列，都可以设置为子表的外键？作外键有要求吗？\n外键：必须是父表的主键.\r查看指定表（如student）的约束, 注意表名必须大写。\nSELECT constraint_name, constraint_Type, search_condition FROM user_constraints WHERE table_name=\u0026#39;STUDENT\u0026#39;; 12 其它数据库对象 视图： 视图是一种常见数据库对象, 它是从表中抽出的逻辑上相关的数据集合。\n所以：1. 视图基于表。2. 视图是逻辑概念。3. 视图本身没有数据。\n创建视图 创建语法与创建表类似，只需要将table → view即可:\ncreate view empincomeview ASSELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 出错提示：权限不足。因为创建视图需要“create view”的权限。默认scott用户没有该种权限。加之！\r添加步骤：\n使用管理员登陆：sqlplus / as sysdba\n给scott用户增加权限\ngrant create view to scott; 执行“/”可成功创建视图empincomeview.\n视图的操作和表的操作完全一样.\nSELECT * FROM empincomeview; 视图的优点： 视图的优点\n简化复杂查询: 原来分组、多表、子查询等可以用一条select * from xxxview代替,视图可以看做是表的复杂的SQL一种封装。\n限制数据访问: 只看视图的结构和数据是无法清楚视图是怎样得来的。可以限制数据的访问。例如：银行项目，所谓的各个“表”都是“视图”，并有可能只是“只读视图”\n注意：1. 视图不能提高性能 2. 不建议通过视图对表进行修改。\nimg 创建视图细节： 使用下面的语法格式创建视图：\nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view\n[(alias[, alias]\u0026hellip;)]\nAS subquery\n[WITH CHECK OPTION [CONSTRAINT constraint]]\n[WITH READ ONLY [CONSTRAINT constraint]];\n视图只能创建、删除、替换。（不能修改，修改即替换replace）\n如：刚刚创建的empincomeview，其他语句不变，将create一行改写成：\ncreate # 视图不存在则创建、存在则替换。 OR replace view empincomeview AS select…… from…..where….. WITH read only; # 可以将视图设为只读视图。 别名: 可以写在子查询select各个列的后面，也可以写在视图的名字后面。\nwith read only 表示该视图为只读视图。\nwith check option\t了解即可， 举例：\ncreate view testview ASSELECT * FROM emp WHERE deptno=10 WITH check option; insert into testview values(******, 10); 不建议向视图插入，但可以做。向视图插入10号员工。\ninsert into testview values(******, 20); 因为创建视图时加了“with check option”，所以失败。\n视图中使用DML的规定：\n一：\n当视图定义中包含以下元素之一时不能使用delete:\n组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n二：\n当视图定义中包含以下元素之一时不能使用update :\r组函数\nGROUP BY子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n三：\n当视图定义中包含以下元素之一时不能使用insert :\r组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n表中非空的列在视图定义中未包括\n总结一句话：不通过视图做insert、update、delete操作。因为视图提供的目的就是为了简化查询。\n删除视图:\ndrop view testview; \u0026mdash;\u0026mdash;à不加“purge”关键字。\n序列： 可以理解成数组：默认，从[1]开始，长度[20]\t[1, 2, 3, 4, 5, 6, …, 20]\t在内存中。\n由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。\n序列的使用： 初始状态下：指针指向1前面的位置。欲取出第一个值，应该将向后移动。每取出一个值指针都向后移。\n常常用序列来指定表中的主键。\n创建序列：create sequence myseq 来创建一个序列。\n​\n创建序列：\nCREATE SEQUENCE sequence [INCREMENT BY n] [START WITH n] [{MAXVALUE n | NOMAXVALUE}] [{MINVALUE n | NOMINVALUE}] [{CYCLE | NOCYCLE}] [{CACHE n | NOCACHE}]; NOCACHE表示没有缓存，一次不产生20个，而只产生一个。\n创建序列 创建序列、表，以备后续测试使用：\n`create sequence myseq;` 按默认属性创建一个序列。\rcreate table tableA (tid number, tname varchar2(20)); tid作为主键，准备使用序列来向表中插入值。\n序列的属性： 每个序列都有两个属性, nextval和currval.\nNextVal 必须在CurrVal之前被指定。因为初始状态下，CurrVal指向1前面的位置，无值\n对于新创建的序列使用select myseq.currval from dual; 得到出错。\n但select myseq.nextval from dual; 可以得到序列的第一值1.\n此时再执行select myseq.currval from dual; currval的值也得到1\n使用序列给tableA表创建主键tid：\ninsert into tableA values(myseq.nextval, ‘aaa’) 只有nextval取完会向后移动，使用currval不会移动。\rinsert into tableA values(myseq.nextval, ‘bbb’) 继续使用nextval向表中添加主键tid\rinsert into tableA values(myseq.nextval, \u0026amp;name) 可以使用“\u0026amp;”和“/”来指定名字。\rSELECT * FROM tableA; 由于前面测试currval和nextval关系时调用过nextval，所以tableA的tid起始从2开始。\n查询序列的属性：``select * from user_sequences; user_sequences`为数据字典视图。\n修改序列：\n必须是序列的拥有者或对序列有 ALTER 权限\n只有将来的序列值会被改变\n改变序列的初始值只能通过删除序列之后重建序列的方法实现\n删除序列：drop sequence myseq; 使用序列需要注意的地方: 应首先执行nextval, 之后才能使用currval的值, 刚刚创建的序列不能直接使用currval的值.\n使用序列需要注意的问题： 序列是公有对象，所以多张表同时使用序列，会造成主键不连续。\t如：[1, 2, 3, 4, 5, …, 20] tableA:\t1\t2\t4\ntableB:\t3\t5\tA、B表有可能主键不连续。\n回滚也可能造成主键不连续。\t如：多次调用insert操作使用序列创建主键。但是当执行了rollback后再次使用insert借助序列创建主键的时候，nextval不会随着回滚操作回退。\n掉电等原因，也可能造成不连续。由于代表序列的数组保存在内存中，断电的时候内存的内容丢失。恢复供电时候，序列直接从21开始。\n索引： 索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）\n一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中\n索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度\n索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引\n在删除一个表时, 所有基于该表的索引会自动被删除\n通过指针加速 Oracle 服务器的查询速度\n通过快速定位数据的方法，减少磁盘 I/O\nimg 上图中：\nemp表中保存数据，其中包含部门号列。有10号部门，有20部门员工\n当 select * from emp where deptno=10 的时候。由于10号部门员工不连续，没规律。\n为了提高访问速度，可以在数据库中，依照rowid给deptno列建立索引\ncreate index myindex ON emp(deptno); 这样就建立了“索引表”可以通过rowid保存的行地址快速的找到表中数据。即使表中数据不连续。\r建立了索引以后，如果再执行select语句的时候，会先检查表上是否有索引表。如果有，可以通过有规律的rowid找到连续的数据。\nOracle的数据库中，索引有 B树索引（默认）和 位图索引两种。\n使用create index 索引表名 on 表名（列名1， 列名2…）;来创建索引表。由数据库自动进行维护。\n使用主键查询数据最快速，因为主键本身就是“索引”，所以检索比较快。\n索引使用的场景：\n以下情况可以创建索引:\n列中数据值分布范围很广\n列经常在 WHERE 子句或连接条件中出现\n表经常被访问而且数据量很大, 访问的数据大概占数据总量的2%到4%\n下列情况不要创建索引:\n表很小\n列不经常作为连接条件或出现在WHERE子句中\n查询的数据大于2%到4%\n表经常更新\n删除索引: drop index myindex;\nsynonym同义词： 就是指表的别名。\n如：scott用户想访问hr用户下的表employees。默认是不能访问的。需要hr用户为scott用户授权.\n`sqplus hr/11\t或 conn hr/11`（已登录界面， 切换登陆）\rgrant select ON employees to scott; hr用户为scott用户开放了employees表的查询权限。\n这时scott用户就可以使用select语句，来查询hr用户下的employees表的信息了。\nSELECT count(*) FROM hr.employees; ​\t若用户名叫zhangsanfeng则zhangsanfeng.employees\nhr.employees名字过长，为了方便操作，scott用户为它重设别名:\ncreate synonym hremp for hr.employees; # 为hr.employees创建了同义词。 如有权限限制，那么切换管理员登录，给scott用户添加设置同义词权限。\nconn / as sysdba; grant create synonym to scott; SELECT count(*) FROM hremp; # 使用同义词进行表查询操作。 同义词、视图 等用法在数据保密要求较高的机构使用广泛，如银行机构。好处是既不影响对数据的操作，同时又能保证数据的安全。\nOCA\nOCP\nOCM\t认证\nSELECT rownum, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) WHERE rownum \u0026lt;=3; SELECT * FROM (SELECT rownum rn, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) ) WHERE rn\u0026gt;=4 AND rn\u0026lt;=7; SELECT d.deptno, e.empno, e.ename, d.avgsal, e.sal FROM emp e, (SELECT deptno, avg(sal) avgsal FROM emp GROUP BY deptno) d WHERE e.deptno=d.deptno AND e.sal\u0026gt;d.avgsal; ","date":"2022-01-09T16:51:29Z","permalink":"https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Oracle数据库介绍"},{"content":" 1. 一些基本概念 ###1.1 Nginx初步认识\nNginx介绍\nengine x\n俄罗斯\n开源的框架\nc语言\nTengine - 淘宝基于nginx修改的\nNginx能干什么?\n作为web服务器 解析http协议 反向代理服务器 了解反向代理的概念 邮件服务器 解析邮件相关的协议: pop3/smtp/imap Nginx的优势?\n更快\n高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求 高扩展\n低耦合设计的模块组成,丰富的第三方模块支持 高可靠\n经过大批网站检验 www.sina.com.cn www.xunlei.com www.163.com 每个worker进程相对独立, 出错之后可以快速开启新的worker worker进程的个数是可以控制的 在后台干活的进程 低内存消耗\n一般情况下,10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗 2.5M内存 单机支持10万以上的并发连接\n取决于内存,10万远未封顶 热部署\nmaster和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件 最自由的BSD许可协议\nBSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布 淘宝: tengine 1.2 正向/反向代理 正向代理\n正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。\n正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径, 比如:\n学校的局域网\n单位局域网访问外部资源\n051157002507977.jpg 正向代理服务器是为用户服务的\n反向代理\n反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。\n1.png 2.png 3.png 4.png 客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的\n请求直接发给反向代理服务器\n反向代理服务器将请求转发给后边的web服务器\nweb服务器 N 台 反向代理服务器转发请求会轮询进行 web服务器收到请求进行处理, 得到结果\nweb服务器将处理结果发送给反向代理服务器\n反向代理服务器将拿到的结果转发给客户端\n1.3 域名和IP 什么是域名？ https://www.baidu.com https://www.jd.com https://taobao.com 什么是IP地址？ 点分十进制的字符串 11.22.34.45 域名和IP地址的关系？ 域名绑定IP 一个域名只能绑定一个IP 一个IP地址被多个域名绑定 2. Nginx 安装和配置 2.1 安装 切换到/usr/local/src目录\n下载\n官方地址: nginx: download 下载 wget http://nginx.org/download/nginx-1.19.9.tar.gz 解压 tar -zxvf nginx-1.19.9.tar.gz Nginx相关依赖: OpenSSL: http://www.openssl.org/ 密码库 使用https进行通信的时候使用 下载 git clone https://github.com.cnpmjs.org/openssl/openssl.git 安装 cd openssl ./Configure make make install ZLib下载: http://www.zlib.net/ 数据压缩 下载 wget http://zlib.net/zlib-1.2.11.tar.gz 安装: tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make sudo make install PCRE下载: http://www.pcre.org/ 解析正则表达式 下载 wget https://ftp.pcre.org/pub/pcre/pcre-8.45.tar.gz 安装 tar -zxvf pcre-8.45.tar.gz cd pcre-8.45 ./configure make sudo make install 安装\nnginx的安装\n进入nginx目录cd nginx-1.19.9\n# nginx工作时候需要依赖三个库 # 三个参数=这三个库对应的源码安装目录 # 根据自己的电脑的库安装包的位置进行指定 ./configure --with-openssl=/usr/local/src/openssl \\ --sbin-path=/usr/local/nginx/sbin/nginx \\ --with-pcre=/usr/local/src/pcre-8.45 \\ --with-zlib=/usr/local/src/zlib-1.2.11 \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/conf/nginx.pid \\ --lock-path=/usr/local/nginx/conf/nginx.lock \\ --with-http_gzip_static_module \\ --with-http_stub_status_module \\ --with-file-aio \\ --with-http_realip_module \\ --with-http_ssl_module \\ --with-ipv6 make -j2 sudo make install 1539658551107.png Nginx 相关的指令\nNginx的默认安装目录\n/usr/local/nginx conf -\u0026gt; 存储配置文件的目录 html -\u0026gt; 默认的存储网站(服务器)静态资源的目录 [图片, html, js, css] logs -\u0026gt; 存储log日志 sbin -\u0026gt; 启动nginx的可执行程序 Nginx可执行程序的路径\n/usr/local/nginx/sbin/nginx # 快速启动的方式 # 1. 将/usr/local/nginx/sbin/添加到环境变量PATH中 # 2. /usr/local/nginx/sbin/nginx创建软连接, 放到PATH对应的路径中, 比如: /usr/bin ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 启动Nginx - 需要管理器权限\n# 假设软连接已经创建完毕 sudo nginx # 启动 关闭Nginx\n# 第一种, 马上关闭 sudo nginx -s stop # 第二种, 等nginx作为当前操作之后关闭 sudo nginx -s quit 重新加载Nginx\nsudo nginx -s reload # 修改了nginx的配置文件之后, 需要执行该命令 测试是否安装成功\n知道nginx对应的主机的IP地址 - \u0026gt; 192.168.1.100 在浏览器中访问该IP地址 看到一个welcom nginx的欢迎界面 2.2 配置 Nginx配置文件的位置\n/usr/local/nginx/conf/nginx.conf Nginx配置文件的组织格式\n5.png http -\u0026gt; 模块, http相关的通信设置 server模块 -\u0026gt; 每个server对应的是一台web服务器 location 模块 处理的是客户端的请求 mail -\u0026gt; 模块, 处理邮件相关的动作 常用配置项介绍\nuser nobody; # 启动之后的worker进程属于谁 - 错误提示: nginx操作xxx文件时候失败, 原因: Permission denied - 将nobody -\u0026gt; root worker_processes 1; # 设置worker进程的个数, 最大 == cpu的核数 (推荐) error_log logs/error.log; # 错误日志, /usr/local/nginx pid logs/nginx.pid; # pid文件, 里边是nginx的进程ID # nginx的事件处理 events { use epoll;\t# 多路IO转接模型使用epoll worker_connections 1024;\t// 每个工作的进程的最大连接数 } http-\u0026gt;server -\u0026gt; 每个server模块可以看做一台web服务器 server{ listen 80; # web服务器监听的端口, http协议的默认端口 server_name localhost; # 对应一个域名, 客户端通过该域名访问服务器 charset utf8; # 字符串编码 location {\t// 模块, 处理客户端的请求 } # 客户端 (浏览器), 请求: http://192.168.10.100:80/login.html # 服务器处理客户端的请求 服务器要处理的指令如何从url中提取? - 去掉协议: http - 去掉IP/域名+端口: 192.168.10.100:80 - 最后如果是文件名, 去掉该名字: login.html - 剩下的: / 服务器要处理的location指令: location / { 处理动作 } 3. Nginx的使用 3.1 部署静态网页 静态网页存储目录\n默认的存储目录:\n/usr/local/nginx/html 自己创建新的目录:\n应该在 /usr/local/nginx/ mkdir /usr/local/nginx/mydir 练习\n在Nginx服务器上进行网页部署, 实现如下访问:\n在/usr/local/nginx/创建新的目录, yundisk用来存储静态网页\n访问地址: http://192.168.80.254/login.html\nlogin.html放到什么位置?\n/ -\u0026gt; 服务器的资源根目录, /usr/local/nginx/yundisk login.htm-\u0026gt; 放到yundisk中 服务器要处理的动作\n# 对应这个请求服务器要添加一个location location 指令(/) { # 找一个静态网页 root yundisk; # 相对于/usr/local/nginx/来找 # 客户端的请求是一个目录, nginx需要找一默认显示的网页 index index.html index.htm; } # 配置之后重启nginx sudo nginx -s reload 访问地址: http://192.168.80.254/hello/reg.html\nhello是什么?\n目录 reg.html放到哪儿?\nhello目录中 如何添加location\nlocation /hello/ { root yundisk; index xx.html; } 访问地址: http://192.168.80.254/upload/ 浏览器显示upload.html\n直接访问一个目录, 得到一默认网页\nupload是一个目录, uplaod.html应该再upload目录中\nlocation /upload/ { root yundisk; index upload.html; } 3.2 反向代理和负载均衡 反向代理和负载均衡是两码事儿\n8.png 准备工作:\n需要客户端 - 1个 Window中的浏览器作为客户端 反向代理服务器 -\u0026gt; 1个 window作为反向代理服务器 web服务器 -\u0026gt; 2个 ubuntu - robin: 192.168.247.135 ubuntu - luffy : 192.168.26.250 反向代理设置\n1539680213601 找window上对应的nginx的配置文件 - conf/nginx.conf # 代理几台服务器就需要几个server模块 # 客户端访问的url: http://192.168.1.100/login.html server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name ubuntu.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://robin.test.com; } } # 添加一个代理模块 upstream robin.test.com { server 192.168.247.135:80; } # luffy server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name hello.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://luffy.test.com; } } # 添加一个代理模块 upstream luffy.test.com { server 192.168.26.250:80; } } 负载均衡设置\n1539681085862 server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name localhost; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /hello/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /upload/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } } # 添加一个代理模块 upstream linux.com { server 192.168.247.135:80 weight=1; server 192.168.26.250:80 weight=3; } ## ===================================== web服务器需要做什么? # 192.168.247.135 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } # 192.168.26.250 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } 课外知识导读 1. URL和URI 概念:\nURL（Uniform Resource Locator）: 统一资源定位符\n表示资源位置的字符串\n基本格式: \u0026ldquo;协议://IP地址/路径和文件名\u0026rdquo; ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt telnet://192.0.2.16:80/ URN（Uniform Resource Name）: 统一资源名称\nP2P下载中使用的磁力链接 URI（Uniform Resource Identifier）: 统一资源标识符\n是一个紧凑的字符串用来标示抽象或物理资源, URL是URI的一种 让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. http:// or ftp://。 files.hp.com tel:+1-816-555-1212 ftp://ftp.is.co.za/rfc/rfc1808.txt （also a URL） http://www.ietf.org/rfc/rfc2396.txt （also a URL） telnet://192.0.2.16:80/ （also a URL） 经验式理解:\n从包含关系上说: URI包含URL\n字符串长度上说: URL包含URI\nUIRI可以没有协议, 没有地址(IP/域名)\nURL 红色字体部分+绿色字体部分 URI 绿色字体部分 2. DNS解析过程 wps_clip_image-14256 DNS解析的过程\n在浏览器中输入www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到www.magedu.com主机。 如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 域名解析服务器\nPod DNS+:\n首选：119.29.29.29 备选：182.254.116.116 114DNS:\n首选：114.114.114.114 备选：114.114.114.115 阿里 AliDNS:\n首选：223.5.5.5\n备选：223.6.6.6\nhosts文件\n# 存储的是域名和IP的对应关系 -windows目录: \u0026#34;C:\\Windows\\System32\\drivers\\etc\\hosts\u0026#34; 复习 redis\n是什么?\n非关系型数据库 - nosql 数据存储在内存里边 能干什么?\n提高程序效率 程序中频繁访问的数据, 可以存储到redis中 我们需要干什么?\n会安装\n掌握启动redis服务器和客户端的启动命令\n# 服务器 redis-server (配置文件名) # 客户端 redis-cli (-h redis服务器IP -p 端口) redis中支持的数据类型 - value\n键值对方式存储数据\nkey - 字符串 value 字符串 - string 列表 - list 集合 - set 排序集合 - sortedSet 哈希 - hash 关于服务器使用的配置文件的修改\nredis中持久化\nrdb aof 能够在程序中操作redis服务器\n需要使用以下函数接口 官方地址 - \u0026gt; 客户端 -\u0026gt; 选择语言 ","date":"2022-01-08T16:07:29Z","permalink":"https://okokfun.github.io/post/nginx%E5%AE%89%E8%A3%85/","title":"nginx安装"},{"content":" MySQL数据库API库 访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。\n可使用mysql -V 命令查看当前系统内所使用的mysql数据库版本信息。数据库版本为5.6.20版。因此，我们可从帮助手册refman-5.6-en.a4.pdf入手，了解学习MySQL C API使用的一般信息。\n从API手册23.8中可获取信息，MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数-I、-L、-l。\n从手册中可获知，函数库名为mysqlclient。\n因此我们使用命令:\nfind / -name libmysqlclient* 查找该库的路径。得到 /usr/lib64/mysql/libmysqlclient.a。 nm /usr/lib64/mysql/libmysqlclient.a命令可查看库内包含的函数。\n编写hello应用链接函数库 编写一个hello.c应用程序，链接使用该库。\n用到头文件 \u0026lt;mysql.h\u0026gt; 可使用locate mysql.h查看其目录位置/usr/include/mysql/mysql.h。\n编译引用了库的应用程序。\ngcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient 参见帮助手册refman-5.6-en.a4.pdf：23.8.4.3小节。\nMySQL API常用函数 总体印象 使用MySQL库API函数的一般步骤：\na. 初始化. MYSQL *mysql_init(MYSQL *mysql);\nb. 错误处理\tunsigned int mysql_errno(MYSQL *mysql);\rchar *mysql_error(MYSQL *mysql);\nc. 建立连接.\tMYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);\nd. 执行SQL语句\tint mysql_query(MYSQL *mysql, const char *stmt_str);\ne. 获取结果\tMYSQL_RES *mysql_store_result(MYSQL *mysql) MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);\nf. 释放内存\tvoid mysql_free_result(MYSQL_RES *result);\ng. 关闭连接\tvoid mysql_close(MYSQL *mysql);\n初始化 编写程序测试 初始化函数MYSQL *mysql_init(MYSQL *mysql)。\n其中有一种新数据类型MYSQL。可在头文件mysql.h → 263. typedef struct st_mysql {\u0026hellip;} MYSQL;找到其定义。是一个结构体。\n处理错误码的函数：unsigned int mysql_errno(MYSQL *mysql) #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); return 0; } 编译出错，原因是64位Linux环境下，动态库配置不完整。 需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：\n__gxx_personality_v0 \u0026ndash;\u0026gt; -lstdc++\t使用g++相关的环境\ndlclose/dlopen/dlsym\t\u0026ndash;\u0026gt;\t-ldl\t完成用一个程序加载其他动态库的作用。\npthread_*\t\u0026ndash;\u0026gt; -lpthread\t线程库\nmy_getsystime'/clock_gettime\u0026rsquo;\t\u0026ndash;\u0026gt; -lrt\tlibrt.so是glibc中对real-time的支持库\n使用ldd命令可以查看该可执行文件运行所依赖的库文件。\nMakefile 管理 src = $(wildcard *.c) target = $(patsubst %.c, %, $(src)) inc_path = /usr/include/mysql/ lib_path = /usr/lib64/mysql/ all: $(target) %:%.c gcc $\u0026lt; -o $@ -I$(inc_path) -L$(lib_path) -lmysqlclient -lstdc++ -lpthread -ldl -lrt clean: -rm -rf $(target) .PHONY: all clean 注意：在测试makefile时，应先使用-n参数，检查无误再执行。\n连接数据库关闭连接 // 依据proc猜想应该是一个类似于connect的函数，查看API文档发现：mysql_connect();但该函数已经过时，应该使用手册中推荐的mysql_real_connect函数取而代之。 MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag ); // 根据手册中的描述，我们可以使用基础的链接方式与MySQL数据库建立连接。 mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0 ); // 连接数据库成功。对表中数据进行访问， //\t访问结束需调用void mysql_close(MYSQL *mysql) 函数关闭连接。 // 该函数在断开连接的同时，还可以解除分配由mysql指向的连接句柄。 mysql_close(mysql); 读取数据 查询表数据 // mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。 // 是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。查询以\\0结尾的字符串。 // 如果语句中包含二进制数据，则需要调用mysql_real_query来执行查询语句。 // 函数原型：int mysql_query(MYSQL *mysql, const char *query);\t//\t成功返回0，失败返回非0 char *psql = \u0026#34;select * from emp\u0026#34;; ret = mysql_query(mysql, psql); 若执行的是UPDATE, DELETE或INSERT语句，则可通过mysql_affected_rows()获知受影响的记录数。\n若执行的是SELECT语句，查询结束后，查询结果被保存在mysql句柄中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。\n注意: mysql_query执行的SQL语句不应为语句添加终结分号（‘;’）或“\\g”。\n获取结果集 一种方式是通过mysql_store_result()将整个结果集全部取回来。另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过mysql_fetch_row()来访问每一条记录。\nMYSQL_RES *mysql_store_result(MYSQL *mysql) // 成功返回MYSQL_RES结果集指针，失败返回NULL。 // MYSQL_RES是一个结构体类型，可以从mysql.h头文件中找到该结构体的定义： mysql.h → 308. typedef struct st_mysql_res {...} MYSQL_RES; 整体获取的结果集，保存在 MYSQL_RES 结构体指针中，通过检查mysql_store_result()是否返回NULL，可检测函数执行是否成功：\nMYSQL_RES *result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} 该函数调用成功，则SQL查询的结果被保存在result中，但我们不清楚有多少条数据。所以应使用游标的方式将结果集中的数据逐条取出。\n解析结果集 通过游标一行一行fetch结果集中的数据。根据游标使用的一般特性，应使用循环结构，到达结尾或者出错，返回NULL。\n// 函数原型：MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) 成功返回下一行的MYSQL_ROW结构。 // 如果没有更多要检索的行或出现了错误，返回NULL。-----MYSQL_ROW定义在118行 select * from emp // 可以看到emp表一共有8列数据。可以循环将每行上每一列的数据显示到屏幕。 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); } MYSQL_ROW的本质是 typedef char ** MYSQL_ROW; 数据信息存储的形式如下图所示：\nimg 从mysql.h头文件可查看MYSQL_ROW定义: 118. typedef char **MYSQL_ROW; /return data as array of string/\n// 从上图分析MYSQL_ROW为什么被定义为char**类型呢？推测mysq_fetch_row()的函数实现大致思想如下： char **mysql_fetch_row() { char **tmp = (char **) malloc(sizeof(char *) * 8); for (i = 0; i \u0026lt; 8; i++) { tmp[i] = (char *)malloc(50); } strcpy(tmp[0], \u0026#34;7369\u0026#34;); strcpy(tmp[1], \u0026#34;SMITH\u0026#34;); strcpy(tmp[2], \u0026#34;CLERK\u0026#34;); ... return tmp; } 释放结果集 结果集处理完成，应调用对应的函数释放所占用的内存。\nvoid mysql_free_result(MYSQL_RES *result); 成功释放参数传递的结果集。没有失败情况。\nmysql_free_result(result); 思考：上述实现是直接在MySQL工具中数出列数。找寻能获取列数的API函数、获取表头的API函数。\n获取列数 // 查看帮助手册可以看到，有两个函数具备获取列数的功能： unsigned int mysql_field_count(MYSQL *mysql) // 从mysql句柄中获取有多少列。 unsigned int mysql_num_fields(MYSQL_RES *result) // 从返回的结果集中获取有多少列。 // 选择任意一种方式均可以完成该功能。 int num = mysql_field_count(connect); while (row = mysql_fetch_row(result)) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); //printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); 获取表头 // 获取表头的API函数同样有两个： MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result) // 全部获取 MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result) // 获取单个 // MYSQL_FIELD也是一个结构体类型，其内部保存了选择列表项的信息， // 其中的name成员变量就保存着列名。可从头文件mysql.h中94-116行找到其定义。 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result);\t//得到表头的结构体数组 for (i = 0; i \u0026lt; num; i++) {\t//已通过 mysql_field_count\t获取了总列数\tprintf(\u0026#34;%s\\t\u0026#34;, fields[i].name);\t//每一列的列名保存在name成员中 } printf(\u0026#34;\\n\u0026#34;); 示例程序 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; char *psql = \u0026#34;select * from emp\u0026#34;;\tMYSQL_RES *result = NULL; MYSQL_FIELD *fields = NULL; MYSQL_ROW row = NULL;\tMYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, psql); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} num = mysql_field_count(mysql); result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } mysql_free_result(result); mysql_close(mysql); return 0;\t} MySQL tools实现 依托我们所学习的MySQL基础类API函数，可以编写程序实现简单的sqlplus/mysql 工具的功能。\n思路分析 \\1. 仿照mysql工具，应在连接数据库成功之后，在一个while循环中不断的接受用户输入的SQL语句。定义char sqlbuf[1024] 存储用户输入的SQL语句。初始化该buf，并提示用户输入SQL语句。使用gets函数在循环中动态接收用户输入。\nwhile (1) { memset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;\\nYourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin); } 在mysql_query(connect, sqlbuf)之前，如果用户输入了“exit”那么程序直接结束。\n在执行完 mysql_query(connect, sqlbuf)之后，应该判别用户输入的是否为select语句。如不是select语句不需要查询结果集、处理结果集等繁复操作。\n如用户输入的是有结果集的SQL语句，将获取列数、获取结果集、获取表头、解析结果集、释放结果集等相关代码一起并入if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6))中。\n测试注意：执行SQL语句时不要在结尾加“;”\n程序实现 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; //char *psql = \u0026#34;select * from emp\u0026#34;;\tchar sqlbuf[1024]; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, \u0026#34;set names utf8\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} while (1) {\tmemset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;YourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin);\tif (strncmp(sqlbuf, \u0026#34;exit\u0026#34;, 4) || strncmp(sqlbuf, \u0026#34;quit\u0026#34;, 4) ) { break; } ret = mysql_query(mysql, sqlbuf); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} if (strncmp(sqlbuf, \u0026#34;select\u0026#34;, 6) || strncmp(sqlbuf, \u0026#34;SELECT\u0026#34;, 6)) { num = mysql_field_count(mysql);\tMYSQL_RES *result = NULL; result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} //打印表头 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;);\t//解析结果集 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); }\tmysql_free_result(result);\t} else { printf(\u0026#34;\\n--- not select sql---\\n\u0026#34;); printf(\u0026#34;affected: %ld\\n\u0026#34;, (long)mysql_affected_rows(mysql)); } } mysql_close(mysql); return 0;\t} 中文问题： 修改mysql_real_connect()参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用mysql_query函数来解决该问题。\n在 while (1) 之前使用 ret = mysql_query(mysql, \u0026quot;set names utf8\u0026quot;); 来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。\n或者mysql_set_character_set(mysql, \u0026quot;utf8\u0026quot;);\n获取当前使用的字符集: const char *mysql_character_set_name(MYSQL *mysql)\n预处理类API函数： 该类函数解决问题：处理带有占位符的SQL语句。insert into table111(col1, col2, col3) values(?, ?, ?);\n这种SQL语句由两部分组成，一部分是SQL语句体模型部分，另一部分是？所匹配的值。\n性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。\n元数据（Metadata）：又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\n根据API提供的案例学习该部分内容。主要有 4 个函数：\nmysql_stmt_init()\t初始化预处理环境句柄。\t返回一个结构体指针 MYSQL_STMT *stmt\nmysql_stmt_prepare()\t向上面句柄中添加SQL语句，带有 (?,?,?) 占位符\nmysql_stmt_param_count() 求绑定变量的个数(辅助函数)， 有多少个\u0026rsquo;?\u0026lsquo;就返回多少\nmysql_stmt_bind_param()\t将?对应的实参，设置到预处理环境句柄中\nmysql_stmt_execute()\t执行预处理的SQL语句\nimg 在不熟悉这套API函数的情况下，如何能快速的找到一个完整的案例，使用这套函数呢？分析：在以上4个过程中，哪个最重要呢？找到它，去查看API文档！发现有对应的demo程序。将该demo导入到我们的程序中，运行，观察它的作用。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define STRING_SIZE 50 #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(40),\\ col3 SMALLINT,\\ col4 TIMESTAMP)\u0026#34; #define INSERT_SAMPLE \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ////////////////////////以下为demo源码//////////////////////////////// MYSQL_STMT *stmt; MYSQL_BIND bind[3]; my_ulonglong affected_rows; int param_count; short small_data; int int_data; char str_data[STRING_SIZE]; unsigned long str_length; my_bool is_null; if (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } /* Prepare an INSERT query with 3 parameters */ /* (the TIMESTAMP column is not named; the server */ /* sets it to the current date and time) */ stmt = mysql_stmt_init(mysql); if (!stmt) { fprintf(stderr, \u0026#34; mysql_stmt_init(), out of memory\\n\u0026#34;); exit(0); } if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) { fprintf(stderr, \u0026#34; mysql_stmt_prepare(), INSERT failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } fprintf(stdout, \u0026#34; prepare, INSERT successful\\n\u0026#34;); /* Get the parameter count from the statement */ param_count= mysql_stmt_param_count(stmt); fprintf(stdout, \u0026#34; total parameters in INSERT: %d\\n\u0026#34;, param_count); if (param_count != 3) /* validate parameter count */ { fprintf(stderr, \u0026#34; invalid parameter count returned by MySQL\\n\u0026#34;); exit(0); } /* Bind the data for all 3 parameters */ memset(bind, 0, sizeof(bind)); /* INTEGER PARAM */ /* This is a number type, so there is no need to specify buffer_length */ bind[0].buffer_type = MYSQL_TYPE_LONG; bind[0].buffer = (char *)\u0026amp;int_data; bind[0].is_null = 0; bind[0].length = 0; /* STRING PARAM */ bind[1].buffer_type = MYSQL_TYPE_STRING; bind[1].buffer = (char *)str_data; bind[1].buffer_length = STRING_SIZE; bind[1].is_null = 0; bind[1].length = \u0026amp;str_length; /* SMALLINT PARAM */ bind[2].buffer_type = MYSQL_TYPE_SHORT; bind[2].buffer = (char *)\u0026amp;small_data; bind[2].is_null = \u0026amp;is_null; bind[2].length = 0; /* Bind the buffers */ if (mysql_stmt_bind_param(stmt, bind)) { fprintf(stderr, \u0026#34; mysql_stmt_bind_param() failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); }\t/* Specify the data values for the first row */ int_data= 10; /* integer */ strncpy(str_data, \u0026#34;MySQL\u0026#34;, STRING_SIZE); /* string */ str_length= strlen(str_data); /* INSERT SMALLINT data as NULL */ is_null= 1; /* Execute the INSERT statement - 1*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute(), 1 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } /* Get the total number of affected rows */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 1): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Specify data values for second row, then re-execute the statement */ int_data= 1000; strncpy(str_data, \u0026#34;The most popular Open Source database\u0026#34;, STRING_SIZE); str_length= strlen(str_data); small_data= 1000; /* smallint */ is_null= 0; /* reset */ /* Execute the INSERT statement - 2*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute, 2 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt));\texit(0); } /* Get the total rows affected */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 2): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Close the statement */ if (mysql_stmt_close(stmt)) { fprintf(stderr, \u0026#34; failed while closing the statement\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } mysql_close(mysql); printf(\u0026#34;hello mysql...\\n\u0026#34;); return 0;\t} 注意：bind \u0026ndash;\u0026gt; mysql.h下 MYSQL_BIND结构体 bind[3]; 是一个结构体数组。有3个‘?’占位符，所以用三个结构体(数组)来对应保存信息。0-\u0026gt;第一列；1-\u0026gt;第二列；2-\u0026gt;第三列。\nmysql.h中查找 MYSQL_BIND 结构体原型。对比：select * from teat_table; 和 desc test_table; 的查询结果。\n帮助理解bind的小程序框架：\ntypedef struct xxx{ char *p1; char *p2; char *p3; } MYSQL_BIND; void saveXXXInfo(MYSQL_BIND *bind, int num) { insert into test_table valudes(bind[0].p2, bind[1].p3, bind[2].p1); } int main(void) { MYSQL_BIND bind[3]; bind[0].p1 = \u0026#34;类型1\u0026#34;;\t//第一列 bind[0].p2 = \u0026#34;10\u0026#34;; bind[0].p3 = \u0026#34;其他数据\u0026#34;; bind[1].p1 = \u0026#34;类型\u0026#34;;\t//第二列 bind[1].p2 = \u0026#34;数据\u0026#34;; bind[1].p3 = \u0026#34;描述\u0026#34;; bind[2].p1 = \u0026#34;p1p1p1\u0026#34;;\t//第三列 //第四列是时间戳，不需要用户使用?来指定，直接使用了系统时间。 bind[2].p2 = \u0026#34;数据\u0026#34;; bind[2].p3 = \u0026#34;其他限定条件\u0026#34;;\tsaveXXXInfo(bind, 3); } 日期时间类API函数 练习：熟悉上述预处理类工作模式，模拟精简一个将时间插入数据库的程序。将时间存入数据库有两种方式：\n使用SQL语句方式\n预处理环境句柄变量方式存入\n提示：\nMYSQL_TIME ts;\t// 浏览头文件 mysql_time.h 熟悉MYSQL_TIME结构体。 MYSQL_BIND bind[3]; MYSQL_STMT *stmt; // 可直接使用SQL语句提前创建表test_table2，也可以使用mysql_query函数来创建。 create table test_table2 (date_field date, time_field time, timestamp_field timestamp); char query[1024] = \u0026#34;INSERT INTO test_table2(date_field, time_field, timestamp_field) VALUES(?,?,?)\u0026#34;; stmt = mysql_stmt_init(mysql); // MYSQL_TIME 是一个结构体，使用typedef定义。位于mysql_time.h文件中。\tAPI参考：refman-5.6-en.a4.pdf手册25.2.10. 日期和时间值的C API处理\n多查询执行的C API函数 一次性执行多条SQL语句，包括select、drop、update、create等。 如：\nmysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\\ DROP TABLE test_table\u0026#34;); 文档：25.2.9. 多查询执行的C API处理。中文文档只有demo框架。查阅对应英文文档refman-5.6-en.a4.pdf。关键字Multiple 23.8.17\r注意：打桩函数——函数接口\rif (mysql_real_connect (mysql, host_name, user_name, password,\rdb_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL)\rCLIENT_MULTI_STATEMENTS：客户端通知Server，将要发送多个SQL语句。\rmysql_field_count(mysql)：影响的行数。 如：\r当select * from dept;\t执行结束，提示：“5 rows in set”\t表示影响了4行。\r当Create一张表，\t执行结束，提示：“Query OK, 0 rows affected (0.01 sec)”\r当delete一行，\t执行结束，提示：“Query OK, 1 row affected (0.00 sec)”\rmysql_field_count函数调用后会将影响的行数保存到句柄 mysql 中。\r下方是帮助文档中demo程序，它将帮助我们分析与之前掌握的API函数间的区别与联系：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; void process_result_set(MYSQL *mysql, MYSQL_RES *result) { int i, num; num = mysql_field_count(mysql); MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); MYSQL_ROW row = NULL; while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int ret = 0, status = 0; MYSQL_RES *result = NULL; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, CLIENT_MULTI_STATEMENTS); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } /////////////////////////////以下为demo源码////////////////////////////// /* execute multiple statements */ status = mysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\u0026#34;); DROP TABLE test_table if (status) { printf(\u0026#34;Could not execute statement(s)\u0026#34;); mysql_close(mysql); exit(0); } /* process each statement result */ do { /* did current statement return data? */ result = mysql_store_result(mysql); if (result)\t{ /* yes; process rows and free the result set */ process_result_set(mysql, result); mysql_free_result(result); } else /* no result set or error */ { if (mysql_field_count(mysql) == 0) { printf(\u0026#34;%lld rows affected\\n\u0026#34;, mysql_affected_rows(mysql)); } else /* some error occurred */ { printf(\u0026#34;Could not retrieve result set\\n\u0026#34;); break; }\t} /* more results? -1 = no, \u0026gt;0 = error, 0 = yes (keep looping) */ if ((status = mysql_next_result(mysql)) \u0026gt; 0) printf(\u0026#34;Could not execute statement\\n\u0026#34;); printf(\u0026#34;------------status: %d\\n\u0026#34;, status); } while (status == 0); mysql_close(mysql);\treturn 0; } process_result_set函数是文档中给我们预留的打桩函数，需要我们在使用的过程中，自己实现它。\n函数实现就是借助mysql和result两个参数打印一条sql语句查询到的结果集到屏幕。\n可以直接使用mysq_tool.c中if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6) == 0 || strncmp(sqlbuf, \u0026quot;SELECT\u0026quot;, 6) == 0)内的代码。“获取结果集”片段可以删除。“释放结果集”片段可以删除。API示例中含有该部分内容。\n常见错误：在process_result_set函数实现中，不要使用mysql_store_result(mysql)再次获取结果集， 该result已经在API函数接口传入，直接使用参数result即可。否则会出现【段错误】。\nMySQL中的事务 测试MySQL中事务的特性。\nMySQL的事务的默认自动提交的，每执行一个sql语句都自动commit\rOracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit\r在程序中设置autocommit修改MySQL事务的属性。\nset autocommit = 0 禁止自动提交\rset autocommit = 1 开启自动提交MySQL中InnoDB引擎才支持事务默认自动提交机制。MYISAM引擎不支持。\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define SET_TRAN\t\u0026#34;SET AUTOCOMMIT=0\u0026#34; //手动commit\t#define UNSET_TRAN\t\u0026#34;SET AUTOCOMMIT=1\u0026#34;\t//自动commit //设置事务为手动提交 int mysql_OperationTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为手动提交 ret = mysql_query(mysql, SET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; }\t//设置事务为自动提交 int mysql_AutoTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为自动提交 ret = mysql_query(mysql, UNSET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret;\t} //执行commit，手动提交事务 int mysql_Commit(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;COMMIT\u0026#34;); if (ret != 0) { printf(\u0026#34;commit err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } //执行rollback，回滚事务\tint mysql_Rollback(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;ROLLBACK\u0026#34;); if (ret != 0) { printf(\u0026#34;rollback err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(10),\\ col3 VARCHAR(10))\u0026#34; #define sql01 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(10, \u0026#39;AAA\u0026#39;, \u0026#39;A1\u0026#39;)\u0026#34; #define sql02 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(20, \u0026#39;BBB\u0026#39;, \u0026#39;B2\u0026#39;)\u0026#34; #define sql03 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(30, \u0026#39;CCC\u0026#39;, \u0026#39;C3\u0026#39;)\u0026#34; #define sql04 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(40, \u0026#39;DDD\u0026#39;, \u0026#39;D4\u0026#39;)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb2\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;func mysql_real_connect() err：%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34; --- connect ok......\\n\u0026#34;);\tif (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); }\tret = mysql_OperationTran(mysql); //开启事务，并修改事务属性为手动commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql01);\t//向表中插入第一行数据 ‘AAA’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret);\treturn ret; } ret = mysql_query(mysql, sql02);\t//向表中插入第二行数据 ‘BBB’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Commit(mysql); //手动提交事务 if (ret != 0) { printf(\u0026#34;mysql_Commit() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_AutoTran(mysql); // =再次= 修改事务属性为【自动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_OperationTran(mysql); // =再次= 修改事务属性为【手动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql03);\t//向表中插入第三行数据 ‘CCC’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql04);\t//向表中插入第四行数据 ‘DDD’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Rollback(mysql);\t//直接rollback操作 if (ret != 0) { printf(\u0026#34;mysql_Rollback() err:%d\\n\u0026#34;, ret); return ret; } //rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。 mysql_close(mysql); return 0;\t} 对应参考API手册。中文：25.2.3.2.\t英文：23.8.7.2\n","date":"2022-01-05T20:21:29Z","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93api%E5%BA%93/","title":"MySQL数据库API库"},{"content":" 1 MySQL基础知识 瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。\nMySQL是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低、MySQL软件采用了双授权政策，分为社区版和企业版。\n1.1 MySQL版本及下载 MySQL数据库版本相对比较繁杂。常见的有：Community社区版、Enterprise企业版。\nMySQL Community Server 版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。\nMySQL Enterprise Edition 企业版收费的，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。\n其中Community Server 可以直接从mysql 的官网下载。但Enterprice Edition只能从Oracle edelivery上下载，而Edelivery有时会屏蔽中国IP。\nMySQL各版本区别参见：\nhttp://www.admin10000.com/Document/62.html\n下载mysql时注意区分版本细节及所应用的系统平台：linux(32/64) 、win(32/64)\n举例：\nwin版本：\nmysql-installer-community-8.0.26.0.msi版本\n​ GA 是指软件的通用版本，一般指正式发布的版本 (Generally Available (GA) Release)\n​ mysql-essential-5.1.60-win32.msi精简版，如果只需要mysql服务，就选择此版本。\n​ mysql-5.1.60-win32.msi 是完 是整版，包含安装程序和配置向导，有MySQL文档。\nmysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导\n​ mysql-5.1.60.zip 是用于windows的Mysql源码压缩包\nlinux版本\n​ 在http://www.mysql.com/downloads/网站上下载不了\n​ 在 www.oracle.com/downloads 找mysql 注册用户, 选择操作系统平台和mysql版本 进行下载\n官方文档上有关MySQL安装，介绍了3种类型及其对应安装方式来安装MySQL数据库：\nLinux supports a number of different solutions for installing MySQL. The recommended method is to use one of the distributions from Oracle. If you choose this method, there are three options available:\n(1) Installing from a generic binary package in .tar.gz format. See Section 2.2,“Installing MySQL from Generic Binaries on Unix/Linux”for more information.\n(2) Extracting and compiling MySQL from a source distribution. For detailed instructions, see Section 2.9, “Installing MySQL from Source”.\n(3) Installing using a pre-compiled RPM package. For more information on using the RPM solution, see Section 2.5.1,“Installing MySQL from RPM Packages on Linux”\n我们选用较简单的RPM 包来安装。\n1.2 下载安装包 Community Server 下载地址：https://dev.mysql.com/downloads/mysql/\nMySQL Community Server. mysql社区版，开源、免费\nMySQL Enterprise Edition. mysql企业版，非免费\nMySQL Cluster. mysql集群版，开源、免费\n2 MySQL服务器安装和启动 2.1 查询服务器上已经安装的mysql ​ 在终端提示符输入：rpm -aq | grep mysql 命令。查询结果如下显示：\nqt-mysql-4.6.2-25.el6.x86_64 mysql-connector-odbc-5.1.5r1144-7.el6.x86_64 mysql-bench-5.1.66-2.el6_3.x86_64 mysql-devel-5.1.66-2.el6_3.x86_64 libdbi-dbd-mysql-0.8.3-5.1.el6.x86_64 mysql-test-5.1.66-2.el6_3.x86_64 mysql-libs-5.1.66-2.el6_3.x86_64 mysql-5.1.66-2.el6_3.x86_64 mysql-connector-java-5.1.17-6.el6.noarch mysql-server-5.1.66-2.el6_3.x86_64 ​ 注：各机器有可能不相同，软件列表视实际情况。\n2.2 卸载旧的版本 rpm -e 软件包名 \u0026ndash;nodeps \u0026ndash;allmatches (不理会依赖关系，删除所有上一步查出来的相同的mysql)\n[root@localhost home]# rpm -e mysql-connector-odbc-3.51.26r1127-1.el5 --nodeps --allmatches [root@localhost home]# rpm -e libdbi-dbd-mysql-0.8.1a-1.2.2 --nodeps --allmatches [root@localhost home]# rpm -e mysql-server-5.0.77-3.el5 --nodeps --allmatches [root@localhost home]# rpm -aq | grep mysql [root@localhost home]# ​ 将老版本的几个文件手动删除\nrm -f /etc/my.cnf rm -rf /var/lib/mysql rm -rf /var/share/mysql rm -rf /usr/bin/mysql* 2.3 安装 解压.zip安装包\nunzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip 得到如下软件包：\nMySQL-client-advanced-5.6.20-1.el6.x86_64.rpm MySQL-devil-advanced-5.6.20-1.el6.x86_64.rpm MySQL-server-advanced-5.6.20-1.el6.x86_64.rpm MySQL-embedded-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-compal-advanced-5.6.20-1.el6.x86_64.rpm MySQL-test-advanced-5.6.20-1.el6.x86_64.rpm README.txt 2.3.1 安装服务器 rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER ! You will find that password in \u0026#39;/root/.mysql_secret\u0026#39;. You must change that password on your first connect, no other statement but \u0026#39;SET PASSWORD\u0026#39; will be accepted. See the manual for the semantics of the \u0026#39;password expired\u0026#39; flag. Also, the account for the anonymous user has been removed. In addition, you can run: /usr/bin/mysql_secure_installation which will also give you the option of removing the test database. This is strongly recommended for production servers. See the manual for more instructions. Please report any problems at http://bugs.mysql.com/ The latest information about MySQL is available on the web at http://www.mysql.com Support MySQL by buying support/licenses at http://shop.mysql.com New default config file was created as /usr/my.cnf and will be used by default by the server when you start it. You may edit this file to change server settings 2.3.2 安装客户端： rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm 说明:不安装mysql-client是不能使用mysql工具登陆到mysql数据库\n​ 其他软件包选择性安装： rpm -ivh MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm\n2.4 查看mysql服务器是否已经启动 # 查看状态 systemctl status mysqld # 启动mysql systemctl start mysqld # 关闭mysql systemctl stop mysqld # 重新启动mysql systemctl restart mysqld # 开机启动mysql systemctl enable mysqld # 关闭开机启动mysql systemctl disable mysqld # 另外一种操作方式 service mysqld status 2.5 登录Mysql oracle收购Mysql后, 新版的mysql刚安装完mysql后不能直接输入mysql登录数据库, 而是设置了默认free password密码, 默认密码放在了/root/.mysql_secret文件中, 登陆后需要修改密码。\n1.查看文件寻找密码 cat /root/.mysql_secret 2.以root用户身份登陆MySQL 服务启动和关闭：\nservice mysql start service mysql stop ps -u mysql #可以查看mysql用户（安装MySQL时，系统自动创建该用户）的进程\nPID TTY TIME CMD 7586 ? 00:00:50 mysqld 守护进程 登陆服务器：\nmysql -uroot –p 密码\n输入从.mysql_secret中读到的密码登录。\n如果登录期间发生异常，无法登陆：\n使用root将mysql的后台进程kill -9 PID\n3.修改密码 mysql\u0026gt; set password=password('123456'); 将密码设置为：123456\n密码修改成后，再次登录使用：\n$mysql -uroot -p123456 即可。\n4.查看数据库 mysql\u0026gt; show databases; 5.远程root登录mysql 5.1Mysql8.0创建用户和授权 mysql8.0需要先创建用户和设置密码,然后才能授权.\n#先创建一个用户 create user \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123123\u0026#39;; #再进行授权 grant all privileges on *.* to \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; with grant option; 5.2MySQL8.0 的远程链接 MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题.\n5.2.1登录MySQL mysql -u root -p #然后输入您的密码 5.2.2选择 mysql 数据库 use mysql; --因为 mysql 数据库中存储了用户信息的 user 表。 5.2.3在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 select host, user, authentication_string, plugin from user; --执行完上面的命令后会显示一个表格 --查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。 5.2.4授权 root 用户的所有权限并设置远程访问 GRANT ALL ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;你自己的密码\u0026#39;; 5.2.5刷新权限 --所有操作后，应执行 flush privileges; 5.2.6查看 root 用户的 host use mysql;\rselect host, user, authentication_string, plugin from user;\r--会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。\r5.3访问数据库 --输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.7 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。 --出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password. --解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. --这里采用第二种方式 ： --修改加密规则: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39; PASSWORD EXPIRE NEVER; password 为你当前密码。 --更新 root 用户密码: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; password 为你新设置的密码。 --刷新权限: FLUSH PRIVILEGES; --OK，设置完成，再次使用 Navicat 连接数据库 6. 数据库的CURD 对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。\n6.1查看数据库 显示所有数据库 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | itcast | | itcast1 | | itcast2 | | mysql | | performance_schema | | sys | +--------------------+ 7 rows in set (0.01 sec) 显示创建数据库的语句信息 mysql\u0026gt; show create database itcast; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | itcast | CREATE DATABASE `itcast` /*!40100 DEFAULT CHARACTER SET utf8 */ | +----------+-----------------------------------------------------------------+ 1 row in set (0.00 sec) /* `itcast` 两端是反单引号, esc下的键, 使用``包含数据库的名字是区分大小写的 */ 使用数据库 /* 我们以root用户登录, 用户下有很多数据库, 需要指定, 当前使用哪一个数据库, 操作的就是那个数据库中的数据 */ mysql\u0026gt; use itcast1; Database changed mysql\u0026gt; use itcast2; Database changed 6.2创建数据库 -- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句\r-- create_specification是建库的一些选项\r-- 关键字不区分大小写\rCREATE {DATABASE} [IF NOT EXISTS] db_name\r[create_specification [, create_specification] ...]\r创建一名为itcast的数据库 mysql\u0026gt; create database itheima; /* utf8 */ 创建一个使用 latin1 字符集的数据库 mysql\u0026gt; create database itheima character set latin1; 6.3修改数据库 -- 修改字符集, 不能改名 alter database itcast character set utf8; 6.4删除数据库 drop database itcast; 7. 表的CURD 对表本身进行操作：创建，查看，修改，删除\n7.1 查看表 查看当前数据库下的数据库表\n\u0026ndash; 当前使用的数据库下的表 mysql\u0026gt; show tables;\n查看指定表的创建语句\nmysql\u0026gt; show create table 表名;\n查看表结构\nmysql\u0026gt; desc 表名;\n7.2创建表 mysql中表名区分大小写, 列名不区分大小写\n数据类型 float/double: 指定精确到小数点以后第几位, 比如: 精确到后3位 通过计算得到一个数据: 12.345678 这个数的678会被抹掉 decimal 完整的保存精度, 最少有小数后有两位 12.3 保存为: 12.30 创建表 create table 表名( 列名 text [default \u0026#39;xxx\u0026#39;], 列名 类型 [default value], 类名 类型 [default value], ...... ); 7.3修改表 修改表名\n-- oracle和mysql相同 rename table oldN to newN; 添加一个字段\n-- oracle alter table 表名 add 列名 列的类型; -- mysql alter table 表名 add column 列名 列的类型; 修改一个字段\n-- oracle alter table 表名 modify 列名 列的类型; -- mysql alter table 表名 modify column 列名 列的类型; 删除一个字段\n-- mysql和oracle相同 alter table 表名 drop column 列; -- mysql中没有对对字段的rename操作 修改表的字符集\nalter table 表名 character set utf8; 7.4 删除表 drop table 表名; -- oracle中可以这么做, mysql中不行 drop table 表名 purge 8. 表数据的CURD 插入数据\n表名后的列名什么时候可以省略? 在values(列的值, 列的值, \u0026hellip;.)中将表有的字段值都指定出来的时候, 列名可以省略 insert into 表名[(列名, 列名, ...)] values(列的值, 列的值, ....); 更新数据\nupdate 表名 set 列名=新值 where 列名=值; 删除数据\ndelete from 表名; -- 删除所有行 delete from 表名 where 列名=值; -- 删除满足条件的行 查询数据\nselect *|列名|表达式 from 表名 where 条件 group by 列名 having 条件 order by asc|desc; 练习\n创建数据库 student 表 create table student( id int, name varchar(20), chinese int, english int, math int ); 插入数据 insert into student(id,name,chinese,english,math) values(1, \u0026#39;范建\u0026#39;,80,85,90); insert into student(id,name,chinese,english,math) values(2,\u0026#39;罗况\u0026#39;,90,95,95); insert into student(id,name,chinese,english,math) values(3,\u0026#39;杜子腾\u0026#39;,80,96,96); insert into student(id,name,chinese,english,math) values(4,\u0026#39;范冰\u0026#39;,81,97,85); insert into student(id,name,chinese,english,math) values(5,\u0026#39;申晶冰\u0026#39;,85,84,90); insert into student(id,name,chinese,english,math) values(6,\u0026#39;郝丽海\u0026#39;,92,85,87); insert into student(id,name,chinese,english,math) values(7,\u0026#39;郭迪辉\u0026#39;,75,81,80); insert into student(id,name,chinese,english,math) values(8,\u0026#39;拎壶冲\u0026#39;,77,80,79); insert into student(id,name,chinese,english,math) values(9,\u0026#39;任我行\u0026#39;,95,85,85); insert into student(id,name,chinese,english,math) values(10,\u0026#39;史泰香\u0026#39;,94,85,84); 查询表中所有学生的信息。 查询表中所有学生的姓名和对应的英语成绩。 将第二步查询结果中的重复成绩过滤掉。\n在所有学生英语分数上加10分特长分。\n统计每个学生的总分。\n使用别名表示学生分数\n查询姓名为何东的学生成绩\n查询英语成绩大于90分的同学\n查询总分大于250分的所有同学\n查询英语分数在 85－95之间的同学。\n查询数学分数为84,90,91的同学。\n查询所有姓何的学生成绩。\n查询数学分\u0026gt;85，语文分\u0026gt;90的同学。\n对数学成绩排序后输出。\n对总分排序后输出，然后再按从高到低的顺序输出\n对姓何的学生成绩排序输出\n统计一个班级共有多少学生？\n统计数学成绩大于90的学生有多少个？\n统计总分大于250的人数有多少？\n统计一个班级数学总成绩？\n统计一个班级语文、英语、数学各科的总成绩\n统计一个班级语文、英语、数学的成绩总和\n求一个班级数学平均分？\n求一个班级总分平均分\n求班级最高分和最低分\n9. mysql函数的使用 9.1 日期函数 MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。\n-- 当前时间: now() == sysdate() mysql\u0026gt; select sysdate() from dual; +---------------------+ | sysdate() | +---------------------+ | 2019-12-02 09:03:42 | +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select now() from dual; +---------------------+ | now() | +---------------------+ | 2019-12-02 09:04:35 | +---------------------+ 1 row in set (0.00 sec) -- addtime(time, s) 给当前实际, 添加对应的秒数 select addtime(\u0026#39;09:04:35\u0026#39;,20) from dual; +------------------------+ | addtime(\u0026#39;09:04:35\u0026#39;,20) | +------------------------+ | 09:04:55 | +------------------------+ -- 当前日期: 年, 月, 日 mysql\u0026gt; select current_date() from dual; +----------------+ | current_date() | +----------------+ | 2019-12-02 | +----------------+ 1 row in set (0.00 sec) -- 当前时间: 时, 分, 秒 mysql\u0026gt; select current_time() from dual; +----------------+ | current_time() | +----------------+ | 09:08:10 | +----------------+ 1 row in set (0.00 sec) -- 时间戳 mysql\u0026gt; select current_timestamp() from dual; +---------------------+ | current_timestamp() | +---------------------+ | 2019-12-02 09:09:47 | +---------------------+ 1 row in set (0.00 sec) -- 将给定时间的日期取出 select date(now()) from dual; +-------------+ | date(now()) | +-------------+ | 2019-12-02 | +-------------+ 1 row in set (0.00 sec) -- date_add(), 第二个参数的type: 天: day, 月:month, 年: year mysql\u0026gt; select date_add(now(), interval 1 day) from dual; +---------------------------------+ | date_add(now(), interval 1 day) | +---------------------------------+ | 2019-12-03 09:14:57 | +---------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 month) from dual; +-----------------------------------+ | date_add(now(), interval 1 month) | +-----------------------------------+ | 2020-01-02 09:15:27 | +-----------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 year) from dual; +----------------------------------+ | date_add(now(), interval 1 year) | +----------------------------------+ | 2020-12-02 09:15:37 | +----------------------------------+ 1 row in set (0.00 sec) -- 计算两个日期的差值 mysql\u0026gt; select datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | 333 | +-------------------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | -32 | +-------------------------------------------------------+ 1 row in set (0.00 sec) -- 单独显示当前年, 月, 日 select year(now()) \u0026#34;年\u0026#34;, month(now()) \u0026#34;月\u0026#34;, day(now()) \u0026#34;日\u0026#34; from dual; -- 单独显示当前日期, 时间, 时间戳 -- 显示昨天, 今天, 明天 select date_sub(now(), interval 1 day), now(), date_add(now(), interval 1 day) from dual; 9.2 字符串函数 -- 字符串连接 -- mydql中可以连接多个字符串, oracle中只能连接两个字符串 mysql\u0026gt; select concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) from dual; +-------------------------------------------------+ | concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) | +-------------------------------------------------+ | hello world 你好,世界 | +-------------------------------------------------+ -- 大小写转换 mysql\u0026gt; select ucase(\u0026#34;hello\u0026#34;), lcase(\u0026#34;WORLD\u0026#34;) from dual; +----------------+----------------+ | ucase(\u0026#34;hello\u0026#34;) | lcase(\u0026#34;WORLD\u0026#34;) | +----------------+----------------+ | HELLO | world | +----------------+----------------+ 1 row in set (0.00 sec) -- 字符串截取, 从左侧开始 mysql\u0026gt; select left(\u0026#34;hello,world\u0026#34;, 5) from dual; +------------------------+ | left(\u0026#34;hello,world\u0026#34;, 5) | +------------------------+ | hello | +------------------------+ 1 row in set (0.00 sec) -- 字符串比较 mysql\u0026gt; select strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) | +----------------------+ | -1 | -- 小于 +----------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) from dual; +---------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) | +---------------------+ | 1 | -- 大于 +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) | +----------------------+ | 0 | -- 等于 +----------------------+ 1 row in set (0.00 sec) 9.3 数学函数 \u0026ndash; 向上取整 \u0026ndash; mysql ceiling(小数) \u0026ndash; oracle ceil(小数)\n-- 进制转换 mysql\u0026gt; select conv(100, 10, 16) from dual; +-------------------+ | conv(100, 10, 16) | +-------------------+ | 64 | +-------------------+ -- 保留指定的小数位数, 可以四舍五入 mysql\u0026gt; select format(12.345, 2) from dual; +-------------------+ | format(12.345, 2) | +-------------------+ | 12.35 | +-------------------+ 1 row in set (0.00 sec) -- 取集合中的最小值 mysql\u0026gt; select least(12, 1, 3, 4, 0) from dual; +-----------------------+ | least(12, 1, 3, 4, 0) | +-----------------------+ | 0 | +-----------------------+ 1 row in set (0.00 sec) -- 生成随机数 -- 生成的随机数范围: 0-1 mysql\u0026gt; select rand(now()) from dual; +--------------------+ | rand(now()) | +--------------------+ | 0.8633374812671333 | +--------------------+ 1 row in set (0.00 sec) 9.4 日期转换 -- oracle 日期格式: yyyy-mm-dd hh24:mi:ss 不区分大小写 to_char() 日期转字符串 to_date() 字符串转日期 -- mysql 日期格式: %Y-%m-%d %H:%i:%s 区分大小写 date_format() 日期转字符串 str_to_date() 字符串转日期 值 含义 秒 %S、%s 两位数字形式的秒（ 00,01, \u0026hellip;, 59） 分 %i 两位数字形式的分（ 00,01, \u0026hellip;, 59） 小时 %H 24小时制，两位数形式小时（00,01, \u0026hellip;,23） %h 12小时制，两位数形式小时（00,01, \u0026hellip;,12） %k 24小时制，数形式小时（0,1, \u0026hellip;,23） %l 12小时制，数形式小时（0,1, \u0026hellip;,12） %T 24小时制，时间形式（HH:mm:ss） %r 12小时制，时间形式（hh:mm:ss AM 或 PM） %p AM上午或PM下午 周 %W 一周中每一天的名称（Sunday,Monday, \u0026hellip;,Saturday） %a 一周中每一天名称的缩写（Sun,Mon, \u0026hellip;,Sat） %w 以数字形式标识周（0=Sunday,1=Monday, \u0026hellip;,6=Saturday） %U 数字表示周数，星期天为周中第一天 %u 数字表示周数，星期一为周中第一天 天 %d 两位数字表示月中天数（01,02, \u0026hellip;,31） %e 数字表示月中天数（1,2, \u0026hellip;,31） %D 英文后缀表示月中天数（1st,2nd,3rd \u0026hellip;） %j 以三位数字表示年中天数（001,002, \u0026hellip;,366） %M 英文月名（January,February, \u0026hellip;,December） %b 英文缩写月名（Jan,Feb, \u0026hellip;,Dec） %m 两位数字表示月份（01,02, \u0026hellip;,12） %c 数字表示月份（1,2, \u0026hellip;,12） 年 %Y 四位数字表示的年份（2015,2016\u0026hellip;） %y 两位数字表示的年份（15,16\u0026hellip;） 文字输出 %文字 直接输出文字内容 date类型装换为varchar类型\n-- date_format(日期, fmt) mysql\u0026gt; select date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) from dual; +-----------------------------------------+ | date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) | +-----------------------------------------+ | 2019/12/02 10:07:37 | +-----------------------------------------+ varchar类型转换为date类型\n-- 参数fmt的个数应该和日期字符串的形式一致 -- str_to_date(日期字符串, fmt) mysql\u0026gt; select str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) from dual; +---------------------------------------------------------+ | str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) | +---------------------------------------------------------+ | 2019-12-02 10:07:37 | +---------------------------------------------------------+ 1 row in set (0.00 sec) 10. 多表查询 -- 分组函数 count(); -- 求总数 avg(); -- 求平均值 sum(); -- 求和 min(); -- 最小值 max(); -- 最大值 -- having 必须出现在group by 后边, 不能写where -- where 写在 from 的后边 -- order by: 默认升序 asc, 降序 desc select 列名|表达式 as \u0026#34;别名\u0026#34; from 表名 \u0026#34;表的别名\u0026#34; where 表达式 group by 列名 having 条件 order by asc | desc -- 求两个表的笛卡尔积 cross join -- 最简单的两个表查询 select * from dept, emp; select * from dept cross join emp; 10.1 内连接 \u0026ndash; inner join 显示部门名称, 部门编号, 员工编号,和员工姓名\n-- mysql+oracle select d.deptno, d.dname, e.empno, e.ename from dept d, emp e where d.deptno=e.deptno; -- mysql+oracle -- 将表之间的逗号替换为 inner join --\u0026gt; 简写为 join -- 将 where 替换为 on select d.deptno, d.dname, e.empno, e.ename from dept d join emp e on d.deptno=e.deptno; 10.2 外连接 \u0026ndash; outer join 外连接: 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 必须使用外连接的方式, 才能够使其显示在结果集中.\n按部门统计员工人数，显示如下信息：部门号，部门名称，人数(所有部门的人数都统计)\n左外连接 \u0026ndash; left outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where d.deptno=e.deptno(+) group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: left outer join -\u0026gt; outer 可以省略 -\u0026gt; left join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from dept d left outer join emp e on d.deptno=e.deptno group by d.deptno, d.dname; 右外连接 \u0026ndash; right outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where e.deptno(+)=d.deptno group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: right outer join -\u0026gt; outer 可以省略 -\u0026gt; right join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from emp e right join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 全外连接 \u0026ndash; full outer join 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 不知道的那个表的字段不满足条件或者是左侧不满足条件或右侧表不满足条件, 需要将这些不满条件对数据全部显示到结果集中, 可以使用全外连接.\n两个表互相补充 -- 在mysql中不支持全外连接, oracle中是支持的 -- full outer join -\u0026gt; 简写: full join -- 有可能emp表给dept提供补充, 也有可能dept给emp提供补充 select d.deptno, d.dname, count(e.empno) from emp e full join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 10.3 自连接 查询员工、老板信息，显示: xxx的老板是xxx\n-- oracle select e.ename \u0026#34;员工\u0026#34;, nvl(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e, emp b where e.mgr=b.empno(+); -- mysql -- mysql 中的ifnull 等价于 oracle 中的 nvl select e.ename \u0026#34;员工\u0026#34;, ifnull(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e left join emp b on e.mgr=b.empno; 11. 表的约束 create table 表名( 列名 列的类型 default 默认值, 列名 列的类型, 列名 列的类型 ); 11.1 约束种类 mysql中常用的约束有五种:\n主键约束　primary key\n非空 + 唯一 主键自动增长　auto_increment\n给主键用的, 只有列是主键才能加这个约束 主键是数字的时候使用 唯一约束　unique\n非空约束　not null\n外键约束　foreign key\n检查约束 check (在MySQL中语法保留，但没有效果)\n11.2 约束的使用 create table persion( id int, -- 主键, 自动增长 age int, -- 非空 name varchar(20), -- 唯一 deptno int -- 外键 ); 表级别的约束 -- auto_increment只能放到列的位置 -- not null 非空只能在列上添加约束 create table persion( id int auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20), -- 唯一 deptno int, -- 外键 constraint pk_id_xxx primary key(id) , constraint un_name_xxx unique(name), constraint fk_deptno_xx foreign key(deptno) references dept(deptno) ); 列级别的约束 create table persion1( id int primary key auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20) unique, -- 唯一 deptno int references dept(deptno) -- 外键 ); 12. 事务 在mysql中事务默认是自动提交的，oracle中默认是手动提交的。\n原子性 一致性 隔离性 永久性 -- 修改事务提交方式 -- 手动提交 mysql\u0026gt; set autocommit=0; Query OK, 0 rows affected (0.00 sec) -- 提交数据 mysql\u0026gt; commit; Query OK, 0 rows affected (0.00 sec) -- 数据回滚 mysql\u0026gt; rollback; Query OK, 0 rows affected (0.00 sec) -- 自动提交 mysql\u0026gt; set autocommit=1; Query OK, 0 rows affected (0.00 sec) 13. mysql API 初始化连接环境 连接mysql的服务器 执行sql语句 查询 插入 更新 删除 创建/删除/修改数据库表 如果是插入/删除/修改数据等操作只能看到状态 成功 失败 如果sql语句是查询, 得到结果集 遍历结果集 释放资源 初始化连接环境 // 参数: NULL // 返回值: 返回函数申请的内存的地址 MYSQL *mysql_init(MYSQL *mysql) 连接mysql服务器 // 返回值: 失败-\u0026gt; NULL, 成功了-\u0026gt; 返回值和第一个参数的地址相同 MYSQL *mysql_real_connect( MYSQL *mysql, // mysql_init函数的返回值 // 本地: localhost, 远程连接:192.168.xx.xx; const char *host, // mysql服务器地址, IP/主机名 const char *user, // mysql数据用户名, root const char *passwd, // root用户的密码 const char *db, // 数据库的名字 // 如果port==0, 使用默认端口, !=0是使用指定的端口 unsigned int port, // 数据库的端口, 默认3306 const char *unix_socket, // NULL unsigned long client_flag // 0 ); 执行sql语句 // 添删查改的sql语句都是可以执行的 // 参数: // mysql: mysql_real_connect()函数的返回值 // query: sql语句, 语句的结尾不要加 ; // 返回值: 成功-\u0026gt; 0, 失败-\u0026gt;非0 int mysql_query(MYSQL *mysql, const char *query); 获取结果集 // 将结果集保存到本地内存中 // 返回值: 错误-\u0026gt;null, 成功-\u0026gt;非空 // 参数 mysql: mysql_real_connect() 返回值 // 结果集中保存了多条记录, 每条记录中有若干个字段 MYSQL_RES *mysql_store_result(MYSQL *mysql); 得到结果集的列数 unsigned int mysql_num_fields(MYSQL_RES *result) 获取表头 -\u0026gt; 列名(字段名) / mysql.h typedef struct st_mysql_field { char *name; /* Name of column */ char *org_name; /* Original column name, if an alias */ char *table; /* Table of column if column was a field */ char *org_table; /* Org table name, if table was an alias */ char *db; /* Database for table */ char *catalog; /* Catalog for table */ char *def; /* Default value (set by mysql_list_fields) */ unsigned long length; /* Width of column (create length) */ unsigned long max_length; /* Max width for selected set */ unsigned int name_length; unsigned int org_name_length; unsigned int table_length; unsigned int org_table_length; unsigned int db_length; unsigned int catalog_length; unsigned int def_length; unsigned int flags; /* Div flags */ unsigned int decimals; /* Number of decimals in field */ unsigned int charsetnr; /* Character set */ enum enum_field_types type; /* Type of field. See mysql_com.h for types */ void *extension; } MYSQL_FIELD; // 返回值 中保存了所有的字段名, 返回值是一个数组 MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result); MYSQL_FIELD *fields = mysql_fetch_fields(result); for(int i=0; i\u0026lt;num; ++i) { fields[i].name } 遍历结果集 typedef char** MYSQL_ROW; // 函数每调用一次, 从结果集中取出一条记录(行) // 参数: 结果集, mysql_store_result()返回值 // 返回值: char* row[], char**执向一个指针数组, 数组中的每一个元素都是一个字符串, 字符串就是字段值 // 不管字段原来是什么类型, 结果集中都是以字符串形式保存的 // 如果还有下一行返回非空, 没有下一行, 或者失败了返回NULL MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 资源回收 // 参数是 mysql_store_result() 函数的返回值 void mysql_free_result(MYSQL_RES *result); // 参数是: mysql_init() 函数的返回值 void mysql_close(MYSQL *mysql); 字符编码 // 获取字节编码 const char *mysql_character_set_name(MYSQL *mysql); // 设置字节编码 // csname: 编码的名字, utf8 int mysql_set_character_set(MYSQL *mysql, char *csname); 事务操作 // mode==0 -\u0026gt; 手动提交, mode1 -\u0026gt; 自动提交事务 my_bool mysql_autocommit(MYSQL *mysql, my_bool mode); my_bool mysql_commit(MYSQL *mysql); my_bool mysql_rollback(MYSQL *mysql); 打印错误信息 // 返回错误的描述 const char *mysql_error(MYSQL *mysql); // 返回错误的编号 unsigned int mysql_errno(MYSQL *mysql); 需要的头文件 #include \u0026lt;mysql.h\u0026gt; // 动态库名: libmysqlclient.so // 静态库名: libmysqlclient.a 搜索文件 find 路径 -name 文件名 locate 文件名 # centos # 切换到root下安装 yum install mlocate updatedb # 只需要做一次, 安装完成之后做 完整实例 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;mysql.h\u0026gt; int main() { MYSQL *mysql = mysql_init(NULL); if (mysql == nullptr) { printf(\u0026#34;mysql_init() failed\\n\u0026#34;); return -1; } mysql_real_connect(mysql, \u0026#34;192.168.213.128\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;zzc123\u0026#34;, \u0026#34;scott\u0026#34;, 0, NULL, 0); if (mysql == NULL) { printf(\u0026#34;mysql_real_connect() failed\\n\u0026#34;); return -1; } printf(\u0026#34;服务器连接成功!\\n\u0026#34;); printf(\u0026#34;原字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); mysql_set_character_set(mysql, \u0026#34;utf8\u0026#34;); printf(\u0026#34;现字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); int ret = mysql_query(mysql, \u0026#34;select * from emp\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query(select) failed: %s\\n\u0026#34;, mysql_error(mysql)); return -1; } MYSQL_RES *res = mysql_store_result(mysql); int colNum = mysql_num_fields(res); //fields是一个结构体数组 MYSQL_FIELD *fields = mysql_fetch_fields(res); for (int i = 0; i \u0026lt; colNum; i ++) { //遍历结构体内名字字段 printf(\u0026#34;%s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); //读取每一行 //二级指针 MYSQL_ROW row; while ((row = mysql_fetch_row(res)) != NULL) { for (int i = 0; i \u0026lt; colNum; i ++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); } //释放结果集 mysql_free_result(res); //设置事务手动提交 mysql_autocommit(mysql, 0); //将下面的四个操作设置为事务 //插入数据 int fl1 = mysql_query(mysql, \u0026#34;insert into dept values(11, \u0026#39;海军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl2 = mysql_query(mysql, \u0026#34;insert into dept values(12, \u0026#39;革命军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl3 = mysql_query(mysql, \u0026#34;insert into dept values(13, \u0026#39;马戏团\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); //更新数据 int fl4 = mysql_query(mysql, \u0026#34;update dept set dname=\u0026#39;群众\u0026#39; where loc=\u0026#39;china\u0026#39;\u0026#34;); //全部成功 if (!fl1 \u0026amp;\u0026amp; !fl2 \u0026amp;\u0026amp; !fl3 \u0026amp;\u0026amp; !fl4) { //提交事务 mysql_commit(mysql); } else { //事务回滚 mysql_roolback(mysql); } //释放资源 mysql_close(mysql); return 0; } mysql和oracle区别\n结构不同\nmsyql 基于数据库\n表存储在数据库中 oracle 基于用户的\n表属于用户 mysql没有表空间, oracle有表空间\n管理员\nmysql\nroot oralce\nsys -\u0026gt; 管理员, 身份 sysdba system -\u0026gt; 管理员, 登录的时候需要使用normal身份登录 其他的普通用户 事务\noracle默认手动提交\nocci接口 (C++接口), 这个接口中是自动提交事务的 mysql中默认是自动提交\nsql语句\n外连接\noralce中可以使用 (+) mysql中必须使用 , 不支持(+) right outer join -\u0026gt; oracle也支持这种写法 left outer join mysql不支持全外连接, oracle支持的 full outer join 函数:\nnvl -\u0026gt; oralce\nifnull -\u0026gt; mysql\n日期\n字符串\n数学函数\n建表的时候的约束指定\n都有:\n主键 -\u0026gt; primary key 非空: not null 唯一性: unique 外键约束: foreign key 不同:\noralce: check, 在mysql中也有, 但是不起作用 mysql 主键自动增长: auto_increment\n需要和主键约束一起使用 删除表\noracle\ndrop talbe 表名 purge; msyql\ndrop talbe 表名; \u0026ndash;\u0026gt; 不能使用 purge 字段的修改\noralce\n列的添加 alter table 表名 add 列名 列的属性; alter table 表名 modify 列名 列的属性; mysql\n列的添加修改 alter table 表名 add column 列名 列的属性; alter table 表名 modify column 列名 列的属性; ","date":"2022-01-05T12:57:29Z","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Mysql数据库"},{"content":" 百度百科 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n本文采用 @MistEO MistEO哥哥写的项目。\n他写两个很棒的项目\nJson:MistEO/meojson: A fast and easy-to-use JSON parser/generator for C++ (github.com)\n明日方舟助手：MistEO/MeoAssistantArknights: 明日方舟助手，自动刷图、智能基建换班，全日常一键长草！ (github.com)\n他的博客肝！ (misteo.top)，不过是鸽王。\n好了开始正题了\njson下载 下载玛丽写的Json项目MistEO:Json\ngit clone https://github.com.cnpmjs.org/MistEO/meojson.git 编译 json静态库 make 运行命令后会在build文件夹生成libmeojson.a,然后就在项目中可以使用了\n在代码中添加头文件 #include \u0026#34;json.h\u0026#34; 若您需要解析 Json5, 则请包含 json5.hpp 头文件 #include \u0026#34;json5.hpp\u0026#34; meojson 仅依赖 STL, 但需要 c++17 标准 使用 json /*** * from sample/sample.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json.hpp\u0026#34; void parsing() { std::string content = R\u0026#34;( { \u0026#34;repo\u0026#34;: \u0026#34;meojson\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;MistEO\u0026#34;: \u0026#34;https://github.com/MistEO\u0026#34;, \u0026#34;ChingCdesu\u0026#34;: \u0026#34;https://github.com/ChingCdesu\u0026#34; }, \u0026#34;list\u0026#34;: [ 1, 2, 3 ], \u0026#34;str\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;num\u0026#34;: 3.1416 } )\u0026#34;; auto ret = json::parse(content); if (!ret) { std::cerr \u0026lt;\u0026lt; \u0026#34;Parsing failed\u0026#34; \u0026lt;\u0026lt; std::endl; return; } auto value = ret.value(); // As also, you can use rvalues, like // `auto value = std::move(ret).value();` // Output: meojson std::cout \u0026lt;\u0026lt; value[\u0026#34;repo\u0026#34;].as_string() \u0026lt;\u0026lt; std::endl; /* Output: ChingCdesu \u0026#39;s homepage: https://github.com/ChingCdesu MistEO \u0026#39;s homepage: https://github.com/MistEO */ for (auto\u0026amp;\u0026amp; [name, homepage] : value[\u0026#34;author\u0026#34;].as_object()) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#39;s homepage: \u0026#34; \u0026lt;\u0026lt; homepage.as_string() \u0026lt;\u0026lt; std::endl; } // Output: abc std::string str = (std::string)value[\u0026#34;str\u0026#34;]; // As also, you can use `value[\u0026#34;str\u0026#34;].as_string()` std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; // Output: 3.141600 double num = value[\u0026#34;num\u0026#34;].as_double(); // As also, you can use `(double)value[\u0026#34;num\u0026#34;]` std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; // Output: not found std::string str_get = value.get(\u0026#34;maybe_exists\u0026#34;, \u0026#34;not found\u0026#34;); std::cout \u0026lt;\u0026lt; str_get \u0026lt;\u0026lt; std::endl; /* Output: 1 2 3 */ // It\u0026#39;s const! for (const auto\u0026amp; ele : value.at(\u0026#34;list\u0026#34;).as_array()) { int x = (int)ele; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } } 解析 Json5 /*** * from sample/json5_parse.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json5.hpp\u0026#34; void parsing() { std::string content = R\u0026#34;( // 这是一段json5格式的信息 { 名字: \u0026#34;MistEO\u0026#34;, /* key的引号可省略 */ 😊: \u0026#39;😄\u0026#39;, // emoji为key thanks: \u0026#39;ありがとう\u0026#39;, /* 单引号也可以表示字符串 */ \\u006Bey: [\u0026#39;value\u0026#39;,], // 普通字符和转义可以混用 inf: +Infinity, nan: NaN, // 数字可以以\u0026#34;+\u0026#34;开头 fractional: .3, integer: 42., // 小数点作为起始/结尾 byte_max: 0xff, // 十六进制数 light_speed: +3e8, // 科学计数法 } )\u0026#34;; auto ret = json::parse5(content); if (!ret) { std::cerr \u0026lt;\u0026lt; \u0026#34;Parsing failed\u0026#34; \u0026lt;\u0026lt; std::endl; return; } auto value = ret.value(); // As also, you can use rvalues, like // `auto value = std::move(ret).value();` // Output: MistEO std::cout \u0026lt;\u0026lt; value[\u0026#34;名字\u0026#34;] \u0026lt;\u0026lt; std::endl; // Output: value std::string str = (std::string)value[\u0026#34;key\u0026#34;][0]; std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; // for more json::value usage, please refer to sample.cpp } 生成 /*** * from sample/sample.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json.hpp\u0026#34; void generating() { json::value root; root[\u0026#34;hello\u0026#34;] = \u0026#34;meojson\u0026#34;; root[\u0026#34;Pi\u0026#34;] = 3.1416; root[\u0026#34;arr\u0026#34;] = json::array{ \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; }; root[\u0026#34;obj\u0026#34;] = json::object{ {\u0026#34;obj_key1\u0026#34;, \u0026#34;aaa\u0026#34;}, {\u0026#34;obj_key2\u0026#34;, 123}, {\u0026#34;obj_key3\u0026#34;, true} }; root[\u0026#34;obj\u0026#34;].object_emplace(\u0026#34;key4\u0026#34;, json::object{ { \u0026#34;key4 child\u0026#34;, \u0026#34;lol\u0026#34; } }); root[\u0026#34;obj_another\u0026#34;][\u0026#34;child\u0026#34;][\u0026#34;grand\u0026#34;] = \u0026#34;i am grand\u0026#34;; std::vector\u0026lt;int\u0026gt; vec = { 1, 2, 3, 4, 5 }; root[\u0026#34;arr from vec\u0026#34;] = json::array(vec); root[\u0026#34;arr from vec\u0026#34;].array_emplace(6); std::set\u0026lt;std::string\u0026gt; set = { \u0026#34;a\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;cc\u0026#34; }; root[\u0026#34;arr from set\u0026#34;] = json::array(set); std::map\u0026lt;std::string, int\u0026gt; map; map.emplace(\u0026#34;key1\u0026#34;, 1); map.emplace(\u0026#34;key2\u0026#34;, 2); root[\u0026#34;obj from map\u0026#34;] = json::object(map); std::cout \u0026lt;\u0026lt; root.format() \u0026lt;\u0026lt; std::endl; } ","date":"2022-01-04T17:38:16Z","permalink":"https://okokfun.github.io/post/json%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Json的使用"},{"content":" 文件夹创建 在项目根目录创建Dependencies,然后在Dependencies创建include目录 在Dependencies中创建Libs 把头文件和库文件放到对目录\n项目头文件添加 然后用Visual Studio打开项目，找到 红色圈中的功能条\n再点击最下边的属性\n定位到常规，然后再编辑附加包含目录，添加一条新item为$(SolutionDir)Dependencies\\include\\\n其中 $(SolutionDir)为项目根目录，Dependencies\\include\\为头文件目录\n至此第三方库的头文件已经添加完成\n项目库文件添加 点击链接器，常规，附加库目录，添加一条$(SolutionDir)Dependencies\\Libs\\GLFW,\n然后点击输入，附加依赖项，写入要使用的库文件名，点击确定，第三方库已被添加到项目中\nEnd.\n","date":"2022-01-04T17:36:44Z","permalink":"https://okokfun.github.io/post/visual-studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","title":"Visual_Studio_2022添加第三方库"},{"content":" 安装 cmake是自动化项目编译工具，可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。\n下载地址👉Download | CMake， 建议二进制安装。\nwin:\nhttps://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-windows-x86_64.zip ubuntu:\nsudo apt install cmake wget https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-linux-x86_64.tar.gz centos:\nsudo yum install cmake arch:\nsudo pacman -S cmake 编写CMakeLists.txt 单文件单目录CMakeLists.txt编写 # 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo1) # 指定编译后文件名 set(OUTPUTNAME demo1) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(. DIR_SRCS) # 编译文件 add_executable(${OUTPUTNAME} ${DIR_SRCS}) 此文件加编写完毕后，创建一个build文件夹，cd进去，执行cmake ..，会生成Makefile文件，再然后执行make编译，最终生成项目文件。\n多文件单目录CMakeLists.txt编写 和demo1相同\n# 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo2) # 指定编译后文件名 set(OUTPUTNAME demo2) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(. DIR_SRCS) # 编译文件 add_executable(${OUTPUTNAME} ${DIR_SRCS}) 多文件多文件夹CMakeLists.txt编写 每一个项目都要建一个CMakeLists.txt，并且每一个文件夹都要有一个CMakeLists.txt文件\n项目根目录的CMakeLists.txt\n# 指定cmake版本 cmake_minimum_required (VERSION 3.22) # 项目信息 project (Demo3) # 指定编译后文件名 set(OUTPUTNAME demo3) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 添加 math 子目录 add_subdirectory(math) # 指定生成目标 add_executable(${OUTPUTNAME} ${DIR_SRCS}) # 添加链接库 target_link_libraries(${OUTPUTNAME} MathFunctions) 项目其他目录的CMakeLists.txt\n# 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 库文件CMakeLists.txt编写 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 库文件安装CMakeLists.txt编写 在指定的库源文件目录添加：\n# 指定 MathFunctions 库的安装路径 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) demo会被放到bin，*.h会被放到/usr/local/include\n# 指定安装路径 install (TARGETS Demo DESTINATION bin) install (FILES \u0026#34;${PROJECT_BINARY_DIR}/config.h\u0026#34; DESTINATION include) 库文件指定输出路径与编译后的工程目录 库文件输出目录设置\n# 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 把库文件的输出路径设置为lib set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 项目工程目录设置\ncmake_minimum_required(VERSION 3.22) project(abstract_factory_pattern) set(OUTPUTNAME test) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 声明库文件目录 include_directories(${PROJECT_SOURCE_DIR}/mylib) set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) # 设置可执行文件输出目录为bin aux_source_directory(. DIR_SRCS) add_executable(${OUTPUTNAME} ${DIR_SRCS}) target_link_libraries(${OUTPUTNAME} Mylib) # 链接mylib目录下的Mylib库 ","date":"2022-01-03T16:24:52Z","permalink":"https://okokfun.github.io/post/cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ecmakelists-txt%E7%9A%84%E7%BC%96%E5%86%99/","title":"Cmake的安装与CMakeLists.txt的编写"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n适用场景:\n当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。\n观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。\n当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n订阅列表是动态的， 因此订阅者可随时加入或离开该列表。\n/** * Observer Design Pattern * * Intent: Lets you define a subscription mechanism to notify multiple objects * about any events that happen to the object they\u0026#39;re observing. * * Note that there\u0026#39;s a lot of different terms with similar meaning associated * with this pattern. Just remember that the Subject is also called the * Publisher and the Observer is often called the Subscriber and vice versa. * Also the verbs \u0026#34;observe\u0026#34;, \u0026#34;listen\u0026#34; or \u0026#34;track\u0026#34; usually mean the same thing. */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; class IObserver { public: virtual ~IObserver(){}; virtual void Update(const std::string \u0026amp;message_from_subject) = 0; }; class ISubject { public: virtual ~ISubject(){}; virtual void Attach(IObserver *observer) = 0; virtual void Detach(IObserver *observer) = 0; virtual void Notify() = 0; }; /** * The Subject owns some important state and notifies observers when the state * changes. */ class Subject : public ISubject { public: virtual ~Subject() { std::cout \u0026lt;\u0026lt; \u0026#34;Goodbye, I was the Subject.\\n\u0026#34;; } /** * The subscription management methods. */ void Attach(IObserver *observer) override { list_observer_.push_back(observer); } void Detach(IObserver *observer) override { list_observer_.remove(observer); } void Notify() override { std::list\u0026lt;IObserver *\u0026gt;::iterator iterator = list_observer_.begin(); HowManyObserver(); while (iterator != list_observer_.end()) { (*iterator)-\u0026gt;Update(message_); ++iterator; } } void CreateMessage(std::string message = \u0026#34;Empty\u0026#34;) { this-\u0026gt;message_ = message; Notify(); } void HowManyObserver() { std::cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; list_observer_.size() \u0026lt;\u0026lt; \u0026#34; observers in the list.\\n\u0026#34;; } /** * Usually, the subscription logic is only a fraction of what a Subject can * really do. Subjects commonly hold some important business logic, that * triggers a notification method whenever something important is about to * happen (or after it). */ void SomeBusinessLogic() { this-\u0026gt;message_ = \u0026#34;change message message\u0026#34;; Notify(); std::cout \u0026lt;\u0026lt; \u0026#34;I\u0026#39;m about to do some thing important\\n\u0026#34;; } private: std::list\u0026lt;IObserver *\u0026gt; list_observer_; std::string message_; }; class Observer : public IObserver { public: Observer(Subject \u0026amp;subject) : subject_(subject) { this-\u0026gt;subject_.Attach(this); std::cout \u0026lt;\u0026lt; \u0026#34;Hi, I\u0026#39;m the Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; ++Observer::static_number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;.\\n\u0026#34;; this-\u0026gt;number_ = Observer::static_number_; } virtual ~Observer() { std::cout \u0026lt;\u0026lt; \u0026#34;Goodbye, I was the Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;.\\n\u0026#34;; } void Update(const std::string \u0026amp;message_from_subject) override { message_from_subject_ = message_from_subject; PrintInfo(); } void RemoveMeFromTheList() { subject_.Detach(this); std::cout \u0026lt;\u0026lt; \u0026#34;Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; removed from the list.\\n\u0026#34;; } void PrintInfo() { std::cout \u0026lt;\u0026lt; \u0026#34;Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;: a new message is available --\u0026gt; \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;message_from_subject_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: std::string message_from_subject_; Subject \u0026amp;subject_; static int static_number_; int number_; }; int Observer::static_number_ = 0; void ClientCode() { Subject *subject = new Subject; Observer *observer1 = new Observer(*subject); Observer *observer2 = new Observer(*subject); Observer *observer3 = new Observer(*subject); Observer *observer4; Observer *observer5; subject-\u0026gt;CreateMessage(\u0026#34;Hello World! :D\u0026#34;); observer3-\u0026gt;RemoveMeFromTheList(); subject-\u0026gt;CreateMessage(\u0026#34;The weather is hot today! :p\u0026#34;); observer4 = new Observer(*subject); observer2-\u0026gt;RemoveMeFromTheList(); observer5 = new Observer(*subject); subject-\u0026gt;CreateMessage(\u0026#34;My new car is great! ;)\u0026#34;); observer5-\u0026gt;RemoveMeFromTheList(); observer4-\u0026gt;RemoveMeFromTheList(); observer1-\u0026gt;RemoveMeFromTheList(); delete observer5; delete observer4; delete observer3; delete observer2; delete observer1; delete subject; } int main() { ClientCode(); return 0; } 访问者模式 问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n适用场景:\n如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。\n可使用访问者模式来清理辅助行为的业务逻辑。\n该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。\n当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。\n/** * The Visitor Interface declares a set of visiting methods that correspond to * component classes. The signature of a visiting method allows the visitor to * identify the exact class of the component that it\u0026#39;s dealing with. */ class ConcreteComponentA; class ConcreteComponentB; class Visitor { public: virtual void VisitConcreteComponentA(const ConcreteComponentA *element) const = 0; virtual void VisitConcreteComponentB(const ConcreteComponentB *element) const = 0; }; /** * The Component interface declares an `accept` method that should take the base * visitor interface as an argument. */ class Component { public: virtual ~Component() {} virtual void Accept(Visitor *visitor) const = 0; }; /** * Each Concrete Component must implement the `Accept` method in such a way that * it calls the visitor\u0026#39;s method corresponding to the component\u0026#39;s class. */ class ConcreteComponentA : public Component { /** * Note that we\u0026#39;re calling `visitConcreteComponentA`, which matches the * current class name. This way we let the visitor know the class of the * component it works with. */ public: void Accept(Visitor *visitor) const override { visitor-\u0026gt;VisitConcreteComponentA(this); } /** * Concrete Components may have special methods that don\u0026#39;t exist in their base * class or interface. The Visitor is still able to use these methods since * it\u0026#39;s aware of the component\u0026#39;s concrete class. */ std::string ExclusiveMethodOfConcreteComponentA() const { return \u0026#34;A\u0026#34;; } }; class ConcreteComponentB : public Component { /** * Same here: visitConcreteComponentB =\u0026gt; ConcreteComponentB */ public: void Accept(Visitor *visitor) const override { visitor-\u0026gt;VisitConcreteComponentB(this); } std::string SpecialMethodOfConcreteComponentB() const { return \u0026#34;B\u0026#34;; } }; /** * Concrete Visitors implement several versions of the same algorithm, which can * work with all concrete component classes. * * You can experience the biggest benefit of the Visitor pattern when using it * with a complex object structure, such as a Composite tree. In this case, it * might be helpful to store some intermediate state of the algorithm while * executing visitor\u0026#39;s methods over various objects of the structure. */ class ConcreteVisitor1 : public Visitor { public: void VisitConcreteComponentA(const ConcreteComponentA *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;ExclusiveMethodOfConcreteComponentA() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor1\\n\u0026#34;; } void VisitConcreteComponentB(const ConcreteComponentB *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;SpecialMethodOfConcreteComponentB() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor1\\n\u0026#34;; } }; class ConcreteVisitor2 : public Visitor { public: void VisitConcreteComponentA(const ConcreteComponentA *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;ExclusiveMethodOfConcreteComponentA() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor2\\n\u0026#34;; } void VisitConcreteComponentB(const ConcreteComponentB *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;SpecialMethodOfConcreteComponentB() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor2\\n\u0026#34;; } }; /** * The client code can run visitor operations over any set of elements without * figuring out their concrete classes. The accept operation directs a call to * the appropriate operation in the visitor object. */ void ClientCode(std::array\u0026lt;const Component *, 2\u0026gt; components, Visitor *visitor) { // ... for (const Component *comp : components) { comp-\u0026gt;Accept(visitor); } // ... } int main() { std::array\u0026lt;const Component *, 2\u0026gt; components = {new ConcreteComponentA, new ConcreteComponentB}; std::cout \u0026lt;\u0026lt; \u0026#34;The client code works with all visitors via the base Visitor interface:\\n\u0026#34;; ConcreteVisitor1 *visitor1 = new ConcreteVisitor1; ClientCode(components, visitor1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;It allows the same client code to work with different types of visitors:\\n\u0026#34;; ConcreteVisitor2 *visitor2 = new ConcreteVisitor2; ClientCode(components, visitor2); for (const Component *comp : components) { delete comp; } delete visitor1; delete visitor2; return 0; } 责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n适合应用场景:\n当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。\n当必须按顺序执行多个处理者时， 可以使用该模式。\n无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。\n如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。\n/** * The Handler interface declares a method for building the chain of handlers. * It also declares a method for executing a request. */ class Handler { public: virtual Handler *SetNext(Handler *handler) = 0; virtual std::string Handle(std::string request) = 0; }; /** * The default chaining behavior can be implemented inside a base handler class. */ class AbstractHandler : public Handler { /** * @var Handler */ private: Handler *next_handler_; public: AbstractHandler() : next_handler_(nullptr) { } Handler *SetNext(Handler *handler) override { this-\u0026gt;next_handler_ = handler; // Returning a handler from here will let us link handlers in a convenient // way like this: // $monkey-\u0026gt;setNext($squirrel)-\u0026gt;setNext($dog); return handler; } std::string Handle(std::string request) override { if (this-\u0026gt;next_handler_) { return this-\u0026gt;next_handler_-\u0026gt;Handle(request); } return {}; } }; /** * All Concrete Handlers either handle a request or pass it to the next handler * in the chain. */ class MonkeyHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;Banana\u0026#34;) { return \u0026#34;Monkey: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; class SquirrelHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;Nut\u0026#34;) { return \u0026#34;Squirrel: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; class DogHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;MeatBall\u0026#34;) { return \u0026#34;Dog: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; /** * The client code is usually suited to work with a single handler. In most * cases, it is not even aware that the handler is part of a chain. */ void ClientCode(Handler \u0026amp;handler) { std::vector\u0026lt;std::string\u0026gt; food = {\u0026#34;Nut\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cup of coffee\u0026#34;}; for (const std::string \u0026amp;f : food) { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Who wants a \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;?\\n\u0026#34;; const std::string result = handler.Handle(f); if (!result.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; result; } else { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34; was left untouched.\\n\u0026#34;; } } } /** * The other part of the client code constructs the actual chain. */ int main() { MonkeyHandler *monkey = new MonkeyHandler; SquirrelHandler *squirrel = new SquirrelHandler; DogHandler *dog = new DogHandler; monkey-\u0026gt;SetNext(squirrel)-\u0026gt;SetNext(dog); /** * The client should be able to send a request to any handler, not just the * first one in the chain. */ std::cout \u0026lt;\u0026lt; \u0026#34;Chain: Monkey \u0026gt; Squirrel \u0026gt; Dog\\n\\n\u0026#34;; ClientCode(*monkey); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Subchain: Squirrel \u0026gt; Dog\\n\\n\u0026#34;; ClientCode(*squirrel); delete monkey; delete squirrel; delete dog; return 0; } 命令模式 命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n适合应用场景:\n如果你需要通过操作来参数化对象， 可使用命令模式。\n命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。\n举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。\n如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。\n如果你想要实现操作回滚功能， 可使用命令模式。\n尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。\n为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。\n这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。\n其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。\n/** * The Command interface declares a method for executing a command. */ class Command { public: virtual ~Command() { } virtual void Execute() const = 0; }; /** * Some commands can implement simple operations on their own. */ class SimpleCommand : public Command { private: std::string pay_load_; public: explicit SimpleCommand(std::string pay_load) : pay_load_(pay_load) { } void Execute() const override { std::cout \u0026lt;\u0026lt; \u0026#34;SimpleCommand: See, I can do simple things like printing (\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;pay_load_ \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; } }; /** * The Receiver classes contain some important business logic. They know how to * perform all kinds of operations, associated with carrying out a request. In * fact, any class may serve as a Receiver. */ class Receiver { public: void DoSomething(const std::string \u0026amp;a) { std::cout \u0026lt;\u0026lt; \u0026#34;Receiver: Working on (\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;.)\\n\u0026#34;; } void DoSomethingElse(const std::string \u0026amp;b) { std::cout \u0026lt;\u0026lt; \u0026#34;Receiver: Also working on (\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;.)\\n\u0026#34;; } }; /** * However, some commands can delegate more complex operations to other objects, * called \u0026#34;receivers.\u0026#34; */ class ComplexCommand : public Command { /** * @var Receiver */ private: Receiver *receiver_; /** * Context data, required for launching the receiver\u0026#39;s methods. */ std::string a_; std::string b_; /** * Complex commands can accept one or several receiver objects along with any * context data via the constructor. */ public: ComplexCommand(Receiver *receiver, std::string a, std::string b) : receiver_(receiver), a_(a), b_(b) { } /** * Commands can delegate to any methods of a receiver. */ void Execute() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ComplexCommand: Complex stuff should be done by a receiver object.\\n\u0026#34;; this-\u0026gt;receiver_-\u0026gt;DoSomething(this-\u0026gt;a_); this-\u0026gt;receiver_-\u0026gt;DoSomethingElse(this-\u0026gt;b_); } }; /** * The Invoker is associated with one or several commands. It sends a request to * the command. */ class Invoker { /** * @var Command */ private: Command *on_start_; /** * @var Command */ Command *on_finish_; /** * Initialize commands. */ public: ~Invoker() { delete on_start_; delete on_finish_; } void SetOnStart(Command *command) { this-\u0026gt;on_start_ = command; } void SetOnFinish(Command *command) { this-\u0026gt;on_finish_ = command; } /** * The Invoker does not depend on concrete command or receiver classes. The * Invoker passes a request to a receiver indirectly, by executing a command. */ void DoSomethingImportant() { std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: Does anybody want something done before I begin?\\n\u0026#34;; if (this-\u0026gt;on_start_) { this-\u0026gt;on_start_-\u0026gt;Execute(); } std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: ...doing something really important...\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: Does anybody want something done after I finish?\\n\u0026#34;; if (this-\u0026gt;on_finish_) { this-\u0026gt;on_finish_-\u0026gt;Execute(); } } }; /** * The client code can parameterize an invoker with any commands. */ int main() { Invoker *invoker = new Invoker; invoker-\u0026gt;SetOnStart(new SimpleCommand(\u0026#34;Say Hi!\u0026#34;)); Receiver *receiver = new Receiver; invoker-\u0026gt;SetOnFinish(new ComplexCommand(receiver, \u0026#34;Send email\u0026#34;, \u0026#34;Save report\u0026#34;)); invoker-\u0026gt;DoSomethingImportant(); delete invoker; delete receiver; return 0; } 迭代器模式 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n适合应用场景:\n当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。\n使用该模式可以减少程序中重复的遍历代码。\n重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。\n如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。\n/** * Iterator Design Pattern * * Intent: Lets you traverse elements of a collection without exposing its * underlying representation (list, stack, tree, etc.). */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; /** * C++ has its own implementation of iterator that works with a different * generics containers defined by the standard library. */ template \u0026lt;typename T, typename U\u0026gt; class Iterator { public: typedef typename std::vector\u0026lt;T\u0026gt;::iterator iter_type; Iterator(U *p_data, bool reverse = false) : m_p_data_(p_data) { m_it_ = m_p_data_-\u0026gt;m_data_.begin(); } void First() { m_it_ = m_p_data_-\u0026gt;m_data_.begin(); } void Next() { m_it_++; } bool IsDone() { return (m_it_ == m_p_data_-\u0026gt;m_data_.end()); } iter_type Current() { return m_it_; } private: U *m_p_data_; iter_type m_it_; }; /** * Generic Collections/Containers provides one or several methods for retrieving * fresh iterator instances, compatible with the collection class. */ template \u0026lt;class T\u0026gt; class Container { friend class Iterator\u0026lt;T, Container\u0026gt;; public: void Add(T a) { m_data_.push_back(a); } Iterator\u0026lt;T, Container\u0026gt; *CreateIterator() { return new Iterator\u0026lt;T, Container\u0026gt;(this); } private: std::vector\u0026lt;T\u0026gt; m_data_; }; class Data { public: Data(int a = 0) : m_data_(a) {} void set_data(int a) { m_data_ = a; } int data() { return m_data_; } private: int m_data_; }; /** * The client code may or may not know about the Concrete Iterator or Collection * classes, for this implementation the container is generic so you can used * with an int or with a custom class. */ void ClientCode() { std::cout \u0026lt;\u0026lt; \u0026#34;________________Iterator with int______________________________________\u0026#34; \u0026lt;\u0026lt; std::endl; Container\u0026lt;int\u0026gt; cont; for (int i = 0; i \u0026lt; 10; i++) { cont.Add(i); } Iterator\u0026lt;int, Container\u0026lt;int\u0026gt;\u0026gt; *it = cont.CreateIterator(); for (it-\u0026gt;First(); !it-\u0026gt;IsDone(); it-\u0026gt;Next()) { std::cout \u0026lt;\u0026lt; *it-\u0026gt;Current() \u0026lt;\u0026lt; std::endl; } Container\u0026lt;Data\u0026gt; cont2; Data a(100), b(1000), c(10000); cont2.Add(a); cont2.Add(b); cont2.Add(c); std::cout \u0026lt;\u0026lt; \u0026#34;________________Iterator with custom Class______________________________\u0026#34; \u0026lt;\u0026lt; std::endl; Iterator\u0026lt;Data, Container\u0026lt;Data\u0026gt;\u0026gt; *it2 = cont2.CreateIterator(); for (it2-\u0026gt;First(); !it2-\u0026gt;IsDone(); it2-\u0026gt;Next()) { std::cout \u0026lt;\u0026lt; it2-\u0026gt;Current()-\u0026gt;data() \u0026lt;\u0026lt; std::endl; } delete it; delete it2; } int main() { ClientCode(); return 0; } 中介者模式 中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n适合应用场景:\n当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。\n当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。\n如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; /** * The Mediator interface declares a method used by components to notify the * mediator about various events. The Mediator may react to these events and * pass the execution to other components. */ class BaseComponent; class Mediator { public: virtual void Notify(BaseComponent *sender, std::string event) const = 0; }; /** * The Base Component provides the basic functionality of storing a mediator\u0026#39;s * instance inside component objects. */ class BaseComponent { protected: Mediator *mediator_; public: BaseComponent(Mediator *mediator = nullptr) : mediator_(mediator) { } void set_mediator(Mediator *mediator) { this-\u0026gt;mediator_ = mediator; } }; /** * Concrete Components implement various functionality. They don\u0026#39;t depend on * other components. They also don\u0026#39;t depend on any concrete mediator classes. */ class Component1 : public BaseComponent { public: void DoA() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 1 does A.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;A\u0026#34;); } void DoB() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 1 does B.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;B\u0026#34;); } }; class Component2 : public BaseComponent { public: void DoC() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 2 does C.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;C\u0026#34;); } void DoD() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 2 does D.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;D\u0026#34;); } }; /** * Concrete Mediators implement cooperative behavior by coordinating several * components. */ class ConcreteMediator : public Mediator { private: Component1 *component1_; Component2 *component2_; public: ConcreteMediator(Component1 *c1, Component2 *c2) : component1_(c1), component2_(c2) { this-\u0026gt;component1_-\u0026gt;set_mediator(this); this-\u0026gt;component2_-\u0026gt;set_mediator(this); } void Notify(BaseComponent *sender, std::string event) const override { if (event == \u0026#34;A\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;Mediator reacts on A and triggers following operations:\\n\u0026#34;; this-\u0026gt;component2_-\u0026gt;DoC(); } if (event == \u0026#34;D\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;Mediator reacts on D and triggers following operations:\\n\u0026#34;; this-\u0026gt;component1_-\u0026gt;DoB(); this-\u0026gt;component2_-\u0026gt;DoC(); } } }; /** * The client code. */ void ClientCode() { Component1 *c1 = new Component1; Component2 *c2 = new Component2; ConcreteMediator *mediator = new ConcreteMediator(c1, c2); std::cout \u0026lt;\u0026lt; \u0026#34;Client triggers operation A.\\n\u0026#34;; c1-\u0026gt;DoA(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client triggers operation D.\\n\u0026#34;; c2-\u0026gt;DoD(); delete c1; delete c2; delete mediator; } int main() { ClientCode(); return 0; } 备忘录模式 备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n适合应用场景：\n当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。\n当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。\n/** * The Memento interface provides a way to retrieve the memento\u0026#39;s metadata, such * as creation date or name. However, it doesn\u0026#39;t expose the Originator\u0026#39;s state. */ class Memento { public: virtual std::string GetName() const = 0; virtual std::string date() const = 0; virtual std::string state() const = 0; }; /** * The Concrete Memento contains the infrastructure for storing the Originator\u0026#39;s * state. */ class ConcreteMemento : public Memento { private: std::string state_; std::string date_; public: ConcreteMemento(std::string state) : state_(state) { this-\u0026gt;state_ = state; std::time_t now = std::time(0); this-\u0026gt;date_ = std::ctime(\u0026amp;now); } /** * The Originator uses this method when restoring its state. */ std::string state() const override { return this-\u0026gt;state_; } /** * The rest of the methods are used by the Caretaker to display metadata. */ std::string GetName() const override { return this-\u0026gt;date_ + \u0026#34; / (\u0026#34; + this-\u0026gt;state_.substr(0, 9) + \u0026#34;...)\u0026#34;; } std::string date() const override { return this-\u0026gt;date_; } }; /** * The Originator holds some important state that may change over time. It also * defines a method for saving the state inside a memento and another method for * restoring the state from it. */ class Originator { /** * @var string For the sake of simplicity, the originator\u0026#39;s state is stored * inside a single variable. */ private: std::string state_; std::string GenerateRandomString(int length = 10) { const char alphanum[] = \u0026#34;0123456789\u0026#34; \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; int stringLength = sizeof(alphanum) - 1; std::string random_string; for (int i = 0; i \u0026lt; length; i++) { random_string += alphanum[std::rand() % stringLength]; } return random_string; } public: Originator(std::string state) : state_(state) { std::cout \u0026lt;\u0026lt; \u0026#34;Originator: My initial state is: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /** * The Originator\u0026#39;s business logic may affect its internal state. Therefore, * the client should backup the state before launching methods of the business * logic via the save() method. */ void DoSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Originator: I\u0026#39;m doing something important.\\n\u0026#34;; this-\u0026gt;state_ = this-\u0026gt;GenerateRandomString(30); std::cout \u0026lt;\u0026lt; \u0026#34;Originator: and my state has changed to: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /** * Saves the current state inside a memento. */ Memento *Save() { return new ConcreteMemento(this-\u0026gt;state_); } /** * Restores the Originator\u0026#39;s state from a memento object. */ void Restore(Memento *memento) { this-\u0026gt;state_ = memento-\u0026gt;state(); std::cout \u0026lt;\u0026lt; \u0026#34;Originator: My state has changed to: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; /** * The Caretaker doesn\u0026#39;t depend on the Concrete Memento class. Therefore, it * doesn\u0026#39;t have access to the originator\u0026#39;s state, stored inside the memento. It * works with all mementos via the base Memento interface. */ class Caretaker { /** * @var Memento[] */ private: std::vector\u0026lt;Memento *\u0026gt; mementos_; /** * @var Originator */ Originator *originator_; public: Caretaker(Originator *originator) : originator_(originator) { this-\u0026gt;originator_ = originator; } void Backup() { std::cout \u0026lt;\u0026lt; \u0026#34;\\nCaretaker: Saving Originator\u0026#39;s state...\\n\u0026#34;; this-\u0026gt;mementos_.push_back(this-\u0026gt;originator_-\u0026gt;Save()); } void Undo() { if (!this-\u0026gt;mementos_.size()) { return; } Memento *memento = this-\u0026gt;mementos_.back(); this-\u0026gt;mementos_.pop_back(); std::cout \u0026lt;\u0026lt; \u0026#34;Caretaker: Restoring state to: \u0026#34; \u0026lt;\u0026lt; memento-\u0026gt;GetName() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; try { this-\u0026gt;originator_-\u0026gt;Restore(memento); } catch (...) { this-\u0026gt;Undo(); } } void ShowHistory() const { std::cout \u0026lt;\u0026lt; \u0026#34;Caretaker: Here\u0026#39;s the list of mementos:\\n\u0026#34;; for (Memento *memento : this-\u0026gt;mementos_) { std::cout \u0026lt;\u0026lt; memento-\u0026gt;GetName() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } }; /** * Client code. */ void ClientCode() { Originator *originator = new Originator(\u0026#34;Super-duper-super-puper-super.\u0026#34;); Caretaker *caretaker = new Caretaker(originator); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; caretaker-\u0026gt;ShowHistory(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Now, let\u0026#39;s rollback!\\n\\n\u0026#34;; caretaker-\u0026gt;Undo(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Once more!\\n\\n\u0026#34;; caretaker-\u0026gt;Undo(); delete originator; delete caretaker; } int main() { std::srand(static_cast\u0026lt;unsigned int\u0026gt;(std::time(NULL))); ClientCode(); return 0; } 状态模式 状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n适合应用场景:\n如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。\n如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。\n当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; /** * The base State class declares methods that all Concrete State should * implement and also provides a backreference to the Context object, associated * with the State. This backreference can be used by States to transition the * Context to another State. */ class Context; class State { /** * @var Context */ protected: Context *context_; public: virtual ~State() { } void set_context(Context *context) { this-\u0026gt;context_ = context; } virtual void Handle1() = 0; virtual void Handle2() = 0; }; /** * The Context defines the interface of interest to clients. It also maintains a * reference to an instance of a State subclass, which represents the current * state of the Context. */ class Context { /** * @var State A reference to the current state of the Context. */ private: State *state_; public: Context(State *state) : state_(nullptr) { this-\u0026gt;TransitionTo(state); } ~Context() { delete state_; } /** * The Context allows changing the State object at runtime. */ void TransitionTo(State *state) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Transition to \u0026#34; \u0026lt;\u0026lt; typeid(*state).name() \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; if (this-\u0026gt;state_ != nullptr) delete this-\u0026gt;state_; this-\u0026gt;state_ = state; this-\u0026gt;state_-\u0026gt;set_context(this); } /** * The Context delegates part of its behavior to the current State object. */ void Request1() { this-\u0026gt;state_-\u0026gt;Handle1(); } void Request2() { this-\u0026gt;state_-\u0026gt;Handle2(); } }; /** * Concrete States implement various behaviors, associated with a state of the * Context. */ class ConcreteStateA : public State { public: void Handle1() override; void Handle2() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA handles request2.\\n\u0026#34;; } }; class ConcreteStateB : public State { public: void Handle1() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB handles request1.\\n\u0026#34;; } void Handle2() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB handles request2.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB wants to change the state of the context.\\n\u0026#34;; this-\u0026gt;context_-\u0026gt;TransitionTo(new ConcreteStateA); } }; void ConcreteStateA::Handle1() { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA handles request1.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA wants to change the state of the context.\\n\u0026#34;; this-\u0026gt;context_-\u0026gt;TransitionTo(new ConcreteStateB); } /** * The client code. */ void ClientCode() { Context *context = new Context(new ConcreteStateA); context-\u0026gt;Request1(); context-\u0026gt;Request2(); delete context; } int main() { ClientCode(); return 0; } 策略模式 策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n适合应用场景:\n当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。\n当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。\n如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。\n当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。\n/** * The Strategy interface declares operations common to all supported versions * of some algorithm. * * The Context uses this interface to call the algorithm defined by Concrete * Strategies. */ class Strategy { public: virtual ~Strategy() {} virtual std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const = 0; }; /** * The Context defines the interface of interest to clients. */ class Context { /** * @var Strategy The Context maintains a reference to one of the Strategy * objects. The Context does not know the concrete class of a strategy. It * should work with all strategies via the Strategy interface. */ private: Strategy *strategy_; /** * Usually, the Context accepts a strategy through the constructor, but also * provides a setter to change it at runtime. */ public: Context(Strategy *strategy = nullptr) : strategy_(strategy) { } ~Context() { delete this-\u0026gt;strategy_; } /** * Usually, the Context allows replacing a Strategy object at runtime. */ void set_strategy(Strategy *strategy) { delete this-\u0026gt;strategy_; this-\u0026gt;strategy_ = strategy; } /** * The Context delegates some work to the Strategy object instead of * implementing +multiple versions of the algorithm on its own. */ void DoSomeBusinessLogic() const { // ... std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = this-\u0026gt;strategy_-\u0026gt;DoAlgorithm(std::vector\u0026lt;std::string\u0026gt;{\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34;}); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // ... } }; /** * Concrete Strategies implement the algorithm while following the base Strategy * interface. The interface makes them interchangeable in the Context. */ class ConcreteStrategyA : public Strategy { public: std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const override { std::string result; std::for_each(std::begin(data), std::end(data), [\u0026amp;result](const std::string \u0026amp;letter) { result += letter; }); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const override { std::string result; std::for_each(std::begin(data), std::end(data), [\u0026amp;result](const std::string \u0026amp;letter) { result += letter; }); std::sort(std::begin(result), std::end(result)); for (int i = 0; i \u0026lt; result.size() / 2; i++) { std::swap(result[i], result[result.size() - i - 1]); } return result; } }; /** * The client code picks a concrete strategy and passes it to the context. The * client should be aware of the differences between strategies in order to make * the right choice. */ void ClientCode() { Context *context = new Context(new ConcreteStrategyA); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context-\u0026gt;DoSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context-\u0026gt;set_strategy(new ConcreteStrategyB); context-\u0026gt;DoSomeBusinessLogic(); delete context; } int main() { ClientCode(); return 0; } 模板方法模式 模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n适合应用场景:\n当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。\n当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。\n/** * The Abstract Class defines a template method that contains a skeleton of some * algorithm, composed of calls to (usually) abstract primitive operations. * * Concrete subclasses should implement these operations, but leave the template * method itself intact. */ class AbstractClass { /** * The template method defines the skeleton of an algorithm. */ public: void TemplateMethod() const { this-\u0026gt;BaseOperation1(); this-\u0026gt;RequiredOperations1(); this-\u0026gt;BaseOperation2(); this-\u0026gt;Hook1(); this-\u0026gt;RequiredOperation2(); this-\u0026gt;BaseOperation3(); this-\u0026gt;Hook2(); } /** * These operations already have implementations. */ protected: void BaseOperation1() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: I am doing the bulk of the work\\n\u0026#34;; } void BaseOperation2() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I let subclasses override some operations\\n\u0026#34;; } void BaseOperation3() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I am doing the bulk of the work anyway\\n\u0026#34;; } /** * These operations have to be implemented in subclasses. */ virtual void RequiredOperations1() const = 0; virtual void RequiredOperation2() const = 0; /** * These are \u0026#34;hooks.\u0026#34; Subclasses may override them, but it\u0026#39;s not mandatory * since the hooks already have default (but empty) implementation. Hooks * provide additional extension points in some crucial places of the * algorithm. */ virtual void Hook1() const {} virtual void Hook2() const {} }; /** * Concrete classes have to implement all abstract operations of the base class. * They can also override some operations with a default implementation. */ class ConcreteClass1 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation2\\n\u0026#34;; } }; /** * Usually, concrete classes override only a fraction of base class\u0026#39; operations. */ class ConcreteClass2 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation2\\n\u0026#34;; } void Hook1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Overridden Hook1\\n\u0026#34;; } }; /** * The client code calls the template method to execute the algorithm. Client * code does not have to know the concrete class of an object it works with, as * long as it works with objects through the interface of their base class. */ void ClientCode(AbstractClass *class_) { // ... class_-\u0026gt;TemplateMethod(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass1 *concreteClass1 = new ConcreteClass1; ClientCode(concreteClass1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass2 *concreteClass2 = new ConcreteClass2; ClientCode(concreteClass2); delete concreteClass1; delete concreteClass2; return 0; } ","date":"2022-01-03T15:48:22Z","permalink":"https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-行为模式"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n代理模式 解释\n对真正要被访问的产品或类加以控制，并可以进行一些控制，把访问产品与代理进行映射，访问代理就相当于访问产品\n适用场景：\n使用代理模式的方式多种多样， 我们来看看最常见的几种。\n延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。\n访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n代理可仅在客户端凭据满足要求时将请求传递给服务对象。\n本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。\n记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。\n代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。\n智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。\n代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。\nclass Subject { public: virtual void Request() const = 0; }; /** * The RealSubject contains some core business logic. Usually, RealSubjects are * capable of doing some useful work which may also be very slow or sensitive - * e.g. correcting input data. A Proxy can solve these issues without any * changes to the RealSubject\u0026#39;s code. */ class RealSubject : public Subject { public: void Request() const override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\\n\u0026#34;; } }; /** * The Proxy has an interface identical to the RealSubject. */ class Proxy : public Subject { /** * @var RealSubject */ private: RealSubject *real_subject_; bool CheckAccess() const { // Some real checks should go here. std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Checking access prior to firing a real request.\\n\u0026#34;; return true; } void LogAccess() const { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Logging the time of request.\\n\u0026#34;; } /** * The Proxy maintains a reference to an object of the RealSubject class. It * can be either lazy-loaded or passed to the Proxy by the client. */ public: Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) { } ~Proxy() { delete real_subject_; } /** * The most common applications of the Proxy pattern are lazy loading, * caching, controlling the access, logging, etc. A Proxy can perform one of * these things and then, depending on the result, pass the execution to the * same method in a linked RealSubject object. */ void Request() const override { if (this-\u0026gt;CheckAccess()) { this-\u0026gt;real_subject_-\u0026gt;Request(); this-\u0026gt;LogAccess(); } } }; /** * The client code is supposed to work with all objects (both subjects and * proxies) via the Subject interface in order to support both real subjects and * proxies. In real life, however, clients mostly work with their real subjects * directly. In this case, to implement the pattern more easily, you can extend * your proxy from the real subject\u0026#39;s class. */ void ClientCode(const Subject \u0026amp;subject) { // ... subject.Request(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the client code with a real subject:\\n\u0026#34;; RealSubject *real_subject = new RealSubject; ClientCode(*real_subject); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the same client code with a proxy:\\n\u0026#34;; Proxy *proxy = new Proxy(real_subject); ClientCode(*proxy); delete real_subject; delete proxy; return 0; } 适配器模式 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n适用场景：\n当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。\n如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。\n将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。\nclass Target { public: virtual ~Target() = default; virtual std::string Request() const { return \u0026#34;Target: The default target\u0026#39;s behavior.\u0026#34;; } }; /** * The Adaptee contains some useful behavior, but its interface is incompatible * with the existing client code. The Adaptee needs some adaptation before the * client code can use it. */ class Adaptee { public: std::string SpecificRequest() const { return \u0026#34;.eetpadA eht fo roivaheb laicepS\u0026#34;; } }; /** * The Adapter makes the Adaptee\u0026#39;s interface compatible with the Target\u0026#39;s * interface. */ class Adapter : public Target { private: Adaptee *adaptee_; public: Adapter(Adaptee *adaptee) : adaptee_(adaptee) {} std::string Request() const override { std::string to_reverse = this-\u0026gt;adaptee_-\u0026gt;SpecificRequest(); std::reverse(to_reverse.begin(), to_reverse.end()); return \u0026#34;Adapter: (TRANSLATED) \u0026#34; + to_reverse; } }; /** * The client code supports all classes that follow the Target interface. */ void ClientCode(const Target *target) { std::cout \u0026lt;\u0026lt; target-\u0026gt;Request(); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: I can work just fine with the Target objects:\\n\u0026#34;; Target *target = new Target; ClientCode(target); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; Adaptee *adaptee = new Adaptee; std::cout \u0026lt;\u0026lt; \u0026#34;Client: The Adaptee class has a weird interface. See, I don\u0026#39;t understand it:\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Adaptee: \u0026#34; \u0026lt;\u0026lt; adaptee-\u0026gt;SpecificRequest(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: But I can work with it via the Adapter:\\n\u0026#34;; Adapter *adapter = new Adapter(adaptee); ClientCode(adapter); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete target; delete adaptee; delete adapter; return 0; } 桥接模式 桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n适用场景：\n如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。\n类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。\n桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。\n如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。\n如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。\n顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。\nclass Implementation { public: virtual ~Implementation() {} virtual std::string OperationImplementation() const = 0; }; /** * Each Concrete Implementation corresponds to a specific platform and * implements the Implementation interface using that platform\u0026#39;s API. */ class ConcreteImplementationA : public Implementation { public: std::string OperationImplementation() const override { return \u0026#34;ConcreteImplementationA: Here\u0026#39;s the result on the platform A.\\n\u0026#34;; } }; class ConcreteImplementationB : public Implementation { public: std::string OperationImplementation() const override { return \u0026#34;ConcreteImplementationB: Here\u0026#39;s the result on the platform B.\\n\u0026#34;; } }; /** * The Abstraction defines the interface for the \u0026#34;control\u0026#34; part of the two class * hierarchies. It maintains a reference to an object of the Implementation * hierarchy and delegates all of the real work to this object. */ class Abstraction { /** * @var Implementation */ protected: Implementation* implementation_; public: Abstraction(Implementation* implementation) : implementation_(implementation) { } virtual ~Abstraction() { } virtual std::string Operation() const { return \u0026#34;Abstraction: Base operation with:\\n\u0026#34; + this-\u0026gt;implementation_-\u0026gt;OperationImplementation(); } }; /** * You can extend the Abstraction without changing the Implementation classes. */ class ExtendedAbstraction : public Abstraction { public: ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) { } std::string Operation() const override { return \u0026#34;ExtendedAbstraction: Extended operation with:\\n\u0026#34; + this-\u0026gt;implementation_-\u0026gt;OperationImplementation(); } }; /** * Except for the initialization phase, where an Abstraction object gets linked * with a specific Implementation object, the client code should only depend on * the Abstraction class. This way the client code can support any abstraction- * implementation combination. */ void ClientCode(const Abstraction\u0026amp; abstraction) { // ... std::cout \u0026lt;\u0026lt; abstraction.Operation(); // ... } /** * The client code should be able to work with any pre-configured abstraction- * implementation combination. */ int main() { Implementation* implementation = new ConcreteImplementationA; Abstraction* abstraction = new Abstraction(implementation); ClientCode(*abstraction); std::cout \u0026lt;\u0026lt; std::endl; delete implementation; delete abstraction; implementation = new ConcreteImplementationB; abstraction = new ExtendedAbstraction(implementation); ClientCode(*abstraction); delete implementation; delete abstraction; return 0; } 组合模式 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n适用场景\n如果你需要实现树状对象结构， 可以使用组合模式。\n组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。\n如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。\n组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; /** * The base Component class declares common operations for both simple and * complex objects of a composition. */ class Component { /** * @var Component */ protected: Component *parent_; /** * Optionally, the base Component can declare an interface for setting and * accessing a parent of the component in a tree structure. It can also * provide some default implementation for these methods. */ public: virtual ~Component() {} void SetParent(Component *parent) { this-\u0026gt;parent_ = parent; } Component *GetParent() const { return this-\u0026gt;parent_; } /** * In some cases, it would be beneficial to define the child-management * operations right in the base Component class. This way, you won\u0026#39;t need to * expose any concrete component classes to the client code, even during the * object tree assembly. The downside is that these methods will be empty for * the leaf-level components. */ virtual void Add(Component *component) {} virtual void Remove(Component *component) {} /** * You can provide a method that lets the client code figure out whether a * component can bear children. */ virtual bool IsComposite() const { return false; } /** * The base Component may implement some default behavior or leave it to * concrete classes (by declaring the method containing the behavior as * \u0026#34;abstract\u0026#34;). */ virtual std::string Operation() const = 0; }; /** * The Leaf class represents the end objects of a composition. A leaf can\u0026#39;t have * any children. * * Usually, it\u0026#39;s the Leaf objects that do the actual work, whereas Composite * objects only delegate to their sub-components. */ class Leaf : public Component { public: std::string Operation() const override { return \u0026#34;Leaf\u0026#34;; } }; /** * The Composite class represents the complex components that may have children. * Usually, the Composite objects delegate the actual work to their children and * then \u0026#34;sum-up\u0026#34; the result. */ class Composite : public Component { /** * @var \\SplObjectStorage */ protected: std::list\u0026lt;Component *\u0026gt; children_; public: /** * A composite object can add or remove other components (both simple or * complex) to or from its child list. */ void Add(Component *component) override { this-\u0026gt;children_.push_back(component); component-\u0026gt;SetParent(this); } /** * Have in mind that this method removes the pointer to the list but doesn\u0026#39;t * frees the * memory, you should do it manually or better use smart pointers. */ void Remove(Component *component) override { children_.remove(component); component-\u0026gt;SetParent(nullptr); } bool IsComposite() const override { return true; } /** * The Composite executes its primary logic in a particular way. It traverses * recursively through all its children, collecting and summing their results. * Since the composite\u0026#39;s children pass these calls to their children and so * forth, the whole object tree is traversed as a result. */ std::string Operation() const override { std::string result; for (const Component *c : children_) { if (c == children_.back()) { result += c-\u0026gt;Operation(); } else { result += c-\u0026gt;Operation() + \u0026#34;+\u0026#34;; } } return \u0026#34;Branch(\u0026#34; + result + \u0026#34;)\u0026#34;; } }; /** * The client code works with all of the components via the base interface. */ void ClientCode(Component *component) { // ... std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component-\u0026gt;Operation(); // ... } /** * Thanks to the fact that the child-management operations are declared in the * base Component class, the client code can work with any component, simple or * complex, without depending on their concrete classes. */ void ClientCode2(Component *component1, Component *component2) { // ... if (component1-\u0026gt;IsComposite()) { component1-\u0026gt;Add(component2); } std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component1-\u0026gt;Operation(); // ... } /** * This way the client code can support the simple leaf components... */ int main() { Component *simple = new Leaf; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I\u0026#39;ve got a simple component:\\n\u0026#34;; ClientCode(simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; /** * ...as well as the complex composites. */ Component *tree = new Composite; Component *branch1 = new Composite; Component *leaf_1 = new Leaf; Component *leaf_2 = new Leaf; Component *leaf_3 = new Leaf; branch1-\u0026gt;Add(leaf_1); branch1-\u0026gt;Add(leaf_2); Component *branch2 = new Composite; branch2-\u0026gt;Add(leaf_3); tree-\u0026gt;Add(branch1); tree-\u0026gt;Add(branch2); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Now I\u0026#39;ve got a composite tree:\\n\u0026#34;; ClientCode(tree); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I don\u0026#39;t need to check the components classes even when managing the tree:\\n\u0026#34;; ClientCode2(tree, simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete simple; delete tree; delete branch1; delete branch2; delete leaf_1; delete leaf_2; delete leaf_3; return 0; } 装饰模式 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n适用场景：\n如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。\n如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n许多编程语言使用 final 最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。\n/** * The base Component interface defines operations that can be altered by * decorators. */ class Component { public: virtual ~Component() {} virtual std::string Operation() const = 0; }; /** * Concrete Components provide default implementations of the operations. There * might be several variations of these classes. */ class ConcreteComponent : public Component { public: std::string Operation() const override { return \u0026#34;ConcreteComponent\u0026#34;; } }; /** * The base Decorator class follows the same interface as the other components. * The primary purpose of this class is to define the wrapping interface for all * concrete decorators. The default implementation of the wrapping code might * include a field for storing a wrapped component and the means to initialize * it. */ class Decorator : public Component { /** * @var Component */ protected: Component* component_; public: Decorator(Component* component) : component_(component) { } /** * The Decorator delegates all work to the wrapped component. */ std::string Operation() const override { return this-\u0026gt;component_-\u0026gt;Operation(); } }; /** * Concrete Decorators call the wrapped object and alter its result in some way. */ class ConcreteDecoratorA : public Decorator { /** * Decorators may call parent implementation of the operation, instead of * calling the wrapped object directly. This approach simplifies extension of * decorator classes. */ public: ConcreteDecoratorA(Component* component) : Decorator(component) { } std::string Operation() const override { return \u0026#34;ConcreteDecoratorA(\u0026#34; + Decorator::Operation() + \u0026#34;)\u0026#34;; } }; /** * Decorators can execute their behavior either before or after the call to a * wrapped object. */ class ConcreteDecoratorB : public Decorator { public: ConcreteDecoratorB(Component* component) : Decorator(component) { } std::string Operation() const override { return \u0026#34;ConcreteDecoratorB(\u0026#34; + Decorator::Operation() + \u0026#34;)\u0026#34;; } }; /** * The client code works with all objects using the Component interface. This * way it can stay independent of the concrete classes of components it works * with. */ void ClientCode(Component* component) { // ... std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component-\u0026gt;Operation(); // ... } int main() { /** * This way the client code can support both simple components... */ Component* simple = new ConcreteComponent; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I\u0026#39;ve got a simple component:\\n\u0026#34;; ClientCode(simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; /** * ...as well as decorated ones. * * Note how decorators can wrap not only simple components but the other * decorators as well. */ Component* decorator1 = new ConcreteDecoratorA(simple); Component* decorator2 = new ConcreteDecoratorB(decorator1); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Now I\u0026#39;ve got a decorated component:\\n\u0026#34;; ClientCode(decorator2); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete simple; delete decorator1; delete decorator2; return 0; } 外观模式 外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。\n适用场景:\n如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。\n如果需要将子系统组织为多层结构， 可以使用外观。\n创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。\n让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与中介者模式非常相似。\n/** * The Subsystem can accept requests either from the facade or client directly. * In any case, to the Subsystem, the Facade is yet another client, and it\u0026#39;s not * a part of the Subsystem. */ class Subsystem1 { public: std::string Operation1() const { return \u0026#34;Subsystem1: Ready!\\n\u0026#34;; } // ... std::string OperationN() const { return \u0026#34;Subsystem1: Go!\\n\u0026#34;; } }; /** * Some facades can work with multiple subsystems at the same time. */ class Subsystem2 { public: std::string Operation1() const { return \u0026#34;Subsystem2: Get ready!\\n\u0026#34;; } // ... std::string OperationZ() const { return \u0026#34;Subsystem2: Fire!\\n\u0026#34;; } }; /** * The Facade class provides a simple interface to the complex logic of one or * several subsystems. The Facade delegates the client requests to the * appropriate objects within the subsystem. The Facade is also responsible for * managing their lifecycle. All of this shields the client from the undesired * complexity of the subsystem. */ class Facade { protected: Subsystem1 *subsystem1_; Subsystem2 *subsystem2_; /** * Depending on your application\u0026#39;s needs, you can provide the Facade with * existing subsystem objects or force the Facade to create them on its own. */ public: /** * In this case we will delegate the memory ownership to Facade Class */ Facade( Subsystem1 *subsystem1 = nullptr, Subsystem2 *subsystem2 = nullptr) { this-\u0026gt;subsystem1_ = subsystem1 ?: new Subsystem1; this-\u0026gt;subsystem2_ = subsystem2 ?: new Subsystem2; } ~Facade() { delete subsystem1_; delete subsystem2_; } /** * The Facade\u0026#39;s methods are convenient shortcuts to the sophisticated * functionality of the subsystems. However, clients get only to a fraction of * a subsystem\u0026#39;s capabilities. */ std::string Operation() { std::string result = \u0026#34;Facade initializes subsystems:\\n\u0026#34;; result += this-\u0026gt;subsystem1_-\u0026gt;Operation1(); result += this-\u0026gt;subsystem2_-\u0026gt;Operation1(); result += \u0026#34;Facade orders subsystems to perform the action:\\n\u0026#34;; result += this-\u0026gt;subsystem1_-\u0026gt;OperationN(); result += this-\u0026gt;subsystem2_-\u0026gt;OperationZ(); return result; } }; /** * The client code works with complex subsystems through a simple interface * provided by the Facade. When a facade manages the lifecycle of the subsystem, * the client might not even know about the existence of the subsystem. This * approach lets you keep the complexity under control. */ void ClientCode(Facade *facade) { // ... std::cout \u0026lt;\u0026lt; facade-\u0026gt;Operation(); // ... } /** * The client code may have some of the subsystem\u0026#39;s objects already created. In * this case, it might be worthwhile to initialize the Facade with these objects * instead of letting the Facade create new instances. */ int main() { Subsystem1 *subsystem1 = new Subsystem1; Subsystem2 *subsystem2 = new Subsystem2; Facade *facade = new Facade(subsystem1, subsystem2); ClientCode(facade); delete facade; return 0; } 享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n适用场景:\n仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：\n程序需要生成数量巨大的相似对象 这将耗尽目标设备的所有内存 对象中包含可抽取且能在多个对象间共享的重复状态。 /** * Flyweight Design Pattern * * Intent: Lets you fit more objects into the available amount of RAM by sharing * common parts of state between multiple objects, instead of keeping all of the * data in each object. */ struct SharedState { std::string brand_; std::string model_; std::string color_; SharedState(const std::string \u0026amp;brand, const std::string \u0026amp;model, const std::string \u0026amp;color) : brand_(brand), model_(model), color_(color) { } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const SharedState \u0026amp;ss) { return os \u0026lt;\u0026lt; \u0026#34;[ \u0026#34; \u0026lt;\u0026lt; ss.brand_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; ss.model_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; ss.color_ \u0026lt;\u0026lt; \u0026#34; ]\u0026#34;; } }; struct UniqueState { std::string owner_; std::string plates_; UniqueState(const std::string \u0026amp;owner, const std::string \u0026amp;plates) : owner_(owner), plates_(plates) { } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const UniqueState \u0026amp;us) { return os \u0026lt;\u0026lt; \u0026#34;[ \u0026#34; \u0026lt;\u0026lt; us.owner_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; us.plates_ \u0026lt;\u0026lt; \u0026#34; ]\u0026#34;; } }; /** * The Flyweight stores a common portion of the state (also called intrinsic * state) that belongs to multiple real business entities. The Flyweight accepts * the rest of the state (extrinsic state, unique for each entity) via its * method parameters. */ class Flyweight { private: SharedState *shared_state_; public: Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state)) { } Flyweight(const Flyweight \u0026amp;other) : shared_state_(new SharedState(*other.shared_state_)) { } ~Flyweight() { delete shared_state_; } SharedState *shared_state() const { return shared_state_; } void Operation(const UniqueState \u0026amp;unique_state) const { std::cout \u0026lt;\u0026lt; \u0026#34;Flyweight: Displaying shared (\u0026#34; \u0026lt;\u0026lt; *shared_state_ \u0026lt;\u0026lt; \u0026#34;) and unique (\u0026#34; \u0026lt;\u0026lt; unique_state \u0026lt;\u0026lt; \u0026#34;) state.\\n\u0026#34;; } }; /** * The Flyweight Factory creates and manages the Flyweight objects. It ensures * that flyweights are shared correctly. When the client requests a flyweight, * the factory either returns an existing instance or creates a new one, if it * doesn\u0026#39;t exist yet. */ class FlyweightFactory { /** * @var Flyweight[] */ private: std::unordered_map\u0026lt;std::string, Flyweight\u0026gt; flyweights_; /** * Returns a Flyweight\u0026#39;s string hash for a given state. */ std::string GetKey(const SharedState \u0026amp;ss) const { return ss.brand_ + \u0026#34;_\u0026#34; + ss.model_ + \u0026#34;_\u0026#34; + ss.color_; } public: FlyweightFactory(std::initializer_list\u0026lt;SharedState\u0026gt; share_states) { for (const SharedState \u0026amp;ss : share_states) { this-\u0026gt;flyweights_.insert(std::make_pair\u0026lt;std::string, Flyweight\u0026gt;(this-\u0026gt;GetKey(ss), Flyweight(\u0026amp;ss))); } } /** * Returns an existing Flyweight with a given state or creates a new one. */ Flyweight GetFlyweight(const SharedState \u0026amp;shared_state) { std::string key = this-\u0026gt;GetKey(shared_state); if (this-\u0026gt;flyweights_.find(key) == this-\u0026gt;flyweights_.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;FlyweightFactory: Can\u0026#39;t find a flyweight, creating new one.\\n\u0026#34;; this-\u0026gt;flyweights_.insert(std::make_pair(key, Flyweight(\u0026amp;shared_state))); } else { std::cout \u0026lt;\u0026lt; \u0026#34;FlyweightFactory: Reusing existing flyweight.\\n\u0026#34;; } return this-\u0026gt;flyweights_.at(key); } void ListFlyweights() const { size_t count = this-\u0026gt;flyweights_.size(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nFlyweightFactory: I have \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; flyweights:\\n\u0026#34;; for (std::pair\u0026lt;std::string, Flyweight\u0026gt; pair : this-\u0026gt;flyweights_) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } }; // ... void AddCarToPoliceDatabase( FlyweightFactory \u0026amp;ff, const std::string \u0026amp;plates, const std::string \u0026amp;owner, const std::string \u0026amp;brand, const std::string \u0026amp;model, const std::string \u0026amp;color) { std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Adding a car to database.\\n\u0026#34;; const Flyweight \u0026amp;flyweight = ff.GetFlyweight({brand, model, color}); // The client code either stores or calculates extrinsic state and passes it // to the flyweight\u0026#39;s methods. flyweight.Operation({owner, plates}); } /** * The client code usually creates a bunch of pre-populated flyweights in the * initialization stage of the application. */ int main() { FlyweightFactory *factory = new FlyweightFactory({{\u0026#34;Chevrolet\u0026#34;, \u0026#34;Camaro2018\u0026#34;, \u0026#34;pink\u0026#34;}, {\u0026#34;Mercedes Benz\u0026#34;, \u0026#34;C300\u0026#34;, \u0026#34;black\u0026#34;}, {\u0026#34;Mercedes Benz\u0026#34;, \u0026#34;C500\u0026#34;, \u0026#34;red\u0026#34;}, {\u0026#34;BMW\u0026#34;, \u0026#34;M5\u0026#34;, \u0026#34;red\u0026#34;}, {\u0026#34;BMW\u0026#34;, \u0026#34;X6\u0026#34;, \u0026#34;white\u0026#34;}}); factory-\u0026gt;ListFlyweights(); AddCarToPoliceDatabase(*factory, \u0026#34;CL234IR\u0026#34;, \u0026#34;James Doe\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;M5\u0026#34;, \u0026#34;red\u0026#34;); AddCarToPoliceDatabase(*factory, \u0026#34;CL234IR\u0026#34;, \u0026#34;James Doe\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;X1\u0026#34;, \u0026#34;red\u0026#34;); factory-\u0026gt;ListFlyweights(); delete factory; return 0; } ","date":"2022-01-03T15:07:58Z","permalink":"https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-结构型模式"},{"content":" 推荐看👉 OI Wiki\n数据结构：数据结构是为算法服务而设计的。 算法：充分且合理利用计算机资源处理数据而诞生。\n数据结构部分 一. 数据结构的存储方式有两种 1.顺序存储(数组,内存连续) 2.链式存储(链表,内存不连续,依靠节点的指针指向下一个节点) 常见的数据结构有：\n数组(array),链表(LinkedList),\n双向链表(doubly-linked-list),\n树：\n二叉树(Binary tree),\n二叉查找树(Binary Search Tree),平衡二叉树(AVL),\n2-3-4树\n红黑树(Red Black Tree), B树, B+树, B*树, AA-树\ntreap树, k-d树, 伸展树(Splay Tree)\n最小生成树(Minimum Spanning Tree)\n图(graph),\n栈(stack), 堆(heap),队列(queue),\n散列表(hash), 位图(bitmap),\n字典(map)\n二 常见数据结构实现 1.链表 链表(LinkedList) 避免数组插入和删除的线性开销,我们需要允许表可以不连续存储,防止数据大量移动\n链表的设计 设计成一个链表节点至少包含两部分：\n数据部和指针部\n数据部为我们要存储的数据,指针部为指向下一个链表节点\ntypedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 单向链表 typedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 例子 /*1ist.h*/ #ifndef LIST_H #define LIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for linked list elements. */ typedef struct ListElnt_ { void *data: struct ListElnt *next; } ListElmt; /* Define a structure for linked lists, */ typedef struct List_ { int size: int (*match()const void *keyl, const void *key2); void (*destroy)(void *data); ListElmt *head; ListElmt *tail; } List; /* Public Interface*/ void list_init(List *list, void (*destroy)(void *data)); // 初始化一个链表以便于进行后续操作 void list_destroy(List *list);\tint list_ins_next(List *list, ListEInt *element, const void *data); int list_rem_next(List *list, ListElnt *element, void **data); #define list_size(list()(list)-\u0026gt;size) #define list_head(list()(list)-\u0026gt;head) #define list_tail(1ist()(1ist)-\u0026gt;tail) #define list_is_head(list, element()(element)= (list)-\u0026gt;head ? 1: 0) #define list_is_tail(element()(element)-\u0026gt;next NULL ? 1:0) #define list_data(element()(element)-\u0026gt;data) #define list_next(element()(element)-\u0026gt;next) #endif /* list.c*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /*list init */ void list_init(List *list, void (*destroy)(void *data)) { /* Initialize the list. */ list-\u0026gt;size = 0; list-\u0026gt;destroy = destroy; list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; } /*listdestroy*/ void list_destroy(List *list) { void* data; /* Remove each element.*/ while (list_size(list) \u0026gt; 0){ if (0 == list_rem_next(list, NULL, (void **)\u0026amp;data) \u0026amp;\u0026amp; NULL != list-\u0026gt;destroy){ /* Call a user-defined function to free dynanically allocated data, */ list-\u0026gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precaution. */ memset(list, 0, sizeof(List)); } /*list_ins_next*/ int list_ins_next(List *list, ListElmt *element,const void *data){ ListElmt*\tnew_element; /*Allocate storage for the element. */ if(NULL == (new_element-(ListElmt*)malloc(sizeof(ListElmt)))) return -1; /* Insert the element into the list. */ new_element-\u0026gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list. */ if (list_size(list)==0) list-\u0026gt;tail = new _element; new_element-\u0026gt;next = list-\u0026gt;head; list-\u0026gt;head=new_element; } else{ /* Handle insertion somewhere other than at the head. */ if(element-\u0026gt;next == NULL) list-\u0026gt;tail = new_element; new_element-\u0026gt;next = element-\u0026gt;next; element-\u0026gt;next = new_element; } /*Adjust the size of the list to account for the inserted element. */ list-\u0026gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt\t*old_element; /*Do not allow removal from an empty list.*/ if (list_size(list) == 0) return -1; /* Remove the element from the list. */ if (element == NULL) { /* Handle removal from the head of the list, */ *data = list-\u0026gt;head-\u0026gt;data; old_element = list-\u0026gt;head; list-\u0026gt;head = list-\u0026gt;head-\u0026gt;next; if (list_size(list) == 1) list-\u0026gt;tail = NULL; } else { /* Handle removal from somewhere other than the head. */ if (element—\u0026gt;next == NULL) return -1; *data = element-\u0026gt;next-\u0026gt;data; old_element = element-\u0026gt;next; element-\u0026gt;next = element-\u0026gt;next-\u0026gt;next; if (element-\u0026gt;next = NULL) list-\u0026gt;tail = element; } /* Free the storage allocated by the abstract datatype. */ free(old_element); /*Adjust the size of the list to account for the removed element.*/ 1ist—\u0026gt;size--; return 0; } 双向链表 typedef struct DListEImt_ { void *data; struct DListEImt_ *prev; struct DListEImt_ *next; } DListEImt; 例子 /*dlist h */ #ifndef DLIST_H #define DLIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for doubly-linked list elements. */ typedef struct DListEImt_ { void *data; struct DListEImt_ *prev; struct DListEImt_ *next; } DListEImt; /*Define structure for doubly-linked lists. */ typedef struct Dlist_ { int size; int (*match)(const void*key1, const void *key2); void (*destroy)(void *data); DListEImt *head; DListEImt *tail; }DList; /* Public Interface */ void dlist_init(DList *list, void (*destroy)(void *data)); void dlist_destroy(DList *list); int dlist_ins_next(DList *list, DListEImt *element const void *data); int dlist_ins_prev(DList *list, DListEImt *element, const void *data); int dlist_remove(DList *list, DListEImt *element, void **data); #define dlist_size(list)\t((list)-\u0026gt;size) #define dlist_tail(list)\t((list)-\u0026gt;tail) #define dlist_is_head(element)\t((element)-\u0026gt;prev == NULL ? 1: 0) #define dlist_is_tail(element)\t((element)-\u0026gt;next == NULL ? 1: 0) #define dlist_data(element)\t((element)-\u0026gt;data) #define diist_next(element)\t((element)-\u0026gt;next) #define dlist_prev(element)\t(element )-\u0026gt;prev) /*d]主st.C*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include dlist . h /* dlist init */ void dlist_init(DList *list, void (*destroy)(void *data)) { /* Initialize the list. */ list-\u0026gt;size = 0; list-\u0026gt;destory = destroy; list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; } /* dlist_destory */ void dlist_destroy (DList *list) { void *data /* Remove each element. */ while (dlist_size(list) \u0026gt; 0) { if (dlist_remove(list, dlist_tail(list), (void**)adata)==0 \u0026amp;\u0026amp; list-\u0026gt;destory != NULL) { /* Call a user-defined function to free dynamically allocated data. */ list-\u0026gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precaution. */ memset(list, 0, sizeof(DList)); } int dlist_ins_next(DList *list, DListElmt *element, const void *data) { DListElmt *new_element; /* Do not allow a NUll element unless the list is empty. */ if (element == NULL \u0026amp;\u0026amp; dlist_size(list) != 0) return -1; /* Allocate storage for the element. */ if ((new_element = (DListElmt *)malloc(sizeof(DListElmt)))== NULL) return -1: /* Insert the new_element into the list. */ new_element-\u0026gt;data = (void *)data; if (dlist size(list) == 0) { /* Handle insertion when the list is empty. */ list-\u0026gt;head = new_element; list-\u0026gt;head-\u0026gt;prev = NULL; list-\u0026gt;head-\u0026gt;next = NULL; list-\u0026gt;tail = new_element; } else{ /* Handle insertion when the list is not empty. */ new_element-\u0026gt;next = element-\u0026gt;next; new_element-\u0026gt;prev = element; if(element-\u0026gt;next == NULL) list-\u0026gt;tail = new_element; else element-\u0026gt;next-\u0026gt;prev = new_element; element-\u0026gt;next = new_element; } /* Adjust the size of the list to account for the inserted element. */ list-\u0026gt;size++; return 0; } /* dlist ins_ prev */ int dlist_ins_prev(DList *list, DListElmt *element, const void *data) { DListElmt *new_element; /* Do not allow a NULL element unless the list is empty. */ if (element == NULL \u0026amp;\u0026amp; dlist_size(list) != 0) return -1; /* Allocate storage to be managed by the abstract datatype. */ if(new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL) return - 1; /* Insert the new_element into the list */ new_element-\u0026gt;data =(void *)data; if (dlist_size(list)== 0) { /* Handle insertion when the list is empty. */ list-\u0026gt;head = new_element; list-\u0026gt;head-\u0026gt;prev = NULL; list-\u0026gt;head-\u0026gt;next = NULL; list-\u0026gt;tail = new_element; } else { /* Handle inserton when the list is not empty. */ new_element = element; new_element-\u0026gt;prev = element-\u0026gt;prev; if (element-\u0026gt;prev == NULL) list-\u0026gt;head = new_element; else element-\u0026gt;prev-\u0026gt;next = new_element; element-\u0026gt;prev = new_element; } /* Adjust the size of the list to account for the new_element. */ list-\u0026gt;size++; return 0; } /* d1ist_remove */ int dlist_remove(DList *list, DListElmt. *element, void s*data) { /* Do not allow a NULL element or removal from an empty list. */ if (element == NULL || dlist_size(list) == 0) return -1: /* remove the element from the list. */ *data s element -\u0026gt;data; if (element == list-\u0026gt;head) { /* Handle removal from the head of the list. */ list-\u0026gt;head = element-\u0026gt;next; if (list-\u0026gt;head == NULL) list-\u0026gt;tail = NULL; else element-\u0026gt;next-\u0026gt;prev = NULL; } else { /* Handle removal from other than the head of the list. */ element-\u0026gt;prev-\u0026gt;next = element-\u0026gt;next; if (element-\u0026gt;next == NULL) list-\u0026gt;tail = elenent-\u0026gt;prev; else element-\u0026gt;next-\u0026gt;prev = element-\u0026gt;prev; } /* Free the storage allocated by the abstract datatype. */ free(element); /* Adjust the size of the list to account for the removed element */ list-\u0026gt;size--; return 0; } 循环链表 typedef struct ClistElmt_ { void *data; struct ClistElmt_ *next; }ClistElmt; 例子 /* clist .h */ #ifndef CLIST_H #define CLIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for circular list elements .*/ typedef struct CListElmt { void * data; struct CListElmt * next; } CListElmt; /* Definea structure for circular lists .*/ typedef struct CList_ { int size; int (*match)(constvoid * key1, const void * key2); void (*destroy)(void* data); CListElmt *head; }CList; /* Public Interface */ void clist_init(CList* list,void ( *destroy)( void* data)); void clist_destroy(CList* list); int clist_ins_next (CList* list,CListElmt * element,const void *data); int clist_rem_next (CList* list,CListElmt * element,void **data); #defineclist _size(list)((list)-\u0026gt;size) #defineclist head (list)(()-\u0026gt;head) #defineclist data (element)((element)-\u0026gt;data) #defineclist _next(element)((element)-\u0026gt;next) #endif /* clist .c */ #include \u0026lt;stdlib.h \u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;clist.h\u0026#34; /* clist init */ void clist_init(CList* list,void ( *destroy)( void* data)) { /* Initialize the list .*/ list-\u0026gt;size = 0; list-\u0026gt;destroy = destroy ; list-\u0026gt;head = NULL; } /* clist destroy */ void clist_destroy (CList* list) { void *data; /* Remove each element .*/ while (clist_size(list) \u0026gt; 0) { if (clist_remnext (list,list-\u0026gt;head, (void **)\u0026amp;data)== 0 \u0026amp;\u0026amp; list-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data .*/ list-\u0026gt;destroy(data); } } /* No operations are allowed now ,but clear the structure as a precaution .*/ memset (list, 0, sizeof(CList)); } /* clist ins next */ int clist_insnext (CList* list,CListElmt * element,const void * data) { CListElmt* new_element; /*Allocate storage for the element .*/ if ((new_element = (CListElmt* )malloc(sizeof(CListElmt))) == NULL) return -1; /* Insert the element into the list .*/ new_element-\u0026gt;data = (void *)data; if (clist_size(list) == 0) { /* Handle insertion when the list empty .*/ new_element-\u0026gt;next = new_element; list-\u0026gt;head = new_element; } else { /* Handle insertion when the list is not empty .*/ new_element-\u0026gt;next = element-\u0026gt;next; element-\u0026gt;next = new_element; } /* Adjust the size of the list to account for the inserted element .*/ list-\u0026gt;size++; return 0 ; } /* clist_rem_next */ int clist_rem_next(CList* list, CListElmt *element,void **data) { CListElmt * old_element; /* Do not allow removal from an empty list . */ if (clist_size(list) == 0) return -1; /* Remove the element from the list . */ *data = element-\u0026gt;next-\u0026gt;data; if (element-\u0026gt;next == element) { /* Handle removing the last element . */ old_element = element-\u0026gt;next; list-\u0026gt;headNULL; } else { /* Handle removing other than the last element . */ old_element = element-\u0026gt;next; element-\u0026gt;next = element-\u0026gt;next-\u0026gt;next; if (old_element == clist_head(list)) list-\u0026gt;head = old_element-\u0026gt;next; } /* Free the storage allocated by the abstract datatype . */ free(old_element); /* Adjust the size of the list to account for the removed element . */ 1ist-\u0026gt;size--; return 0; } 2.栈和队列 栈和队列是另一种数据的存储方式。\n用于检索数据的常用数据结构称为栈,栈的检索顺序和存储元素相反\n栈: 按照后进先出的顺序存储和检索数据的高效数据结构, 它检索数据的顺序和存储数据相反。\n队列：按照先进先出的顺序存储和检索数据的高效数据结构, 它按照存储元素的顺序检索元素。\n栈例子 /* stack .h*/ #ifndef STACK_H #define STACK_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement stacks as linked lists .*/ typedef List Stack; /*Public Interface */ #define stack_init list_init #define stack_destroy list_destroy int stack_push(Stack* stack,const void * data); int stack_pop(Stack* stack,void ** data); #define stack_peek(stack)\t((stack)-\u0026gt;head == NULL ? NULL : (stack)-\u0026gt;head-\u0026gt;data) #define stack_size list_size #endif /* Stack.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;Stack.h\u0026#34; /* stack_push */ int stack_push(Stack* stack,const void * data) { /* push the data onto the stack. */ return list_ins_next(stack, NULL, data); } /* stack_pop */ int stack_pop(Stack* stack,void ** data) { /* Pop the data off the stack. */ return list_rem_next(stack, NULL, data); } 队列例子 /* queue . h */ #ifndef QUEUE_H #define QUEUE_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement queues as linked lists . */ typedef List Queue ; /* Public Interface */ #define queue_init list_init #define queue_destroy list_destroy int queue_enqueue (Queue * queue, const void* data ); int queue_dequeue (Queue * queue, void **data); #define queue_peek(queue()(queue)-\u0026gt;head == NULL ? NULL : (queue)-\u0026gt;head-\u0026gt;data) #define queue_size list_size #endif /* queue.c */ #include \u0026lt;stdlib\u0026gt;h \u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;queue.h\u0026#34; /* queue_enqueue */ int queue_enqueue (Queue* queue, const void* data) { /* Enqueue the data . */ return list_ins_next(queue, list_tail(queue), data); } /* queue_dequeue */ int queue_dequeue(Queue* queue, void** data) { /* Dequeue the data . */ return list_rem_next(queue, NULL, data); } 队列示例：事件处理 遵循实时事件发生的顺序执行。\n/* events.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;event.h\u0026#34; #include \u0026#34;events.h\u0026#34; #include \u0026#34;queue.h\u0026#34; /* receive_event */ int receive_event(Queue *events, const Event *event) { Event* new_event; /* Allocate space for the event. */ if(NULL == (new_event = (Event*)(sizeof(Event)))) return -1; /* Make a copy of the event and enqueue it. */ memcpy(new_event, event, sizeof(Event)); if(queue_enqueue(events, new_event) != 0) return -1; return 0; } /* process_event */ int process_event(Queue *events, int (*dispatch)(Event* event)) { Event* event; if(0 == queue_size(events)) /* Return that there are no events to dispatch. */ return -1; else { if(0 != queue_deququq(events, (void **)\u0026amp;event)) /* Return that an event could not be retrived. */ return -1; else { /* Call a user-defined fintion to dispatch the event. */ dispatch(event); free(event); } } return 0; } 3.集合 集合定义：集合是相关联成员的无序组合,且每个成员在集合中只出现一次\n例子 /* set.h */ #ifndef SET_H #define SET_H #include \u0026lt;Stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement sets as linked lists. */ typedef List Set; /* Public Interface */ void set_init(Set *set, int (*match)(const void *keyl, const void *key2), void (*destory)(void *data)); int set_insert(Set *set, const void *data); int set_remcve(Set *set, void **data); int set_union(Set *setu, const Set *setl, const Set *set2); int set_intersection(Set*seti, const Set *seta, const Set *set2); int set_difference(Set *setd, const Set *setl, const Set *set2); int set_is_memeber(const Set *set, const void *data); int set_is_subset(const Set *setl, const Set *set2); int set_is_equal(const Set *setl, const Set *set2); #define set_size(set()(set) osize) #define set_destroy list_destroy #endif /* set.c */ #include \u0026lt;Stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;set.h\u0026#34; /* set_init */ void set_init(Set *set, int (*match)(const void *keyl, const void *key2), void (*destory)(void *data)) { /* Initialize the set. */ list_init(set, destory); set-\u0026gt;match = match; } /* set_insert */ int set_insert(Set *set, const void *data) { /* Do not allow the insertion of duplicates. */ if (set_in_number(set, data)) return 1; /* Insert the data. */ return list_ins_tail(set, list_tail(set), data); } /* set_remove. */ int set_remove(Set* set, void **data) { ListE1mt *member, *prev; /* Find the member to remove.*/ prev = NULL; for (member = list_head(set); member != NULL; member = list_next(member)) { if list_data(member))) break; prev = member; } /* Return if the member was not found.*/ if (member == NULL) return -1 ; /* Remove the member. */ return list_rem_next(set, prev, data); } /* set_union */ int set_unicn(Set *setu, const Set *setl, const Set *set2) { ListE1mt *member; void *data; /* Initialize the set for the union. */ set_init(setu, set1-\u0026gt;match, NULL); /* Insert the members of the first set. */ for (member = list_head(setl); member != NULL; member = list_next(member)) { data = list_data(member); if (list_ins_next(setu, list_tail(setu), data) != 0) { set_destroy(setu); return -1; } } /* Insert the members of the second set. */ for (member = list_head(set2); member != NULL; member = list_next(member)) { if (set_is_member(setl, list_data(member))) { /* Do not allow the insertion of duplicates. */ continue; } else { data = list_data(member); if (list_ins_next(setu, list_tail(setu), data) != 0) { set_destroy(setu); return -1; } } } return 0; } /* set_intersection */ int set_intersection(Set *seti, const Set *setl, const Set *set2) { ListElmt *member; void *data; /* Initialize the set for the intersection. */ set_init(set1, set1-\u0026gt;match, NULL); /* Insert the members present in both sets- */ for (member = list_head(set1); member != NULL; member = list_next(member)) { if (set_is_member(set2, list_data(member))) { data = list_data(member); if (list_ins_next(seti, list_tail(seti), data) != 0) { set_destroy(seti); return -1; } } } return 0; } /* set_difference */ int set_difference(Set *setd, const Set *seti, const Set *set2) { ListElmt *member; void *data; /* Initialize the set for the difference. */ $et_init(setd, set1-Mnatch, NULL); /* Insert the members from setl not in set2 */ for (member = list_head(setl); member != NULL; member = list_next(member)) { if (lset_is_member(set2, list_data(member))) { data = list_data(member); if (list_ins_next(setd, list_tail(setd), data) != 0) { set_destroy(setd); return -1; } } } return 0; } /* set_ls_member */ int set_is_member(const Set *set const void *data) { ListElmt *member; /* Determine if the data is a member of the set. */ for (member = list_head(set); member != NULL; member = list_next(member)) { if (set-\u0026gt;match(dataj listdata(member))) return 1; } return o; } /* set_is_subset */ int set_is_subset(const Set *setl, const Set *set2) { ListElmt\t*加ember; /* Do a quick test to rule out some cases. */ if (set_size(setl) \u0026gt; set_size(set2)) return 0; /* Determine if setl is a subset of set2, */ for (member = list_head(set1); member != NULL; member = list_next(member)) { if(!list_is_member(set2, list_data(member))) return 0; } return 1; } /* setis_equal */ int set_is_equal(const Set *setl, const Set *set2) { /* Do a quick test to rule out some cases. */ if (set_size(setl) != set_size(set2)) return 0; /* Sets of the same size are equal if they are subsets, */ return set_is_subset(set1, set2); } Set示例：集合覆盖 集合覆盖是一种优化求解问题, 对很多组合数学和资源选择问题给出了漂亮的抽象模型\n/* cover,c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;cover.h” #include \u0026#34;list\u0026#39;h\u0026#34; #include \u0026#34;set.h\u0026#34; /* cover */ int cover(Set *members\u0026gt; Set 率subsets, Set *covering) { Set intersection; KSet *subset; ListElflit \u0026#34;member, *max_member; void *data; int max_size; /* Initialize the covering» */ set_init(covering, subsets-\u0026gt;match, NULL); /* Continue while there are noncovered members and candidate subsets. */ while (set_size(members) \u0026gt; 0 \u0026amp;\u0026amp; set_size(subset) \u0026gt; 0) { /* Find the subset that covers the most members.*/ max_size = 0; for (member = list_head(subsets); member != NULL; member = list_next(member)) { if (set-intersectionC\u0026amp;intersection, \u0026amp;((KSet *)list_data(member))-\u0026gt;set, members) != 0) { return -1; } if (set_size(\u0026amp;inteisection) \u0026gt; max_size) { max_member = member; max_size = set_size(\u0026amp;intersection); } set_destroy(\u0026amp;intersection); } /* A covering is not possible if there was no intersection♦ */ if (max_size == 0) return 1; /* Insert the selected subset into the covering» */ subset = (KSet *)list_data(max_nember); if (set_insert(coverings, subset) != 0) return -1; /* Remove each covered member -from the set of noncovered members. */ for (member = list_head(\u0026amp;((KSet *)list_data(max_member))-\u0026gt;set); member != NULL; member = list_next(member))) { data = list_data(member); if(set_remove(members, (void*)\u0026amp;data) == 0 \u0026amp;\u0026amp; members-\u0026gt;destory != NULL) members-\u0026gt;destory(data); } /* Remove the subset from the set of cnadidate subsets. */ if(set_remove(subsets, (void**)\u0026amp;subset) != 0) return -1; } /* No covering is possible if there are still noncoverd member */ if(set_size(members) \u0026gt; 0) return -1; return 0; } 4.哈希表 哈希表是一种最有效的检索方法：散列。\n从根本上来说,一个哈希表包含一个数组, 通过特殊的索引值(键)来访问数组中的元素,哈希表的主要思想是通过一个哈希函 数,在所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与 键相对应的哈希编码或哈希值。键的数据类型可能多种多样,但哈希值的类型只能是整型。\n链式哈希表 将数据存储在 桶 (bucket)中的哈希表。每个 “桶” 都是都是一个链表; 且链表的 容量能够随着冲突的增加而增大。\n解决哈希表冲突 如果想插入表中的元素数量远大于桶数量,那么即使是在一个均匀散列过的程中,表的性能会迅速降低。这种情况下桶会变得越来越深。因此我们要注意一个哈希表的负载因子。\n其定义为：\n​\tα = n/m\n​\tn为表中的元素数量,m是桶中的数量(数组元素数量)。\n​\t在均匀散列情况下,链式哈希表的负载因子告诉我们表中桶能装元素的最大值\n选择哈希函数 这是哈希算法的核心问题：将键随机地分散到表中,使冲突最小化。因此,选择一 个能够实现这一过程的哈希函数尤为重要。\n其定义为：\n​\th(k) = x\n​\tk为要被映射的值,h()为哈希函数,x为哈希表的位置\n例子 /* chtbl.h */ #ifndef CHTBL_H #define CHTBL_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Define a structure for chained hash table. */ typedef struct CHTBL_ { int buckets; int (*h)(const void* key); int (*match)(const void* key1, const void *key2); int size; List* table; } CHTbl; /* Public interface */ int chtbl_init(CHTbl* htbl, int buckets, int (*h)(const void* key), int (*match)(const void* key1, const void *key2), void (*destory)(void* data)); void chtbl_destory(CHTbl *htbl); int chtbl_insert(CHTbl *htbl, const void *data); int chtbl_remove(CHTbl *htbl, void **data); int chtbl_lookup(CHTbl *htbl, void **data); #define chtbl_size(htbl()(chtbl)-\u0026gt;size) #endif /*chtbl.c*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;chtbl.h\u0026#34; /* chtbl_init */ int chtbl_init(CHTbl* htbl, int buckets, int (*h)(const void* key), int (*match)(const void* key1, const void *key2), void (*destory)(void* data)) { int i; /* Allocate space for the hash table.*/ if ((htbl-\u0026gt;table = (List *)malloc(buckets * sizeof(List))) == NULL) return -1; /* Initialize the buckets. */ htbl-\u0026gt;buckets = buckets; for(i = 0; i \u0026lt; htbl-\u0026gt;buckets; i++) list_init(\u0026amp;htbl-\u0026gt;table[i], destroy); /* Encapsulate the functions. */ htbl-\u0026gt;h = h htbl-\u0026gt;match match; htbl-\u0026gt;destroy = destroy; /* Initialize the number of elements in the table. */ htbl-\u0026gt;size = o; return 0; } /* chtbl_destroy */ void chtbl_destory(CHTbl *htbl) { /* Destroy each bucket. */ for (int i = O; i \u0026lt; htbl-\u0026gt;buckets; i++) { list_destroy (\u0026amp;htbl -\u0026gt;tableßl) ; } /*Free the storage allocated for the hash table. */ free(htbl-\u0026gt;table); /* No operations are allowed now, but clear the structure as a precaution.*/ memset(htbl, 0, sizeof(CHTbl)); } /* chtbl insert */ int chtbl_insert(CHTbl *htbl, const void *data) { void* temp; int bucket, retval; /* Do nothing if the data is already in the table. */ temp = (void *)data; if(chtbl_lookup(htbl, \u0026amp;temp) == 0) return 1 ; /* Hash the key. */ bucket = htbl-\u0026gt;h(data) % htbl-\u0026gt;buckets; /* Insert the data into the bucket. */ if (0 == (retval = list_ins_next(\u0026amp;htbl-\u0026gt;table[bucket], NULL, data))) htbl-\u0026gt;size++; return retval; } /* chtbl remove */ int chtb1_remove(CHTbl* htbl, void **data) { ListEImt*\telement, *prev; int bucket; /* Hash the key. */ bucket = htbl-\u0026gt;h(*data) % htbl-\u0026gt;buckets; /* Search fcy the data in the bucket. */ prev = NULL; for (element = list_head(\u0026amp;htbl-\u0026gt;table[bucket]); element != NULL; element = list_next(element)) { if (htbl-\u0026gt;match(*data, list_data(element))) { /* Remove the data from the bucket. */ if(0 == list_rem_next(\u0026amp;htbl-\u0026gt;table[bucket], prev, data)) { htbl-\u0026gt;size--; return 0; } else return -1; } prev = element; } /* Return that the data was not found. */ return -1; } /* chtbl lookup */ int chtbl_lookup(CHTbl *htbl, void **data) { ListE1mt *element; int bucket; /* Hash the key.*/ bucket = htbl-\u0026gt;h(*data) % htbl-\u0026gt;buckets; /* Search for the data in the bucket.*/ for(element = list_head(\u0026amp;htbl-\u0026gt;table[bucket]); element = list_next(eleemnt)) { if(htbl-\u0026gt;match(*data, list_data(element))) { /* Pass back the data from the table. */ *data = list_data(element); return 0; } } /* Return that the was not found. */ return -1; } 开地址哈希表 将数据存储在表本身中,而不是桶中的哈希表。它通过各种探查方法来避免冲突问题。\n例子 /* ohtbl.h */ #ifndef OHTBL_H #define OHTBL_H #incluge\u0026lt;stdlib.h\u0026gt; /*Define astructure for open-addressed hash tables.*/ typedef struct OHTbl_ { int positions; void* vacateds int (*h1)(const void*key); int (*h2)(const void*key); int (*match)(const void*key1,const void*key2); int (*destroy)(void*data); int sizes; void **table; }OHTbl; /*Public Interface*/ int ohtbl_init(oHTbl*htbl,int positions,int{*hi)(const void*key),int (*h2)(const void*key),int (*match)(const void*key1, const void*key2); void (*destroy)(void*data)); void ohtbl_destroy(OHTbl*htbl); int ohtbl_insert(OHTbl*htbl,const void*data); int ohtbl_remove(OHTbl*htbl,void**data); int ohtbl_lookup(const OHTbl *htbl,void **data); #define ohtbl_size(htbl()(htbl)-\u0026gt;size) #endif /* ohtbl.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;ohtbl.h\u0026#34; /*Reserveasentinelmemoxy address for vacated elements.*/ static char vacated; /*ohtb_linit*/ int ohtb_linit(oHTbl*htbl,int positions,int (*h1)(const void*key),int (*h2)(const void*key),int (*match)(const void*key1,const void*key2),void (*destroy)(voi*data)) { int i; /*Allocate space for the hash table.*/ if ((htbl-\u0026gt;table= (void**)malloc(positions*sizeof(void*)))==NULL) return -1; /*Initializeeachposition、*/ htbl-\u0026gt;positicns = pasitions; for (i=0; i\u0026lt; htbl-\u0026gt;positions；i++) htbl-\u0026gt;table[i] = NULL; /*Set the vacated member tothe sentinel memory address reserved for this,*/ htbl-\u0026gt;vacated= \u0026amp;vacated; /*Encapsulate the functions.*/ htbl-\u0026gt;h1 = h1; htbl-\u0026gt;h2 = h2; htbl-match = match; htbl-\u0026gt;destroy = destroy; /*Initialize the number of elements in the table.*/ htbl-\u0026gt;size = 0; return 0; } /*ohtbl_destroy*/ vold ohtbl_destroy(OHTbl*htbl) { int i; if(htbl-\u0026gt;destroy != NULL) { /*Calla user-defined function to free dynamically allocated data.*/ for(i = 0; i \u0026lt; htbl-\u0026gt;positions; i++) { if(htbl-\u0026gt;table[i] != NULL \u0026amp;\u0026amp; htbl-\u0026gt;table[i] != htbl-\u0026gt;vacated) htbl-\u0026gt;destroy(htbl-\u0026gt;table[i]); } } /*Free the storage allocated for the hash table，*/ free(htbl-\u0026gt;table); /*No operations are allowed nowybut clear the structure asaprecautlon.*/ memset(htbl, 0, sizeof(OHTbl)); } /*ohtblinsert*/ int ohtb_linsert(OHTbl*htbl，constvoid *data) { void* temp; int position, i; /*Do not exceed the number of positions in the table.*/ if (htbl-\u0026gt;size == htbl-\u0026gt;positions) return -1; /*Do nothing ifthe data is already in the table.*/ temp= (void*)data; if (ohtbl_fookup(htbl, \u0026amp;temp) == 0) return 1; /*Use double hashing to hash the key.*/ for (i=0; i \u0026lt; htbl-\u0026gt;positions; i++) { position = (htbl-\u0026gt;h1(data) + (i * htbl-\u0026gt;h2(data))) % htbl-\u0026gt;positions; if (htbl-\u0026gt;table[position] == NULL || htbl-\u0026gt;table[position] == htbl-\u0026gt;vacated) { /* Insert the data into the table.*/ htbl-\u0026gt;table[position] = (void*)data; htbl-\u0026gt;size++; return 0 } } /* Return that the hash funtions were selected incorrectly. */ return -1; } /*ohtbl_remove */ int ohtbl_remove(OHTbl *htbl，void**data) { int position, i; /*Use touble hashingtohashthekey.*/ for (i=0; i \u0026lt; htbl-\u0026gt;positions; i++) { position = (htbl-\u0026gt;h1(*data) + (i * htbl-\u0026gt;h2(*data))) % htbl-\u0026gt;positions; } if (htbl-\u0026gt;table[position] == NULL) { /* Returnthat the data was not found，*/ return -1； } else if (htbl-\u0026gt;table[position]==htbl-\u0026gt;vacated) { /*Seaxch beyond vacated pasitions.*/ continue; } else if (htbl-\u0026gt;match(htbl-\u0026gt;table[position],*data)) { /* Pass back the data from the table，*/ *data = htbl-\u0026gt;table[position]; htbl-\u0026gt;table[positian] = htbl-\u0026gt;vacated; htbl-\u0026gt;size--; return 0; } /*Return that the data wasnot found，*/ return -1; } /* ohtbI_lookup */ int ohtbl_lcokup(const OHTbl *htbl, void **data) { int positiong, i; /* Use double hashing to hash the key.*/ for (i = O; i \u0026lt; htbl-\u0026gt;positions; i++) { positicn = (htb1-\u0026gt;hz(*data) + (i * htb1-\u0026gt;h2(*data))) % htb1-\u0026gt;positions; if (htbl-\u0026gt;table[position] == NULL) { /* Return that the data was not found.*/ return -1; } else if(htbl-\u0026gt;match(htbl-\u0026gt;table[position], *data)) { /* Pass back the data from the table. */ *data = htbl-\u0026gt;table[positipon]; return 0; } } /* Return that the data was not found. */ return -1; } 5.树 树的定义： 在计算机科学中，树由称之为节点的元素按照层次结构方式组织而成。层次最顶端为根(root)。与根相连的为子节点，通常子节点也有自己的子节点。二叉树是分支因子为2的树。二叉搜索树是专门用于查找的树。\n二叉树 二叉树的一个节点包含三部分：一个数据部和两个左右指针部\n树的遍历算法 先序遍历：根(root)，左，右\n中层遍历：左，根(root)，右\n后序遍历：左，右，根(root)\n层序遍历：根(root), 一层一层遍历到叶子\n树的平衡 树的平衡是指对于给定数量的节点，保证树的高度尽可能短的过程。这意味着在结点加入下一层之前必须保证本层结点满额。也就是说树的叶子都在倒数两层，且倒数第二层叶子是满的，则称这棵树是平衡的。最后一层叶子结点靠左，则称这棵树是左平衡的。\n二叉树的接口定义： /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for binary tree nodes.*/ typedef struct BiTreeNode_ { void *data; struct BiTreeNode *left; struct BiTreeNode_*right; }BiTreeNode; /* Defmne a structure for binary trees.*/ typedef struct BiTree_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); BiTreeNode *root; }BiTree; /* Public Interface */ void bitree_init(BiTree *tree, void (*destroy)(void *data)); void bitree_destroy(BiTree *tree); int bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data); int bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data); void bitree_rem_left(BiTree *tree, BiTreeNode *node); void bitree_rem_right(BiTree *tree,BiTreeNode *node); int bitree_merge(BiTree *merge, BiTree *left,BiTree *right,const void *data); #define bitree_size(tree)\t((tree)-\u0026gt;size) #define bitree root(tree)\t((tree)-\u0026gt;root)) #define bitxee_is_eob(node)\t((node) == NULL) #define bitree_is_leaf(node) ((node)-\u0026gt;left == NULL \u0026amp;\u0026amp; (node)-\u0026gt;right == NULL) #define bitree_data(node) ((node)-\u0026gt;data) #define bitree left(node) ((node)-\u0026gt;left) #define bitree_right(node) ((node)-\u0026gt;right) #edif /* bitree.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;bitree.h\u0026#34; /*bitree init*/ void bitree_init(BiTree *tree, void (*destroy)(void *data)) { /* Initialize the binary tree.*/ tree-\u0026gt;size = 0; tree-\u0026gt;destroy = destroy; tree-\u0026gt;root = NULL; } /* bitree_destroy*/ void bitree_destroy(BiTree *tree) { /* Remove all the nodes from the tree.*/ bitree_rem_left(tree, NULL); /* No operations are aIlowed now, but clear the structure as a precaution. */ memset(tree, 0, sizeof(BiTree); } /* bitree ins left */ int bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data) { BiTreeNode new_node, **position; /* Determine where to insert the node.*/ if (node == NULL) { /* Allow insertion at the root only in an empty tree.*/ if (bitree_size(tree) \u0026gt; 0) return -1; position = \u0026amp;tree-\u0026gt;root; } else { /* Normally allow insertion only at the end of a branch.*/ if (bitree_left(node) != NULL) return -1; position = \u0026amp;node-\u0026gt;left; } /* Allocate storage for the node.*/ if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNcde))) == NULL) return -1; /* Insert the node into the tree.*/ new_node-\u0026gt;data = (void *)data; new_node-\u0026gt;ieft = NULL; new_node-\u0026gt;right = NULL; *position = new_node; /* Adjust the size of the tree to account for the inserted node.*/ tree-\u0026gt;size++; return 0; } /* bitree_ins_right */ int bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data) { BiTreeNode *new_node, **position; /* Determine where to insert the node.*/ if (node == NULL) { /* Allow insertion at the root only in an empty tree.*/ if (bitree_size(tree) \u0026gt; 0) return -1; position = \u0026amp;tree-\u0026gt;root; } else { /* Normally allow insertion only at the end of a branch. */ if (bitree_right(node) != NULL) return -1; position = \u0026amp;node-\u0026gt;right; } /* Allocate storage for the node.*/ if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNode))) == NULL) return -1; /* Insert the node into the tree.*/ new_node-\u0026gt;data = (void *)data; new_node-\u0026gt;left = NULL; new_node-\u0026gt;right = NULL; *position = new_node; /* Adjust the size of the tree to account for the inserted node.*/ tree-\u0026gt;size++; return 0; } /* bitree_rem_left */ void bitree_rem_left(BiTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow removal from an empty tree.*/ if (bitree_size(tree) == 0) return; /*Determine where to remove nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;node-\u0026gt;left; /*Remove the nodes.*/ if (*position != NULL) { bitree_rem_left(tree, *position); bitree_rem_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data.*/ tree-\u0026gt;destroy((*position-\u0026gt;data); } free(*position); *position = NULL; /* Adjust the size of the tree to account for the removed node.*/ tree-\u0026gt;size--; } return; } /* bitree_rem_right */ void bitree_rem_right(BiTzee *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow removal from an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to remove nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;node-\u0026gt;right; /* Remove the nodes.*/ if (*position != NULL) { bitree_rem_left(txee,*position); bitree_rem_right(tree,*position); if (tree-\u0026gt;destroy != NULL) { /* CalI a user-defined function to free dynamically allocated data.*/ tree-\u0026gt;destroy((*position)-\u0026gt;data); } free(*position); *position = NULL; /* Adjust the size of the tree to account for the removed node.*/ tree-\u0026gt;size--; } return; } /* bitree_merge*/ int bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data) { /* Initialize the merged tree.*/ bitree_init(merge, left-\u0026gt;destroy); /* Insert the data for the root node of the merged tree.*/ if (bitree_ins_left(merge, NULL, data) != 0) { bitree_destroy(merge); return -1; } /* Merge the two binary trees into a single binary tree.*/ bitree_root(merge)-\u0026gt;left = bitree_root(left); bitree_root(merge)-\u0026gt;right = bitree_root(right); /* Adjust the size of the new binary tree.*/ merge-\u0026gt;size = merge-\u0026gt;size + bitree_size(left) + bitree_size(right); /* Do not let the original trees access the merged nodes.*/ left-\u0026gt;root = NULL; left-\u0026gt;size = 0; right-\u0026gt;root = NULL; right-\u0026gt;size = 0; return 0; } 二叉搜索树 定义： 二叉搜索树是有二叉树组成的专用于查找和搜索目的的一种数据结构。\n数据插入遵循：比根节点(root)大的数插入根右边，比根节点小的数插入左边。\n数据搜索遵循：要查询的值比根(root)大的数向右子节点查，比根节点小向左节点查。\n不允许有重复值出现\n二叉搜素树应尽量保持平衡，但比较困难。非平衡树会造成搜索的节点数量过多，最多O(n)\n二叉搜索树要保持平衡最好的方法是\nAVL树 其定义为：\nAVL树每个节点都保持了一个平衡因子。\n插入结点时AVL树需要自我调整。\n平衡因子：结点的右子树高度-左子树高度，其值为+1, 0，-1。\n+1：代表树是左倾斜的\n-1：代表树是右倾斜的\n平衡因子改变：\n插入新的结点会造成平衡因子改变，因此这棵树需要重新平衡，我们称这种平衡为AVL树的旋转\nAVL树旋转方法：\nLL(left-left)，LR(left-right)，RR(right-right)，RL(right-left)\navl树旋转有一个更简单的方法:\n把这颗树抽象成一棵自然界的树，节点的平衡因子不是-1，0，+1时，RR和LL的节点小于-1或大于+1时树的树梢向下落一层；\nRL和LR的节点小于-1或大于+1时是因为不平衡的子节点引起的，找到不平衡的子节点重复LL或RR的过程，不平衡子节点旋转之后父节点重复LL或RR.\n接口定义： /* bistree.h */ #ifndef BISTREE_H #define BISTREE_R #include \u0026#34;bitree.h\u0026#34; /* Define balance factors for AVL trees. */ #define AVL_LFT_HEAVY 1 #define AVL_BALANCED 0 #deftne AVERGT_HEAVY -1 /* Define a structure for nodes in AVL trees. */ typedef struct AvlNode_ { void *data; int hidden; int factor; }Av1Node; /* Implement binary search trees as binary trees. */ typedef BiTree BisTree; /* Public Interface */ void bistree_init(Bistree *tree, int (*compare)(const void *key1, const void *key2), void (*destroy)(void *data)); void bistree_destroy(BisTree *tree); int bistree_insert(BisTree *tree, const void *data); int bistree_remove(BisTree *tree, const void *data); int bistree_lookup(BisTree *tree, void **data); #define bistree_size(tree) ((txee) -\u0026gt;size) #endif /* bistree.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;bistree.h\u0026#34; static void destroy_right(BisTree *tree, BiTreeNode *node); / * rotate_left */ static void rotate_left(BiTreeNode **node) { BiTreeNode *left, *grandchild; left = bitree_left(*node); if (((AvlNode *)bitree_data(left))-\u0026gt;factor == AVL_LFT_HEAVY) { /* Perform an LL rotation. */ bitree_left(*node) = bitree_right(left); bitree_right(left) = *node; ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; *node = left; } else { /* Perform an LR rotation. */ grandchild = bitree_right(left); bitree_right(left) = bitree_left(grandchild); bitree_left(grandchild) = left; bitree_left(*node) = bitree_right(grandchild); bitree_right(grandchild) = *node; switch (((AvlNode *)bitree_data(left))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_RGT_HEAVY; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_LFT_HEAVY; break; } ((AvlNode *)bitree_data(grandchild))-\u0026gt;factor = AVL_BALANCED; *node = grandchild; } } / * rotate_right */ static void rotate_right(BiTreeNode **node) { BiTreeNode *right, *grandchild; right = bitree_right(*node); if (((AvlNode *)bitree_data(right))-\u0026gt;factor == AVL_RGT_HEAVY) { /* Perform an RR rotation. */ bitree_right(*node) = bitree_right(right); bitree_left(right) = *node; ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED; *node = right; } else { /* Perform an RL rotation. */ grandchild = bitree_left(right); bitree_right(right) = bitree_right(grandchild); bitree_right(grandchild) = right; bitree_right(*node) = bitree_left(grandchild); bitree_left(grandchild) = *node; switch (((AvlNode *)bitree_data(grandchild))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_RGT_HEAVY; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_LFT_HEAVY; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED ; break; } ((AvlNode *)bitree_data(grandchild))-\u0026gt;factor = AVL_BALANCED; *node = grandchild; } } /* destroy_left */ static void destroy_left(BisTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow destruction of an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to destroy nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;tree-\u0026gt;left; /* Destroy the nodes. */ if (*position != NULL) { destroy_left(tree, *position); destroy_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data. */ tree-\u0026gt;destory(((AvlNode *)(*position)-\u0026gt;data)-\u0026gt;data); } /* Free the AVL data in the node, then free the node itself. */ free((*position)-\u0026gt;data); free(*position); *position = NULL; /* Adjust the size of the tree to account for the destroyed node. */ tree-\u0026gt;size--; } } / * destroy_right */ static void destroy_right(BisTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow destruction of an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to destroy nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;tree-\u0026gt;right; /* Destroy the nodes. */ if (*position != NULL) { destroy_left(tree, *position); destroy_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data. */ tree-\u0026gt;destory(((AvlNode *)(*position)-\u0026gt;data)-\u0026gt;data); } /* Free the AVL data in the node, then free the node itself. */ free((*position)-\u0026gt;data); free(*position); *position = NULL; /* Adjust the size of the tree to account for the destroyed node. */ tree-\u0026gt;size--; } } /* insert */ static int insert(BisTree *tree, BiTreeNode **node, const void *data, int *balanced) { AvlNode *avl_data; int cmpval, retval; /* Insert the data into the tree. */ if (bitree_is_eob(*node)) { /* Handle insertion into an empty tree.*/ if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl data-\u0026gt;factor = AVL_BALANCED; avi data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; return bitree_ins_left(tree, *node, avl_data); } else { /* Handle insertion into a tree that is not empty. */ cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(*node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left. */ if (bitree_is_eob(bitree_left(*node))) { if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl_data-\u0026gt;factor = AVL_BALANCED; avl_data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; if (bitree_ins_left(tree, *node, avl_data) != 0) return -1; *balance = 0; } else { if ((retval = insert(tree, \u0026amp;bitree_left(*node), data, balanced)) != 0) return retval; } /* Ensure that the tree remains balanced. */ if (!(*balanced)) { switch (((AvlNode *)bitree_data(*node))-\u0026gt;factor) { case AVL_LFT_HEAVY: rotate_left(node) ; *balanced = 1; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_LFT_HEAVY; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; *balanced = 1; break; } } } /* if (cmpval \u0026lt; 0) */ else if (cmpval \u0026gt; 0) { /* move to the right. */ if (bitree_is_eob(bitree_right(*node))) { if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl_data-\u0026gt;factor = AVL_BALANCED; avl_data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; if (bitree_ins_right(tree, *node, avl_data) != 0) return -1; *balance = 0; } else { if ((retval = insert(tree, \u0026amp;bitree_right(*node), data, balanced)) != 0) return retval; } /* Ensure that the tree remains balanced. */ if (!(*balanced)) { switch (((AvlNode *)bitree_data(*node))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; *balanced = 1; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_RGT_HEAVY; break; case AVL_RGT_HEAVY: rotate_right(node) ; *balanced = 1; break; } } /* if (cmpval) \u0026gt; 0 */ else { /* Handle finding a copy of the data. */ if (!((Av1Node *)bitree_data(*node))-\u0026gt;hodden) { /* Do nothing since the data is in the tree and not hidden. */ return 1; } else { /* Insert the new data and mark it as not hidden. */ if (tree-\u0026gt;destroy != NULL) { /* Destroy the hidden data since it is being replaced. */ tree-\u0026gt;destory(((Av1Node *)bitree_data(*node))-\u0026gt;data); } ((Av1Node *)bitree_data(*node))-\u0026gt;data = (void *)data; ((Av1Node *)bitree_data(*node))-\u0026gt;hidden = 0; /* Do not rebalance because the tree structure is unchanged. */ *balanced = 1; } } } } return 0; } /* hide */ static int hide(BisTree *tree, BiTreeNode *node, const void *data) { int cmpval, retval; if (bitree_is_eob(node)) { /* Return that the data was not found. */ return -1; } cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left.*/ retval = hide(tree, bitree_left(node), data); } else if (cmpval \u0026gt; 0) { /* Move to the right.*/ retval = hide(tree, bitree_right(node), data); } else { /* Mark the node as hidden. */ ((AvLNode *)bitree_data(node))-\u0026gt;hidden = 1; retvaL = 0; } return retval; } /* lookup */ static int lookup(BisTree *tree, BiTreeNode *node, void *data) { int cmpval, retval; if (bitree_is_eob(node)) { /* Return that the data was not found. */ return -1; } cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left.*/ retval = lookup(tree, bitree_left(node), data); } else if (cmpval \u0026gt; 0) { /* Move to the right.*/ retval = lookup(tree, bitree_right(node), data); } else { if(!((AvlNode *)bitree_data(node))-\u0026lt;hidden) { /* Pass back the data from the tree. */ *data = ((AvlNode *)bitree_data(node))-\u0026gt;data; retval = 0; } else { /* Return that the data was not found. */ return -1; } } return retval; } /* bistree_init */ void bistree_init(BisTree *tree, int (*cpmpare)(void *keyl, const void *key2), void (*destory)(*data)) { /* Initialize the tree. */ bitree_init(tree, destory); tree-\u0026gt;compare = compare; } /* bistree_destroy */ void bistree_destroy(BisTree *tree) { /* Destroy all nodes in the tree. */ destory_left(tree, NULL); /* No operations are allowed now, but clear the structure as a precaution. */ memset(tree, 0, sizeof(BisTree)); } /* bistree_insert */ int bistree_insert(BisTree *tree, const void *data) { int balanced = O; return insert(tree, \u0026amp;bitree_rot(tree), data, \u0026amp;balanced); } /* bitree_remove */ int bitree_remove(BisTree *tree, const void *data) { return hide(tree, bitree_root(tree), data); } /* bistree_lookup */ int bistree_lookup(BisTree *tree, void *data) { return lookup(tree, bitree_root(tree), data); } 红黑树（R-B树） 定义： 红黑树 为妥协的AVL树，平衡要求没AVL树严格，因此适用范围比AVL树多\n红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。待插入结点默认为红色结点，插入时按照二分插入。\n性质1. 结点是红色或黑色。\n性质2. 根结点是黑色。\n性质3. 所有叶子都是黑色。（叶子是NIL结点）\n性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）\n性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。\nR_B树的插入旋转法 RR或LL，刚插入的结点的父节点是红色，叔叔结点也是红色，那么父节点和叔叔变为黑色，祖父结点变为红色\n刚插入的结点的父节点是红色，叔叔结点是黑色，那么父节点和叔叔结点需要左旋或右旋，然后原父结点变为黑色，叔叔结点变为红色。\nLR或RL，刚插入结点父结点是红色，叔叔结点也是红色，那么父节点和叔叔结点变为黑色，祖父结点变为红色，\n刚插入结点父结点是红色，叔叔结点为黑色，那么刚插入结点和父节点需要左旋或右旋，再次执行RR或LL步骤。\nR_B树的删除旋转法： ​\tR_B树的删除为红黑树最复杂部分\n1、红黑树删除的情形\n​\t一、从树中删除节点X（以寻找后继节点的方式进行删除）\n​\t情况①：如果X没有孩子，且如果X是红色，直接删除X；如果X是黑色，则以X为当前节点进行旋转调色，最后删掉X\n​\t情况②：如果X只有一个孩子C，交换X和C的数值，再对新X进行删除。根据红黑树特性，此时X不可能为红色，因为红色节点要么没有孩子，要么有两个黑孩子。此时以新X为当前节点进行情况①的判断\n​\t情况③：如果X有两个孩子，则从后继中找到最小节点D，交换X和D的数值，再对新X进行删除。此时以新X为当前节点进行情况①或②的判断\n​\t二、旋转调色（N=旋转调色的当前节点[等于情况①中的X]，P=N的父亲，W=N的兄弟，Nf=N的远侄子，Nn=N的近侄子）\n​\t情况1：N是根或者N是红色，则：直接将N设为黑色\n​\t情况2：N不是根且N是黑色，且W为红色，则：将W设为黑色，P设为红色，对P进行旋转(N为P的左子时进行左旋，N为P的右子时进行右旋)，将情况转化为情况1、2、3、4、5\n​\t情况3：N不是根且N是黑色，且W为黑色，且W的左右子均为黑色，则：将W设为红色，将P设为当前节点进行旋转调色，将情况转化为情况1、2、3、4、5\n​\t情况4：N不是根且N是黑色，且W为黑色，且Nf为黑色，Nn为红色，则：交换W与Nn的颜色，并对W进行旋转(N为P的左子进行右旋，N为P的右子进行左旋)，旋转后N的新兄弟W有一个红色WR，则转换为情况5\n​\t情况5：N不是根且N是黑色，且W为黑色，且Nf为红色，Nn为黑色，则：将W设为P的颜色，P和Nf设为黑色，并对P进行旋转(N为P的左子进行左旋，N为P的右子进行右旋)，N设为根\nB树，B+树，B*树 当数据量非常大时，二叉树已经不能满足需求，如果还用二叉树那么树的深度过大，一个节点存储多个数据就应运而生了。\n定义：\nB树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件：\n每个节点最多只有m个子节点。\n每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。\n如果根不是叶节点，则根至少有两个子节点。\n具有k个子节点的非叶节点包含k -1个键。\n所有叶子都出现在同一水平，没有任何信息（高度一致）。\n此树的一个节点最多有4个结点，一个节点最多有三个值，\n插入如删除方法：B树插入与删除\nB+树\n在B树的基础上增加了数据遍历优点，想要遍历整个树的数据只要把叶子节点便完毕就行，因为B+树的叶子节点数据是整棵树数据，非叶子节点是叶子节点索引。\nB*树\nB*树在B+树的基础上增加了非叶子结点之间链表相联系。\n2-3-4树 2-3-4树是4阶B树，2-3-4树插入与删除\ntreap树 所谓的Treap树堆其实就是树 + 堆。树是二叉查找树BST，堆是二叉堆，大根堆小根堆都可以。\n树堆既是一棵二叉查找树，也是一个二叉堆。但是这两种数据结构貌似还是矛盾的存在，如果是二叉查找树，就不能是一个堆，如果是一个堆，那么必然不是二叉查找树。\n所以树堆用了一个很巧妙的方式解决这个问题：给每个键值一个随机附加的优先级，让键值满足二叉查找树的结构，让优先级满足二叉堆的结构。\ntreap树的详解，插入与删除\nk-d树 k-d树常用来作空间划分及近邻搜索，是二叉空间划分树的一个特例。\nK-D TREE算法原理及实现\n最小生成树(Minimum Spanning Tree) 对于有n个顶点的连通图，生成树有n-1条边，若边数小于此数就不可能将各顶点连通，如果边的数量多于n-1条边，必定会产生回路。\n最小生成树(Minimum Spanning Tree理解\n6.堆和优先队列 在许多问题中，当对数据集进行频繁的插入和删除操作时，往往需要快速确定最大或最小的元素。处理这个问题的方法之一，就是使用一个已排好序的数据集，通过这种方法，最大或最小的元素总是处在数据集的头部（这取决于使用升序还是降序排列）。然而将数据集一遍又一遍地进行排序的代价是非常高的。并且许多情况下，将元素排序并不是超越的目的，最终我们可能在真正要做的工作之外做了很多其他工作，想要快速的找到最大或最小的元素，只需要让元素储存在可以找到它的位置上就行。堆和优先队列，就是一种处理这种问题的有效方法。\n本章内容包括：\n堆： 它是一种树形组织，使我们能够迅速确定包含最大值的结点。维持一棵树的代价低于维持一个有序数据集。同样，我们可以确定通过堆快速地找到包含最小值的元素。\n优先队列 它是一个从堆自然衍生而来的数据结构。在优先队列中，数据保存在一个堆中，这样我们能够迅速确定下一个最高优先级的结点。所谓元素的“优先级”在不同的问题中有不同的意义。\n队和优先队列的一些应用：\n排序：堆排序 任务调度 任务调度会告诉操作系统接下来哪个进程将在CPU上运行。操作系统会不断调整进 程的优先级，用优先队列来存储进程是相对比较高效的方法，因为它可以确保下一 个将在CPU中运行的进程的优先级是最高的。\n包褰分拣（见本章相关章节） 快递公司通常用包裹分拣法来确定包裹递送的优先级。当扫描包裹时，高优先级的 包裹将作为急快件投递出去。而非急快件将作为较低优先级的包裹投递出去。计算 机系统通常使用优先队列来保证最高优先级的包在系统中运行最顺畅，因为这种方 法十分高效。\n霍夫曼编码 这是一种数据压缩方法，它使用霍夫曼树为数据符号分配编码（见第14章）。向出 现频率较高的符号分配较短的编码,向出现频率较低的符号分配较长的编码。霍夫 曼树是由较小的二叉树两两合并构成。由于每次都必须合并键值最小的二叉树，因 此每次合并的两棵树都是从一个优先队列中取出的。\n负载均衡 它用来维护管理一系列处理类似任务的服务。当连接请求到达时，优先队列可以确定哪 个服务器能够最好地处理到达的任务。\n堆排序\n优先队列的描述:\n优先队列将数据按照优先级顺序排列。一个优先队列由许多有序的元素构成，所以优先级最高的元素可以有效而快速地确定,例如，我们看一组用来做负载均衡的服务器，时时观察它们的使用情况。当连接请求到达时，优先队列可以告知当前哪个服务器是处理 此连接请求的最佳服务器。在这种情况下，最空闲的服务器获取的优先级最高，因为它 可以最好地处理服务请求。\n","date":"2022-01-01T19:32:29Z","permalink":"https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":" 推荐看👉 OI Wiki\n算法部分 位图(bitmap) 通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。\n位图BitMap\n字典(map) 字典有什么特点呢?\n字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情况下取出这些信息. 使用数组的方式: [18, \u0026ldquo;Coderwhy\u0026rdquo;, 1.88]. 可以通过下标值取出信息. 使用字典的方式: {\u0026ldquo;age\u0026rdquo; : 18, \u0026ldquo;name\u0026rdquo; : \u0026ldquo;Coderwhy\u0026rdquo;, \u0026ldquo;height\u0026rdquo;: 1.88}. 可以通过key取出value 字典(map)的详细解释\nkmp算法 kmp算法也就是字符串匹配算法。\n比如： 在string str = \u0026ldquo;abcababcba\u0026quot;中匹配 string str2 = \u0026ldquo;ababc\u0026ldquo;字符串\n最长公共前后缀：要匹配的字符串生成的数组\n从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计\n0\ta\n0\ta\tb\n1\ta\tb\ta\n2\ta\tb\ta\tb\n0\ta\tb\ta\tb\tc\n得出的公共前后缀为\n0 0 1 2 0 然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为\n-1 0 0 1 2 kmp匹配过程\nabcababcba\nababc\n如果匹配到不相等元素，则通过next数组(P)决定next数组移动的位置，例如上图next数组(P)下标为2的元素与T字符串不相等，则看一下P数组下标2的next数组的值为0，则把next数组下标为0的位置移动到不匹配的地方\n如果next数组的值为-1则next数组整体右移，或找到T字符串与子字符串第一个元素(如果找到的话)，然后把P移动到此位置(T的剩余的元素大于等于子字符串元素个数)；\n代码\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 计算最长公共前后缀 void prefix_table(char pattern[], int prefix[], int n) { prefix[0] = 0; int len = 0; int i = 1; while (i \u0026lt; n) { if (pattern[i] == pattern[len]) { len++; prefix[i] = len; i++; } else { if (len \u0026gt; 0) { len = prefix[len - 1]; } else { prefix[i] = len; i++; } } } } // 计算next数组 void move_prefix_table(int table[], int n) { for (int i = n - 1; i \u0026gt; 0; --i) { table[i] = table[i - 1]; } table[0] = -1; } // kmp算法 void kmp_search(char text[], char pattern[]) { int n = strlen(pattern); int m = strlen(text); int *prefix = new int[n]; prefix_table(pattern, prefix, n); move_prefix_table(prefix, n); int i = 0; int j = 0; while (i \u0026lt; m) { if (j == n - 1 \u0026amp;\u0026amp; text[i] == pattern[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;Found pattern at \u0026#34; \u0026lt;\u0026lt; i - j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; j = prefix[j]; } if (text[i] == pattern[j]) { i++; j++; } else { j = prefix[j]; if (j == -1) { i++; j++; } } } delete[] prefix; } int main(void) { char pattern[] = \u0026#34;ABABCABAA\u0026#34;; char text[] = \u0026#34;ABABABCABAABABABAAB\u0026#34;; kmp_search(text, pattern); return 0; } 双指针 同向双指针 判断一个链表是否有环\n创建两个指针ptr1,ptr2,两个指针同时指向链表头结点。ptr1每次向后移动一个结点，ptr2每次移动2个结点，如果链表有环他们会指向同一个结点\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ bool samecircle(Node head) { // write your code here Node ptr2 = head; Node ptr2 = head; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 return true; } return false; } }; 判断环长\n第一次相遇代表有环，第二次相遇代表两个指针发生了套环，所以：\n环长 = 速度差 * 移动次数\n判断入环点\n慢指针ptr1每次走一步，所以走的距离是：\nd1 = D + X * (S1 + S2) + S1\n快指针ptr2走的距离是：\nd2 = D + N * (S1 + S2) + S1\n快指针速度是慢指针2倍。 即：\n2 * d1 = d2\n整理后的公式为\nD = (n - 2X - 1)(S1 + S2) + S2\n假设n - 2X -1的值为0，则D = S2;，那么我们就可以在首次相遇点的时候，定义一个指针指向链表的起点，一个指针指向首次相遇点，然后两个指针每次前进1步，当两个指针相遇的时候就是链表的入环点。\n例子：\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ Node find_node(Node head) { // write your code here Node ptr1 = head; Node ptr2 = head; Node ptr3 = nullptr; Node ptr4 = nullptr; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 ptr3 = head; ptr4 = ptr1; break; } if (ptr3 != nullptr \u0026amp;\u0026amp; != ptr4 != nullptr) { while(ptr3 != ptr4) { ptr3 = ptr3.next; ptr4 = ptr4.next; } return ptr4; } return nullptr; } }; 相向双指针 二分法 又称折半搜索，期望时间复杂度为O(log2n)，最差为O(log2(n + 1)) 二分法前提是数据已经有序\n在A[0] \u0026hellip; A[n]中搜索K。\n步骤： \\1. 令low = 0， high = n - 1，初始的查找区域为[low， high]. \\2. 取low和high的中间值mid = (low+high)/2。 \\3. 如果A[mid] = K，则返回mid, 如果不等，则重新确定查找区间。 \\4. 当low \u0026gt; high 时，则表示区间已经失效，如果还未找到，则表示数组中不包含K的值，返回-1。\ntemplate\u0026lt;class T\u0026gt; int binary_search(vector\u0026lt;T\u0026gt; \u0026amp;A, T K) { int low = 0; int high = A.size() - 1; while( low \u0026lt; high ) { int mid = (low + high)/2; if( A[mid] \u0026lt; K ) low = mid + 1; else if( A[mid] \u0026gt; k ) high = mid - 1; else return mid; } return -1; /*返回-1表示数组不存在K的值*/ } 二分答案 二分答案与二分查找 其实是不一样的\n二分答案: 即对你要求的答案进行二分 二分查找: 对一个已知的有序数据集上进行二分的查找\n基础算法·二分答案 - Potassium - 博客园 (cnblogs.com)\n分治法 分治分治，即分而治之。分治，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……直接说就是将一个难以直接解决的大问题，分割成一些规模比较小的相同的小问题，以便各个击破，分而治之。\n分治法所能解决的问题一般具有以下几个特征：\n\\1) 该问题的规模缩小到一定的程度就可以容易地解决\n\\2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。\n\\3) 利用该问题分解出的子问题的解可以合并为该问题的解；\n\\4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\n第一条: 特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；\n第二条: 特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、\n第三条: 特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。\n第四条: 特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。\n经典问题:\n二分查找\n棋盘覆盖\n汉诺塔问题\n归并排序/合并排序\n快速排序\n宽度优先搜索(BFS) 它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。\n基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。\n广度优先搜索原理与实践 - huansky - 博客园 (cnblogs.com)\nprivate Map\u0026lt;String, Boolean\u0026gt; status = new HashMap\u0026lt;String, Boolean\u0026gt;(); private Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); public void BFSSearch(String startPoint) { //1.把起始点放入queue； queue.add(startPoint); status.put(startPoint, false); bfsLoop(); } private void bfsLoop() { while(!queue.isEmpty()) { // 1) 从queue中取出队列头的点；更新状态为已经遍历。 String currentQueueHeader = queue.poll(); //出队 status.put(currentQueueHeader, true); System.out.println(currentQueueHeader); // 2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。 List\u0026lt;String\u0026gt; neighborPoints = graph.get(currentQueueHeader); for (String poinit : neighborPoints) { if (!status.getOrDefault(poinit, false)) { //未被遍历 if (queue.contains(poinit)) continue; queue.add(poinit); status.put(poinit, false); } } } } 拓扑排序法 拓扑排序指的是将有向无环图（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。 算法：拓扑排序 - 子烁爱学习 - 博客园 (cnblogs.com)\n拓扑排序算法及C语言实现 (biancheng.net)\n深度优先搜索/回溯法 (DFS) 深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。\n/** * DFS核心伪代码 * 前置条件是visit数组全部设置成false * @param n 当前开始搜索的节点 * @param d 当前到达的深度，也即是路径长度 * @return 是否有解 */ bool DFS(Node n, int d){ if (isEnd(n, d)){//路径长度为返回true，表示此次搜索有解 return true; } for (Node nextNode in n){//遍历跟节点n相邻的节点nextNode， if (!visit[nextNode]){//未访问过的节点才能继续搜索 //例如搜索到V1了，那么V1要设置成已访问 visit[nextNode] = true; //接下来要从V1开始继续访问了，路径长度当然要加 if (DFS(nextNode, d+1)){//如果搜索出有解 //例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解 return true; } //重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中 visit[nextNode] = false; } //到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。 } return false;//本次搜索无解 } 动态规划 它将问题分成小问题，并先着手解决这些小问题\n背包型DP 假设有三种商品，分别是小汽车1吨，卡车3吨，起重机4吨.价格分别是：3000，4000，6000。\n现在只能卖总共4吨的商品，怎么卖商品售价最高？\n所有的组合为：\n组合 价值 无 0 小汽车 3000 卡车 4000 起重机 6000 小汽车和起重机 重量过大 小汽车和卡车 7000 卡车和起重机 重量过大 小汽车,卡车，起重机 重量过大 可以看到随着商品种类增加组合也在飞速增长，时间复杂度为O(2^n),太慢了\n动态规划算法可以用网格描述\n填充这些表格最后就是背包问题的解法。\n当在小汽车一行时，其他种类的商品选不了，所以都是3000\n当加入卡车时1-2吨放不下3吨的卡车，3吨可以放下卡车，所以为4000，4吨可以放下一个卡车和一个小汽车，共7000\n加入起重机时，1-2背包只能装小汽车，3吨可以装一辆卡车，4吨可以装起重机，但是价格低于7000所以不选起重机的价格，定位卡车加小汽车，价格为7000.\n坐标型DP 又被称为网格型动态规划\n一个网格有m行n列，一个小动物从(0, 0)出发，每一步可以向下或向右走一步，最总到达(m - 1, n - 1)处\n最简单的动态规划类型 给定一个序列或者网格 需要找到序列中某个/些子序列或网格中的某条路径 某种性质最大/最小 计数 存在性 动态规划方程 f[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，f[i][j] 中下标 i , j 表示以格子( i , j )为结尾的满足条件的路径的性质 最大值/最小值 个数 存在性 坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质 D2-坐标型动态规划\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid==null||obstacleGrid.length==0){ return 0; } int [] [] dp = new int[obstacleGrid.length][obstacleGrid[0].length]; for(int i=0;i\u0026lt;obstacleGrid.length;i++){ for(int j=0;j\u0026lt;obstacleGrid[i].length;j++){ if(obstacleGrid[i][j]==1){//有障碍 dp[i][j]=0; continue; }else{ if(i == 0 \u0026amp;\u0026amp; j == 0) dp[i][j]=1;//没有障碍起点 else if(i==0) dp[i][j]=dp[i][j-1];//在第一行,上一题在没有障碍情况下默认是1,但是有障碍就取决于该行前面是否有障碍了 else if(j==0) dp[i][j]=dp[i-1][j];//第一列,没有障碍默认是1,有障碍就取决于该列前面是否有障碍了 else{ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } } } return dp[obstacleGrid.length-1][obstacleGrid[0].length-1]; } } 序列型DP D3-序列型动态规划\n双序列型DP D7-双序列型动态规划\n划分型DP 常见类型：\n1. 给定长度为N的序列或字符串，要求划分成若干段 - 段数不限，或指定K段 - 每一段满足一定的性质 2. 做法 - 类似于序列型动态规划，但是通常要加上段数信息 - 一般用`f[i][j]`记录前i个元素（元素0~i-1）分成 j 段的性质，如最小代价 D4 划分型动态规划\n记忆化搜索 记忆化搜索 - OI Wiki (oi-wiki.org)\n区间型DP D6-区间型动态规划\n状态压缩DP 状压 DP - OI Wiki (oi-wiki.org)\n博弈型DP D4-博弈型动态规划\n匹配型DP 数位 DP 数位 DP - OI Wiki (oi-wiki.org)\n树形DP 树形 DP - OI Wiki (oi-wiki.org)\n插头 DP 插头 DP - OI Wiki (oi-wiki.org)\n概率 DP 概率 DP - OI Wiki (oi-wiki.org)\n动态 DP 动态 DP - OI Wiki (oi-wiki.org)\n排序算法 排序简介 - OI Wiki (oi-wiki.org)\n外排序算法 排序之外部排序 - Judy518 - 博客园 (cnblogs.com)\n快速排序算法 快速排序 - OI Wiki (oi-wiki.org)\n欧拉路径 什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。\n欧拉路径详解 - TEoS - 博客园 (cnblogs.com)\n模拟法 模拟算法（C++）_1只小弛的博客-CSDN博客_c++模拟\nC++算法：模拟 - 无咕 - 博客园 (cnblogs.com)\n扫描线算法 扫描线是一种用于求矩阵面积并或者周长并的算法，可以使用 线段树 来优化。假设给定了平面上若干个可能相交的矩阵，需要求出它们的面积并（面积之和减去相交部分）或者周长并（外轮廓的长度）。我们可以虚拟出一条按顺序扫描整个平面的线段，通过对平行或垂直于 [Math Processing Error]x 轴的线段进行处理得到答案。\n扫描线 - Ling_Lover - 博客园 (cnblogs.com)\n枚举法 枚举法 - Huise.J - 博客园 (cnblogs.com)\n最短路径 看完就懂了！一篇搞定图论最短路径问题 - thousfeet - 博客园 (cnblogs.com)\n贪心法 贪心算法原理及其应用 - vcjmhg - 博客园 (cnblogs.com)\n最小生成树 最小生成树 - SeanOcean - 博客园 (cnblogs.com)\n狄克斯特拉算法 Dijkstra算法(一)之 C语言详解 - 如果天空不死 - 博客园 (cnblogs.com)\n近似算法 算法课堂笔记6—近似算法 - f91og - 博客园 (cnblogs.com)\n高精度计算 高精度计算\nLRU算法 缓存淘汰算法\n长期不被使用的数据，在未来被用到的几率也不大。如果缓存到达了预设值就要删除一些内容，给新的内容腾位置\n如何实现LRU算法？ - murphy_gb - 博客园 (cnblogs.com)\nA星寻路算法 A星寻路算法 - szmtjs10 - 博客园 (cnblogs.com)\nA星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com)\nA-Star（A*）寻路算法原理与实现 - 知乎 (zhihu.com)\n","date":"2022-01-01T19:32:29Z","permalink":"https://okokfun.github.io/post/%E7%AE%97%E6%B3%95/","title":"算法"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n设计模式描述：\n用特定的套路解决现实问题，每一个设计模式对应一个法子\n分类 根据意图或目的分类\n创建型模式: 提供创建对象机制，增加已有的代码灵活性和可复用性 结构型模式: 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 行为模式: 负责对象间的高效沟通和职责委派。 创建型模式 simple_factory_pattern(简单工厂) Factory Method(工厂方法) 在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n要解决的问题：\n当增加一个新类，和其他类低耦合\n解决方案:\n增加一个子类的抽象类，所有的子类继承于抽象类，并且写父类的实现\n#include \u0026lt;iostream\u0026gt; class product { public: virtual ~product() {} }; class phone : public product { public: phone() { std::cout \u0026lt;\u0026lt; \u0026#34;make phone\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class tv : public product { public: tv() { std::cout \u0026lt;\u0026lt; \u0026#34;make tv\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class factory { public: virtual ~factory() {} virtual product* make_product() = 0; }; class phone_factory : public factory { public: virtual product* make_product() { return new phone(); } }; class tv_factory : public factory { public: virtual product* make_product() { return new tv(); } }; int main() { factory* factory1 = new phone_factory(); product* product1 = factory1-\u0026gt;make_product(); factory* factory2 = new tv_factory(); product* product2 = factory2-\u0026gt;make_product(); delete factory1; delete product1; delete factory2; delete product2; return 0; } Abstract Factory(抽象工厂模式) 随着业务的发展，更多的类需要创建，比如美国工厂，欧洲工厂，亚洲工厂，南美工厂，每个地区工厂又需要创建各自的产品\n问题：\n每个地区生产的产品拥有一个风格，不同地区的产品混杂一起对顾客不友好\n保持核心代码不修改。\n解决：\n首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如phone、 tv）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 phone接口； 所有风格的咖啡桌都实现 tv接口， 以此类推。\n#include \u0026lt;iostream\u0026gt; // 食草动物. class herbivore { public: virtual ~herbivore() {} }; // 食肉动物. class carnivore { public: virtual ~carnivore() {} virtual void eat(herbivore* h) = 0; }; // 角马. class wildebeest : public herbivore { }; // 野牛. class bison : public herbivore { }; // 狮子. class lion : public carnivore { public: void eat(herbivore*) { std::cout \u0026lt;\u0026lt; \u0026#34;lion eat wildebeest\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 狼. class wolf : public carnivore { public: void eat(herbivore*) { std::cout \u0026lt;\u0026lt; \u0026#34;wolf eat bison\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂. class factory { public: virtual ~factory() {} // 创建食草动物. virtual herbivore* create_herbivore() = 0; // 创建食肉动物. virtual carnivore* create_carnivore() = 0; }; // 非洲工厂. class africa_factory : public factory { public: virtual herbivore* create_herbivore() { return new wildebeest(); } virtual carnivore* create_carnivore() { return new lion(); } }; // 美洲工厂. class america_factory : public factory { public: virtual herbivore* create_herbivore() { return new bison(); } virtual carnivore* create_carnivore() { return new wolf(); } }; // 动物世界（客户端）. class animal_world { public: animal_world(factory* f) { _herbivore = f-\u0026gt;create_herbivore(); _carnivore = f-\u0026gt;create_carnivore(); } void start() { _carnivore-\u0026gt;eat(_herbivore); } private: herbivore* _herbivore; carnivore* _carnivore; }; int main() { factory* factory1 = new africa_factory(); animal_world* world1 = new animal_world(factory1); world1-\u0026gt;start(); factory* factory2 = new america_factory(); animal_world* world2 = new animal_world(factory2); world2-\u0026gt;start(); delete factory1; delete world1; delete factory2; delete world2; return 0; } singletonton_pattern(单例模式) 保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n问题：\n同时解决了两个问题, 但违反了单一职责原则\n解决：\n将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n#include \u0026lt;iostream\u0026gt; class singleton { public: singleton() = default; singleton(const singleton\u0026amp;) = delete; singleton\u0026amp; operator=(const singleton\u0026amp;) = delete; static singleton\u0026amp; get_instance() { static singleton s; return s; } void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { singleton::get_instance().print(); singleton::get_instance().print(); return 0; } prototype_pattern(原型模式) 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n问题：\n如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。\n不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。\n直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。\n解决：\n原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。\n所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。\n支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。\n其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。\n可以类比有丝分裂：由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // #include \u0026lt;vector\u0026gt; class resume { public: resume() {} virtual ~resume() {} virtual resume* clone() { return nullptr; } virtual void set(char*) {} virtual void show() {} protected: char* _name = nullptr; }; class resume_a : public resume { public: resume_a(const char* str) { if (str == nullptr) { _name = new char[1]; _name[0] = \u0026#39;\\0\u0026#39;; } else { _name = new char[strlen(str) + 1]; strcpy(_name, str); } } ~resume_a() { if (_name != nullptr) { delete [] _name; _name = nullptr; } } resume_a(const resume_a\u0026amp; other) { if (_name != nullptr) { delete [] _name; _name = nullptr; } _name = new char[strlen(other._name) + 1]; strcpy(_name, other._name); } virtual resume_a* clone() { return new resume_a(*this); } virtual void show() { std::cout \u0026lt;\u0026lt; \u0026#34;resume_a name: \u0026#34; \u0026lt;\u0026lt; _name \u0026lt;\u0026lt; std::endl; } }; int main() { resume* r1 = new resume_a(\u0026#34;A\u0026#34;); resume* r2 = r1-\u0026gt;clone(); r1-\u0026gt;show(); delete r1; r2-\u0026gt;show(); delete r2; return 0; } builder_pattern(生成器模式) 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n问题：\n假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。 例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？\n最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。\n另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。 通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。\n解决：\n生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。 该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。\n当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。\n在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。\n例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。 主管 你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。\n严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。\n此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 产品. class product { public: void add(const std::string\u0026amp; product_name) { _product_name_vec.emplace_back(product_name); } void show() { for (auto\u0026amp; name : _product_name_vec) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } } private: std::vector\u0026lt;std::string\u0026gt; _product_name_vec; }; // 抽象建造者. class builder { public: virtual ~builder() {} virtual void build_ricenoodles() = 0; virtual void build_cooldish() = 0; virtual void build_drink() = 0; virtual product* get_product() = 0; }; // 建造者A. class builder_a : public builder { public: builder_a() { _product = new product; } ~builder_a() { delete _product; } virtual void build_ricenoodles() { _product-\u0026gt;add(\u0026#34;ricenoodles a\u0026#34;); } virtual void build_cooldish() { _product-\u0026gt;add(\u0026#34;cooldish a\u0026#34;); } virtual void build_drink() { _product-\u0026gt;add(\u0026#34;drink a\u0026#34;); } virtual product* get_product() { return _product; } private: product* _product; }; // 导演. class director { public: void construct(builder* b) { b-\u0026gt;build_ricenoodles(); b-\u0026gt;build_cooldish(); b-\u0026gt;build_drink(); } }; int main() { director* d = new director(); builder* b = new builder_a(); d-\u0026gt;construct(b); product* p = b-\u0026gt;get_product(); p-\u0026gt;show(); delete b; delete d; return 0; } ","date":"2021-12-27T13:48:06Z","permalink":"https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-创建型模式"},{"content":" GDB是是 Linux 平台下最常用的一款程序调试器，通常服务于终端下，无GUI。Linux下很多IDE的调试能力源于GDB调试器\n1. Linux下安装二进制版GDB调试器 centos下命令：\nsudo yum -y install gdb Ubuntu下安装命令：\nsudo apt -y install gdb 2. 源码安装下载： sudo wget http://ftp.gnu.org/gnu/gdb/gdb-11.1.tar.xz 解压：\ntar -zxvf gdb-11.1.tar.xz 进入源码目录安装：\n./configure make sudo make install 3. 调试准备 GDB supports the following languages (in alphabetical order):\nAda Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust 只是为了调试代码需要在编译时加入：-g参数，关掉编译器优化参数：-O0，打开所有 warning：-Wall 4. GDB的启动与退出 启动gdb调试 gdb 可执行程序文件名\n(gdb) gdb app 退出调试\nquit = q (gdb) q 命令行传参:show args 设置的时机: 启动gdb之后, 在应用程序启动之前\n(gdb) set args 参数1 参数2 …. … 查看设置的命令行参数\n(gdb) show args 例子： 非gdb调试命令行传参\nargc 参数总个数，argv[0] == ./app， argv[1] == \u0026#34;11\u0026#34; argv[2] == \u0026#34;22\u0026#34; argv[3] == \u0026#34;33\u0026#34; argv[4] == \u0026#34;44\u0026#34; argv[5] == \u0026#34;55\u0026#34; ./app 11 22 33 44 55 使用 gdb 调试\ngdb app (gdb) set args 11 22 33 44 55 查看设置的命令行参数\n(gdb) show args Argument list to give program being debugged when it is started is \u0026#34;11 22 33 44 55\u0026#34;. gdb 中启动程序 run: 缩写为 r,停在第一个断点的位置，如果没有设置断点，程序就执行完了 start: 启动程序，阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令\n例子：\n\u0026gt;# 两种方式 # 方式1: run == r (gdb) run (如果有断点会停在断点处) # 方式2: start (会停在main函数处) (gdb) start 继续运行：\n# quit == q (gdb) qui 5. 查看代码 查看代码的命令叫做 list 可以缩写为 l，此命令可以通过行号，函数名查看，也可以查看不同文件的信息\n如果不切换文件会停在main函数所在文件\n当前文件 从第一行开始显示 (gdb) l 默认只显示10行内容，上下文 (gdb) l 行号 显示这个函数的上下文内容, 默认显示10行 (gdb) l 函数名 切换文件 切到指定文件行号处，默认显示10行 (gdb) l 文件名:行号 切到指定文件函数处，默认显示10行 (gdb) l 文件名:函数名 设置默认显示的行数 # 以下两个命令中的 listsize 都可以写成 list (gdb) set listsize 行数 # 查看当前list一次显示的行数 (gdb) show listsize 6.断点操作 设置断点 断点设置有两个方式：常规断点：程序只要运行到这个位置就会被阻塞\n条件断点：条件被满足了程序才会在断点处阻塞。\n当前文件： # 在当前文件的某一行上设置断点 # break == b (gdb) b 行号 (gdb) b 函数名\t# 停止在函数的第一行 非当前文件： # 在非当前文件的某一行上设置断点 (gdb) b 文件名:行号 (gdb) b 文件名:函数名\t# 停止在函数的第一行 设置条件断点 # 必须要满足某个条件, 程序才会停在这个断点的位置上 # 通常情况下, 在循环中条件断点用的比较多 (gdb) b 行数 if 变量名==某个值 查看断点 # 查看设置的断点信息 (gdb) i b #info break # 举例 (gdb) i b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400cb5 in main() at test.cpp:12 2 breakpoint keep y 0x0000000000400cbd in main() at test.cpp:13 3 breakpoint keep y 0x0000000000400cec in main() at test.cpp:18 4 breakpoint keep y 0x00000000004009a5 in insertionSort(int*, int) at insert.cpp:8 5 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 6 breakpoint keep y 0x00000000004009e5 in insertionSort(int*, int) at insert.cpp:16 需要关注的点：\nNum: 断点的编号，删除断点或者设置断点状态的时候都需要使用 Enb: 当前断点的状态，y 表示断点可用，n 表示断点不可用 What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上 删除断点 # 需要 info b 查看断点的信息, 第一列就是编号 (gdb) d 断点的编号1 \u0026amp;#091;断点编号2 ...] # 举例: (gdb) d 1 # 删除第1个断点 (gdb) d 2 4 6 # 删除第2,4,6个断点 # 删除一个范围, 断点编号 num1 - numN 是一个连续区间 (gdb) d num1-numN # 举例, 删除第1到第5个断点 (gdb) d 1-5 设置断点状态 断点无效化 dis 断点编号 dis 断点1编号-断点n编号 断点无效化例子：\n# 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep y 0x0000000000400d7d in main() at test.cpp:30 # 设置第2, 第4 个断点无效 (gdb) dis 2 4 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep y 0x0000000000400d7d in main() at test.cpp:30 # 设置 第5,6,7,8个 断点无效 (gdb) dis 5-8 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 让无效的断点生效 # enable == ena # 设置某一个或者某几个断点有效 (gdb) ena 断点1的编号 \u0026amp;#091;断点2的编号 ...] # 设置某个区间断点有效 (gdb) ena 断点1编号-断点n编号 有效化例子：\n# 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 # 设置第2, 第4个断点有效 (gdb) ena 2 4 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 # 设置第5,6,7个断点有效 (gdb) ena 5-7 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 7.调试命令 继续运行 gdb # cont = continue (gdb) cont = continue 手动打印信息 当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。\n打印变量值 print 命令的语法格式如下:\n# print == p (gdb) p 变量名 # 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表 (gdb) p/fmt 变量名 例子：\n# 举例 (gdb) p i # 10进制 $5 = 3 (gdb) p/x i # 16进制 $6 = 0x3 (gdb) p/o i # 8进制 $7 = 03 打印变量类型 查看某个变量的类型\n(gdb) ptype 变量名 例子：\n# 打印变量类型 (gdb) ptype i type = int (gdb) ptype array\u0026amp;#091;i] type = int (gdb) ptype array type = int \u0026amp;#091;12] 自动打印信息 设置变量名自动显示 频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式\n# 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示) (gdb) display 变量名 # 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令 (gdb) display/fmt 变量名 查看自动显示列表 # info == i (gdb) info display Auto-display expressions now in effect: Num Enb Expression 1: y i 2: y array\u0026amp;#091;i] 3: y /x array\u0026amp;#091;i] 在展示出的信息中，每个列的含义如下:\nNum : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号 Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。 Expression ：被自动打印值的变量或表达式的名字。 取消自动显示 对于不需要再打印值的变量或表达式，可以将其删除或者禁用。\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) undisplay num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) undisplay num1-numN (gdb) delete display num \u0026amp;#091;num1 ...] (gdb) delete display num1-numN\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 例子：\n# 查看显示列表 (gdb) info display Auto-display expressions now in effect: Num Enb Expression 1: y i 2: y array\u0026amp;#091;i] 3: y /x array\u0026amp;#091;i] # 删除变量显示, 需要使用 info display 得到的变量/表达式编号 (gdb) undisplay 1 2 # 查看显示列表, 只剩下一个了 (gdb) i display Auto-display expressions now in effect: Num Enb Expression 3: y /x array\u0026amp;#091;i] 禁用自动显示列表中处于激活状态下的变量或表达式\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) disable display num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) disable display num1-numN 当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) enable display num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) disable display num1-numN 单步调试 当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:\nstep step 命令可以缩写为 s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。\n# 从当前代码行位置, 一次调试当前行下的每一行代码 # step == s # 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部 (gdb) step finish 作用：跳出函数体，函数体内不能有有效断点\n# 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体 (gdb) finish next 作用：和step相似，但不会进入函数体内部\n# next == n # 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部 (gdb) next until until作用：直接跳出某个循环体 循环体内部不能有有效的断点，必须要在循环体的开始 / 结束行执行该命令\n(gdb) until 设置变量值 set var 变量名=值\n设置某个变量的值\n","date":"2021-12-26T16:46:38Z","permalink":"https://okokfun.github.io/post/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","title":"gdb代码调试工具"},{"content":" 1.点击home,再点击配置，然后填写nas的ip地址即可 ","date":"2021-12-26T13:43:29Z","permalink":"https://okokfun.github.io/post/%E4%BB%8Eportainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/","title":"从Portainer点击端口号进入容器服务方法"},{"content":" 1. 安装完第三方插件后，再安装docker与portainer 2. 点击Opem Portainer创建管理账号 3. 然后创建一个容器网络 ","date":"2021-12-26T13:42:29Z","permalink":"https://okokfun.github.io/post/openmediavault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8Egui%E5%B7%A5%E5%85%B7portainer/","title":"OpenMediaVault中docker与工具portainer"},{"content":" OpenMediaVault 国内软件源镜像服务器\n清华大学镜像 https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/ 北京外国语大学镜像 https://mirrors.bfsu.edu.cn/OpenMediaVault/ OMV 5\n一、编辑 sources.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list\u0026#39; 3. 编辑配置文件\nsudo nano /etc/apt/sources.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free 二、编辑 openmediavault-kernel-backports.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list.d/openmediavault-kernel-backports.list /etc/apt/sources.list.d/openmediavault-kernel-backports.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault-kernel-backports.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault-kernel-backports.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian buster-backports main contrib non-free 三、编辑 openmediavault.list 1. 备份配置文件 sudo cp /etc/apt/sources.list.d/openmediavault.list /etc/apt/sources.list.d/openmediavault.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/public/ usul main 四、编辑 omvextras.list\n1. 备份配置文件 sudo cp /etc/apt/sources.list.d/omvextras.list /etc/apt/sources.list.d/omvextras.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/omvextras.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/omvextras.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers usul main deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable deb http://linux.teamviewer.com/deb stable main 五. 刷新软件源 sudo apt update ","date":"2021-12-26T13:42:29Z","permalink":"https://okokfun.github.io/post/openmediavault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/","title":"OpenMediaVault软件源修改"},{"content":" 要创建的容器有：\nMariadb: 关系型数据库，mysql的开源版本\rAdminer：开源的数据库管理软件\rGitea：开源的私人代码版本管理器\rFlarum：开源的论坛\rWordPress：开源的博客软件\rNextCloud：开源的私人网盘软件\r1.在一个分区上创建我们需要的文件夹存放配置文件 2.在终端拉取上面的各个镜像文件 1.flarum docker pull mondedie/flarum:latest\r2.wordpress docker pull wordpress\r3.adminer docker pull adminer\r4.mariadb docker pull mariadb\r5.gitea docker pull gitea/gitea\r6.nextcloud docker pull nextcloud\r3.创建各个容器 按顺序应该创建数据库软件与数据库管理软件 1.mariadb容器创建参考 container_name: mariadb\renvironment:\r- PUID=1000\r- PGID=1000\r- MYSQL_ROOT_PASSWORD=1\r- TZ=Asia/Shanghai\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/mariadb/config:/config\rports:\r- 3306:3306\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r2.adminer创建参考 container_name: adminer\renvironment:\r- ADMINER_DEFAULT_SERVER=mariadb\rports:\r- 8080:8080\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.flarum创建参考 3.1在映射的flarum根目录创建docker-compose.yaml version: \u0026quot;3\u0026quot;\rservices:\rflarum:\rimage: mondedie/flarum:stable\rcontainer_name: flarum\renv_file:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/flarum.env\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/assets:/flarum/app/public/assets\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/extensions:/flarum/app/extensions\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/nginx:/etc/nginx/flarum\r- /mnt/docker/flarum/storage/logs:/flarum/app/storage/logs\rports:\r- 8081:8888\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.2再创建flarum.env DEBUG=false\rFORUM_URL=http://192.168.1.105:8081\r# Database configuration\rDB_HOST=mariadb\rDB_NAME=flarum\rDB_USER=flarum\rDB_PASS=123456789\rDB_PREF=flarum_\rDB_PORT=3306\r# User admin flarum (environment variable for first installation)\r# /!\\ admin password must contain at least 8 characters /!\\\rFLARUM_ADMIN_USER=admin\rFLARUM_ADMIN_PASS=123456789\rFLARUM_ADMIN_MAIL=txt1994s@163.com\rFLARUM_TITLE=txt1994的论坛\r登录adminer,然后创建数据库\nDB_HOST=mariadb (地址)\rDB_NAME=flarum (数据库)\rDB_USER=flarum （用户）\rDB_PASS=123456789（密码）\r然后运行命令：\ndocker-compose up -d flarum\r安装中文插件\n=Beta 14\ndocker exec -ti flarum extension require ffans/lang-simplified-chinese\n安装emoji表情插件 docker exec -ti flarum extension require clarkwinkelmann/flarum-ext-emojionearea\n安装显示帖子阅读次数 docker exec -ti flarum extension require michaelbelgium/flarum-discussion-views\n安装flarum媒体增强插件 docker exec -ti flarum extension require fof/formatting\n表格支持插件\ndocker exec -ti flarum extension require askvortsov/flarum-markdown-tables\n代码高亮\ndocker exec -ti flarum extension require therealsujitk/flarum-ext-hljs\n4.gitea创建参考 container_name: gitea\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/gitea/data:/data\rports:\r- \u0026quot;3000:3000\u0026quot;\r- \u0026quot;2222:22\u0026quot;\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建数据库：\r- MYSQL_ROOT_PASSWORD=1\r- MYSQL_DATABASE=gitea\r- MYSQL_USER=gitea\r- MYSQL_PASSWORD=123456789\r5.wordpress创建参考 container_name: wordpress\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/wordpress/html:/var/www/html\rports:\r- 8082:80\renvironment:\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建好数据库：\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\r6.nextcloud创建参考 container_name: nextcloud\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/nextcloud/html:/var/www/html\rports:\r- 8083:80 networks:\r- mynet restart: always\r创建好数据库：\renvironment:\r- MYSQL_PASSWORD=123456789\r- MYSQL_DATABASE=nextcloud\r- MYSQL_USER=nextcloud\r- MYSQL_HOST=mariadb ","date":"2021-12-26T13:41:29Z","permalink":"https://okokfun.github.io/post/openmediavault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/","title":"OpenMediaVault创建容器"},{"content":" OpenMediaVault（omv）是开源的nas系统，本博客尽量采用开源的代码和软件\n1. 镜像下载 下载地址\nhttps://sourceforge.net/projects/openmediavault/files/latest/download 2. 刻录或虚拟机安装 可以用etcher软件刻录镜像\n安装 omv-extras 启用 OMV 5 社区插件支持 3. 安装依赖的工具 sudo apt --yes --no-install-recommends install dirmngr gnupg 4. 下载最新的omv-extras 安装包 地址：https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 下载命令：sudo wget https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 5. 安装 sudo dpkg -i openmediavault-omvextrasorg_5.6.2_all.deb 6. 安装完开启docker扩展源 7. Docker修改镜像源并在OMV 中的安装和使用 Docker 设置国内镜像服务器\n第一步 创建 docker 配置文件目录 sudo mkdir /etc/docker 第二步 创建 daemon.json 配置文件 sudo touch /etc/docker/daemon.json 第三步 编辑配置文件 sudo nano /etc/docker/daemon.json 在编辑器中粘贴以下内容: { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.baidubce.com\u0026#34; ] } 第四步 重启 docker 服务 sudo systemctl daemon-reload sudo systemctl restart docker 检查设置是否生效\nsudo docker info 如果生效返回的信息类似下面这样\nRegistry Mirrors: https://hub-mirror.c.163.com/ ","date":"2021-12-26T13:39:29Z","permalink":"https://okokfun.github.io/post/openmediavault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/","title":"OpenMediaVault安装与初步设置"},{"content":" 开源 C++ 库列表 \u0026lt; cpp‎ | links\n此页面的目的是构建开源 C++ 库的比较列表，使得人们在需要特定功能的实现时，不必浪费时间在网上（ DuckDuckGo 、谷歌、必应等）搜索。\n若你知道可能对其他人有用的库，请在此添加到它的链接。能包含进来的库没有限制，但是必须能便捷地下载库的源码。\n以“原态”提供此页面——希望这有用，但不提供任何担保。过时、误导或错误的链接可能出现于此。若你注意到这些错误，则改正它会很有意义。\n包管理器 Package manager Description build2 一个开源的 (MIT)、跨平台的构建工具链，旨在为开发和打包 C/C++ 项目时提供如 Rust Cargo 一样的便利性。 cget Cmake 包检索工具，可用于下载并安装 Cmake 包。 cmodule 非侵入式 CMake 依赖管理。 conan 去中心化、开源 (MIT) 的 C/C++ 包管理器。 CPM.cmake 一段可以为 CMake 加入依赖管理功能的 CMake 脚本。它是作为 CMake 的 FetchContent 模块的一个简单包装构建的。该模块加入了版本控制、缓存、简单 API 等功能。 hunter 一个 CMake 驱动的跨平台包管理器，服务于 C/C++ 项目。 spack 一个超级计算机、Linux、macOS 平台的包管理器。它使得安装科学软件变得简单。非绑定于某一特定语言。 teaport 一个受 cocoapods 启发的依赖管理器。 vcpkg 一个 Windows、Linux、macOS 平台的 C++ 包管理器。 库 音频 库名 简述 协议 配置手段 Aquila Aquila 是一个开源、跨平台的 C++11 DSP 库。 MIT 许可 CMake Essentia 开源库，音频和音乐分析、描述和合成工具 (MIR) (源码) Affero GPLv3 FFTW 离散傅里叶变换 (DFT) 计算库 (SSE/SSE2/AVX/Altivec/ARM Neon)。 (源码) GPL-2.0 CMake KFR 快速、现代、C++17、开源并且跨平台的 DSP/DFT 框架。支持音频重采样、 FIR/IIR 滤波器、二阶滤波器, (SSE, AVX, AVX-512, ARM NEON)。 (源码) GPL-2.0 CMake soundtouch SoundTouch 是一个开源、跨平台的音频处理库，用于更改音频流或音频文件的速度、音调和播放速率。 (源码) LGPL-2.1 Makefile 音频指纹 库名 简述 协议 配置手段 chromaprint (源码) MIT 许可, LGPL 2.1 CMake libmusicbrainz (源码) LGPL-2.1 CMake libofa MusicIP 开源音频指纹库 APL makefile 格式 库名 简述 协议 配置手段 audiofile LGPL-2.1 makefile flac Open Source, BSD 许可, GPL 许可 libsndfile LGPL v2.0 or v3.0 标签 库名 简述 协议 配置手段 id3lib LGPL v2 taglib (源码) LGPL 和 MPL v1.1 CD 库名 简述 协议 配置手段 libkcompactdisc CD 接口库 GPL v2.0 CMake 性能测试 库名 简述 协议 配置手段 benchmark Apache2.0 许可 CMake Celero Apache 许可 CMake gperftools “谷歌性能工具”包含高性能、多线程的 malloc 实现加上评测堆分配和 CPU 利用的工具。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License configure plf::nanotimer 用于性能评测的最低开销、跨平台的简单定时器类。 zlib 许可 通信 库名 简述 协议 配置手段 ACE 异步网络、多路分离、报文发送 Apache Thrift Apache Thrift 软件框架，用于规模可变的跨语言服务开发，将软件栈与代码生成引擎结合，构建有效而无缝地在 C++ 、 Java 、 Python 、 PHP 、 Ruby 、 Erlang 、 Perl 、 Haskell 、 C# 、 Cocoa 、 JavaScript 、 Node.js 、 Smalltalk 、 Ocaml 、 Delphi 及其他语言间工作的服务。 Boost.Asio 异步及同步网络、定时器、序列 I/O BSL-1.0 Boost.Beast 建立于 Boost.Asio 顶上的 HTTP 及 WebSocket 库 BSL-1.0 Breep 基于事件、高层、点对点库，允许用户直接发送和接收对象。 European Union Public License 1.1 CMake C++ REST SDK 异步 HTTP 客户端及监听器、异步 Stream 、 URI 、 JSON MIT 许可 CMake cpp-netlib cpp-netlib ： C++ 网络库 BSL-1.0 CMake cpr 现代 C++ HTTP 请求库 MIT 许可 CMake Crow BSD-3-Clause CMake curlpp CURL 库的 C++ 包装 DumaisLib MIT 许可 Makefile EasyHttp 跨平台的 HTTP 客户端库，专注于可用性和速度，支持 http 响应缓存及更多 MIT 许可 CMake eCAL 高性能进程间通信 Apache2.0 许可 CMake fineftp-server MIT 许可 CMake gRPC gsoap XML 数据绑定、快速 WSDL/SOAP/XML 网络服务、 WS 安全、 JSON/XML-RPC RESTful 服务的 C/C++ 开发工具套 HTTPP 简单、生产就绪的构建在 Boost 上的 HTTP 服务器，及构建在 libcurl 上的客户端。 BSD 2-Clause \u0026ldquo;Simplified\u0026rdquo; License CMake, Makefile IXWebSocket 无依赖的开源 WebSocket + HTTP 库，支持 SSL 和逐条消息 deflate 的 WebSocket 扩展。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake, Makefile KCP 快速可靠的 ARQ 协议，帮助应用减少网络延迟。 MIT 许可 CMake libashttp 异步 HTTP 客户端库 GNU Lesser General Public License v3.0 libnavajo CeCILL-C FREE SOFTWARE LICENSE AGREEMENT CMake libtins 网络包装制作及嗅探库 nanomsg netif BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake nghttp2 HTTP/2 C 库及工具（服务器、客户端、代理和评测工具） MIT 许可 CMake, configure ngrest 快速而简易的利用 JSON 的 RESTful 网络服务框架 Apache2.0 许可 CMake nng omniORB 最快速、完整而可移植的 CORBA ORB 在 C++ 中的实现 OpenDDS DDS 实现 Paho MQTT CMake PcapPlusPlus 多平台 C++ 网络嗅探和包装分析及制作框架 POCO 网络：加密、 HTTP ； ZIP 文件 rest_rpc 现代、简单、易用的 rpc 框架 CMake restbed 设计以嵌入到宽范围的应用中的 C++ 为框架。 许可协议 CMake restc-cpp 将痛苦从自 C++ 访问 JSON API 带走。 HTTP 客户端，原生 C++ 类到/自 JSON 的序列化，通过 boost::asio coroutines 携程的异步 IO 。 C++14 。 MIT 许可 CMake restful_mapper 于 C++ 中消费 RESTful JSON API 的 ORM CMake, Makefile seastar 用C++11实现的高性能异步编程框架。 Apache2.0 许可 CMake, etc. Silicon 快速而稳健的 Web APIs MIT 许可 CMake sockpp 简单的现代 C++ 套接库 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake Simple C++ REST library 在你的 C++ 应用中创建 REST API 的非常简单且自成文档的库 stream-client 轻量、唯头文件的、基于 Boost 的客户端 socket/connector/socket pool/resolver Apache2.0 许可 CMake tacopie C++11 TCP 库 MIT 许可 CMake TAO CORBA taox11 基于 C++11 的 CORBA 实现 MIT 许可 Unicomm 异步网络、高层 TCP 交互框架 uvw 现代 C++ 书写的 libuv MIT 许可 CMake wvstreams GPL 许可 zeromq 快速消息队列 并发 库名 简述 协议 配置手段 BlockingCollection C++11 线程安全汇集类，模仿 .Net BlockingCollection。 Boost.Atomic BSL-1.0 Boost.Compute （非官方） OpenCL 的仿 STL 算法及数据结构 BSL-1.0 Boost.Context BSL-1.0 Boost.Interprocess BSL-1.0 Boost.Lockfree BSL-1.0 Boost.MPI BSL-1.0 Boost.Thread BSL-1.0 Cpp-Taskflow 带任务依赖的快速 C++ 并行编程 hipSYCL BSD-2-Clause License CMake HPX 任何规模的并行和分布式应用的通用 C++ 运行时系统 Intel TBB KOKKOS C++ 中的编程模型，用于书写高性能的便携 HPC 应用 libopenmpi libsimdpp MutexGear The MutexGear Library License configure, MSVC OpenMP RaftLib 类似并发行动者的 C++ 流 SObjectizer 通过行动者和出版订阅模型，简化开发并发和事件驱动应用的 C++ 中的小型框架。 subprocess Taskflow Thrust CUDA 的仿 STL 算法及数据结构 VexCL OpenCL 和 CUDA 的 C++ 表达式模板库 ViennaCL 带 OpenMP 、 CUDA 及 OpenCL 后端的线性代数及算法 Xenium 配置 库名 简述 协议 配置手段 Boost.Program_options BSL-1.0 gconfmm libconfig libconfini INI 分析器 XML 库名 简述 协议 配置手段 ai-xml GPDS gSOAP XML 数据绑定 libxml++ pugixml tinyxml tinyxml2 另一 TinyXML ，建设中。 Xerces JSON 库名 简述 协议 配置手段 ArduinoJson ArduinoJson CAJUN jansson Jansson 是编码、解码及操纵 JSON 数据的 C 库。 jeayeson 非常健全的（唯头文件） C++14 JSON 库 jios JSON 输入输出流 (JSON Input Output Streams) MIT 许可 CMake JOST JSON Voorhees C++ 的杀手 JSON json Niels Lohmann JSON json-cpp json11 json11 是 C++11 的轻量 JSON 库，提供 JSON 分析及序列化。 JsonBox jsoncons JSON 与类 JSON 数据结构的唯头文件库，含 JSON Pointer 、 JSON Patch 、 JSONPath 、 CSV 、 MessagePack 、 CBOR 、 BSON 、 UBJSON。 jsoncpp jsonme\u0026ndash; libjson minijson C++ 无 DOM 且免分配的 JSON 分析及序列化 nosjob qjson rapidjson simdjson 每秒解析 GB 级别的 JSON struct_mapping ThorsSerializer JSON/YAML Input Output Streams MIT 许可 Makefile ujson µjson 是小型的 C++11、UTF-8 JSON 库 zoolib meojson json简单库，作者MistEo MIT许可 Cmake, Makefile YAML 库名 简述 协议 配置手段 yaml-cpp TOML 库名 简述 协议 配置手段 toml++ toml11 基于 C++11 的 TOML 解析库 HOCON 库名 简述 协议 配置手段 cpp-hocon Pupplet 开发的 HOCON 格式的 C++ 实现。 CSS 库名 简述 协议 配置手段 mycss CSS 解析器 容器 库名 简述 协议 配置手段 Boost.Bimap BSL-1.0 Boost.Container BSL-1.0 Boost.Fusion BSL-1.0 Boost.Heap BSL-1.0 Boost.Pointer Container BSL-1.0 Boost.Tuple BSL-1.0 Boost.Variant BSL-1.0 cpp-btree btree_map 、 btree_set 、 btree_multimap 、 btree_multiset 。 DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 eggs::variant Eggs.Variant 是 C++11/14 的泛型、线程安全、有区别的联合体。值得注意的是它有很好的 constexpr 支持。 Frozen constexpr 完美基于哈希的冻结集合与映射（ Apache 2.0 ）。 Immer Boost License CMake plf::colony 无序的“类背包”容器，在高度修改场景中性能优于 std:: 容器，同时维护指向未被擦除元素的合法指针，无关乎插入或擦除。 plf::list std::list 实现，为缓存友好牺牲范围切割，导致更快的插入、擦除和迭代。 plf::stack std::stack 容器适配器的随意访问替换容器，在栈环境中有优于 std::vector 和 std::deque 的性能。 ring_span Guy Davidson 与 Arthur O\u0026rsquo;Dwyer 的 ring_span ——即环状缓冲区视图的简化实现。 strict_variant 快速而决不空的 variant ，目标 C++11 。阻止许多不想要的隐式转换。 TdhLists Ygg 高性能容器和数据结构，例如红黑树、区间数和区间映射的侵入式 C++11 实现。 密码学 库名 简述 协议 配置手段 Botan crypto++ gnutls openssl TomCrypt 数据库 库名 简述 协议 配置手段 redis-plus-plus 用C++ 11编写的Redis客户端, 支持Redis Sentinel，Redis Cluster，管道，事务，发布订阅，连接池以及类似于STL的接口 cpp-redis C++11 轻量的 Redis 客户端：异步、线程安全、无依赖、管道化、多平台。 OTL DTL libpqxx lmdb++ LMDB 嵌入式 B+ 树数据库的 C++11 包装。 mongocxx MongoDB 的 C++11 驱动库 mysql++ ODB - C++ Object-Relational Mapping (ORM) Pgfe - PostGres FrontEnd 现代 C++ 客户端 API 到 PostgreSQL QUINCE: QUeries IN C++ Expressions (ORM+EDSL) QxOrm - C++ Qt Object-Relational Mapping (ORM) SOCI sqlpp11 SQLAPI++ EasyQtSql 轻量唯头文件 C++11 库，用 QtSql 快速便捷地进行 SQL 查询 LevelDB 谷歌开发的、能够处理十亿级别规模 Key-Value 型数据持久性存储的C++ 程序库。 嵌入语言绑定 库名 简述 协议 配置手段 ChaiScript ExprTk lua sol2 AngelScript 类似 C++ 的脚本语言。 mozjs muparser PythonQt ScriptCaller 允许程序员调用 Ruby 脚本的唯头文件库。 v8pp 将 C++ 函数和类绑定到 V8 JavaScript引擎中。 嵌入式/实时 库名 简述 协议 配置手段 QP/C++ RTOS 内核，双重 GPL ETL - Embedded Template Library C++03 ，为少资源平台裁剪的可移植模板库 distortos 微控制器的面向对象 C++ RTOS µcuREST 微控制器的 C++11 REST/JSON 服务器框架 文件元数据 库名 简述 协议 配置手段 libkexiv2 exiv2 exempi rarian 金融计算 库名 简述 协议 配置手段 QuantLib - Quantitative finance library DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 游戏引擎架构 库名 简述 协议 配置手段 EntityX Anax EntityPlus EnTT BOX2D 物理引擎 通用多媒体 库名 简述 协议 配置手段 SFML (Simple and Fast Multimedia Library) SDL (Simple DirectMedia Layer) 对音频、键盘、鼠标、操纵杆及图形硬件，经由平台上图形 API （通常为 OpenGL 或 Direct3D ）的跨平台低层访问（ zlib 许可） SIGIL (Sound, Input, and Graphics Integration Library) 文本、形状、输入、音频及 2D 图像的难以置信地简单的跨平台极简库 Cinder openFrameworks 通用 库名 简述 协议 配置手段 Boost 大量通用库的汇集 Boost 许可 GSL Guideline Support Library 实现，为 Bjarne Stroustrup, Herb Sutter 和 Co 在《 C++ 核心方针》中推荐 BDE 来自 Bloomberg L.P. 的 Bloomberg Development Environment 核心库 Apache 许可 Dlib 网络、线程、图形用户界面、数据结构、线性代数、机器学习、 XML 及文本分析、数值优化、贝叶斯网络和大量其他任务 Boost 许可 JUCE 扩展性的成熟跨平台 C++ 工具套 GPL 许可 Loki 设计模式 Reason xml 、 xpath 、正则表达式、线程、接头、 http 、 sql 、日期时间、流、编码与解码、文件系统、压缩 GPL 许可 yomm2 C++17 的开放式多方法 Boost 许可 Folly Facebook 开源库。设计带有构思中的实践性和效率设计的 C++11 组件库。 Abseil Google 设计以补足 C++ 标准库的开源 C++ 库代码汇集。 cxxomfort C++ 特性逆向移植（ C++11 到 C++03 及 C++1y 提案到 C++11/C++03 ）。 libsourcey 高速网络化和多媒体编码的跨平台 C++11 库。 HTTP 、 WebSockets 、 TURN 、 STUN 、 Symple 及更多…… OnPosix 在 POSIX 平台上提供各种抽象（例如线程、网络化、日志、 IPC 等）的 C++ 库。 Ultimate++ 跨平台的迅速应用开发框架 CAF C++ Actor Framework (CAF) 是开源的 C++11 行动者模型实现，特性为轻量而快速的行动者实现、消息的模式匹配、网络不可见消息传递及更多 BSD 许可 cpp-mmf 对 POSIX 或 Windows 封装映射到内存文件的 C++98 库 CommonPP 多用途库，强调在项目中得出度规。 BSD Better Enums 反射性枚举（枚举到字符、迭代等），带 constexpr 支持。 BSD Smart Enum 给你的枚举 \u0026ldquo;to_string\u0026rdquo; 、 \u0026ldquo;from_string\u0026rdquo; 和更多。 Boost 许可 nytl 通用的 C++17 唯头文件模板库。 Boost 许可 SaferCPlusPlus SaferCPlusPlus - 不安全的 C++ 原始工具的安全兼容替换品，包括指针、 int 和 std::vector。 Boost 许可 fcppt Freundlich 的 C++ 工具套 (fcppt) 是聚焦于通过提供更好的类型和函数式编程改进 C++ 代码的库汇集。 bitfield.h 位域结构设施，比基础语言设施更可移植/灵活。 composite_op.h 基础类数据成员自省，繁琐且常常不可重入，但有时有用。 Abstract Intrusive Containers 比 boost::intrusive 更灵活，但非 STL 兼容。 Yato 现代 C++ (14/17) 的跨平台 STL 风格及 STL 兼容库，实现容器、范围、迭代器、类型特性和其他工具；行动者系统；类型安全配置接口 Apache-2.0 Kangaru C++11 与 C++14 的依赖注入容器 MIT 许可 yaal 算法、汇集、任意精度计算、泛型 DSL 文法驱动分析器及更多 CC BY-ND-NC 4.0 CMake gsl-lite C++98 、 C++11 及后续版本的 ISO C++ Guideline 支持库 (GSL) 的单文件唯头文件版本。 nonstd-lite *-lite 仓库的亲属，将 C++11 后特性移植到古代 C++ 环境的迁移路径。 units 编译时唯头文件的量纲分析及单位转换库，建立于 C++14 而无依赖。 GPS 库名 简述 协议 配置手段 gpsd 图形用户界面 库名 简述 协议 配置手段 Dear ImGui 高度优化的不膨胀的图形用户界面库。 FLTK nana 用现代 C++ 风格的 GUI 编程（ Boost 许可） nanogui 最小化的跨平台器件库，适用于 OpenGL 3.x 或更高版本 WxWidgets OWLNext 对 OWL 的，用于在 Windows 上以标准 C++ 书写 GUI 应用的现代更新 tiny file dialogs 单个 C C++ 跨平台文件（无初始化、无 main 循环、 6 种形态的函数调用） CopperSpice 库名 简述 协议 配置手段 CopperSpice CopperSpice 是用于开发跨平台软件应用的 C++ 库集合。它在 LGPL V2.1 许可下发布。它使用现代理念的 C++ 并与 STL 无缝结合。 CopperSpice 派生自 Qt 框架。 CsSignal 独立的 C++ 具线程信号/槽库 CsString 独立的 C++ 具 Unicode 字符串库 libGuarded 独立的 C++ 多线程库，用于管理对共享数据的访问 GTK+ 库名 简述 协议 配置手段 glibmm gtkmm goocanvasmm libglademm libgnomecanvasmm webkitgtk flowcanvas evince Qt 库名 简述 协议 配置手段 Qt qwtplot3d qwt5 技术应用到 Qt Widgets libdbusmenu-qt QuickQanava 直接在 Qt/QML 应用中画图的 C++14 库；项目主页： http://www.qanava.org QuickProperties QObject/QtObject 属性编辑的 C++/QML 库；项目主页： http://www.qanava.org 图形 库名 简述 协议 配置手段 cairomm nux pangomm nanovg 基于openGL/DX/metal的2d绘图库。 bgfx 非常强大的跨平台图形渲染库，支持平台包括 Windows Mac Linux iOS Android Web，渲染后端包括 DX, opengl, metal webgl等。 图像 库名 简述 协议 配置手段 gegl stb.image Adobe/boost GIL 高层通用库，聚焦于 2D 图像上操作的算法。非常有限定 I/O 选项。 GraphicsMagick 读、写、操纵 88 种主要格式的图像。于 2002 年分化自 ImageMagick Skia Graphics Engine Google 从 2005 年起的图形库，用于 Chrome 、 Chrome OS 、 Android 还有 Firefox 和 Sublime Text enwiki:Skia_Graphics_Engine Anti-Grain Evolution 跨平台 2D 光栅化及绘图引擎 打点 库名 简述 协议 配置手段 plotutils 格式 库名 简述 协议 配置手段 libraw openexr qimageblitz imagemagick djvulibre poppler SVG++ 3D 图形 库名 简述 协议 配置手段 Vulkan OpenGL bgfx 跨平台、不知图形 API 、“带来你自己的引擎/框架”风格的制图库。 Ogre3D Diligent Engine 现代跨平台低层 3D 图形库。 GLEW OpenGL 功能加载 GLAD 可定制的轻量库，用于加载 OpenGL 功能 Epoxy GLEM 的现代后继者。在 GL 环境的一些种类间抽象，这使得有时比使用 GLEW 更加单。自 2015 起为 GTK+ 项目所用。 GLFW OpenGL 窗口管理器 GLM 制图用的唯头文件 C++ 数学库 hlsl++ 使用 hlsl 语法的唯头文件 C++ 渲染库。支持 SSE 和 NEON assimp 3D 模型加载 VTK Magnum 游戏和数据可视化的轻量模块化的 C++11/C++14 图形中间件 Irrlicht Horde3D Visionaray C++ 光束追踪模板库 Open CASCADE 3D CAD/CAM/CAE 应用的 SDK OpenSceneGraph 图像处理 库名 简述 协议 配置手段 opencv dlib ITK OTB 国际化 库名 简述 协议 配置手段 IBM ICU gettext spirit-po 快速的唯头文件库，分析 po 文件，并提供类似 GNU libintl 的接口。基于 boost::spirit 。 记录 库名 简述 协议 配置手段 Log4cpp 用于灵活地记录到文件、系统日志、 IDSA 或其他目标的 C++ 类库 (LGPL) Log4cplus 日志 API ，提供日志管理及配置上的线程安全、灵活且有任意粒度的控制。 spdlog 超快的唯头文件 C++ 日志库 plog C++ 的可移植且简单的日志，少于 1000 行代码 (MPL2) Boost.Log glog Google 日志库 log4cxx Apache log4cxx 是 Apache log4j 后的 C++ 模式化记录框架 Pantheios 诊断日志 API 库，提供类型安全、效率、泛型和可扩展性的结合 Backward 打印漂亮的 Python 风格栈追踪，带颜色和源代码片段，特别是在崩溃时（ MIT 许可）。 数学 库名 简述 协议 配置手段 stats++ 先进、广泛的统计软件：数据收集及预处理、统计、机器学习及优化，拥有开放的 C++ 源码。 StatsLib 统计分布函数的模板化唯头文件库。 alglib ArrayFire High Performance Computation Library GNU MP bignum C++ interface BigNumber 创建和计算任意长度整数的 C++ 类 Boost.Multiprecision Boost.Math.Special Functions and Statistical Distributions Boost.Random NTL - A Library for doing Number Theory cpp-measures 处理物理度量的唯头文件 C++11 库 G+Smo 等几何分析的跨平台库 C++ Matrix 高性能且精确（例如极端情况）的矩阵数学库，带表达式模板算术运算符 Exact floating-point arithmetic library RPNX Uniform Smooth Noise N 维均匀分布的平滑噪声函数，以 C++ 实现。 数值计算 库名 简述 协议 配置手段 LibBF 由 Bellard 开发的任意精度数值计算库，拥有一个将圆周率计算到数十亿位的示例程序 线性代数 库名 简述 协议 配置手段 Boost.uBLAS Eigen Armadillo Blitz++ IT++ Dlib - linear algebra tools Blaze ETL DecompLib 唯头文件的 C++11 库，分解向量为正定加权基向量的集合。 优化 库名 简述 协议 配置手段 OptimLib 非线性函数数值优化方法的 C++11 库。 图论 库名 简述 协议 配置手段 Boost.Graph LEMON OGDF - Open Graph Drawing Framework NGraph - a simple (Network) Graph library in C++ GTpo C++14 泛型图拓扑库，带 Protocol Buffer 序列化；项目主页： http://www.qanava.org 数的类库 库名 简述 协议 配置手段 cln Universal 通用数算术的 C++ 模板库，取代 IEEE 浮点（ MIT 许可） 人工智能 库名 简述 协议 配置手段 stats++ liblinear Dlib 机器学习工具 MLPACK 机器学习包 Shogun 大规模机器学习工具箱 FANN 快速人工神经网络库 TensorFlow 面向所有人的开源机器学习框架 Paddle 并行化分布式深度学习库 DLDT OpenVINO™工具包-深度学习部署工具包 TensorRT 用于在 NVIDIA GPU 和深度学习加速器上进行高性能推理的 C++ 库 NCNN 腾讯开发的、针对移动平台进行了优化的高性能神经网络推理框架 OpenPose 实时多人关键点检测库，用于身体，面部，手和脚的检测 ANNetGPGPU 基于GPU（CUDA）的人工神经网络库。 btsk 游戏行为树入门套件。 Evolving Objects 基于模板的 C++ 演化计算库，可帮助您快速随意地编写自己的随机优化算法。 frugally-deep 仅头文件的库，用于在 C++ 中使用Keras模型。 Genann 简单神经网络库。 Recast/Detour 导航网格生成器和浏览器，主要用于游戏。 CNTK 微软认知工具包（CNTK），一种开源的深度学习工具包。 tiny-dnn 基于 C++11 的唯头文件、无依赖的深度学习框架。 Veles 用于快速深度学习应用程序开发的分布式平台。 Kaldi 语音识别工具包。 计算几何 库名 简述 协议 配置手段 CGAL 计算几何算法库 Wykobi 计算几何库 PCL 点云库 自动化理论 库名 简述 协议 配置手段 yasmine - C++11 UML state machine framework 元编程 库名 简述 协议 配置手段 Boost.MPL 原初元编程库，目标为 C++03 ，慢 Boost.Hana 类型与值的新元编程库 Boost.Mp11 Boost.CallableTraits Metal 使用饿元函数， 100% SFINAE 友好 Brigand 使用饿元函数，为最佳性能优化 Meta 使用饿元函数，在 metal 和 brigand 之间，相对于性能妥协 Boost.Metaparse 编译时分析器库，从编译时字符串产生类型、值和元函数 Boost.Proto 构建基于表达式模板的 EDSLs 的库 CoMeta 轻量、唯头文件的 C++14 元编程库 visit_struct 小规模反射库，提供 C++11 的结构体观察器。自容纳， 100-200 行代码，取决于如何计算。 PDF 库名 简述 协议 配置手段 HARU PoDoFo JagPDF 物理与模拟 库名 简述 协议 配置手段 ReactPhysics3D 进行 3D 模拟与游戏的 C++ 物理引擎 ProjectCHRONO 开源多物理模拟引擎 Bullet 游戏、视觉效果、机器人及加固学习的物理模拟 序列化 库名 简述 协议 配置手段 Boost.Serialization libs11n sweet_persist protobuf gSOAP 准确的 XML 序列化 ai-xml 通过添加单个最小的函数到类，在 XML 间序列化及反序列化。在底层使用 libxml++ 。 C++ XML objects YAS (Yet Another Serialization) yaml-cpp cereal (C++11 serialization) jios (JSON serialization) ThorsSerializer (JSON/YAML Input Output Streams) cppcodec 唯头文件库，编码/解码 base64 、 base32 和十六进制，有一致而灵活的 API （ MIT 许可） iguana (universal serialization engine) rpnx-serial 能（反）序列化如 std::map 、 std::vector 等类型的库 二进制序列化 库名 简述 协议 配置手段 UBjsonCpp 基于 C++14 的高性能 UBJson 读写库 binn 旨在紧凑，快速且易于使用的二进制序列化库，自身是同名格式的实现。 bson-cxx BSON 格式的 C++ 实现。 排序 库名 简述 协议 配置手段 Timsort 模板化的稳定排序函数，对于逆序或半排序的数据，性能优于基于快速排序的算法，包括 std::sort 。 (MIT) 终端 库名 简述 协议 配置手段 cwidget replxx readline 和 libedit 的替换品，支持 UTF-8 、语法高亮和提示。 测试 库名 简述 协议 配置手段 Boost.Test cppunit Google Test Catch2 doctest 单元测试和 TDD 使用的最轻量的特性丰富的 C++ 单头文件测试框架 lest 现代的 C++11 原生的单文件唯头文件的轻量单元测试、 TDD 和 BDD 框架（包含 C++98 变体）。 liblittletest 可移植，单个唯头文件的测试框架 ELFspy 杜绝假象和间谍的测试 - 仅 Linux xtd.tunit Windows 、 macOS 、 Linux 、 iOS 和 Android 上的现代 C++17 单元测试库。官方网站 bandit C++11 的对人类友好单元测试 文本 编码 库名 简述 协议 配置手段 uchardet 实现猜字符串编码的功能,和python里的uchardet功能基本一样。 win-iconv Linux 和 Mac 上的字符集编码转换库 iconv 的 Windows 实现，基于 Win32 字符集转换 API 实现。 格式化 库名 简述 协议 配置手段 fmt printf 不好用，ostream 也不好用，format 好用 分析 库名 简述 协议 配置手段 PEGTL 分析表达式文法的模板库 BNFlite 仅单个头文件的轻量文法分析器库 搜索 库名 简述 协议 配置手段 clucene xapian Step Ukkonen 的构建后缀树在线算法， Manber 的构建后缀数组算法。 模板引擎 库名 简述 协议 配置手段 inja 现代 C++ 的模板引擎 版本控制 库名 简述 协议 配置手段 LibGit2 版本控制系统 Git 的核心库。 cpp-semver 语义化版本号的 C++ 操作库。 视频 库名 简述 协议 配置手段 crystalhd mjpegtools libmatroska libVLC gstreamermm Web 库名 简述 协议 配置手段 libmusicbrainz5 liblastfm libkcddb Chromium Embedded QtWebApp Java Servlets 所启发的 HTTP(s) Server ，以 C++ 实现 Wt Tufão libhttpserver cpp-jwt oatpp 用于创建高性能网络服务的轻量零依赖框架 ","date":"2021-12-26T13:23:02Z","permalink":"https://okokfun.github.io/post/openlib-c/","title":"OpenLib-c++"},{"content":" Arch安装 一.准备工作 1.1下载镜像 地址：\n清华：https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/ 163:https://mirrors.163.com/archlinux/iso/latest/ 中科大：https://mirrors.ustc.edu.cn/archlinux/iso/latest/ 上海交通：https://mirror.sjtu.edu.cn/archlinux/iso/latest/ 北大：https://mirrors.pku.edu.cn/archlinux/iso/latest/ 本文是Arch官方文档的再次梳理版\nhttps://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 安装方法有很多种比如脚本，实体机，虚拟机\n本文采用虚拟机+SSH安装+UEFI，SSH方便复制命令\n二.安装 1.键盘布局,默认为us，不需要更改 2.验证引导模式 ls /sys/firmware/efi/efivars 结果无错误切有目录则是UEFI，反之是BIOS引导\n3.连接网络 ip link 用 ping 检查网络连接\nping archlinux.org 4.更新系统时间 timedatectl set-ntp true 可用 timedatectl status 检查服务状态\n5.建立硬盘分区 cfdisk比fdisk配置简单许多，因此本文采用cfdisk\ncfdisk -l cfdisk UEFI采用GPT分区，一般情况下需要创建\n挂载点 分区 分区类型 建议大小 /mnt/boot 或 /mnt/efi /dev/efi_system_partition（efi 系统分区） EFI 系统分区 至少 260 MiB [SWAP] /dev/swap_partition（交换空间分区） Linux swap (交换空间) 大于 512 MiB /mnt /dev/root_partition（根分区） Linux x86-64 根目录 (/) 剩余空间 文件系统 创建命令 工具 Archiso [1] 内核文档 [2] 说明 Btrfs mkfs.btrfs(8) btrfs-progs 是 btrfs.html 可靠性 VFAT mkfs.fat(8) dosfstools 是 vfat.html exFAT mkexfatfs(8) exfat-utils 是 N/A (FUSE-based) F2FS mkfs.f2fs(8) f2fs-tools 是 f2fs.html 基于闪存的设备 ext3 mke2fs(8) e2fsprogs 是 (base) ext3.html ext4 mke2fs(8) e2fsprogs 是 (base) ext4.txt HFS mkfs.hfsplus(8) hfsprogsAUR 否 hfs.html macOS (8.x-10.12.x) 文件系统 JFS mkfs.jfs(8) jfsutils 是 (base) jfs.txt NILFS2 mkfs.nilfs2(8) nilfs-utils 是 nilfs2.html NTFS mkfs.ntfs(8) ntfs-3g 是 N/A (FUSE-based) Windows 文件系统 Reiser4 mkfs.reiser4(8) reiser4progsAUR 否 ReiserFS mkfs.reiserfs(8) reiserfsprogs 是 (base) UDF mkfs.udf(8) udftools Optional udf.html XFS mkfs.xfs(8) xfsprogs 是 (base) xfs.txt xfs-delayed-logging-design.html xfs-self-describing-metadata.html ZFS zfs-linuxAUR 否 N/A (OpenZFS 移植) 本文创建俩分区：根分区和ESP分区，ESP分区300M，根分区剩余全部空间\n6.格式化上边创建的分区 mkfs.ext4 /dev/sda2 //根分区 mkfs.vfat /dev/sda1\t//ESP分区 7.挂载格式化后的分区 挂载有先后顺序， 先挂载根（root）分区（到 /mnt），再挂载引导（boot）分区（到 /mnt/boot 或 /mnt/efi ， 否则您可能遇到安装完成后无法启动系统的问题\nmount /dev/sda2 /mnt mkdir /mnt/efi mount /dev/sda1 /mnt/efi 8.更换软件源 curl -L -o /etc/pacman.d/mirrorlist \u0026#34;https://www.archlinux.org/mirrorlist/?country=CN\u0026#34; 编辑/etc/pacman.d/mirrorlist，反注释其中一个或多个链接\n本文采用中科大和清华源\nvim /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 9.安装系统到磁盘 基础包：\npacstrap /mnt base base-devel linux linux-firmware #base-devel在AUR包的安装是必须的 功能性软件 :\npacstrap /mnt vim nano ctags wget clang clangd gcc g++ cmake make git networkmanager dhcpcd iwd sudo bash-completion openssh #一个有线所需 一个无线所需 一个编辑器 一个提权工具 一个补全工具 iwd也需要dhcpcd 10.配置系统 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab 11.切换到新系统 arch-chroot /mnt 三.设置时区 本地时区配置\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 生成 /etc/adjtime\nhwclock --systohc --utc 本地化： 明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。\n需在这两个文件设置：locale.gen 与 locale.conf。\n编辑 /etc/locale.gen，然后取消掉 en_US.UTF-8 UTF-8，zh_CN.UTF-8 UTF-8 和其他需要的 地区 前的注释（#）。\n接着执行 locale-gen 以生成 locale 信息：\nlocale-gen 编辑： /etc/locale.conf\necho \u0026#39;LANG=en_US.UTF-8\u0026#39; \u0026gt; /etc/locale.conf 四.配置主机名 编辑/etc/hostname，写入myhostname 默认为archlinux\necho \u0026#34;archlinux\u0026#34; \u0026gt;\u0026gt; /etc/hostname 五.配置hosts 编辑/etc/hosts，把myhostname改为你自己的主机名\n127.0.0.1 localhost ::1 localhost 127.0.1.1 archlinux.localdomain archlinux 六.引导系统 1）Grub引导Windows或其他Linux pacman -S os-prober 2)\t主板支持UEFI引导 |安装微码 pacman -S intel-ucode #Intel pacman -S amd-ucode #AMD 2.1)\t下载grub安装时所必需的文件 pacman -S grub efibootmgr 2.2)\t安装grub grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB 编辑/etc/default/grub 文件，去掉GRUB_CMDLINE_LINUX_DEFAULT一行中最后的 quiet 参数，同时把 log level 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错。同时加入 nowatchdog 参数，这可以显著提高开关机速度\n2.3)\t更新grub grub-mkconfig -o /boot/grub/grub.cfg 七.\t用户设置 vim /etc/hostname #输入主机名，只能输入字母 passwd root #设置root密码 useradd -m -g users -G wheel -s /bin/bash username #添加用户 passwd username #设置用户密码 vim /etc/sudoers #为用户添加sudo权限 反注释%wheel ALL=(ALL) ALL #如果想在输入密码时显示星号，可以追加Defaults env_reset,pwfeedback 八.设置默认编辑器 ln -f /usr/bin/vim /usr/bin/vi 九.安装网络驱动 1）wifi pacman -S netctl iw wpa_supplicant dialog networkmanager pacman -S broadcom-wl #博通无线网卡驱动 2）有线连接dhcp pacman -S dhcp dhcpcd 十.退出chroot并重启 # 退出chroot exit # 卸载 /mnt umount -R /mnt # 重启电脑 reboot 注意 运行reboot命令后，请拔掉U盘 使用ssh或其他Linux发行版本安装的用户请在新系统中配置好ssh环境，重启后可以直接ssh连接（需要安装net-tools软件包，不然无法运行ifconfig命令）\n配置系统 （一）网络配置 1）Wi-Fi 最新版的arch可能没有wifi-menu命令\nsudo wifi-menu 2）dhcp 有线连接\nsudo systemctl enable --now dhcpcd 3) timezone 设置系统时区\nsudo timedatectl set-timezone Asia/Shanghai 4) set-ntp 网络时间同步\nsudo timedatectl set-ntp true 查看时间状态\ntimedatectl status 5) /etc/skel/.bashrc 编辑用户配置文件.bashrc以在终端显示文件夹，以颜色\ncd /etc/skel/ ls -la vim .bashrc 在PS1之前添加如下文本\nexport EDITOR=vim alias ls=\u0026#39;ls --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; [ ! -e ~/.dircolors ] \u0026amp;\u0026amp; eval $(dircolors -p \u0026gt; ~/.dircolors) [ -e /bin/dircolors ] \u0026amp;\u0026amp; eval $(dircolors -b \u0026gt; ~/.dircolors) 覆盖家目录的文件\ncp -a . ~ （二）安装驱动 1）显卡驱动 运行lspci | grep VGA查看显卡型号 按照自己的显卡型号安装相应驱动\n显卡 驱动名称 Intel xf86-video-intel vulkan-intel mesa NVIDIA nvidia nvidia-utils nvidia-settings opencl-nvidia lib32-opencl-nvidia lib32-nvidia-utils 开源NVIDIA(不推荐) xf86-video-nouveau AMD xf86-video-amdgpu xf86-video-ati mesa vulkan-radeom FBI Warning 千万不要安装nouveau，千万不要安装nouveau，千万不要安装nouveau！重要的事情说三遍。如果你不怕电脑莫名卡死，当我没说。（doge） ps：博主受过nouveau的折磨\n2）触摸板驱动 sudo pacman -S xf86-input-synaptics //笔记本,外置触摸 3）安装声卡驱动 pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups （三）安装桌面（以gnome桌面为例） 安装x窗口系统\n#安装英文字体 sudo pacman -S ttf-dejavu ttf-droid ttf-hack ttf-fonts-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-ubuntu-font-family #安装中文字体 sudo pacman -S ttf-hannom noto-fonts noto-fonts-extra noto-fonts-cjk noto-fonts-emoji adobe-source-code-oro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-serif-cn-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts wqy-zenhei wqy-microhei sudo vim /etc/locale.conf #将语言改成中文 # 将英语注释掉，添加以下内容LANG=zh_CN.UTF-8 locale-gen sudo pacman -S xorg #安装x窗口系统 安装kde桌面\nsudo pacman -S plasma-meta plasma-nm konsole dolphin kde-connect firefox #简洁的kde桌面 sudo pacman -S plasma plasma-nm kde-applications #kde全家桶 sudo systemctl enable sddm #启动sddm服务 sudo systemctl enable NetworkManager #启动网络管理器 sudo reboot重启 安装gnome桌面\npacman -S gnome gnome-extra gdm#(gdb是登陆管理器) systemctl enable gdm.service reboot 开启字体渲染引擎\nvim /etc/profile.d/freetype2.sh 去掉 #export FREETYPE_PROPERTIES=\u0026quot;truetype:interpreter-version=40\u0026quot; 的 # 号\n清空无用缓存和语言\npacman -Scc （四）安装AUR包软件管理 git clone https://aur.archlinux.org/paru.git 打包工具\nsudo vim /etc/makepkg.conf 取消注释#MAKEFLAGS=\u0026quot;-j$(nproc)\u0026quot;\nmakepkg -si 此时paru已经被安装了\n修改paru排序的相关性，倒序\nvim /etc/paru.conf # 取消注释#BottomUp （五）Arch Linux Gnome桌面环境管理extensions Gnome桌面管理extensions是内置的，但主题较少，在archwiki可以用-theme搜索到想要的主题 然后用：\nsudo pacman -S 主题名 （六）Gnome应用启动器 要使用Gnome启动器要先安装connector,此文件在AUR里，所以要使用paru安装 https://extensions.gnome.org\nparu chrome-gnome-shell 安装dash to dock blur my shell\nArcMenu\nVitals\nJust Perfection\n（七）输入法安装 fcitx5\nsudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-material-color 环境变量与故障处理,wps和firefox无法正确输入 编辑~/.pam_environment\nGTK_IM_MODULE DEFAULT=fcitx QT_IM_MODULE DEFAULT=fcitx XMODIFIERS DEFAULT=@im=fcitx 主题安装\nsudo pacman -S fcitx5-nord 输入法联想与准确度\nfcitx5-config-qt配置工具选择Input Method下Pinyin,选择Enable Cloud Pinyin，字库(Cloud Pinyin)来自Baidu。 离线字库Dictionaries 加入清华的源需要编辑/etc/pacman.conf [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 更新数据库\nsudo pacman -Syy 安装拼音联想词库\nsudo pacman -S archlinuxcn-keyring fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki 键盘布局配置 编辑：\n/etc/vconsole.conf KEYMAP=de-latin1 ","date":"2021-12-24T19:34:05Z","permalink":"https://okokfun.github.io/post/arch%E5%AE%89%E8%A3%85/","title":"Arch安装"},{"content":" C++线程池 任务类 #pragma once #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; // 定义任务结构体 using callback = void (*)(void *); struct Task { Task() { this-\u0026gt;function = nullptr; this-\u0026gt;arg = nullptr; } Task(callback f, void *arg) { this-\u0026gt;function = f; this-\u0026gt;arg = arg; } callback function; void *arg; }; class TaskQueue { public: TaskQueue(); ~TaskQueue(); // 添加任务 void addTask(Task task); void addTask(callback f, void *arg); // 取出一个任务 Task getTask(); // 判断队列任务是否为空 inline bool empty() { return m_taskQ.empty(); } // 当前任务个数 inline int gettaskNumber() { return m_taskQ.size(); } private: std::queue\u0026lt;Task\u0026gt; m_taskQ; std::mutex m_mutex; }; #include \u0026#34;TaskQueue.h\u0026#34; #include \u0026lt;mutex\u0026gt; void TaskQueue::addTask(Task task) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); m_taskQ.push(task); } void TaskQueue::addTask(callback f, void *arg) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); m_taskQ.push(Task(f, arg)); } Task TaskQueue::getTask() { Task task; if (!m_taskQ.empty()) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); task = m_taskQ.front(); m_taskQ.pop(); } return task; } TaskQueue::TaskQueue() {} TaskQueue::~TaskQueue() {} 线程池类 #pragma once #include \u0026#34;TaskQueue.h\u0026#34; #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; class ThreadPool { public: // 创建线程池并初始化 ThreadPool(int min, int max); // 给线程池添加任务 void addTask(Task task); // 获取线程池中工作的线程的个数 int getBusyNumber(); // 获取线程池中活着的线程的个数 int getAliveNumber(); // static ThreadPool *instance(); // static ThreadPool \u0026amp;Instance(); // 销毁线程池 ~ThreadPool(); ThreadPool(); private: ////////////////////// // 工作的线程(消费者线程)任务函数 static void *worker(void *arg); // 管理者线程任务函数 static void *manager(void *arg); private: // 任务队列 TaskQueue *taskQ; int minNum; // 最小线程数量 int maxNum; // 最大线程数量 int busyNum; // 忙的线程的个数 int liveNum; // 存活的线程的个数 std::atomic_int exitNum; // 要销毁的线程个数 std::condition_variable m_notEmpty; std::mutex m_mutex; static const int NUMBER = 2; int shutdown; // 是不是要销毁线程池, 销毁为1, 不销毁为0 }; #include \u0026#34;ThreadPool.h\u0026#34; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // 创建线程池并初始化 ThreadPool::ThreadPool(int min, int max) { do { taskQ = new TaskQueue; if (nullptr == taskQ) { std::cout \u0026lt;\u0026lt; \u0026#34;malloc taskQ fail...\u0026#34; \u0026lt;\u0026lt; std::endl; break; } minNum = min; maxNum = max; busyNum = 0; liveNum = min; // 和最小个数相等 exitNum = 0; shutdown = false; // 管理者线程 std::thread manager_thread(manager, this); std::cout \u0026lt;\u0026lt; \u0026#34;manager_thread created id: \u0026#34; \u0026lt;\u0026lt; manager_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; manager_thread.detach(); // 工作者线程 for (int i = 0; i \u0026lt; min; ++i) { std::thread worker_thread(worker, this); std::cout \u0026lt;\u0026lt; \u0026#34;worker_thread created \u0026#34; \u0026lt;\u0026lt; worker_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker_thread.detach(); } return; } while (0); // 释放资源 if (taskQ) { delete taskQ; taskQ = nullptr; } } ThreadPool::~ThreadPool() { // 关闭线程池 shutdown = true; // 唤醒阻塞的线程 for (int i = 0; i \u0026lt; liveNum; ++i) { m_notEmpty.notify_all(); } // 释放堆内存 if (taskQ) { delete taskQ; taskQ = nullptr; } } void ThreadPool::addTask(Task task) { if (shutdown) { return; } // 添加任务 taskQ-\u0026gt;addTask(task); // 唤醒一个工作者线程 m_notEmpty.notify_one(); } int ThreadPool::getBusyNumber() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); int busyNum_1 = this-\u0026gt;busyNum; return busyNum_1; } int ThreadPool::getAliveNumber() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); int aliveNum = this-\u0026gt;liveNum; return aliveNum; } void *ThreadPool::worker(void *arg) { ThreadPool *pool = static_cast\u0026lt;ThreadPool *\u0026gt;(arg); while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(pool-\u0026gt;m_mutex); // 当前任务队列是否为空 if (pool-\u0026gt;taskQ-\u0026gt;gettaskNumber() == 0 \u0026amp;\u0026amp; !pool-\u0026gt;shutdown) { // 阻塞工作线程 pool-\u0026gt;m_notEmpty.wait(lk, [\u0026amp;] { return pool-\u0026gt;exitNum || pool-\u0026gt;shutdown || !pool-\u0026gt;taskQ-\u0026gt;empty(); }); } lk.unlock(); // 判断线程池是否被关闭了 if (pool-\u0026gt;shutdown || pool-\u0026gt;exitNum \u0026gt; 0) { pool-\u0026gt;exitNum--; std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; exiting...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; break; } // 从任务队列中取出一个任务 auto task = std::move(pool-\u0026gt;taskQ-\u0026gt;getTask()); // 解锁 lk.lock(); pool-\u0026gt;busyNum++; lk.unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; start working...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 消费任务 task.function(task.arg); delete task.arg; task.arg = nullptr; lk.lock(); pool-\u0026gt;busyNum--; lk.unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; end working...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return nullptr; } void *ThreadPool::manager(void *arg) { ThreadPool *pool = static_cast\u0026lt;ThreadPool *\u0026gt;(arg); while (!pool-\u0026gt;shutdown) { // 每隔3s检测一次 std::this_thread::sleep_for(std::chrono::seconds(1)); std::unique_lock\u0026lt;std::mutex\u0026gt; lk(pool-\u0026gt;m_mutex); // 取出线程池中任务的数量和当前线程的数量 int queueSize = pool-\u0026gt;taskQ-\u0026gt;gettaskNumber(); // 取出忙的线程的数量 int busyNum = pool-\u0026gt;busyNum; int liveNum = pool-\u0026gt;liveNum; lk.unlock(); // 添加线程 // 任务的个数\u0026gt;存活的线程个数 \u0026amp;\u0026amp; 存活的线程数\u0026lt;最大线程数 if (queueSize \u0026gt; liveNum \u0026amp;\u0026amp; liveNum \u0026lt; pool-\u0026gt;maxNum) { lk.lock(); int counter = 0; for (int i = 0; i \u0026lt; pool-\u0026gt;maxNum \u0026amp;\u0026amp; counter \u0026lt; NUMBER \u0026amp;\u0026amp; pool-\u0026gt;liveNum \u0026lt; pool-\u0026gt;maxNum; ++i) { std::thread worker_thread(worker, pool); std::cout \u0026lt;\u0026lt; \u0026#34;worker_thread created \u0026#34; \u0026lt;\u0026lt; worker_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker_thread.detach(); pool-\u0026gt;liveNum++; counter++; } lk.unlock(); } // 销毁线程 // 忙的线程*2 \u0026lt; 存活的线程数 \u0026amp;\u0026amp; 存活的线程\u0026gt;最小线程数 if (busyNum * 2 \u0026lt; liveNum \u0026amp;\u0026amp; liveNum \u0026gt; pool-\u0026gt;minNum) { pool-\u0026gt;exitNum = NUMBER; // 让工作的线程自杀 for (int i = 0; i \u0026lt; NUMBER; ++i) { pool-\u0026gt;m_notEmpty.notify_one(); } } } std::cout \u0026lt;\u0026lt; \u0026#34;manager_thread exiting...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return nullptr; } 测试 /************************************************************************* \u0026gt; File Name: main.cpp \u0026gt; Author: txt1994 \u0026gt; Mail: txt1994s@163.com \u0026gt; Created Time: Mon 08 Nov 2021 05:58:32 PM CST ************************************************************************/ #include \u0026#34;ThreadPool.h\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;utility\u0026gt; void taskFunc(void *arg) { int num = *(int *)arg; std::cout \u0026lt;\u0026lt; \u0026#34;thread id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; number = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::this_thread::sleep_for(std::chrono::seconds(1)); } int main(void) { // 初始化线程池 ThreadPool *pool = new ThreadPool(4, 10); for (int i = 0; i \u0026lt; 100; ++i) { int *num = new int; *num = i + 100; Task task; task.arg = num; task.function = taskFunc; pool-\u0026gt;addTask(task); } std::this_thread::sleep_for(std::chrono::seconds(30)); delete pool; return 0; } ","date":"2021-12-24T17:01:29Z","permalink":"https://okokfun.github.io/post/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"C++线程池"}]