[{"content":"","date":"2023-10-14T14:04:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC31%E7%AB%A0plc/","title":"第31章 PLC"},{"content":"","date":"2023-10-14T14:03:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC30%E7%AB%A0%E8%B0%90%E6%B3%A2/","title":"第30章 谐波"},{"content":"","date":"2023-10-14T14:02:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC29%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BA%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%BE%93%E9%85%8D%E7%94%B5%E6%8A%80%E6%9C%AF/","title":"第29章 基于固态控制器的输配电技术"},{"content":"","date":"2023-10-14T13:58:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC27%E7%AB%A0%E7%94%B5%E5%8A%9B%E6%88%90%E6%9C%AC/","title":"第27章 电力成本"},{"content":"","date":"2023-10-14T13:58:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC28%E7%AB%A0%E7%9B%B4%E6%B5%81%E8%BE%93%E7%94%B5/","title":"第28章 直流输电"},{"content":"","date":"2023-10-14T13:55:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC26%E7%AB%A0%E7%94%B5%E8%83%BD%E5%88%86%E9%85%8D/","title":"第26章 电能分配"},{"content":"","date":"2023-10-14T13:53:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC24%E7%AB%A0%E5%8F%91%E7%94%B5/","title":"第24章 发电"},{"content":"","date":"2023-10-14T13:53:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC25%E7%AB%A0%E8%BE%93%E7%94%B5/","title":"第25章 输电"},{"content":"","date":"2023-10-14T13:44:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC23%E7%AB%A0%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/","title":"第23章 交流电机的电子控制"},{"content":"","date":"2023-10-14T13:43:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC22%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6/","title":"第22章 直流电动机的电子控制"},{"content":"","date":"2023-10-14T13:41:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC21%E7%AB%A0%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","title":"第21章 电力电子技术基础"},{"content":"","date":"2023-10-14T13:40:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%94%B5%E6%B0%94%E4%BC%A0%E5%8A%A8/%E7%AC%AC20%E7%AB%A0%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80/","title":"第20章 电动机控制基础"},{"content":"","date":"2023-10-14T13:35:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC19%E7%AB%A0%E6%AD%A5%E8%BF%9B%E7%94%B5%E5%8A%A8%E6%9C%BA/","title":"第19章 步进电动机"},{"content":"","date":"2023-10-14T13:31:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC18%E7%AB%A0%E5%8D%95%E7%9B%B8%E7%94%B5%E5%8A%A8%E6%9C%BA/","title":"第18章 单相电动机"},{"content":"","date":"2023-10-14T13:29:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC17%E7%AB%A0%E5%90%8C%E6%AD%A5%E7%94%B5%E5%8A%A8%E6%9C%BA/","title":"第17章 同步电动机"},{"content":"","date":"2023-10-14T13:11:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC16%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%8F%91%E7%94%B5%E6%9C%BA/","title":"第16章 同步发电机"},{"content":"","date":"2023-10-14T13:09:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC15%E7%AB%A0%E6%84%9F%E5%BA%94%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF/","title":"第15章 感应电动机的等效电路"},{"content":"","date":"2023-10-14T13:05:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC14%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E5%BA%94%E7%94%A8/","title":"第14章 三相感应电机的选择和应用"},{"content":"","date":"2023-10-14T12:46:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC13%E7%AB%A0%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA/","title":"第13章 三相感应电机"},{"content":"","date":"2023-10-14T12:42:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC11%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%8F%98%E5%8E%8B%E5%99%A8/","title":"第11章 特殊变压器"},{"content":"","date":"2023-10-14T12:39:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC10%E7%AB%A0%E5%AE%9E%E9%99%85%E5%8F%98%E5%8E%8B%E5%99%A8/","title":"第10章 实际变压器"},{"content":"","date":"2023-10-14T12:39:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC12%E7%AB%A0%E4%B8%89%E7%9B%B8%E5%8F%98%E5%8E%8B%E5%99%A8/","title":"第12章 三相变压器"},{"content":"","date":"2023-10-14T12:36:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC9%E7%AB%A0%E7%90%86%E6%83%B3%E5%8F%98%E5%8E%8B%E5%99%A8/","title":"第9章　理想变压器"},{"content":"","date":"2023-10-14T12:29:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC7%E7%AB%A0%E6%9C%89%E5%8A%9F%E5%8A%9F%E7%8E%87%E6%97%A0%E5%8A%9F%E5%8A%9F%E7%8E%87%E5%92%8C%E8%A7%86%E5%9C%A8%E5%8A%9F%E7%8E%87/","title":"第7章 有功功率、无功功率和视在功率"},{"content":"","date":"2023-10-14T12:28:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC6%E7%AB%A0%E7%94%B5%E6%9C%BA%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E6%95%A3%E7%83%AD/","title":"第6章 电机的效率和散热"},{"content":"","date":"2023-10-14T12:14:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC4%E7%AB%A0%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA/","title":"第4章 直流发电机"},{"content":"","date":"2023-10-14T12:14:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC5%E7%AB%A0%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/","title":"第5章 直流电动机"},{"content":"","date":"2023-10-14T12:14:19+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%8F%98%E5%8E%8B%E5%99%A8/%E7%AC%AC8%E7%AB%A0%E4%B8%89%E7%9B%B8%E7%94%B5%E8%B7%AF/","title":"第8章 三相电路"},{"content":"","date":"2023-10-14T12:10:14+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC3%E7%AB%A0%E5%8A%9B%E5%AD%A6%E5%92%8C%E7%83%AD%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"第3章 力学和热学的基本知识"},{"content":"","date":"2023-10-14T11:31:14+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC2%E7%AB%A0%E7%94%B5%E5%AD%A6%E7%A3%81%E5%AD%A6%E5%8F%8A%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","title":"第2章 电学、磁学及电路基本原理"},{"content":"1.0 引言 单位在日常生活中起着重要作用。实际上，任何看到、感受到的事物，任何买卖的东西都是用单位来衡量和比较的。我们对于这些单位量是那么熟悉，以至于觉得它们很自然，很少会去想它们是怎么得来的，为什么给它们指定这个单位值。\n几百年前用36个大麦粒首尾相连排列的长度来定义一英尺，而用国王埃德加的鼻子到他伸展的手端的长度来定义一码。\n从那以后，我们在定义出更精确的单位的过程中走了很长的一段路。现在的大部分单位都是基于大自然的物理规律而设定的，由于其有不变性和可重现性的优点。因此，尺和码是用通过光速来计算定义的，时间是通过原子振动的持续时间来定义的。测量标准的提高和科技的进步是息息相关的，它们也是互相依存的。\n虽然基本标准各国是统-一的，但单位的日常应用远未统一。例如，在测量长度时有些人使用英尺和码，而有些人使用毫米和米。天文学家运用秒差距，物理学家用埃，另外一些人员仍在使用杆和测链。但是这些长度单位可以达到很高的精确度，因为现在长度的标准是用光速来衡量的。\n这些基准使同一个测量单位在不同国家或不同专业得以互相比较。长度、质量、时间等标准单位将当今使用的各种单位联系起来。\n1.1单位制 多年来已制定各种单位制以满足商业、工业以及科学的需求。一个单位制可表述为其各单位之间有数值联系，而且常常是整数关系。如在英制中，英寸、英尺、码都是彼此相关的，由12、3、36这几个数联系起来。.\n在公制中也存在类似的相关性，只不过那些单位是由10的倍数联系起来的。因此，厘米、米、千米是由100、1000、100 000这几个数联系起来的。所以从米换算到厘米比从码换算到英尺方便，这也是公制的优点之一.\n公制在当今被认定为国际单位制，SI 是它的缩写。SI 是在1960年召开的第11届度量衡大会上被正式确定的，那届大会的主题是“国际单位制”。\n1.2国际单位制 国际单位制 (SI) 被大多数国家所采用，但它并没有消除其他先前被使用的单位。就像建立了良好的生活习惯一样，那些单位变成我们生活的一部分，不能马上改变它。一夜之间从码到米，以及从盎司到克的转换并不是容易的。这是很自然的，因为长期使用一种单位使我们对事物的质量、规模以及它们怎样与物质世界联系有了自已的认识和理解。\n然而，SI 变得越来越重要 (尤其是在电气和机械领域) ，使得我们应该了解单位制基本内容，从而，能用简单的方法从一个单位系统换算到另一个单位系统。在这方面，附录列出的转换图表是非常有用的。\nSI具有很多其他单位系统没有的明显的优点:\n这是一个十进制系统; 它包含了工业和商业中很多常用的单位，例如伏特、安培、千克以及瓦特; 这是一个连贯系统，在电、机以及热之间有着非常简洁明了的联系; 它可以被科学研究者、技术员、工程师以及外行者使用，能把理论与实践联系起来。 尽管有这些优点，但 SI 并不是万能的。在特殊领域如原子物理学，以及甚至在每天的工作中，其他单位制可能会更方便些。所以我们测量平面角时用度这个单位，尽管在 SI 中角的单位是弧度。而且，我们将继续使用天和小时来计算时间，尽管在 SI 中是用秒计时。\n1.3 基本单位和导出单位 国际单位制由7个基本单位组成 (如表1-1所示) 。 $$ 表1-1~~~基本单位 $$\n量 单位 符号 长度 米 m 质量 千克 kg 时间 秒 s 电流 安培 A 热力学温度 开尔文 K 发光强度 坎德拉 cd 物质的量 摩尔 mol 从这些基本单位我们可以导出其他一-些诸如面积、功率、力、磁通量等单位。能导出的单位在数量上没有限制，有些单位使用频繁从而给它们取了特殊的名字。因此，对于压强单位用更简单的帕斯卡取代原来的牛顿/平方米。一些有特殊名字的导出单位量列在表1-2中。 $$ 表1-2~~~导出单位 $$\n量 单位 符号 电容 法拉 F 电荷 库仑 C 电导 西门子 S 电位 伏特 V 电阻 欧姆 $\\Omega$ 能量 焦耳 J 力 牛顿 N 频率 赫兹 Hz 光照度 勒克斯 lx 电感 亨利 H 光通量 流明 lm 磁通量 韦伯 Wb 磁通密度 特斯拉 T 平面角 弧度 rad 功率 瓦特 W 压强 帕斯卡 Pa 立体角 球面度 sr 1.4 基本单位的定义 以下SI基本单位的定义证明了其精确性。下面的楷体字部分是解释，而并不属于定义的部分。\n米 (m) 是光在真空中行进 299 792 458 分之一秒所走的路程。\n在1983年，光的速度被精确到299 792 458m/s。\n千克 (kg) 是质量的单位;它相当国际千克原器的质量。\n国际千克原器是一个特殊的鉑铱合金圆柱体，它被保存在法国塞勒弗国际计量局的一个容器里。它的复制品在世界各地重要的标准实验室中都可以找到。这个鉑铱合金 (90%的鉑和10%的铱) 高4cm，直径为4cm。\n秒 (s) 的定义是铯133原子基态的两个超精细能级之间跃迁所对应辐射的9 192 631 770个周期所持续的时间。\n将石英晶体振荡器调谐到铯原子的共振频率，可以产生一个高精度和稳定的频率。\n安培 (A) 的定义是在真空中两个相距 1m 的平行无限长导体中 (它们的横截面积可以忽略) 通入一个恒定的电流，在它们之间产生每米 $2\\times10^{-7}$ 牛的力，该电流的大小就是1A。\n热力学温度开尔文 (K) 定义为水的三相点热力学温度的 1/273.16。\n纯净水在疏散电池中冷却直到冰开始形成。冰、水、水汽共存的温度定义为水的三相点温度，它的大小是 273.16K。三相点温度相当于 0.01°C。因此 0°C 就相当于 273.15K。\n坎德拉 (cd) 表示一光源在给定方向上的发光强度，该光源所发出的单色辐射频率为 $540 \\times 10^{12}Hz$，以及在那个方向的辐射功率为 (1/683) W/sr。\n摩尔 (mol) 表示构成一系统中基本物质的数量，相当于0.012kg碳12原子的数量。\n注意:当使用摩尔时，必须指定基本物质的类型，可以是原子、分子、离子、电子以及其他物质或这些物质的特定组合。\n1.5 导出单位的定义 一些比较重要的导出单位的定义如下。\n库仑 (C) 是 1 安培电流 1 秒钟传输的电量大小 (因此1库仑=1安培\\times秒) 。\n摄氏度 (°C) 相当于开尔文，用符号 (t) 表示。它与开尔文的换算关系表示为 $t=T-T$。T表示热力学温度，$T。= 372.15K$.\n法拉 (F) 的定义: 如果平行板电容器两极分别带有 1 库仑的异号电荷，其两极板间电位差为 1 伏特，则其电容定义为 1 法拉 (1 法=1库仑/伏) 。\n亨利(H)的定义:一个闭合电路中的电流以1安培/秒的速率均匀变化时，如果因自感而在电路中产生1伏的电压，则其自感定义为1亨利(因此1亨=1伏X秒/安)。\n赫兹(Hz)是在一秒钟之内周期性发生的现象的频率。\n焦耳(J)是1牛顿力的作用点在力的方向移动1米距离所做的功(因此1焦=1牛X米)。\n牛顿(N)定义为给质量为1千克的物体一个大小为1米/秒2的加速度所需要的力(因此1牛=1千克X米/秒的平方)。\n虽然牛顿是以质量和加速度的形式定义的，但它也适用于固定的对象和其他涉及力的应用的地方。\n欧姆 ($\\Omega$)定义为在一个导体两端加上1伏的电压，则这两端产生1安培的电流时这个导体的电阻，此时这个导体本身不是任何电源(因此1欧=1伏/安)。\n帕斯卡(Pa) 为压强单位或1牛/平方米的压力。\n弧度(rad) 为平面角的单位，它表示为顶点在圆心，弧长等于该圆的半径对应的角。\n西门子(S)为电导的单位，它是欧姆的倒数(西门子以前称姆欧)。\n球面度(sr) 为立体角的单位，它表示为顶点在球心，在球的表面切割等于球半径平方的面积的立体角。\n特斯拉(T)为磁通密度的单位，相当于1韦伯/平方米。\n伏特(V)定义为一段导体两端的电势差，当给这段导体通1安的恒电流时，在这段导体两端消耗的功率为1瓦(因此1伏=1瓦/安)。\n瓦特(W)定义为这样一个功率，它每秒产生1焦耳的能量(因此1瓦=1焦/秒)。\n韦伯(Wb)的定义为: 令通过单匝线圈的磁通量在1秒钟内均匀地减小到零，如果在该线圈中激发产生的感应电动势为1伏特，则原来通过该线圈的磁通量为1韦伯(因此1韦伯=1秒 $\\times$ 伏)。\n1.6 倍数单位和分数单位 倍数和分数单位由加在国际单位前的适当的词头和国际单位-起构成。这些词头(如千、兆、纳以及厘)代表在单位前乘以相应的系数值，具体列在表1-3中。例如:\n1 千安=1000 安，1纳秒= $10^_{-9}$秒，1兆瓦=$10^6$ 瓦。 $$ 表1-3~~~倍数单位和分数单位的词头 $$\n乘数 指数形式 前缀 SI符号 1 000 000 000 000 000 000 000 000 $10^{24}$ 尧(它) Y 1 000 000 000 000 000 000 000 $10^{21}$ 泽(它) Z 1 000 000 000 000 000 000 $10^{18}$ 艾(可萨) E 1 000 000 000 000 000 $10^{15}$ 拍(它) P 1 000 000 000 000 $10^{12}$ 太(拉) T 1 000 000 000 $10^{9}$ 吉(伽) G 1 000 000 $10^{6}$ 兆 M 1000 $10^{3}$ 千 k 100 $10^{2}$ 百 h 10 $10^{1}$ 十 da 0.1 $10^{-1}$ 分 d 0.01 $10^{-2}$ 厘 c 0.001 $10^{-3}$ 毫 m 0.000 001 $10^{-6}$ 微 $\\mu$ 0.000 000 001 $10^{-9}$ 纳(诺) n 0.000 000 000 0001 $10^{-12}$ 皮(可) p 0.000 000 000 000 001 $10^{-15}$ 飞(母托) f 0.000 000 000 000 000 001 $10^{-18}$ 阿(托) a 0.000 000 000 000 000 000 001 $10^{-21}$ 仄(普托) z 0.000 000 000 000 000 000 000 001 $10^{-24}$ 幺(科托) y 1.7 常用单位 表1-4、表1-5和表1-6列出了一些经常使用的单位，涉及力学、热力学以及电学。它们包含特殊的标注，方便于那些对国际单位制不太熟悉的读者阅读。 $$ 表1-4~~~在力学中的常用单位 $$\n量 国际标准单位 符号 角 弧度中 rad 面积 平方米 $m^2$ 能量(功) 焦耳 J 力 牛顿 N 长度 米 m 质量 千克 kg 功率 瓦特 W 压强 帕斯卡 Pa 速度 米/秒 m/s 角速度 弧度/秒 rad/s 转矩 牛.米 N.m 体积 立方米 $m^3$ 体积 升 L ① 虽然弧度是表示角度的国际标准单位，但我们在这本书中几乎用度来表示角的大小(1rad ≈ 57.3°)。\n② 在大多数国家，包括加拿大(以及美国的一些地区)，表示米用 metre, 而不是 meter。\n③ 牛顿是非常小的力，大概只有按门铃那么大的力。\n④ 帕斯卡是一个非常小的压强，大概只有 $1牛/米^2$。\n⑤ 在本书中我们用转每分 (r/min) 来表示角速度 (1rad/s = 9.55r/ min)。\n⑥ 通常用来表示液体和气体体积的单位，英文拼写为 liter 或者 litre, 在加拿大的官方拼写为 litre。 $$ 表1-5~~~在热力学中的常用单位 $$\n量 国际标准单位 符号 热量 焦耳 J 热能 瓦特 W 比热容 焦/ (千克$\\times$开尔文) J/(kg•K)或J(kg•°C) 温度 开尔文 K 温差 开尔文或摄氏度 K或°C 导热性 瓦/ (米$\\times$开尔文) W/(m•°C) ① 温度相差1K等效于温度相差 1°C。摄氏度 °C 是国际制单位认可的，在日常计算中，它常常取代开尔文。\n② 在热力学中，绝对温度都是用开尔文表示的。另一方面，物体温度通常用摄氏度 °C 表示。绝对温度转化为摄氏温度可用公式 $T=t+273.15$ 表示。 $$ 表1-6~~~在电磁学中的常用单位、 $$\n量 国际标准单位 符号 电容 法拉 F 电导 西门子 S 电量 库仑 C 电流 安培 A 电能 焦耳 J 频率 赫兹 Hz 电感 亨利 H 电势差 伏特 V 功率 瓦特 W 电阻 欧姆 $\\Omega$ 电阻率 欧X米 $\\Omega$•m 磁场强度 安/米 A/m 磁通量 韦伯 Wb 磁通密度 特斯拉 T 磁动势 安 A ① 以前叫姆欧。\n② 1Hz=1周期/秒。\n③ 1A/m=1安匝/米\n④ $1T= 1Wb/m^2$\n⑤ 以前叫的安匝现在统称为安: 1A=1安匝\n1.8 换算表及其用处 通过标准换算表我们可以把不熟悉的单位转换为熟悉的单位。但这确实是一个严格的计算过程，应避免换算出错。\n附录中的换算表减轻了我们的麻烦，它通过单位在图中的位置来表示它们的相互关系。最大的单位处在顶端，最小的单位在底部，中间的单位处在它们之间。\n这些单位由箭头连接，每个单位都标有一个数值。该数值大小是大的单位相对于小的单位的比率，因此每个数值都比单位值要大。箭头总是由大的单位指向小的单位。\n$$ 图1-1~~~长度单位换算表 $$ 在图1-1中，例如，5个长度单位:英里、米、码、英寸以及毫米依次呈降序排列，它们之间由指向较小单位的箭头联系。数值表示连接的单位间的大小关系:码比英寸大36倍，而英寸比毫米大25.4倍，等等。因此我们可用如下简单的方法从一种单，位换算到另一种单位。\n假设我们要将码转换为毫米。从码在图1-1的位置开始，我们要向下移两个箭头(36 和25.4)直到来到毫米的位置。\n相反地，如果我们要从毫米转换到码，我们就从毫米的位置开始，向上逆着移两个箭头直到来到码的位置。在做换算时我们应用如下准则。\n如果在转换单位时，我们沿着箭头的方向移动，则运算时我们就把遇到的相应数值相乘。\n相反地，如果逆着箭头方向移动，则除以相应的数值。\n因为箭头是向下指的，这就意味着当沿着表向下移时做乘法，向上移时做除法。值得注意的是，我们可以选择想要的任何路径，最后转换的结果都是一样的。\n标有国际单位的长方形向表的左侧延伸是为了区别其他的单位。每个长方形上都标有单位的符号以及单位的全称。\n1.9 测量中的标幺值系统 国际单位制就是为了让人们准确确定各个量的大小。所以质量单位用千克表示，功率用瓦特表示，电位用伏特表示。实际上，经常可以通过相同事物的比较获得对它们大小更好的认识。因此，可以使用单位体系，通过与指定量的比较确定其他相对量的大小，这个就是标幺值方法。\n例如，假设在纽约成年人的平均体重是 130 磅。将这个数值作为基数，我们可以将任何个人的重量用与这个基数的比值表示。因此一个重 160 磅的人，他的体重用标幺值表示为 1601b/1301b=1.23。而另一个重115磅的人体重用标幺值表示为 1151b/1301b=0.88。\n这个标幺值表示的测量值使被测量量有一个很简单的单位，这个系统称为标幺值系统。因此，参照上面的例子，如果一个橄榄球运动员的标幺体重为1.7，则知道他的体重远大于平均值。而且，他的准确体重为1. 7X130 = 2211b。\n注意，无论什么时候给出的标幺值，它们总是纯数字。所以说某个橄榄球运动员的体重是1.71b是非常可笑的。而应表述为当基准体重是 1301b 时，他的体重标幺值是 1.7。\n一般地，一个标幺值系统包括一个或多个基准值，以便其他量与它们比较。在本书中，选择电压、电流、功率、转矩和阻抗等量作为基准值。\n1.10 一个基准量的标幺值系统 如果只选择一个量作为基准值，则称为单基值标幺值系统。这个基值单位可能是功率、电压、电流或者速度。例如，假设三台电动机的额定功率分别为 25hp、 40hp 和 150hp。将基值选定为 $P_B= 50hp$，则相应的标幺值为 25hp/50hp=0.5，40hp/50hp=0.8 以及 150hp/50hp=3。因此，在这个标幺值为 50hp 的系统中，三台电动机的额定功率分别为 0.5、0.8 以及 3pu。\n当然，也可以选 15hp 为基准值。在这种情况下各自的标幺值为 25hp/15hp= 1.67, 40hp/15hp=2.67 以及150hp/15hp = 10。\n因此知道基准值的大小也很重要。如果不知道这个值，则相关量的准确值我们也计算不出来。\n$$ 图1-3~~~ 典型的电路 $$ 标幺值的方法也适用于阻抗计算中。例如，图1-3中的电路，既包括几个电阻，又包括电容和电感。如采用 1500$\\Omega$ 作为阻抗的基准值，则图1-3中各阻抗的标幺值如下所示: $$ R_1(pu)=\\frac{3500\\Omega}{1500\\Omega}=2.33 \\\\ R_2(pu)=\\frac{450\\Omega}{1500\\Omega}=0.30 \\\\ R_L(pu)=\\frac{4800\\Omega}{1500\\Omega}=3.2 \\\\ X_C(pu)=\\frac{3000\\Omega}{1500\\Omega}=2 $$ $$ 图1-4标幺值电路 $$ $$ 图1-5带j的向量表示标幺值电路 $$ 标幺值电路(见图1-4)与原电路有相同的电路元件，但现在的阻抗大小用标幺值的形式表示出来。我们可以像其他电路一样解这个电路。例如，如果用向量表示法，这个标幺值电路如图1-5所示。\n1.11 两个基准量的标幺值系统 在电工学中，使用两个基准量可使标幺值系统变得更有效。这两个量一般是基准电压 $E_B$ 及基准功率 $P_B$。比如，可以选基准电压为4kV,基准功率为500kW。\n这两个基准值的选取是相互独立的。\n电压/功率基准系统的一个非常有意义的特点是它们也同时确立了相应的电流和阻抗基准值。因此基准电流 $I_B$ 为 $$ I_B=\\frac{基准功率}{基准电压}\\frac{P_B}{E_B} $$ 则基准阻抗 $Z_B$ 为 $$ Z_B=\\frac{基准电压}{基准电流}\\frac{E_B}{I_B} $$ 例如，如果基准电压取4kV,基准功功率取500kW,则基准电流为 $$ I_B = P_B/E_B = 500 000/4000 = 125A $$ 基准阻抗为 $$ Z_B = E_B/I_B = 4000V/125A = 32\\Omega $$ 实际上，在选择电压/功率标幺值系统时也获得了基准电流和基准阻抗。因此，这个所谓的两基准量标幺值系统实际上是一个四基准量标幺值系统。\n通过学习以下两个例子，可使读者明白这个结论的重要性。基准值如上面选的一样: $$ E_B = 4kV~~~~~I_B = 125A \\\\ P_B = 500kW~~~~Z_B = 32\\Omega $$\n","date":"2023-10-14T11:14:14+08:00","permalink":"https://okokfun.github.io/post/%E7%94%B5%E6%9C%BA%E4%B8%8E%E6%8B%96%E5%8A%A8%E5%8F%8A%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AC%AC1%E7%AB%A0%E5%8D%95%E4%BD%8D/","title":"第1章 单位"},{"content":"","date":"2023-08-30T18:38:03+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.11%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4/","title":"11.11控制实验室"},{"content":"","date":"2023-08-30T18:37:48+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.10matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/","title":"11.10MATLAB工具和案例研究"},{"content":"","date":"2023-08-30T18:37:30+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.9%E5%B1%80%E9%83%A8%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/","title":"11.9局部反馈控制"},{"content":"","date":"2023-08-30T18:37:16+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.8%E9%B2%81%E6%A3%92%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"11.8鲁棒控制系统的设计"},{"content":"","date":"2023-08-30T18:36:58+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.7%E5%89%8D%E5%90%91%E5%92%8C%E5%89%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E5%99%A8/","title":"11.7前向和前馈控制器"},{"content":"","date":"2023-08-30T18:36:45+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.6%E9%9B%B6%E6%9E%81%E7%82%B9%E5%AF%B9%E6%B6%88%E8%AE%BE%E8%AE%A1-%E9%99%B7%E6%B3%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"11.6零极点对消设计 陷波滤波器"},{"content":"在校正控制系统中， PID 控制器及其组成部分 PD 和PI控制器是对控制系统进行微分、积分操作。一般来说，我们可以把控制系统的控制器设计看作滤波器设计问题，这样就会有很多可能的设计方案。从滤波角度来看， PD 控制器可以看作高通滤波器,PI控制器可以看作低通滤波器，而 PID 控制器根据控制器参数值的不同，可以看成带通滤波器或带阻滤波器。在本节中，我们所介绍的高通滤波器可以称为相位超前控制器，因为它给控制系统引入的正向相位超出了一定的频率范围。低通滤波器因为引入了负向相位，因此称为相位滞后控制器。两种控制器所对应的电路如图11-30所示。 $$ 图11-30\\ G_c(s)=K_c\\frac{S+Z_1}{S+P_1}的运算放大电路 $$ 一个简单的相位超前或相位滞后控制器的传递函数表达式为 $$ G_c(S) = K_c\\frac{S+Z_1}{S+P_1} \\ (11-69) $$ 如果 $p_1\u0026gt;z_1$，控制器为高通滤波器或相位超前控制器;如果$p_1\u0026gt;z_1$，控制器为低通滤波器或相位滞后控制器。\n式(11-69)所示运算放大电路的实现可见第6章的表6-1g,并在图11-30中使用倒置放大器再次重现。该电路的传递函数可以写为 $$ G_c(S) = \\frac{E_o(S)}{E_{in}(S)}=\\frac{C_1}{C_2}\\frac{S+\\frac{1}{R_1C_1}}{S+\\frac{1}{R_2C_2}} \\ (11-70) $$\n对比式( 11-69)和式( 11-70)，可得: $$ K_c = C_1/C_2\\ (11-71)Z_1 = 1/R_1C_1\\ P_1=1/R_2C_2 $$ 令$C=C_1=C_2$，可以将所需设计的参数从4个减少到3个，则式(11-70)可以写为 $$ G_c(S)=\\frac{R_2}{R_1}(\\frac{1+R_1C_s}{1+R_2C_s})=\\frac{1}{a}(\\frac{1+aTs}{1+Ts})\\(11-72) $$ 其中： $$ a = \\frac{R_1}{R_2}\\(11-73) $$ $$ T = R_2C\\(11-74) $$\n11.5.1相位超前控制器的时域分析和设计 在本节中，我们首先考虑式(11-70)和式(11-72)所表示的相位超前控制器($z_1\u0026lt;p_1$或$a\u0026gt;1$)。为了使得加人相位超前控制器后，系统的稳态误差指标不会下降，式(11-72)中的因子 a 应当包含在前向通道增益系数$K$中。因此可以写为 $$ G_c(s) = \\frac{1+aTs}{1+Ts}，a\u0026gt;1\\(11-75) $$ 式(11-75)的零极点配置图如图11-31所示。根据第7章中的讨论，在前向通道传递函数中加入一对零极点(零点很接近原点)对控制系统会产生影响，若相位超前控制器的参数选择合理，则可以提高闭环系统的稳定性。超前控制器设计从本质上讲就是合理地配置 $G_c(s)$ 的零点，使得控制系统满足实际要求。根轨迹方法可以用来确定参数范围。以下列出的是选择参数a和T的几点指导性原则:\n将零点 $-1/aT$ 移向原点可以改善系统的.上升时间和调节时间。但是如果该零点离原点太近，就会导致系统的最大超调上升，因为 $-1/aT$ 也是闭环系统传递函数的一个零点。 令极点$-1/T$远离零点和原点，可以减少最大超调，但若$T$的值太小，上升时间和调节时间又会增加。 我们总结一下相位超前控制器对控制系统时域特性的影响:\n若控制器的参数选择适当，可以提高系统的阻尼性。 可以改善上升时间和调节时间。 根据式(11-75)，相位超前控制器不会影响系统的稳态误差，因为$G_c(0)=1$。 11.5.2相位超前控制器的频域分析和设计 式(11-75)所表示的相位超前控制器的Bode图如图11-32所示。两个交接频率为$∞=1/aT$和 $∞=1/T$。下面将推导出最大的相位值 $\\phi_m$ 和对应的频率$\\omega_m$。因为$\\omega_m$是两个交接频率的几何平均值，所以有: $$ lg \\omega_m = \\frac{1}{2}(lg\\frac{1}{aT}+lg\\frac{1}{T})\\(11-76) $$ $$ 图11-32相位超前控制器G_c(s)=\\frac{1+ aTs}{1+ Ts}，a\u0026gt;1的Bode图 $$ 因此 $$ \\omega_m = \\frac{1}{\\sqrt[]aT}\\(11-77) $$ 为了确定最大相位$\\phi_m$，$G_c(j\\omega)$ 的相位可以写成 $$ ∠G_c(j\\omega)=\\phi(j\\omega)=arc\\tan ωaT-arc\\tan ωT\\(11-78) $$ 由此可得到: $$ \\tan \\phi(j\\omega)=\\frac{ωaT-ωT}{1+(ω aT)(ωT)}\\(11-79) $$ 将式(11-77)代入式(11-79)可得: $$ \\tan\\phi_m = \\frac{a-1}{2\\sqrt[]a}\\(11-80) $$ 或 $$ \\sin\\phi_m = \\frac{a-1}{a+1}\\(11-81) $$\n因此，只要知道 $\\phi_m$ 的值，就可以得到 a 的值: $$ a = \\frac{1+\\sin\\phi_m}{1-\\sin\\phi_m}\\(11-82) $$\n相位$\\phi_m$和a之间的关系以及相位超前控制器Bode图的一-般性质为频域设计提供了一些便利。当然，困难在于确定时域和频域特性之间的相关性。频域中相位超前控制器设计的概要如下，假设设计要求仅涉及稳态误差和相位裕度。\n根据稳态误差要求，增益常数K被用于构造 $G_p(j\\omega)$ 的Bode图。一旦确定了a的值，就必须向上调整K的值。 确定待校正系统的相位裕度和增益裕度，并确定实现相位裕度所需的相位超前量。根据所需的相位超前量，相应地估计所需的 $\\phi_m$ 值，并根据式(11-82)计算a的值。 一旦a的值确定，只需要确定T值，设计大体上就完成了。同时还要配置好相位超前控制器的两个交接频率$1/aT$和$1/T$，这样就将 $\\phi_m$ 放置在了新增益穿越频率 $\\omega\u0026rsquo;_g$ 处，可以达到校正系统的相位裕量。已知相位超前控制器的高频增益为20lgadB。因此，为了得到在 $\\omega_m$ 处的新增益穿越频率，也就是$1/aT$和$1/T$的几何平均值，我们需要将 $\\omega_m$ 放置在待校正系统 $G_P(j\\omega)$ 的$-10lga dB$幅值处，来使得幅值曲线增加$10lga dB$，从而使得在 $\\omega_m$ 处达到0dB。 检查校正系统前向通道传递丽数的Bode图，看所有的性能指标是否都已满足。如果没有，重新选择$\\phi_m$的值，重复上述步骤。 如果设计要求全部满足，则相位超前控制器的传递由 a 和 T 的值确定。 如果设计要求中还包括$M_r$或 BW 等指标，就要用Nichols表或计算机编程来进行\n11.5.3 相位超前控制的作用 从上面列举的两个例子，下面总结一-下单阶相位超前控制器的作用和局限性。\n相位超前控制器给控制系统的前向通道传递函数增加了\u0026ndash;对零极点，其中零点在极点的右边。一般而言，这使得闭环系统的阻尼增大，.上升时间 和调节时间减小。 控制系统的前向通道传递函数在增益穿越频率点附近的相位增加，改善了闭环系统的相位裕量。 控制系统前向通道传递函数的幅值曲线斜率在增益穿越频率点处减小。这通常会改善系统增益和相位裕量，从而改善系统的相对稳定性。 闭环系统的带宽增加，对应于时间响应变快。 控制系统的稳态误差没有影响。 11.5.4 单阶相位超前控制的局限性 一般而言，相位超前控制器并不适合所有系统。单阶相位超前控制器要能成功地用于改进系统的稳定性要依赖如\u0026quot;下条件:\n带宽的考虑:如果原始系统不稳定或稳定裕量较小，则实现期望的相位裕量所需的相位超前量可能会过多。这会使得控制器的a值很大，结果导致校正系统产生较大的带宽，从而会使在输人端进人系统的高频噪声产生较大的影响。但是，如果噪声是在输出附近进入系统，增加的带宽对抑制噪声是有利的。并且带宽越大，控制系统的鲁棒性越好，也就是说，系统对参数变化不敏感，并如前面所说的可以抑制噪声。 如果原始系统不稳定，或只具有较小的稳定裕量，控制系统前向通道传递函数的相位曲线在增益穿越频率点附近的负斜率很大。在这种情况下，由于在新增益穿越频率点处的附加的相位超前是加在-一个远小于原来的增益穿越频率点处相位值的相角上的，单阶相位超前控制器不再有效，只有采用非常大的a值来实现期望的相位裕量，而a值越大就需要越高的放大器增益K,因此必须增大K值，这样在实际应用中的造价成本就会很大。 如例11-5-2所示，校正系统的欠调可能比超调大。通常，即使满足了所需的相位裕量，一部分相位曲线仍可能会跌落到180°以下，从而形成条件稳定的系统。 3. 单阶相位超前控制器最大允许的相位超前不会超过90%。因此如果需要大于90° 的相位超前，就必须用多阶控制器。\n11.5.5 多阶相位超前控制器 $$ 图11-42 二二阶相位超前(滞后)控制器的电路实现 $$ 当进行相位超前控制器设计需要增加的相位超过90°时，就需要用到多阶相位超前控制器。图11-42给出了一个二阶相位超前控制器的电路实现图，电路图的输人-输出传递函数为 $$ G_c(s) = \\frac{E_o(s)}{E_{in}(s)} = (\\frac{s+\\frac{1}{R_1C}}{s+\\frac{1}{R_2C}})(\\frac{s+\\frac{1}{R_3C}}{s+\\frac{1}{R_4C}})=\\frac{R_2R_4}{R_1R_3}(\\frac{1+R_1C_S}{1+R_2C_S})(\\frac{1+R_3C_S}{1+R_4C_S})\\(11-119) $$ 或者是 $$ G_c(s) = \\frac{1}{a_1a_2}(\\frac{1+a_1T_1s}{1+T_1s})(\\frac{1+a_2T_2s}{1+T_2s})\\(11-120) $$ 其中，$a_1=R_1/R_2，a_2=R_3/R_4， T_1=R_2C，T_2=R_4C$。\n由于现在需要配置更多的极点和零点，因此在时域中进行多阶相位超前控制器的设计会变得更加烦琐。因为存在更多的可变参数，所以根轨迹方法的使用也变得难以操作。在这种情况下，频域设计是一种更好的设计选择。例如对于一个二阶控制器，我们可以先选好第一阶的参数值，使得部分相位裕量满足要求，然后再使得第二阶满足剩余的要求。一般来说，这两个阶段的设计是不相同的。下面的例子将详细阐述二阶相位超前控制器的设计过程。\n11.5.6 灵敏度考虑 灵敏度函数的定义出现在10.15节中，式( 11-128)可以用来作为衡量控制系统鲁棒性的一个性能指标。闭环传递函数关于前向通道传递函数变化的灵敏度定义为 $$ S^M_G(s) = \\frac{\\partial{M(s)}/M(s)}{\\partial{G(s)}/G(s)}=\\frac{G^{-1}(s)}{1+G^{-1}(s)}=\\frac{1}{1+G(s)}\\(11-128) $$\n11.5.7 相位滞后控制的时域解释和设计 11.5.8 相位滞后控制的频域解释和设计 11.5.9 相位滞后控制器的作用和局限性 11.5.10 超前滞后控制器的设计 ","date":"2023-08-30T18:36:20+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.5%E7%9B%B8%E4%BD%8D%E8%B6%85%E5%89%8D%E5%92%8C%E7%9B%B8%E4%BD%8D%E6%BB%9E%E5%90%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"11.5相位超前和相位滞后控制器的设计"},{"content":"从前面的讨论知道， PD 控制器能够增加系统的阻尼但不改变稳态响应。PI控制器可以同时改进系统的相对稳定性和稳态误差，但增加了，上升时间。使用 PID 控制器就是为了利用PI控制器和 PD 控制器各自的优点。下面将要简单介绍一-下设计 PID 控制器的步骤: $$ 图11-27 例11-3-2中具有Pl控制器的控制系统的单位阶跃响应曲线 $$ 1.考虑有这么一个 PID 控制器，它由PI控制器串联上一个 PD 控制器组成。那么该 PID 控制器的传递函数可以写为 $$ G_c(s) =K_P+ K_DS+\\frac{K_I}{S}=(K_{P1}+K_{D1}S)(K_{P2}+\\frac{K_{I2}}{S})\\(11-58) $$ 将 PD 控制器的比例常数设定为Kp=1，因此我们只需要设计 PID 中的3个参数。令式(11-58)左右两边同类项的系数相等，可以得到: $$ (11-59)K_P = K_{P2}+K_{D1}K_{I2}\\\\ \\ (11-60)K_D=K_{D1}K_{P2}\\\\ \\ (11-61)K_I = K_{I2} $$ 2. 考虑只有 PD 部分有效。选择$K_{D1}$的值使得部分期望的相对稳定性可以实现。在时域中，系统的相对稳定性可以表示为最大超调量;在频域中，相对稳定性可以通过相位裕量来描述。 3. 选择参数 $K_{I2}$ 和 $K_{P2}$ 使得系统的相对稳定性完全满足要求。\n注意，设定$K_{p1}$=1的步骤和例11-2-1和11-2-2中的 PD 控制器设计是一致的。下面的例子将用于说明如何在时域和频域中设计 PID 控制器。\n","date":"2023-08-30T18:36:05+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.4pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"11.4PID控制器的设计"},{"content":"从11.2节中，我们得知PD控制器可以改进控制系统的阻尼和上升时间，但其代价是更高的带宽和谐振频率，且PD控制不影响稳态误差，除非稳态误差是随时间变化的，而对阶跃输入而言，PD控制下系统的稳态误差通常是不变的。因此，PD控制器在许多情况下不能满足系统的校正要求。 $$ 图11-19具有PI控制器的控制系统控制框图 $$\nPID控制器的积分部分产生一个与控制器输人的时间积分成比例的信号。串联一个PI控制器的二阶系统结构控制框图如图11-19所示。PI控制器的传递函数为\n$$ G_c(S) = K_P+\\frac{K_I}{S}~~~(11-34) $$\n$$ 图11-20a两运算放大器电路 $$\n使用表6-1中给出的电子元件来实现式( 11-34)的两个运算放大器电路，如图11-20所示。图11-20a中的两运算放大器的传递函数为\n$$ G_c(S) = \\frac{E_o(S)}{E_{in}(S)}=\\frac{R_2}{R_1}+\\frac{R_2}{R_1C_2S}~~~(11-35) $$\n比较式(11-34)和式(11-35)得:\n$$ K_P = \\frac{R_2}{R_1}~~~~~K_I = \\frac{R_2}{R_1C_2}~~~~(11-36) $$\n图11-20b中的三运算放大器的传递函数为\n$$ G_c(s) = \\frac{E_o(s)}{E_{in}(s)}=\\frac{R_2}{R_1}+\\frac{1}{R_iC_is}~~~(11-37) $$\n因此 PI 控制器的参数与电路元件参数的关系为:\n$$ K_P=\\frac{R_2}{R_1}~~~~~K_I = \\frac{1}{R_iC_i}~~~~(11-38) $$\n$$ 图11-20b三运算放大器电路 $$\n$$ 图11-20~~~G_c(s)=K_p +\\frac{K_I}{s}的PI控制器的运算放大器电路 $$\n图11-20b所示电路的优点在于 $K_p$ 和 $K_I$ 的值是相互独立的，但不论是那种电路，$K_I$的值都与电容值成倒数关系，有效的 PI 控制器设计一.般要求有小的 $K_I$ 值，因此必须注意避免出现不符合实际的大电容值。\n校正系统的前向通道传递函数为\n$$ G_(s) = G_c(s)G_p(s) = \\frac{ω^2_n(K_PS+K_I)}{S^2(S+2ξω_n)}~~~(11-39) $$\n通过以上分析，PI 控制器的作用如下:\n在前向通道传递函数 $s=-K_I/K_p$ 处增加了一个零点。 在前向通道传递函数 $s=0$ 处增加了一个极点，这说明控制系统从I型变为I型。因此，原始系统的稳态误差可以得到改善，即，如果响应的稳态误差为常数，PI 控制会将误差减小到0 (要保证校正系统仍稳定)。 如果参考输入是斜坡函数，前向通道传递函数为式(11-39)的控制系统(系统控制框图见图11-19)会产生零稳态误差。但是，此时系统是三阶的，所以它可能比原始的二阶系统具有更差的 稳定性，甚至如果 $K_p$ 和 $K_I$ 的值选择不当，系统会变得不稳定。\n对于具有 PD 控制的 I 型系统来说，由于斜坡误差系数 $K_v$ 与 $K_p$ 成正比，当输人为斜坡信号时，稳态误差的幅值和 $K_p$ 成反比，所以 $K_p$ 值就非常重要。如果 $K_p$ 太大，系统会变得不稳定。同样，对0型系统，阶跃输入产生的稳态误差与 $K_p$ 呈反比。\n系统加人 PI 控制器后，从 I 型系统转化为 II 型系统，对于稳定的 II 型系统，在输人斜坡信号时输出稳态误差一直为 0， $K_p$ 不再对控制系统的稳态误差有影响。现在的问题就是如何适当选择 $K_p$ 和 $K_I$ 的值才能够得到满意的瞬态响应。\n11.3.1 PI 控制的时域分析与设计 $$ 图11-21 PI 控制器的零极点配置 $$\n由式(11-34)表示的 PI 控制器的零极点配置如图11-21所示。初看起来，PI控制在改善系统的稳态误差时会牺牲系统的稳定性。但如果 $G_c(s)$ 零点选择适当，系统的阻尼和稳态误差性能都会得到改善。由于 PI 控制器本质上是一个低通滤波器，校正系统一般会有一个较慢的上升时间和较长的调节时间。PI控制器的另\u0026ndash;种可行设计就是将 $s=-K_I/K_P$ 处的零点设置得离原点比较近，离主导极点比较远，这样 $K_p$ 和 $K_I$ 的值应当相当得小。\n11.3.2 PI控制的频域分析与设计 在频域设计中，PI 控制器的传递函数为\n$$ G_c(s) = K_P+\\frac{K_I}{s}=\\frac{K_I(1+\\frac{K_P}{K_I}s)}{s}~~~(11-40) $$\n$$ 图11-22 $$\n$G_c(jω)$的 Bode 图如图11-22所示。当 $ω=∞$ 时，$G_c(jω)$ 的幅值为20lg $K_p$ dB,说明如果 $K_p$ 的值小于1就存在衰减，由此来改善系统的稳定性。$G_c(jω)$ 的相位一直为负，这样不利于稳定。因此我们置控制器的交接频率 $ω=K_I/K_p$, 使其在带宽要求允许的范围内尽可能地向左，这样 $G_c(jω)$ 的相位滞后特性不会降低系统的期望相位裕量。\n在频域中，设计用来满足期望相位裕量的 PI 控制器大体有以下几步:\n根据稳态性能要求，由控制系统的回路增益作出待校正系统的前向通道传递函数 $G_{p(s)}$ 的 Bode 图。 由 Bode 图得到控制系统的相位裕量和增益裕度。对于特殊的相位裕量要求，在 Bode 图中找到新增益穿越频率 $ω\u0026rsquo;_g$ 对应的相位裕量。为了能实现期望的相位裕量，校正系统传递函数的幅值曲线必须在新增益穿越频率处穿过 0dB 轴。 为了使待校正系统传递函数的幅值曲线在新的增益穿越频率 $ω\u0026rsquo;_g$ 处降为 0dB, PI 控制器所产生的衰减量一定要等于幅值曲线在新增益穿越频率处的增益。换句话说，令 $$ |G_P(jω\u0026rsquo;g)|{dB} = -20lgK_PdB,~~~K_P\u0026lt;1(11-41) $$\n我们有\n$$ K_P = 10^{-{|G_P(jω\u0026rsquo;g)|{dB}/20}},K_P\u0026lt;1\\(11-42)\u0026gt; $$\n一旦 $K_p$ 的值确定下来，就只需选择适当的 $K_I$ 值。到目前为止，我们假设加入 PI 控制器后只是通过减小 $G_c(jω)$ 的幅值改变了 $ω\u0026rsquo;_g$ 处的增益穿越频率，但原始相位并没有因此而改变。然而这种假设并不成立，从图11-22可见，与PI控制器的衰减特性相对应的是对相位裕量有害的相位滞后。显然，如果交接频率 $ω=K_I/K_p$ 远小于 $ω\u0026rsquo;_g$，PI 控制器的相位滞后对校正系统在接近 $ω\u0026rsquo;_g$ 处的相位影响很小。另一方面,$K_I/K_p$ 的值不应太小，否则系统的带宽将太低，因为这样会造成上升时间和调节时间太长。一般来说，$K_I/K_p$ 对应的频率至少是 $ω\u0026rsquo;_g$ 的十分之一(有时可高达二十分之一),即取\n$$ \\frac{K_I}{K_P}=\\frac{ω\u0026rsquo;_g}{10}(rad/s)~~~(11-43) $$\n根据这个基本原则，设计者选择 $K_I/K_p$ 值时要非常慎重，要考虑到它对 BW 的影响以及运算放大电路实现中的实际问题。\n由校正系统的 Bode 图检查性能指标是否全都满足要求。 把 $K_P$ 和$K_I$ 的值代人式( 11-40)，得到 PI 控制器的期望传递函数。 如果受控系统 $G_{p(s)}$ 为 0 型系统，可以根据斜坡误差系数的要求来选择 $K_I$ 这样可能只有 $K_P$ 一个参数需要确定。通过计算闭环系统中一组 $K_P$ 值对应的相位裕量、增益裕量、$M_r$ 和 BW,很容易选出最佳 $K_P$ 值。\n基于上述讨论，我们总结一下有关设计 PI 控制器的优缺点:\n改善阻尼，减小最大超调。 增加上升时间。 降低 BW。 改善增益裕量、相位裕量和 $M_r$。 过滤掉高频噪声。 需要注意的是，在PI控制器的设计过程中，相比于PD控制器，适当选择 $K_p$和$K_I$ 使在实现控制器电路时电容不太大变得更为困难。\n","date":"2023-08-30T18:35:47+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.3pi%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"11.3PI控制器的设计"},{"content":"前面讨论的所有控制系统中的控制器都是常数增益为K的放大器，控制器输出的控制信号只与控制器的输人呈简单的系数比例关系，这类控制方式称为比例控制。\n从直观上讲，除了比例运算外，我们也应该能够使用输入信号的微分或积分运算,因此，更为一般的连续控制器应包括加法器(加法或减法)、放大器、衰减器、微分器和积分器等元件。设计者的任务就是要确定采用其中的哪些元件，用多大的比例，以及如何把它们连接在一起。例如，在实际应用中最常用的一类控制器就是 PID 控制器，三个字母分别表示比例(Proportional)、积分(Integral)、微分(Derivative)，在 PID 控制器中微分和积分部分都有各自的性能含义。要想应用这些部分，就必须理解它们的基本特性。为此,首先我们考虑 PD 控制。\n任意一个二阶反馈控制系统的控制框图如 图11-3 所示，其传递函数为 $$ G_p(s) = \\frac{ω^2_n}{s(s+2ξω_n)}~~~~(11-1) $$\n$$ 图11-3~~~具有PD控制器的控制系统控制框图 $$\n采用比例-微分(PD)控制的串联控制器的传递函数为 $$ G_c(s) = K_p+K_DS~~~(11-2) $$ 因此,系统的控制信号为 $$ u(t) = K_pe(t)+K_D\\frac{de(t)}{dt}~~~(11-3) $$\n式中，$K_p$ 和 $K_D$ 分别是比例和微分系数。用表6-1中的元件，我们可以得到 PD 控制器的两种电路实现，如图11-4所示。图11-4a所示电路的传递函数为 $$ \\frac{E_o(s)}{E_{in}(s)} = \\frac{R_2}{R_1}+R_2C_1s~~~(11-4) $$ 比较式（11-2）和式（11-4）可得到: $$ K_p = R_2/R_1~~~~ K_D = R_2C_1~~~(11-5) $$ 图11-4b所示电路的传递函数为 $$ \\frac{E_o(s)}{E_{in(s)}} = \\frac{R_2}{R_1}+R_dC_ds~~~(11-6) $$ 同样,由式（11-2）和式(11-6)得到: $$ K_p = R_2/R_1~~~~~K_D = R_dC_d~~~~(11-7) $$\n$$ 图11-4 ~~~PD控制器的运算放大器电路实现 $$\n图11-4a 所示电路的优点是只用了两个运算放大器，但是该电路不允许独立选择 $K_P$ 和$K_D$, 因为它们通常取决于 $R_2$。PD 控制器的一个重要问题是，如果 $K_D$ 的值很大，则需要大的电容器 $C_1$。在 图11-4b 所示的电路中，允许独立控制 $K_P$ 和 $K_D$ 值。可以选择一个较大的 $R_d$ 值来补偿较大的 $K_D$,使得$C_d$，值比较合理。虽然在本书中我们不可能顾及设计控制器传递函数中的所有实际应用问题，但我们会介绍一些非常重要的注意事项。\n校正系统前向通道的传递函数为 $$ G(s) = \\frac{Y(s)}{E(s)}=G_c(s)G_p(s)=\\frac{ω^2_n(K_p+K_Ds)}{s(s+2ξω_n)}~~~(11-8) $$ 这表明 PD 控制相当于给系统前向通道传递函数在 $s =-K_p/K_D$ 处增加了一个单零点。\n11.2.1 PD控制的时域分析 PD 控制系统的瞬态时间响应曲线如 图11-5 所示，图11-5a 给出了具有比例控制的稳定系统单位阶跃响应曲线，从图中可以看到只具有比例控制的系统阶跃响应曲线具有偏大的最大超调量，并且振荡也很大。图11-5b 和 c 分别表示误差信号(即单位阶跃输入和输出 $y(t)$ 之差)及其对时间的导数 $de(t)/dt$。从 $e(t)$ 和 $de(t)/dt$ 这两个值的变化也可以看出系统的超调特性和振荡特性。为了方便解释，我们假设系统包含一个其转矩与 $e(t)$ 成正比的电动机。比例控制系统的性能分析如下:\n在时间段 0\u0026lt;t\u0026lt;$t_1$内: 误差信号 $e(t)$ 为正，电动机转矩也为正并且迅速增加。此时,转矩过大使得输出 $y(t)$ 产生大的超调和振荡，在这个时间段中无阻尼。 在 $t_1$\u0026lt;t\u0026lt;$t_3$内: e(t)为负，相应的转矩也为负。负转矩阻碍了输出的增长，最终使得输出 $y(t)$ 反向，低于额定值。 在 $t_3$\u0026lt;t\u0026lt;$t_5$内: 转矩再次为正，这样弥补了在上一个时间段由负转矩产生的欠调。由于假定系统是稳定的，所以每次振荡都会减小误差幅度，并且输出最终会达到稳定值。 $$ a)单位阶跃响应y(t)曲线 $$ $$ b)误差e(t)曲线 $$ $$ c)误差信号随时间变化的de(t)/dt曲线 $$ $$ 图11-5 微分控制下的y(t)、e(t)和 de(t)/dt的波形图 $$ 考虑到以上对系统时间响应的分析，可以得出造成高超调的因素主要有\n在 0\u0026lt;t\u0026lt;$t_1$, 正向校正转矩太大。 在 $t_1$\u0026lt;t\u0026lt;$t_2$, 制动转矩不合适。 因此，为了减小阶跃响应中的超调而又不明显增加上升时间的一种合理方法是:\n当 0\u0026lt;t\u0026lt;$t_1$时，减小正向校正转矩的幅值。 当 $t_1$\u0026lt;t\u0026lt;$t_2$时,增大制动转矩。 同理，在时间段 $t_2$\u0026lt;t\u0026lt;$t_4$ 内，应该减小在 $t_2$\u0026lt;t\u0026lt;$t_3$ 中的负向校正转矩，增加 $t_3$\u0026lt;t\u0026lt;$t_4$ 时间段内正向的制动转矩,由此来改善 $y(t)$ 的欠调。\n由式（11-2）描述的 PD 控制精确给出所需的补偿效果，式（11-3）给出PD控制的控制信号，从图11-5c可看出 PD 控制器具有如下作用:\n当 0\u0026lt;t\u0026lt;$t_1$, $de(t)/dt$ 为负，抑制了由 $e(t)$ 单独作用产生的原始转矩的增加。 当 $t_1$\u0026lt;t\u0026lt;$t_2$, $e(t)$ 和 $de(t)/dt$ 都为负，这意味着产生的负向制动转矩将大于只采用比例控制时的负向制动转矩。 当 $t_2$\u0026lt;t\u0026lt;$t_3$, $e(t)$ 和 $de(t)/dt$ 都反向,减小了产生欠调的负向制动转矩。 上述这些作用会使 $y(t)$ 产生较小的超调和欠调。\n我们还可以从另外一种角度来看待 PD 控制。由于 $de(t)/dt$ 表示 $e(t)$ 的斜率，PD 控制在本质上是一种超前控制,即知道了斜率，控制器可以预料到误差的方向由此来更好地控制系统。通常情况下，在线性系统中，如果由阶跃响应得到的 $e(t)$ 或 $y(t)$ 的斜率很大，相应地就会产生较大的超调量，微分控制测得 $e(t)$ 的瞬间斜率，提前预测出大的超调量,在大超调产生之前做出适当的校正。\n直观上讲，微分控制只有当系统的稳态误差随时间发生变化时才会起作用。如果稳态误差随时间保持不变，误差的时间微分为零，控制器的微分部分就不能给系统提供输入。当稳态误差随时间增加时，转矩与 $de(t)/dt$ 成比例变化，就会减小误差幅值。我们知道控制系统的类型影响单位反馈控制系统的稳态误差，由式（11-8）可以清楚地看到 PD 控制并没有改变系统类型。\n11.2.2 PD控制的频域分析 在频域设计中, PD 控制的传递函数为 $$ G_{c(s)} = K_p+K_DS = K_p(1+\\frac{K_D}{K_P}S)~~~(11-9) $$ 这样可以更容易地用 Bode 图解释。式(11-9)中 $K_p=1$ 的 Bode 图如图11-6所示。一般情况下，比例控制增益 $K_p$ 可以和系统的串联增益合并在一起，这样PD控制器的零频增益可看成单位增益。由Bode图11-6可以看出 PD 控制器是一个高通滤波器，有高通滤波器的高通滤波性，即相位超前特性，可以用来提高控制系统的相位裕量。但PD控制器的幅值特性将增益穿越频率推到一个更高值。这样 PD 控制器的设计原理就涉及控制器交接频率 $\\omega=K_P/K_D$ 的配置，使得在新增益穿越频率点处可以有效地改善系统的相位裕量。对于一个给定系统，有一个改善系统阻尼的 $K_P/K_D$ 最佳范围。在 PD 控制器的实际设计中，还要考虑选择 $K_P$ 和 $K_D$ 值。由于 PD 控制器的高通特性，在频域中 PD 控制器的另一个显著优点是，在大部分情况下增加了控制系统的 BW，同时减小了阶跃响应的上升时间，但它的缺点是高通滤波器的微分部分放大了系统在输入处的高频噪声。\n11.2.3 PD控制的作用总结 虽然PD控制器对有轻微振荡或初始不稳定的系统不适用，但正确设计的 PD 控制器可能通过以下几个方面影响控制系统的性能:\n改善阻尼,减小最大超调量。 缩短上升时间和调节时间。 增加 BW。 改善 GM、PM 和 $M_r$. 可能放大高频噪声。 在电路实现中可能需要相当大的电容。 $$ 图11-6~~~1+\\frac{K_DS}{K_p},K_p=1的Bode图 $$ 下面几个例子解释了 PD 控制器对二阶系统的时域响应和频域响应的影响。\n","date":"2023-08-30T18:35:29+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.2pd%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"11.2PD控制器的设计"},{"content":"我们将利用在前述章节中介绍的所有基础知识和分析方法来实现控制系统设计这一最终目标。以图11-1所示控制框图表示的受控过程为例，控制系统设计主要涉及以下3个步骤:\n确定系统应该做什么以及如何做(设计要求)。 根据控制器或校正器在受控系统中的连接方式,确定其结构配置。 确定控制器的参数,使得系统达到设计目标。我们将在下面几节详细介绍控制系统的设计。 11.1.1 设计要求 正如第7章所讨论的，我们使用设计要求来描述给定输入系统的预期性能。根据不同的应用，设计要求也不尽相同，但通常包括相对稳定性、稳态精度(误差)、瞬态响应和频率响应等特性。在一些特殊的应用中，在系统设计时也会考虑对参数变化的灵敏性,即鲁棒性或抗干扰性。\n线性控制系统的设计既可以使用时域方法也可以采用频域方法。例如，稳态精度可以通过阶跃响应、斜坡响应或抛物线响应的方法来实现，而且用时域方法可以使系统更为方便地达到设计要求。对于其他的要求，例如单位阶跃下的最大超调、上升时间和调节时间也都适用于时域设计。而对于增益裕量、相位裕量和谐振峰值 $M$,，这些衡量相对稳定性的频域特性，通常由Bode图、极坐标图、相位-增益图和 Nichols图来表示，再运用图解法进行研究。\n对于二阶系统，时域性能指标和频域性能指标之间有明确的对应关系，但对于高阶系统而言，这种时域指标和频域指标之间的关系就难以建立。值得一提的是，对控制系统的分析和设计是一个需要经验性的工作。对于同一个问题，设计者可以从诸多方法中选取合适的一个来进行设计。\n因此，设计者可以根据个人喜好在时域方法或频域方法中选择一种最合适的方法来进行控制系统的设计。需要注意的是，在绝大多数情况下，时域指标(例如最大超调、上升时间和调节时间)通常作为系统性能的最终衡量标准。对于一个没有经验的设计者而言，很难理解诸如增益裕量、相位裕量和谐振峰值等频域特性和实际控制系统之间的物理联系。例如，20dB 的增益裕量是否能保证最大超调小于10%?又比如说，人们很容易理解控制系统的最大超调应该小于5%，调节时间应该小于0.01s这类指标，但相位裕量应该为60°、M,应小于1.1这类频域指标与系统性能之间的关系却并不直观。以下几点详细解释了如何选择使用时域或频域特性指标以及选用这些指标的原因。\n以往，在设计线性控制系统时，会采用大量的基于频域的图形工具，例如 Bode图、Nyquist图、增益–相位图和Nichols图等。这些图的优点是:它们不是由精确的点绘制而成的，而是用近似的方法画的。根据图表，设计者可以得到控制系统的增益裕量、相位裕量和M,等频域特性，然后再根据频域方法进行设计。这样使得设计高阶控制系统也不会特别困难。某些类型的控制器在频域中有现成的设计方法，从而可以最大限度地避免反复试验。 时域中的设计主要使用诸如上升时间、延迟时间、调节时间和最大超调等性能指标，但这些分析只适用于二阶系统或可以近似成二阶系统的高阶系统。对于一般高于二阶的控制系统,在时域中就很难遵循一般的设计步骤。 随着高性能、易操作的计算机软件（例如MATLAB)的迅速发展和广泛应用，控制系统的设计也发生了巨大的变化。借助MATLAB，设计者可以在几分钟内完成大量的时域性能指标的设计。这种基于手动执行图形设计的便利性大大降低了频域设计以往的优势。\n在本章中，我们结合小型 MATLAB工具箱来帮助你理解示例。在本章结尾将介绍MATLAB SISO设计工具，该工具将有助你更好地使用根轨迹和频域方法。\n通常来说，选取一组有意义的频域指标使得对应时域性能指标满足要求是很困难的(有经验的设计者除外)。例如，除非我们知道性能指标要求相位裕量为60°所对应的最大超调，否则该频域指标将是无意义的。事实证明，为了控制最大超调，通常必须至少指定相位裕量或M,。最终，建立一组频域特性变成了一个反复试错的过程。然而，频域方法在解决抗噪和系统灵敏度性能的问题上还是很有用的。更重要的是，频域方法为系统设计提供了另外―种选择。因此，为了方便地比较时域设计和频域设计这两种方法的特点,本章将同时介绍这两种设计方法。\n11.1.2控制器结构 通常来说，线性受控过程的动态行为可以用图11-1所示控制框图表示。控制系统的设计目标是在一定的时间间隔内通过控制输入信号u(t)使得输出向量y(t)表示的受控变量满足期望要求。 控制系统中的大多数常规设计方法依赖于所谓的固定结构设计: 设计者一开始就决定了整个设计系统的基本结构，以及控制器相对于受控过程的位置。然后设计问题变成控制器元件的设计。由于大多数控制行为涉及对系统性能特征的修正或校正，所以一般使用固定结构的设计也称为校正。 $$ a)串联(级联)校正 $$ $$ b)反馈校正 $$ $$ c)状态反馈校正 $$ $$ d)串联反馈校正(带二阶自由度) $$ $$ e)带有串联校正的前向校正(带二阶自由度) $$ $$ f)前馈矫正(带二阶自由度) $$ 几个常用的带有校正控制器的控制系统结构如图11-2所示。简单描述如下:\n串联(级联)校正。图11-2a展示了一种最为常用的系统控制结构:在受控过程中串联一个控制器，这种结构被称为串联或级联校正。 反馈校正。如图11-2b所示，这种将控制器放在负反馈回路中的设计称为反馈校正。 状态反馈校正。系统的状态变量经定常增益得到控制信号，这被称为状态反馈,如图11-2c所示。状态反馈的缺点是，对高阶系统来说，状态变量较多，为了进行状态反馈就需要较多的传感器来检测状态变量，这样在实际应用时造价高且不可行。即使对于低阶系统，并不是所有的变量都可以直接可测，因此可能需要用观测器或估计器根据测得的输出变量来估计状态变量。 串联反馈校正。图11-2d是由一个串联控制器和一个反馈控制器组成的串联反馈校正。 前馈校正。图 11-2e 和 11-2f 所示的都是前馈校正。图10-2e中，前馈控制器 $G_{cf}(s)$ 在前向通道中与由控制器 $G_c(s)$ 和受控过程组成的闭环系统串联在一起。在图11-2f中，前馈控制器 $G_{cf}(s)$ 与前向通道平行，而不在控制系统回路中，这样就不会影响原系统特征方程的特征根。可以选择 $G_{cf}(s)$ 的零极点来增加或抵消系统闭环传递函数的零极点。 图11-2a~c所示的系统中即使有的控制器中有多个可变参数，但每个控制系统中都只有一个控制器，因此都属于一阶自由度校正。用一阶自由度控制器来实现性能指标有一定的局限性。例如，如果系统要满足一定的稳定性，那么对参数变化就要不敏感;或者，如果选择特征方程的特征根来提供一定的相对阻尼，由于闭环传递函数存在零点,系统阶跃响应的最大超调量仍可能过大。图11-2d~f给出了带有二阶自由度的校正设计。\nPID控制器是校正设计中一种常用的控制器，在PID控制中，受控信号经过比例控制、积分控制和微分控制。因为这些信号在时域容易实现而且也容易观察，所以一般用时域方法进行设计。除了PID控制器，比较常用的控制器还有超前控制器、滞后控制器、超前–滞后控制器以及陷波控制器。这些控制器都是根据它们各自的频域特性来命名的，因此经常在频域设计中用到这些控制器。但是，尽管有这些设计倾向，从时域和频域两方面来分析设计结果对于所有的控制系统设计都是有益的。因此，本章会广泛使用时域和频域这两种方法。\n需要指出的是，绝不仅仅只有这几种校正方法。我们将在本章后几节中详细介绍这些校正设计方法。图11-2表示的系统结构不仅适用于连续时间控制，也适用于控制器是数字的(在这种情况下，控制器必须是数字的)且带有必要接口和信号变换器的离散时间控制。\n11.1.3设计的基本原则 当一个控制器结构确定后，设计者还必须选择能够满足设计要求的控制器类型以及元件参数。对于同一个控制系统设计要求，设计者可以设计出各种控制器类型。在工程实际应用中人们一般选择能够满足设计要求的最简单的控制器。大多数情况下，控制器越复杂其造价也就越高，可靠性也就越差，设计难度也更大。选择特定应用的控制器经常是基于设计者的经验和直觉的。这使得控制器设计不仅是一门科学，也是一种艺术。对于新手来说，开始很难选择一个合适的控制。本章会提供指导性的经验，以说明控制系统设计的基本要素。\n选择好控制器，下一步就是选择控制器的参数，也就是组成控制器的一个或多个传递函数的系数。基本的方法是用前面章节所讲到的分析方法来确定每个参数对于设计要求和系统特性的影响，并进而确定满足所有设计要求的控制器参数。这种方法虽然简单，但通常情况下控制器参数会互相影响，使得设计要求相互矛盾，造成设计上的重复。例如，选定一个参数以满足最大超调量要求，但选定另外参数满足上升时间时，最大超调特性可能就不再满足了。显然，所要设计的性能指标越多，控制器参数也就越多，设计过程也就越复杂。\n无论是在时域还是在频域范围内设计，均需要注意以下几条基本的设计法则。在时域中，设计通常在s平面上，使用根轨迹方法。在频域中，通过设计回路传递函数的增益和相位来达到设计要求。 一般而言，总结时域和频域的特征是很有用的，这样它们可作为设计指导方针:\n闭环极点为复共栀极点，系统为欠阻尼系统，单位阶跃响应为阻尼振荡过程;闭环极点都是实数，阶跃响应为过阻尼状态。但即使系统过阻尼，闭环系统的零点也可能导致系统超调。 系统的动态性能基本上由s平面上接近原点的闭环极点决定，闭环极点越靠左，时间响应分量的下降速度越快。 对系统动态性能起主要作用的闭环极点称为主导极点，系统的主导极点在s平面上越靠左,系统的响应就越快,带宽也越大。 在s平面上主导极点越靠左，在实际应用中实现这样的系统的造价就越高，系统的内部信号也越大。就像我们用锤子砸钉子，锤子冲击钉子的速度越快，砸钉子的力量就越大，所要消耗的能量也越大;同样，跑车比一般汽车速度快，它所耗费的油也多。 当控制系统传递函数的一对零极点近似可抵消时，这个极点产生的那部分系统响应会有小的幅值。 控制系统的时域特性和频域特性之间有一定的对应关系:上升时间和带宽是反比关系，增大相位裕量和增益裕量，减小M，值可以改善系统的衰减性。 ","date":"2023-08-30T18:35:06+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/11.1%E5%BC%95%E8%A8%80/","title":"11.1引言"},{"content":"","date":"2023-08-30T18:34:50+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.16matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/","title":"10.16MATLAB工具和案例研究"},{"content":"","date":"2023-08-30T18:34:30+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.15%E9%A2%91%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%81%B5%E6%95%8F%E5%BA%A6%E7%A0%94%E7%A9%B6/","title":"10.15频域中的灵敏度研究"},{"content":"","date":"2023-08-30T18:33:14+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.14nichols%E5%9B%BE%E5%BA%94%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%8D%95%E4%BD%8D%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/","title":"10.14Nichols图应用于非单位反馈系统"},{"content":"","date":"2023-08-30T18:32:54+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.13%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%B8%B8m%E6%9B%B2%E7%BA%BF-nichols%E5%9B%BE/","title":"10.13幅值 相位图中的定常M曲线 Nichols图"},{"content":"","date":"2023-08-30T18:32:28+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.12%E7%94%A8%E5%B9%85%E5%80%BC-%E7%9B%B8%E4%BD%8D%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/","title":"10.12用幅值 相位图进行稳定性分析"},{"content":"","date":"2023-08-30T18:32:12+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.11%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8Ebode%E5%9B%BE%E7%9A%84%E5%B9%85%E5%80%BC%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%96%9C%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"10.11相对稳定性与Bode图的幅值曲线的斜率之间的关系"},{"content":"","date":"2023-08-30T18:31:51+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.10%E7%94%A8bode%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/","title":"10.10用Bode图进行稳定性分析"},{"content":"","date":"2023-08-30T18:31:21+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.9%E7%9B%B8%E5%AF%B9%E7%A8%B3%E5%AE%9A%E6%80%A7-%E5%A2%9E%E7%9B%8A%E8%A3%95%E9%87%8F%E5%92%8C%E7%9B%B8%E4%BD%8D%E8%A3%95%E9%87%8F/","title":"10.9相对稳定性 增益裕量和相位裕量"},{"content":"","date":"2023-08-30T18:11:40+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.8%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E5%AF%B9nyquist%E5%9B%BE%E7%9A%84%E5%BD%A2%E7%8A%B6%E7%9A%84%E5%BD%B1%E5%93%8D/","title":"10.8增加的极点和零点对Nyquist图的形状的影响"},{"content":"","date":"2023-08-30T18:11:21+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.7%E7%A4%BA%E4%BE%8B-%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/","title":"10.7示例 最小相位传递函数的Nyquist判据"},{"content":"","date":"2023-08-30T18:10:59+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.6%E6%A0%B9%E8%BD%A8%E8%BF%B9%E5%92%8Cnyquist%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"10.6根轨迹和Nyquist图的关系"},{"content":"","date":"2023-08-30T18:10:39+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.5%E5%85%B7%E6%9C%89%E6%9C%80%E5%B0%8F%E7%9B%B8%E4%BD%8D%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9A%84nyquist%E5%88%A4%E6%8D%AE/","title":"10.5具有最小相位传递函数的系统的Nyquist判据"},{"content":"","date":"2023-08-30T18:10:17+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.4nyquist%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E6%8D%AE-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","title":"10.4Nyquist稳定性判据 基本原理"},{"content":"","date":"2023-08-30T18:09:44+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.3%E5%89%8D%E5%90%91%E9%80%9A%E9%81%93%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E6%9E%81%E7%82%B9%E5%92%8C%E9%9B%B6%E7%82%B9%E7%9A%84%E5%BD%B1/","title":"10.3前向通道传递函数增加极点和零点的影"},{"content":"","date":"2023-08-30T18:09:25+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.2%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%90%E6%8C%AF%E5%B3%B0%E5%80%BC%E8%B0%90%E6%8C%AF%E9%A2%91%E7%8E%87%E5%92%8C%E5%B8%A6%E5%AE%BD/","title":"10.2二阶系统的谐振峰值、谐振频率和带宽"},{"content":"","date":"2023-08-30T18:09:09+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/10.1%E5%BC%95%E8%A8%80/","title":"10.1引言"},{"content":"","date":"2023-08-30T18:08:52+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.6matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/","title":"9.6MATLAB工具箱"},{"content":"","date":"2023-08-30T18:08:31+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.5%E6%A0%B9%E8%BD%A8%E8%BF%B9%E6%97%8F-%E5%A4%9A%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E6%83%85%E5%BD%A2/","title":"9.5根轨迹族 多参数变化情形"},{"content":"","date":"2023-08-30T18:08:15+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.4%E6%A0%B9%E8%BD%A8%E8%BF%B9%E8%AE%BE%E8%AE%A1/","title":"9.4根轨迹设计"},{"content":"","date":"2023-08-30T18:08:01+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.3%E6%A0%B9%E7%81%B5%E6%95%8F%E5%BA%A6/","title":"9.3根灵敏度"},{"content":"","date":"2023-08-30T18:07:41+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.2%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E6%80%A7%E8%B4%A8%E8%AF%A6%E8%A7%A3/","title":"9.2根轨迹的性质详解"},{"content":"","date":"2023-08-30T18:07:25+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/9.1%E6%A0%B9%E8%BD%A8%E8%BF%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8/","title":"9.1根轨迹的基本性质"},{"content":"","date":"2023-08-30T18:07:07+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.21%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstorms%E6%9C%BA%E5%99%A8%E8%87%82%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/","title":"8.21案例研究LEGO_MINDSTORMS机器臂系统的位置控制"},{"content":"","date":"2023-08-30T18:06:37+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.20matlab%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%92%8C%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/","title":"8.20MATLAB工具箱和案例学习"},{"content":"","date":"2023-08-30T18:06:18+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.19%E5%B8%A6%E6%9C%89%E7%A7%AF%E5%88%86%E6%8E%A7%E5%88%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88/","title":"8.19带有积分控制的状态反馈"},{"content":"","date":"2023-08-30T18:05:53+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.18%E9%80%9A%E8%BF%87%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E8%BF%9B%E8%A1%8C%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE/","title":"8.18通过状态反馈进行极点配置"},{"content":"","date":"2023-08-30T18:05:36+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.17%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6/","title":"8.17状态反馈控制"},{"content":"","date":"2023-08-30T18:05:21+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.16%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%A3%81%E7%90%83%E6%82%AC%E6%B5%AE%E7%B3%BB%E7%BB%9F/","title":"8.16案例研究 磁球悬浮系统"},{"content":"","date":"2023-08-30T18:04:57+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.15%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7%E5%AE%9A%E7%90%86/","title":"8.15能控性和能观性的不变性定理"},{"content":"","date":"2023-08-30T18:04:42+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.14%E8%83%BD%E6%8E%A7%E6%80%A7%E8%83%BD%E8%A7%82%E6%80%A7%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"8.14能控性、能观性和传递函数之间的关系"},{"content":"","date":"2023-08-30T18:04:28+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.13%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E8%A7%82%E6%80%A7/","title":"8.13线性系统的能观性"},{"content":"","date":"2023-08-30T18:04:14+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.12%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7/","title":"8.12控制系统的能控性"},{"content":"","date":"2023-08-30T18:03:57+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.11%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%88%86%E8%A7%A3/","title":"8.11传递函数分解"},{"content":"","date":"2023-08-30T18:03:36+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.10%E7%9B%B8%E4%BC%BC%E5%8F%98%E6%8D%A2/","title":"8.10相似变换"},{"content":"","date":"2023-08-30T18:03:20+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.9%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/","title":"8.9特征方程、特征值和特征向量"},{"content":"","date":"2023-08-30T18:03:04+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.8%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"8.8状态方程与传递函数之间的关系"},{"content":"","date":"2023-08-30T18:02:46+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.7%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"8.7状态方程与高阶微分方程之间的关系"},{"content":"","date":"2023-08-30T18:02:32+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.6%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/","title":"8.6状态转移方程"},{"content":"","date":"2023-08-30T18:02:19+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.5%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5/","title":"8.5状态转移矩阵"},{"content":"","date":"2023-08-30T18:02:03+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.4%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E5%90%91%E9%87%8F-%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/","title":"8.4状态方程的向量 矩阵表示"},{"content":"","date":"2023-08-30T18:01:48+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.3%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/","title":"8.3一阶微分系统的状态方程"},{"content":"","date":"2023-08-30T18:01:15+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.2%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%92%8C%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/","title":"8.2控制框图、传递函数和状态控制框图"},{"content":"","date":"2023-08-30T18:01:00+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/8.1%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90/","title":"8.1状态变量分析"},{"content":"","date":"2023-08-30T18:00:37+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.10%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstorms_nxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E4%BB%8B%E7%BB%8D%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/","title":"7.10控制实验室LEGO_MINDSTORMS_NXT电动机介绍—位置控制"},{"content":"","date":"2023-08-30T18:00:02+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.9%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/","title":"7.9案例研究 定位控制系统的时域分析"},{"content":"","date":"2023-08-30T17:59:44+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E5%AF%BC%E9%9B%B6%E6%9E%81%E7%82%B9/","title":"7.8传递函数的主导零极点"},{"content":"","date":"2023-08-30T17:59:18+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.7%E5%9F%BA%E7%A1%80%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%A2%9E%E5%8A%A0%E9%9B%B6%E6%9E%81%E7%82%B9%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D/","title":"7.7基础控制系统以及传递函数增加零极点带来的影响"},{"content":"","date":"2023-08-30T17:59:05+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.6%E7%A8%B3%E6%80%81%E8%AF%AF%E5%B7%AE/","title":"7.6稳态误差"},{"content":"","date":"2023-08-30T17:58:49+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.5%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9A%82%E6%80%81%E5%93%8D%E5%BA%94/","title":"7.5二阶系统的暂态响应"},{"content":"","date":"2023-08-30T17:58:30+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.4%E4%B8%80%E9%98%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/","title":"7.4一阶系统的时间响应"},{"content":"","date":"2023-08-30T17:58:09+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.3%E5%8D%95%E4%BD%8D%E9%98%B6%E8%B7%83%E5%93%8D%E5%BA%94%E5%92%8C%E6%97%B6%E5%9F%9F%E6%8F%8F%E8%BF%B0/","title":"7.3单位阶跃响应和时域描述"},{"content":"","date":"2023-08-30T17:57:44+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.2%E8%AF%84%E4%BB%B7%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B8%E5%9E%8B%E6%B5%8B%E8%AF%95%E4%BF%A1%E5%8F%B7/","title":"7.2评价控制系统时间响应性能的典型测试信号"},{"content":"","date":"2023-08-30T17:57:30+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/7.1%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%8D%E5%BA%94/","title":"7.1连续时间系统的时间响应"},{"content":"","date":"2023-08-30T17:57:09+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.6%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E5%92%8C%E8%A1%A8%E5%BE%81/","title":"6.6虚拟实验室LEGO_MINDSTORMSNXT电动机入门—建模和表征"},{"content":"","date":"2023-08-30T17:56:28+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.5%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/","title":"6.5案例研究"},{"content":"","date":"2023-08-30T17:55:55+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.4%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA%E7%9A%84%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%8F%8A%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6/","title":"6.4直流电动机的速度控制及位置控制"},{"content":"","date":"2023-08-30T17:55:38+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%B5%81%E7%94%B5%E5%8A%A8%E6%9C%BA/","title":"6.3控制系统中的直流电动机"},{"content":"","date":"2023-08-30T17:55:21+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%BC%96%E7%A0%81%E5%99%A8/","title":"6.2控制系统中的传感器和编码器"},{"content":"","date":"2023-08-30T17:55:06+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/6.1%E6%9C%89%E6%BA%90%E7%94%B5%E6%B0%94%E5%85%83%E4%BB%B6%E7%9A%84%E5%BB%BA%E6%A8%A1-%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"6.1有源电气元件的建模 运算放大器"},{"content":"","date":"2023-08-30T17:54:34+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.4matlab%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/","title":"5.4MATLAB工具和案例分析"},{"content":"","date":"2023-08-30T17:54:06+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.3routh-hurwitz%E5%88%A4%E6%8D%AE/","title":"5.3Routh Hurwitz判据"},{"content":"","date":"2023-08-30T17:53:44+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.2%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95/","title":"5.2稳定性判定方法"},{"content":"","date":"2023-08-30T17:53:27+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/5.1%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BB%8B%E7%BB%8D/","title":"5.1稳定性介绍"},{"content":"","date":"2023-08-30T17:53:11+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.5matlab%E5%B7%A5%E5%85%B7%E7%AE%B1/","title":"4.5MATLAB工具箱"},{"content":"","date":"2023-08-30T17:52:57+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.4%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/","title":"4.4案例研究"},{"content":"","date":"2023-08-30T17:52:34+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.3%E7%8A%B6%E6%80%81%E5%9B%BE/","title":"4.3状态图"},{"content":"","date":"2023-08-30T17:52:18+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.2%E4%BF%A1%E5%8F%B7%E6%B5%81%E5%9B%BE/","title":"4.2信号流图"},{"content":"","date":"2023-08-30T17:52:01+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/4.1%E6%8E%A7%E5%88%B6%E6%A1%86%E5%9B%BE/","title":"4.1控制框图"},{"content":"","date":"2023-08-30T17:40:47+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.9%E7%BA%BF%E6%80%A7%E5%8C%96%E5%9B%9E%E9%A1%BE-%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95/","title":"3.9线性化回顾 状态空间方法"},{"content":"","date":"2023-08-30T17:40:28+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.8matlab%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/","title":"3.8MATLAB案例研究"},{"content":"","date":"2023-08-30T17:40:10+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.7%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/","title":"3.7线性齐次状态方程的解"},{"content":"","date":"2023-08-30T17:39:52+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B/","title":"3.6系统的一阶微分方程 状态方程"},{"content":"","date":"2023-08-30T17:39:17+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.5%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%84%89%E5%86%B2%E5%93%8D%E5%BA%94%E5%92%8C%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0/","title":"3.5线性系统的脉冲响应和传递函数"},{"content":"","date":"2023-08-30T17:38:56+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.4%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","title":"3.4拉普拉斯变换在线性常微分方程求解中的应用"},{"content":"","date":"2023-08-30T17:38:37+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.3%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80%E7%9A%84%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%80%86%E5%8F%98%E6%8D%A2/","title":"3.3部分分式展开的拉普拉斯逆变换"},{"content":"","date":"2023-08-30T17:38:05+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.2%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/","title":"3.2拉普拉斯变换"},{"content":"","date":"2023-08-30T17:37:36+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/3.1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%BB%8B%E7%BB%8D/","title":"3.1微分方程介绍"},{"content":"","date":"2023-08-30T17:35:48+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.6%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6lego_mindstormsnxt%E7%94%B5%E5%8A%A8%E6%9C%BA%E6%9C%BA%E6%A2%B0%E5%BB%BA%E6%A8%A1/","title":"2.6案例研究LEGO_MINDSTORMSNXT电动机—机械建模"},{"content":"","date":"2023-08-30T17:33:10+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.5%E7%B1%BB%E6%AF%94/","title":"2.5类比"},{"content":"","date":"2023-08-30T17:32:51+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.4%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96/","title":"2.4非线性系统的线性化"},{"content":"","date":"2023-08-30T17:32:30+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.3%E7%AE%80%E5%8D%95%E7%83%AD%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%AE%80%E5%8D%95%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/","title":"2.3简单热系统和简单流体系统的建模"},{"content":"","date":"2023-08-30T17:31:55+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.2%E7%AE%80%E5%8D%95%E7%94%B5%E6%B0%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/","title":"2.2简单电气系统的建模"},{"content":"","date":"2023-08-30T17:31:35+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/2.1%E7%AE%80%E5%8D%95%E6%9C%BA%E6%A2%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BB%BA%E6%A8%A1/","title":"2.1简单机械系统的建模"},{"content":"本节的目标是让读者对实际系统的控制器设计过程有更好的理解，我们将以 LEGO MINDSTORMS NXT 可编程机器人系统为例。虽然此处使用的示例在现阶段可能看起来难度过大，但是这个例子可以演示成功地实施控制系统所需要的步骤。读者可以在完成附录D的学习以后再来回顾这个示例。\n项目描述\n如图1-16所示，系统的设置是一辆用 MATLAB 和 Simulink 控制的 LEGO MINDSTORMS 车。如图1-17和图1-18所示，此 LEGO 车配有超声波传感器、光传感器、指示灯、NXT 电机齿轮箱和NXT模块。编码器(传感器)用于读取电动机齿轮箱的角位置。NXT模块最多可以读取4个传感器的输人并通过 RJ12 电缆控制多达三台电动机。详细介绍请参见第8章。将超声波传感器放置在小车的前侧以检测车身与障碍物之间的距离。将光传感器朝下放置以检测运行表面的颜色，当检测到颜色为白色时表示出发。使用 USB 把系统与主机连接，主机使用蓝牙连接实时记录编码器数据。\n○ 此文章待完成\n","date":"2023-08-30T17:31:07+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.11%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E5%9F%BA%E4%BA%8Elegomindstorms%E7%9A%84%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BE%86%E9%81%BF%E9%9A%9C/","title":"1.11案例研究 基于LEGOMINDSTORMS的智能车辆避障"},{"content":"区别于连续系统，离散控制系统中一点或多点信号是以脉冲序列或数字编码的形式出现的。通常离散控制系统又分为采样控制系统和数字控制系统。采样控制系统指一大类使用脉冲信号的离散系统。数字控制系统中使用数字计算机或控制器，因此信号是数字编码的，例如二进制码。\n一般情况下，采样系统每隔一定的时间获取一次数据或信息。例如，控制系统的误差信号只能由脉冲提供，在两个相邻的脉冲之间的时间间隔里，系统是收不到误差信号的。严格来讲，采样数据系统属于交流系统，因为信号是脉冲调制的。 $$ 图1-14采样控制系统的控制框图 $$ 图1-14说明了一个典型采样系统的运行过程。对系统施加连续输人信号 $r(t)$,误差信号 $e(t)$ 由采样器采样，采样器的输出是脉冲序列。采样器的采样速率可以一致，也可以不一致。在系统中整合采样器有很多好处，其中一个重要的好处在于系统使用的一.些昂贵的设备在一些控制通道上是共享时间的; 另一个好处是脉冲信号不易受噪声影响。\n由于数字计算机在尺寸、灵活性方面有很多优势，计算机控制近年来越来越流行。许多航空系统含有数字控制器，这种控制器可以在不超过本书大小的空间里集成成千上万的离散元件。图1-15是导弹制导控制的数字自动飞行系统包含的基本元件。 $$ 图1-15 制导导弹的数字自动飞行系统 $$\n","date":"2023-08-30T17:30:17+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.10%E7%A6%BB%E6%95%A3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/","title":"1.10离散控制系统"},{"content":"连续系统是指各部分信号是连续时间变量t的函数的系统。连续系统中的信号可以进一步分为交流信号和直流信号。与电子工程中的交直流定义不同，交流和直流控制系统在控制系统中具有特殊意义。交流控制系统通常是指系统信号已根据某种调制模式调制过。直流控制系统只是意味着信号没有经过调制，但仍然有符合传统定义的交流信号。图1-12是闭环直流控制系统的原理图，图.上也显示了系统的阶跃响应波形。直流控制系统的典型元件是稳压器、直流放大器、直流电动机和直流转速表等。 $$ 图1-12 典型直流闭环控制系统的原理图 $$ 图1-13是一个典型的交流控制系统原理图，其功能等同于图1-12所示直流系统。这种系统中的信号是经过调制的，也就是说，信息由交流载波信号传输。需要注意的是，交流系统输出的被控变量的性能与直流系统中的相似。调制过的信号由交流电动机的低通特性解调。交流控制系统广泛用于飞行器与导弹控制系统，这类系统中往往有噪声和干扰引起的问题。在交流控制系统中使用400Hz或更高频率的载波信号，可以使系统不易受低频噪声影响。交流控制系统的典型元件是自整角机、交流放大器、交流电动机、陀螺仪和加速度计等。 $$ 图1-13典型交流闭环控制系统的原理图 $$\n","date":"2023-08-30T17:30:01+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.9%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/","title":"1.9连续控制系统"},{"content":"如果系统参数在系统运行过程中相对于时间是不变的，那么称此系统为时不变系统。实际上，多数物理系统都包含\u0026ndash;些参数随时间波动或变化的部件。比如在电动机刚启动以及温度升高时，电动机的绕线电阻会发生变化。时变系统的另-一个例子是制导导弹控制系统，飞行中导弹的质量会随着其携带的燃料的不断消耗而减少。尽管不具非线性的时变系统仍然是线性系统，但是这类系统的分析和设计往往比线性时不变系统困难得多。\n","date":"2023-08-30T17:29:41+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.8%E6%97%B6%E4%B8%8D%E5%8F%98%E4%B8%8E%E6%97%B6%E5%8F%98%E7%B3%BB%E7%BB%9F/","title":"1.8时不变与时变系统"},{"content":"这种分类是根据分析与设计的方法进行的。严格来说，线性系统实际上并不存在，因为实际的物理系统总是具有一定程度的非线性。线性反馈控制系统被作为一种理想化模型而提出。当控制系统内信号的幅值被限制在系统各部件呈现线性特征的范围内时，此系统就可以被认为是线性的。但是当信号幅值超过部件线性运行区域时，根据非线性的程度，系统就可能被认为是非线性的了。例如，控制系统中常用的放大器在输入信号较大时呈现饱和特性;电动机电磁场往往也具有饱和特性。控制系统中其他常见的非线性现象包括: 啮合齿轮之间的齿隙和死区，弹簧的非线性特性，两移动组件之间的非线性摩擦力或力矩等。控制系统中常利用非线性特性来改善系统性能或提供更高效的控制。例如，为了实现最短时间控制，许多导弹和太空船的控制系统里常使用开关型(bang-bang或继电)控制器。其中，典型的例子是装在导弹和飞船侧面的喷管，它们产生反作用力矩提供姿态控制。这些喷管往往以全关或全开的方式工作，它们能在一定时间里喷出固定量的气体来控制弹(船)体姿态。\n对于线性系统，有许多解析的和图形的方法可以用于分析与设计。本书的主要内容讲述的是线性系统的分析与设计。至于非线性系统，则往往难以用数学方法处理，也没有适用于各种非线性系统的通用方法。在设计控制器的开始阶段，可以基于线性模型设计不考虑系统的非线性，然后采用计算机仿真，把设计好的控制器用于非线性模型加以评估或重新设计。第8章要介绍的控制实验室主要用于使用逼真的物理部件来模拟实际系统的特征。\n","date":"2023-08-30T17:29:22+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.7%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/","title":"1.7线性系统与非线性系统"},{"content":"反馈控制系统可以有多种分类方法，如何分类取决于分类的目的。例如，按照分析和设计的方法，反馈控制系统可以分为线性与非线性系统、时变与时不变系统。按照系统中信号的种类，可以分为连续与离散系统、调制与非调制系统。控制系统还常根据系统的主要目的来分类。举例来说，位置控制系统和速度控制系统控制的正是与其名称同名的那些输出变量。在第11章里，控制系统的类型是由开环传递函数确定的。总之，根据系统的一些特征有很多种分类方法。在着手分析和设计系统之前，掌握一些控制系统的常见分类方法是很重要的。\n","date":"2023-08-30T17:29:04+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.6%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B/","title":"1.6反馈控制系统的类型"},{"content":"1.4节中显示的使用反馈的动因显得过于简单了。在那些例子里，反馈用于减少系统输出和参考输人之间的误差，但是反馈在控制系统中的意义远比上述例子所展示的深刻得多。减小系统误差只是反馈对于系统的各种重要作用之一。以下几节介绍反馈对于稳定性、带宽、总增益、阻抗和敏感度等系统品质特性的影响。\n要理解反馈对系统的作用，就必须在广义上考察这种现象。如果反馈是为了实现控制而有意识地引入到系统中的，那么反馈的存在性是很容易识别的。但是，对于很多我们认为应该是不存在反馈的物理系统，却可以通过一定的方法观察到其中存在的反馈。一般地，只要系统变量中存在闭合的因果关系序列，系统就存在反馈。按这种观点看，很多通常被认为是无反馈的系统都存在反馈。不过，在控制理论中不管系统是否具有物理反馈，只要能够确定其具有前面提到的反馈，就可以用系统的方法加以研究。\n现在来讨论一下反馈对系统各方面性能的影响。由于目前还不具备线性系统理论的数学基础，我们只讨论简单的静态系统。图1-9所示系统具有简单反馈，$r$代表输人信号，$y$代表输出信号，$e$是误差，$b$是反馈信号，参数$G$和$H$可以看作常量增益。由简单的代数运算很容易得到系统的输入输出关系: $$ 图1-9 反馈系统 $$\n$$ M = \\frac{y}{r}=\\frac{G}{1+GH}\\(1-1) $$ 根据反馈系统结构的基本关系，我们可以得到反馈的一些重要作用。\n1.5.1 反馈对于总增益的影响 由式(1-1) 可以看出，反馈系统的增益中比无反馈系统的增益多了一个因子$1+GH$。图1-9所示的系统包含$负反馈$，因为反馈信号是负的。乘积$GH$自身可能是一个负信号，因此反馈的一般作用是它可以增加或减小增益G。在实际系统里，$G$和$H$是频率的函数，所以$1+GH$的幅值可能在某个频段大于1，而在另一个频段小于1。由此可知，反馈可以在一个频段增加系统增益，而在另一个频段减小系统增益。\n1.5.2 反馈对于稳定性的影响 稳定性的概念用于描述系统能否跟随输人命令，也就是一般意义下的可用性。不严格地说，系统输出失去控制时就被称为不稳定。为了研究反馈对于稳定性的影响,我们仍然考虑式(1-1)。若$GH=-1$，则对于任意的有限输入，系统输出均为无穷，系统不稳定。这意味着反馈可以使原来稳定的系统变成不稳定。确实，反馈是一把双刃剑，使用不当也会有害。需要指出的是，这里讨论的只是静态情况，而且一般情况下$GH=-1$并非是使系统不稳定的唯一 条件。有关系统稳定性的内容将在第5章进行详细讨论。\n$$ 图1-10具有两个反馈环的反馈系统 $$ 反馈的好处之一在于可以使不稳定的系统变得稳定。假设图1-9所示系统不稳定，因为$GH=-1$ ;如果按照图1-10使用负反馈增益$F$引人另一个反馈环，整个系统的输人输出关系为 $$ \\frac{y}{r}=\\frac{G}{1+GH+GF}\\(1-2) $$ 显然，尽管因为 $GH=-1$而使得反馈系统内环不稳定，但通过适当选择外环反馈增益$F$,仍旧可以使整个系统稳定。实际上，$GH$是频率的函数，闭环系统的稳定性条件依赖于$GH$的幅值和相位。概括来讲，反馈可以改善系统稳定性，也会因为不恰当的使用而损害系统稳定性。\n敏感度也是设计控制系统时需要考虑的一个重要因素。由于所有的物理元件都具有随环境和使用时间而改变的性质，所以不能认为控制系统的参数在系统的使用寿命内是一成不变的。例如，电动机的绕线电阻在其运行时会随着温度升高而改变。带有电子元件的控制系统由于系统参数在“预热”的过程中仍在发生变化，在第一次启动时往往不能正常工作，这种现象有时被称为“早困”。大多数复印机在第一次运行的时候有一个“预热”的过程，在这段时间里不做控制操作。\n一般而言，一个好的控制系统应该对参数变化不敏感，而对输人指令敏感。我们来看一下参数变化时反馈对敏感度的影响。考虑图1-9所示系统，我们认为 $G$ 是可能变化的增益参数。整个系统的增益 $M$ 对 $G$ 的变化的敏感度定义为 $$ S^M_G = \\frac{\\partial{M}/M}{\\partial{G}/M}=\\frac{M变化的百分比}{G变化的百分比}\\(1-3) $$ 这里 $\\partial{M}$ 表示 $G$ 的增量引起的 $M$ 的增量。使用式( 1-1 )，敏感度方程可以写成 $$ S^M_G = \\frac{\\partial{M}}{\\partial{G}}\\frac{G}{M}=\\frac{1}{1+GH}\\(1-4) $$ 上述关系式表明: 如果 $GH$ 是正常数，可以在系统保持稳定的情况下，通过增加 $GH$ 来减小敏感度函数的幅值。显然在开环系统里，系统增益与 $G$ 的变化是一一对应的(如 $S^M_G=1$ )。如前所述，$GH$ 是频率的函数; $1+GH$ 的幅值在某些频段内可能小于1，因此反馈可能在某些情况下增大系统对参数变化的敏感度。一般地，反馈系统增益对于参数变化的敏感度取决于参数所在的位置。读者可以推导出图1-9的系统对于H的变化的敏感度。\n1.5.3 反馈对于外部干扰或噪声的作用 所有的物理系统在运行时都会受到外部信号或噪声的影响。此类信号包括电路中的热噪电压和电动机电刷或转向器噪声等。外部干扰，例如作用在天线上的阵风等，在控制系统中也很常见。因此，控制系统应当对噪声和干扰不敏感，而对输入指令敏感。 $$ 图1-11有噪声信号的反馈系统 $$ 反馈对于噪声和干扰的作用很大程度上取决于这类外加信号在系统中施加的位置。尽管没有一般性的结论，但是多数情况下反馈可以减小噪声和干扰对系统性能的影响。考察图1-11所示系统，$r$表示指令信号，$n$表示噪声信号。在没有反馈的情况下，$H=0$,$n$单独作用所产生的输出y为 $$ y = G_2n\\(1-5) $$ 有反馈的情况下，$n$ 单独作用所产生的系统输出为 $$ y = \\frac{G_2}{1+G_1G_2H}\\(1-6) $$ 比较式(1-6)与式(1-5)可以看出，当 $1+G_1G_2H$ 大于1并且系统保持稳定时，包含在输出中的噪声被削弱了。\n第11章里将使用前馈与前向控制器配置与反馈配合来减小扰动和噪声的影响。一般来说，反馈对于带宽、阻抗、暂态响应、频率响应等性能特点也都有影响，这些影响将在后续章节中讨论。\n","date":"2023-08-30T17:28:32+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.5%E5%8F%8D%E9%A6%88%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/","title":"1.5反馈的含义及其作用"},{"content":"开环控制系统缺少从输出到输入的反馈，这种反馈可以提供更精确、更具适应性的控制。为了获得更精确的控制，被控信号y经反馈后与参考输人比较，输人与输出的差值经比例放大得到执行信号，并送给系统以纠正误差。具有至少- -条上述反馈路径的系统称为闭环控制系统。 $$ 图1-7闭环怠速控制系统控制框图 $$ 图1-7是一个闭环怠速控制系统框图。参考输入 $\\omega_r$,设定为期望的怠速。发动机的怠速对应于参考值$\\omega_r$，任意偏差(如转矩 $T_L$)都会被速度变换器和误差传感器检测到。控制器根据偏差产生一个信号来调整节气阀调节角 $\\alpha$ 以消除误差。图1-8比较了开环与闭环怠速控制系统的典型响应特性。在图1-8a中加入负载转矩$T_L$后，开环系统的怠速会降低并稳定在-一个较低值上; 在图1-8b中，加 $T_L$ 后闭环系统的速度会迅速恢复到设定值。 $$ a)开环怠速控制系统的典型响应 $$ $$ b)闭环怠速控制系统的典型响应 $$ $$ 图1-8开环与闭环怠速控制系统的典型响应对比 $$\n","date":"2023-08-30T17:28:10+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.4%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/","title":"1.4闭环控制系统 反馈控制系统"},{"content":"图1-2所示怠速控制系统并不复杂，它被称为开环控制系统。显然，该系统不能达到令人满意的性能指标。某-一时刻，根据发动机速度设置节气阀调节角 $\\alpha$ 初始值后，一旦加上负载转矩 $T_L$，发动机转速不可避免地要降低。要让系统正常工作，唯一的办法是根据负载转矩的变化调节 $\\alpha$,从而维持 $\\omega$ 在期望的水平上。传统的电动洗衣机也是开环控制系统，因为总的洗涤时间完全是由人的判断和估计决定的。 $$ 图1-6开环控制系统的组成 $$ 开环控制系统通常由两个部分组成: 控制器与被控过程(见图1-6)。参考输入 $r$ 被用于控制器，其输出为激励信号 $u$; 激励信号作用于被控过程上，使被控变量$y$达到预先设定值。比较简单的情况下，根据系统特性，控制器可能是放大器、机械连接或者是其他控制元件;在复杂情况下，控制器可能是计算机，如微处理器等。由于开环控制系统具有简单经济的特点，其常被用于很多不重要的应用中。\n","date":"2023-08-30T17:27:36+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.3%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F-%E6%97%A0%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/","title":"1.3开环控制系统 无反馈系统"},{"content":"1.2控制系统应用举例 随着计算机技术的发展和新材料的开发，控制系统的应用范围获得了极大的扩展。这些材料可用于开发高效的执行器和传感器，从而减少了对能源的浪费和环境的影响。这些先进的执行器和传感器几乎可以被应用到任何系统中，包括生物推进、运动、机器人、材料处理、生物医学、外科和内窥镜、航空、海洋、国防和航天工业。\n下面介绍一些我们日常生活中常见的控制系统。\n1.2.1　智能交通系统 汽车及其在过去两个世纪的演变可以说是人类最具有变革性的发明。多年来，许多创新使得汽车更快、更安全、更美观。人们总是希望汽车的智能化程度不断提高，而且能够提供最大程度的舒适、安全和低油耗。汽车智能系统包括空调控制系统、巡航控制系统、防死锁刹车系统(ABS)、用于在粗糙地面上减少震动的主动悬挂、高过载弯道平衡气垫、当汽车转向不足或过高时提供偏移控制的动力系统(通过有选择地启动刹车以重新获得车辆控制)、防车轮加速时抓地不牢的牵引系统、控制车辆侧倾的主动转向杆等。以下是几个例子。\n线控驱动和驾驶辅助系统\n新一代的智能汽车能够了解驾驶环境、定位所在位置、监控汽车健康状态、理解道路标志、监控驾驶员的表现，甚至超越驾驶员以避免事故的发生。要实现上述功能需要对现有控制系统进行大修。线控技术把传统的机械和液压系统替换为电子设备和控制系统，使用机电执行器和人机接口(或者称为触觉系统)，如踏板和转向模拟器。因此，传统的一些汽车元件，如驾驶杆、中间轴、泵、软管、流体、带、冷却器、制动助力器和主汽缸等。触觉界面可以为驾驶员提供足够的透明度，同时保持系统的安全性和稳定性。卸下笨重的机械方向盘和转向系统的其余部分在现代汽车重量的减轻和安全性方面具有明显的优势，并且由于给驾驶员创造了更大的空间而在人体工程学方面也有改善。在这方面，用驾驶员通过触觉控制的触觉装置来替换方向盘是有益的。触觉装置可以让驾驶员产生与机械方向盘相同的感觉，但是由于去除了大体积的机械系统，可以改善成本，提高安全性，同时减少燃料的消耗。\n驾驶辅助系统通过感知、检测危险的性质和程度来帮助驾驶员避免或减轻事故。根据威胁的重要性和时间，车载安全系统将会尽早提醒司机即将到来的危险，并积极协助或最终进行干预，以避免事故或减轻其后果。当驾驶员由于疲劳驾驶或者是注意力不集中导致车辆失控时，辅助系统自动替代功能将是系统中的重要组成部分。在这种系统中，被称为先进车辆控制系统的装置对车辆控制进行纵向和横向的监控，并且通过与中央控制单元的交互，在被需要时可以随时对车辆进行控制。该系统可以方便地与传感器网络集成在一-起，监控道路上的各个环节，并准备以安全的方式采取适当的行动。\n高级混合动力总成技术的综合应用\n混合动力技术可以提高燃油的效率，同时增强驾驶体验。把新能源存储和转换技术与动力总成相结合，是混合动力技术的主要目标。这些技术必须与内燃机平台兼容，并且必须增强而不是危及车辆的功能。应用的示例包括插电式混合动力技术，其单独使用电池供电来增加车辆的巡航距离，并且利用燃料电池、能量收集(例如，通过将悬架中的振动能量或者是制动器中的能量转换为电能)或可持续能源(如太阳能和风力发电)为电池充电。智能的插电式车辆可以作为未来集成智能家居和电网能源系统的一部分，其将利用智能电能计量装置预测峰值能耗小时数，来最大限度地利用电网能源。\n高性能实时控制，健康监测和诊断\n现代车辆使用越来越多的传感器、执行器和网络嵌入式计算机。随着驱动系统等革 命性功能的引入，现代车辆对高性能计算的需求将会增加。将感官数据处理为适当的控 制、监测以及诊断信息所需要的巨大的计算负担为嵌入式计算技术的设计带来了挑战。 为此，与之对应的挑战是如何利用复杂的计算技术来控制、监控和诊断复杂的汽车系 统，同时满足低功耗和成本效益等要求。\n1.2.2　汽车转向控制 其为图1-1所示为控制系统的简单例子，考虑汽车转向系统。被控变量或输出$y$是两个前轮的方向;激励信号或输入$u$为方向盘的方向。转向机构和整车动力系统组成了这样的控制系统或者类似的过程。如果控制汽车的速度是目的，那么施加在加速器上的压力就是激励信号，车辆速度就是被控变量。总体来说，可以认为简化的汽车控制系统有两个输入(方向盘和加速器)和两个输出(方向和速度)。这里的两个控制量和两个输出量是互相独立的，但是有些系统中的控制量之间是相互关联的。具有超过一个输人和一个输出的系统被称为多变量系统。\n1.2.3　汽车怠速控制 以汽车发动机的怠速控制为例，这个控制系统的目标是: 在发动机上施加诸如传动、电力辅助转向、空调等负载的情况下，维持发动机以较低的速度空转，以降低损耗。如果没有怠速控制，任何突加于发动机的负载都会造成发动机速度陡降，甚至导致发动机熄火。因此，怠速控制系统的主要目的在于:在发动机上施加负载时，消除或尽量减少转速下降;使发动机怠速稳定在期望值上。图1-2是怠速控制系统框图。这里节气阀调节角 $\\alpha$ 和负载转矩 $T_L$，(使用空调、电力辅助、转向或电L力制动产生的转矩)是输人，发动机转速 $\\omega$ 是输出，发动机则是被控过程或系统。 $$ 图1-2息速控制系统控制框图 $$\n1.2.4　太阳能收集器的太阳跟踪控制 为了发展经济可行的非石油源电能，人们在替代能源的开发方面已经进行了大量的研究，其包括太阳能转换方法和太阳能电池转换技术。大部分此类系统使用了太阳跟踪装置。图1-3展示了一个太阳能收集器阵列，图1-4是一个使用太阳能的高效抽水机的概念图。白天太阳能收集器产生电能把水从地下抽到蓄水池(在附近的山上)，次日清晨，蓄水池的水再被送至灌溉系统。\n$$ 图1-3太阳 能收集器阵列 $$ $$ 图1-4使用太阳能的高效抽水机的概念图 $$ 太阳能收集器的一个重要特征是蝶形收集器必须精确地跟踪太阳，因此，蝶形收集器的移动必须由复杂的控制系统控制。图1-5所示控制框图描绘了太阳跟踪系统及其他一些重要部件的常见结构。控制器在清晨发出“开始跟踪”命令并保证收集器始终对着太阳。控制器在白天不断计算两个控制轴(方位角和仰角)的移动速度，并使用这个速度与太阳传感器获得的信息作为输人来启动适当的电动机指令，从而转动收集器。 $$ 图1-5太阳跟踪装置的重要部件 $$\n","date":"2023-08-30T17:24:52+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.2%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/","title":"1.2控制系统应用举例"},{"content":"本章的目的是使读者熟悉以下几方面的内容:\n什么是控制系统。 控制系统的重要性。 控制系统的基本组成部分。 控制系统应用例子。 为什么绝大多数控制系统均具有反馈。 控制系统的分类。 在过去的50年里，控制系统在现代文明和技术的发展和进步中发挥着越来越重要的作用。它几乎影响着我们日常活动的方方面面。例如在家中，我们需要控制房间内的温度和湿度以使生活舒适。在工业上，制造过程中的大量产品需要达到一定的指标，这些指标要满足精度和成本利润的要求。一个人要能够完成包括做各种决策在内的各种类型的任务。有些任务通常是-一种程序化的方式，例如捡起物体后从一个地方走到另外一个地方。在某些情况下，一些任务需要按照尽可能好的方式去完成。例如在百米短跑中，运动员希望以尽可能短的时间跑完全程。而对于一名马拉松选手来说，他不仅需要尽可能快地跑完，还需要控制好在这个过程中的能量消耗并设计最好的比赛策略。为了实现这些“目标”，通常需要引人能够执行某种控制策略的控制系统。\n控制系统已经大量应用到工业的各个部门，比如产品质量控制、自动装配线、机床控制、空间技术、计算机控制、交通系统、电力系统、机器人、微机电系统( MEMS)、纳米技术等，甚至包括社会与经济系统。具体地说，控制系统的应用领域包括:\n过程控制，实现工业环境下的自动化和批量生产。\n机床，改善精度并提高生产效率。\n机器人系统，实现运动和速度控制。\n运输系统，现代汽车和飞机的各种功能涉及控制系统。\n微机电系统，微型机电装置，如微型传感器和微型执行器。\n芯片实验室，在只有几毫米至几平方厘米大小的芯片上同时进行用于医疗诊断或者是环境监测的几项实验任务。\n生物力学和生物医学，人造肌肉、药物输送系统和其他辅助技术。\n1.1 控制系统的基本组成部分 控制系统的基本组成部分包括:\n控制目标。 控制系统(元件)。 结果或输出。 $$ 图1-1 控制系统的基本组成部分 $$ 上述三部分之间的基本关系如图1-1所示，此控制框图提供了一种图形化的方法来描述控制系统的元件如何进行交互。我们稍后将在第4章中进行讨论。在这种情况下，控制目标可由输入(或者称为激励信号 u)和输出(或者称为被控变量 y)确定。一般而言，控制系统的目标在于通过输入，经由控制元件, 以某种预先设定的方式来控制输出。 ","date":"2023-08-30T17:23:19+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/1.1%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/","title":"1.1控制系统的基本组成部分"},{"content":"第1章　绪论 1.1　控制系统的基本组成部分 1.2　控制系统应用举例 1.2.1　智能交通系统 1.2.2　汽车转向控制 1.2.3　汽车怠速控制 1.2.4　太阳能收集器的太阳跟踪控制 1.3　开环控制系统（无反馈系统） 1.4　闭环控制系统（反馈控制系统） 1.5　反馈的含义及其作用 1.5.1　反馈对于总增益的影响 1.5.2　反馈对于稳定性的影响 1.5.3　反馈对于外部干扰或噪声的作用 1.6　反馈控制系统的类型 1.7　线性系统与非线性系统 1.8　时不变与时变系统 1.9　连续控制系统 1.10　离散控制系统 1.11　案例研究：基于LEGOMINDSTORMS 的智能车辆避障 1.12　小结 第2章　动态系统的建模 2.1　简单机械系统的建模 2.1.1　平移运动 2.1.2　旋转运动 2.1.3　平移和旋转运动之间的转换 2.1.4　齿轮系 2.1.5　齿隙和死区（非线性特性） 2.2　简单电气系统的建模 2.2.1　无源电气元件建模 2.2.2　电气网络建模 2.3　简单热系统和简单流体系统的建模 2.3.1　热系统的基本属性 2.3.2　流体系统的基本属性 2.4　非线性系统的线性化 2.5　类比 2.6　案例研究：LEGO MINDSTORMSNXT 电动机—机械建模 2.7　小结 参考文献 习题47 第3章　动态系统的微分方程求解 3.1　微分方程介绍 3.1.1　线性常微分方程 3.1.2　非线性微分方程 3.2　拉普拉斯变换 3.2.1　拉普拉斯变换的定义 3.2.2　拉普拉斯变换的重要定理 3.2.3　传递函数 3.2.4　特征方程 3.2.5　解析函数 3.2.6　函数的极点 3.2.7　函数的零点 3.2.8　共轭复极点和零点 3.2.9　终值定理 3.3　部分分式展开的拉普拉斯逆变换 3.4　拉普拉斯变换在线性常微分方程求解中的应用 3.4.1　一阶系统 3.4.2　二阶系统 3.4.3　二阶系统—进一步讨论 3.5　线性系统的脉冲响应和传递函数 3.5.1　脉冲响应 3.5.2　基于脉冲响应的时间响应 3.5.3　传递函数（单输入单输出系统） 3.6　系统的一阶微分方程：状态方程 3.6.1　状态变量的定义 3.6.2　输出方程 3.7　线性齐次状态方程的解 3.7.1　传递函数（多变量系统） 3.7.2　由状态方程到特征方程 3.7.3　由传递函数到状态方程 3.8　MATLAB 案例研究 3.9　线性化回顾：状态空间方法 3.10　小结 参考文献 习题 第4章　控制框图和信号流图 4.1　控制框图 4.1.1　控制系统中典型元件的控制框图建模 4.1.2　数学方程和控制框图的关系 4.1.3　控制框图简化 4.1.4　多输入系统的控制框图：特殊情况—扰动系统 4.1.5　多变量系统的控制框图与传递函数 4.2　信号流图 4.2.1　信号流图代数 4.2.2　信号流图术语的定义 4.2.3　信号流图的增益公式 4.2.4　在输出节点与非输入节点间增益公式的应用 4.2.5　简化增益公式 4.3　状态图 4.3.1　由微分方程到状态图 4.3.2　由状态图到传递函数 4.3.3　由状态图到状态和输出方程 4.4　案例研究 4.5　MATLAB工具箱 4.6　小结 参考文献 习题 第5章　线性控制系统的稳定性 5.1　稳定性介绍 5.2　稳定性判定方法 5.3　Routh-Hurwitz 判据 5.3.1　Routh 表格 5.3.2 Routh 表格提前终止时的特殊情形 5.4　MATLAB 工具和案例分析 5.5 小结 参考文献 习题 第6章　反馈控制系统的重要组成 6.1　有源电气元件的建模：运算放大器 6.1.1　理想运算放大器 6.1.2　和与差 6.1.3　一阶运算放大器的配置 6.2　控制系统中的传感器和编码器 6.2.1　电位计 6.2.2　转速计 6.2.3　增量编码器 6.3　控制系统中的直流电动机 6.3.1　直流电动机的基本操作原理 6.3.2　永磁直流电动机的基本分类 6.3.3　永磁直流电动机的数学模型 6.4　直流电动机的速度控制及位置控制 6.4.1　速度响应、自感效应和扰动：开环响应 6.4.2　直流电动机的速度控制：闭环响应 6.4.3　位置控制 6.5　案例研究 6.5.1　案例1：太阳观测系统 6.5.2　案例2：四分之一车辆悬挂系统 6.6　虚拟实验室：LEGO MINDSTORMSNXT 电动机入门—建模和表征 6.6.1　NXT 电动机 6.6.2　电气特性 6.6.3　机械特性 6.6.4　速度响应和模型验证 6.7　小结 参考文献 习题 第7章　控制系统的时域分析 7.1　连续时间系统的时间响应 7.2　评价控制系统时间响应性能的典型测试信号 7.3　单位阶跃响应和时域描述 7.4　一阶系统的时间响应 7.5　二阶系统的暂态响应 7.5.1　阻尼比和自然频率 7.5.2　最大超调 (0 \u0026lt;ζ \u0026lt;1) 7.5.3　延迟时间和上升时间 (0 \u0026lt;ζ \u0026lt;1) 7.5.4　调节时间（5%和2%） 7.5.5　暂态响应性能指标总结 7.6　稳态误差 7.6.1　稳态误差的定义 7.6.2　有干扰情况下的系统稳态误差 7.6.3　控制系统的类型：单位反馈系统 7.6.4　误差常数 7.6.5　非线性系统元件产生的稳态误差 7.7　基础控制系统以及传递函数增加零极点带来的影响 7.7.1　在前向通道传递函数中增加一个极点：单位反馈系统 7.7.2　在闭环传递函数中增加一个极点 7.7.3　在闭环传递函数中增加一个零点 7.7.4　在前向通道传递函数中增加一个零点：单位反馈系统 7.7.5　增加零极点：时域响应控制 7.8　传递函数的主导零极点 7.8.1　零极点影响的总结 7.8.2　相对阻尼比 7.8.3　稳态响应考虑下的次要极点忽略方法 7.9　案例研究：定位控制系统的时域分析 7.9.1　二阶系统：单位阶跃暂态响应 7.9.2　二阶系统：单位阶跃稳态响应 7.9.3　三阶系统的时间响应—电气时间常数不能忽略 7.9.4　三阶系统：单位阶跃暂态响应 7.9.5　三阶系统：单位阶跃稳态响应 7.10　控制实验室：LEGO MINDSTORMS NXT 电动机介绍—位置控制 7.11　小结参考文献 习题292 第8章　状态空间分析与控制器设计 8.1　状态变量分析 8.2　控制框图、传递函数和状态控制框图 8.2.1　传递函数（多变量系统） 8.2.2　多变量系统的控制框图和传递函数 8.3　一阶微分系统的状态方程 8.3.1　状态变量的定义 8.3.2　输出方程 8.4　状态方程的向量-矩阵表示 8.5　状态转移矩阵 8.5.1　状态转移矩阵的意义 8.5.2　状态转移矩阵的性质 8.6　状态转移方程 8.7　状态方程与高阶微分方程之间的关系 8.8　状态方程与传递函数之间的关系 8.9　特征方程、特征值和特征向量 8.9.1　由微分方程求特征方程 8.9.2　由传递函数求特征方程 8.9.3　由状态方程求特征方程 8.9.4　特征值 8.9.5　特征向量 8.9.6　广义特征向量 8.10　相似变换 8.10.1　相似变换的不变特性 8.10.2　相似变换前后的特征方程、特征值和特征向量 8.10.3　传递函数矩阵 8.10.4　能控标准型 8.10.5　能观标准型 8.10.6　对角标准型 8.10.7　Jordan 标准型 8.11　传递函数分解 8.11.1　直接分解 8.11.2　串级分解 8.11.3　并行分解 8.12　控制系统的能控性 8.12.1　能控性的概念 8.12.2　状态能控性的定义 8.12.3　能控性的其他检验方法 8.13　线性系统的能观性 8.13.1　能观性的定义 8.13.2　能观性的其他检验方法 8.14　能控性、能观性和传递函数之间的关系 8.15　能控性和能观性的不变性定理 8.16　案例研究：磁球悬浮系统 8.17　状态反馈控制 8.18　通过状态反馈进行极点配置 8.19　带有积分控制的状态反馈 8.20　MATLAB 工具箱和案例学习 8.20.1　状态空间分析工具箱的使用和说明 8.20.2　tfsym 在状态空间应用中的使用和说明 8.21　案例研究：LEGO MINDSTORMS 机器臂系统的位置控制 8.22　小结 参考文献 习题 第9章　根轨迹法 9.1　根轨迹的基本性质 9.2　根轨迹的性质详解 9.2.1　K=0 和 K=±∞ 的点 9.2.2　RL 的分支数 9.2.3　RL 的对称性 9.2.4　RL 的渐近线交角：|s|=∞处RL的行为 9.2.5　渐近线的交点（质心） 9.2.6　实轴上的 RL 9.2.7　RL 的出射角和入射角 9.2.8　RL 与虚轴的交点 9.2.9　RL 的分离点（鞍点） 9.2.10　RL 在分离点处的入射角和出射角 9.2.11　RL 上K 值的计算 9.2.12　小结 9.3　根灵敏度 9.4　根轨迹设计 9.4.1　在 G(s)H(s) 中增加零极点的影响 9.4.2　在 G(s)H(s) 中增加极点 9.4.3　在 G(s)H(s) 中增加零点 9.5　根轨迹族：多参数变化情形 9.6　MATLAB 工具箱 9.7　小结 参考文献 习题 第10章　频域分析 10.1　引言 10.1.1　闭环系统的频率响应 10.1.2　频域指标 10.2　二阶系统的谐振峰值、谐振频率和带宽 10.2.1　谐振峰值和谐振频率 10.2.2　带宽 10.3　前向通道传递函数增加极点和零点的影响 10.3.1　前向通道传递函数增加零点的影响 10.3.2　前向通道传递函数增加极点的影响 10.4　Nyquist 稳定性判据：基本原理 10.4.1　稳定性问题 10.4.2　环绕和闭合的定义 10.4.3　环绕和闭合的次数 10.4.4　幅角原理 10.4.5　Nyquist 曲线 10.4.6　Nyquist 判据以及 L(s)或G(s)H(s) 图 10.5　具有最小相位传递函数的系统的 Nyquist 判据 10.6　根轨迹和 Nyquist 图的关系 10.7　示例：最小相位传递函数的 Nyquist 判据 10.8　增加的极点和零点对 Nyquist 图的形状的影响 10.8.1　在 s=0 处加入极点 10.8.2　增加有限个非零极点 10.8.3　增加零点 10.9　相对稳定性：增益裕量和相位裕量 10.9.1　增益裕量 10.9.2　非最小相位系统的增益裕量 10.9.3　相位裕量 10.10　用 Bode 图进行稳定性分析 10.11　相对稳定性与 Bode 图的幅值曲线的斜率之间的关系 10.12　用幅值-相位图进行稳定性分析 10.13　幅值-相位图中的定常M曲线：Nichols图 10.14　Nichols 图应用于非单位反馈系统 10.15　频域中的灵敏度研究 10.16　MATLAB 工具和案例研究 10.17　小结 参考文献 习题 第11章　控制系统设计 11.1　引言 11.1.1　设计要求 11.1.2　控制器结构 11.1.3　设计的基本原则 11.2　PD 控制器的设计 11.2.1　PD 控制的时域分析 11.2.2　PD 控制的频域分析 11.2.3　PD 控制的作用总结 11.3　PI 控制器的设计 11.3.1　PI 控制的时域分析与设计 11.3.2　PI 控制的频域分析与设计 11.4　PID 控制器的设计 11.5　相位超前和相位滞后控制器的设计 11.5.1　相位超前控制器的时域分析和设计 11.5.2　相位超前控制器的频域分析和设计 11.5.3　相位超前控制的作用 11.5.4　单阶相位超前控制的局限性 11.5.5　多阶相位超前控制器 11.5.6　灵敏度考虑 11.5.7　相位滞后控制的时域解释和设计 11.5.8　相位滞后控制的频域解释和设计 11.5.9　相位滞后控制器的作用和局限性 11.5.10　超前-滞后控制器的设计 11.6　零极点对消设计：陷波滤波器 11.6.1　二阶有源滤波器 11.6.2　频域解释和设计 11.7　前向和前馈控制器 11.8　鲁棒控制系统的设计 11.9　局部反馈控制 11.9.1　速度反馈或转速计反馈控制 11.9.2　含有源滤波器的局部反馈控制 11.10　MATLAB 工具和案例研究 11.11　控制实验室 参考文献 习题 索引 ","date":"2023-08-29T17:08:35+08:00","permalink":"https://okokfun.github.io/post/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/","title":"自动控制系统目录"},{"content":"","date":"2023-07-21T22:33:48+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-7pmosnmos%E5%92%8Ce2cmos/","title":"12.7 PMOS、NMOS和E2CMOS"},{"content":"","date":"2023-07-21T22:33:24+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/","title":"12.6 发射极耦合逻辑-ECL电路"},{"content":"","date":"2023-07-21T22:33:03+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/","title":"12.5 CMOS和TTL性能的比较"},{"content":"","date":"2023-07-21T22:32:51+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"12.4 TTL在实际使用中的注意事项"},{"content":"","date":"2023-07-21T22:32:37+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-3ttl%E7%94%B5%E8%B7%AF/","title":"12.3 TTL电路"},{"content":"","date":"2023-07-21T22:32:24+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-2cmos%E7%94%B5%E8%B7%AF/","title":"12.2 CMOS电路"},{"content":"","date":"2023-07-21T22:32:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/","title":"12.1 基本操作特性和参数"},{"content":"","date":"2023-07-21T22:31:50+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/","title":"11.4 数字信号处理基础"},{"content":"","date":"2023-07-21T22:31:38+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"11.3 数—模转换方法"},{"content":"","date":"2023-07-21T22:31:23+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"11.2 模—数转换方法"},{"content":"","date":"2023-07-21T22:31:03+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/","title":"11.1 模拟信号转换为数字信号"},{"content":"","date":"2023-07-21T22:30:48+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/","title":"10.8 磁和光存储"},{"content":"","date":"2023-07-21T22:30:36+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/","title":"10.7 特殊类型的存储器"},{"content":"","date":"2023-07-21T22:30:22+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/","title":"10.6 存储器扩展"},{"content":"","date":"2023-07-21T22:30:03+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-5%E9%97%AA%E5%AD%98/","title":"10.5 闪存"},{"content":"","date":"2023-07-21T22:29:20+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/","title":"10.4 可编程ROM[PROM和EPROM]"},{"content":"","date":"2023-07-21T22:28:49+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/","title":"10.3 只读存储器-ROM"},{"content":"","date":"2023-07-21T22:28:08+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/","title":"10.2 随机存储器-RAM"},{"content":"","date":"2023-07-21T22:27:20+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/","title":"10.1 半导体存储器基础"},{"content":"","date":"2023-07-21T22:27:02+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/","title":"9.9 关联标注的逻辑符号"},{"content":"","date":"2023-07-21T22:26:51+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/","title":"9.8 移位寄存器应用"},{"content":"","date":"2023-07-21T22:26:39+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"9.7 移位寄存器计数器"},{"content":"","date":"2023-07-21T22:26:26+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.6 双向移位寄存器"},{"content":"","date":"2023-07-21T22:26:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.5 并行输入/并行输出移位寄存器"},{"content":"","date":"2023-07-21T22:25:20+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.4 并行输入/串行输出移位寄存器"},{"content":"","date":"2023-07-21T22:25:06+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.3 串行输入/并行输出移位寄存器"},{"content":"","date":"2023-07-21T22:24:45+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/","title":"9.2 串行输入/串行输出移位寄存器"},{"content":"","date":"2023-07-21T22:24:31+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/","title":"9.1 基本移位寄存器的功能"},{"content":"","date":"2023-07-21T22:24:12+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/","title":"8.8 关联标注的逻辑符号"},{"content":"","date":"2023-07-21T22:23:59+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/","title":"8.7 计数器应用"},{"content":"","date":"2023-07-21T22:23:32+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/","title":"8.6 计数器译码"},{"content":"","date":"2023-07-21T22:23:18+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"8.5 级联计数器"},{"content":"","date":"2023-07-21T22:22:10+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"8.4 同步计数器的设计"},{"content":"","date":"2023-07-21T22:21:58+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"8.3 加/减同步计数器"},{"content":"","date":"2023-07-21T22:21:47+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/","title":"8.2 同步计数器运算"},{"content":"","date":"2023-07-21T22:21:29+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/","title":"8.1 异步计数器运算"},{"content":"","date":"2023-07-21T22:21:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"7.6 非稳态多谐振荡器"},{"content":"","date":"2023-07-21T22:20:48+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"7.5 单稳态触发器"},{"content":"","date":"2023-07-21T22:20:19+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/","title":"7.4 触发器应用"},{"content":"","date":"2023-07-21T22:20:05+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/","title":"7.3 触发器运算特性"},{"content":"","date":"2023-07-21T22:19:46+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"7.2 边沿触发器"},{"content":"","date":"2023-07-21T22:19:28+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-1%E9%94%81%E5%AD%98%E5%99%A8/","title":"7.1 锁存器"},{"content":"","date":"2023-07-21T22:18:55+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/","title":"6.10 奇偶发生器/校验器"},{"content":"","date":"2023-07-21T22:18:40+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/","title":"6.9 多路分配器"},{"content":"","date":"2023-07-21T22:18:25+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/","title":"6.8 多路复用器-数据选择器"},{"content":"","date":"2023-07-21T22:17:58+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"6.7 代码转换器"},{"content":"","date":"2023-07-21T22:17:47+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-6%E7%BC%96%E7%A0%81%E5%99%A8/","title":"6.6 编码器"},{"content":"","date":"2023-07-21T22:17:28+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-5%E8%AF%91%E7%A0%81%E5%99%A8/","title":"6.5 译码器"},{"content":"","date":"2023-07-21T22:17:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-4%E6%AF%94%E8%BE%83%E5%99%A8/","title":"6.4 比较器"},{"content":"","date":"2023-07-21T22:16:29+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.3 异步进位与超前进位加法器"},{"content":"","date":"2023-07-21T22:16:12+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.2 并行二进制加法器"},{"content":"","date":"2023-07-21T22:15:49+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/","title":"6.1 基本加法器"},{"content":"","date":"2023-07-21T22:15:09+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/","title":"5.5 具有脉冲波形输入的逻辑电路运算"},{"content":"","date":"2023-07-21T22:14:40+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/","title":"5.4 使用与非门和或非门的组合逻辑"},{"content":"","date":"2023-07-21T22:14:23+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/","title":"5.3 与非门和或非门的通用特性"},{"content":"","date":"2023-07-21T22:14:09+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"5.2 组合逻辑电路的实现"},{"content":"","date":"2023-07-21T22:13:52+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","title":"5.1 基本组合逻辑电路"},{"content":"","date":"2023-07-14T19:07:46+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/","title":"4.10 5变量的卡诺图"},{"content":"","date":"2023-07-14T19:07:32+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/","title":"4.9 卡诺图乘积项之和的最小化"},{"content":"","date":"2023-07-14T19:06:40+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/","title":"4.8 卡诺图"},{"content":"","date":"2023-07-14T19:06:31+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/","title":"4.7 布尔表达式和真值表"},{"content":"","date":"2023-07-14T19:06:22+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/","title":"4.6 布尔表达式的标准形式"},{"content":"","date":"2023-07-14T19:06:12+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/","title":"4.5 使用布尔代数进行化简"},{"content":"","date":"2023-07-14T19:05:51+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/","title":"4.4 逻辑电路的布尔分析"},{"content":"","date":"2023-07-14T19:05:42+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/","title":"4.3 狄摩根定理"},{"content":"","date":"2023-07-14T19:05:32+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/","title":"4.2 布尔代数的定律和法则"},{"content":"","date":"2023-07-14T19:05:21+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"4.1 布尔运算和表达式"},{"content":"3.7.1 逻辑系列 数字逻辑电路的三个系列是 CMOS(互补金属氧化物半导体)、双极型和 BiCMOS(双CMOS)。这三种电路器件实现内部逻辑功能的类型不同。CMOS 是由场效应管(FET)来实现，双极型(也称为TTL，即晶体管-晶体管逻辑)逻辑使用双极型晶体管来实现，而 BiCMOS 是前面两种的组合。这些逻辑器件系列的基本逻辑功能相同，但是工作参数不同，例如开关速度(传输时间)、功率损耗和抗干扰能力。CMOS 与门和双极型或 BiCMOS 与门的逻辑功能相同。对于所有其他功能的逻辑器件也一样。\nCMOS 在这些逻辑系列中，CMOS占有主导地位，双极型显然要被淘汰，BiCMOS 具有的逻辑功能类型也有限。在 CMOS 系列中，按不同的使用电压、功率损耗、开关速度和一些其他参数分为许多种类。表3.14列出了更多的常用 CMOS 逻辑电路,按各种器件的电路运行和优化的直流工作电压进行区分。 $$ 表3.14 ~~~CMOS逻辑器件的种类 $$\n名称 描述 $V_{CC}$ AC 高级CMOS 5.0 V ACT 具有双极型兼容输入的高级CMOS 5.0 V AHC 高级高速CMOS 5.0 V AHCT 具有双极型兼容输入的高级高速CMO 5.0 V ALVC 高级低电压CMOS 3.3 V AUC 高级超低电压CMOS 1.8 V AUP 高级超低功耗CMOS 3.3 V AVC 高级甚低电压CMOS 2.5 V CD4000 标准CMOS 5.0 V FCT 快速CMOS技术 5.0 V HC 高速CMOS 5.0 V HCT 具有双极型兼容输入的高速CMOS 5.0 V LV-A 低电压CMOS 3.3 V LV-AT 具有双极型兼容输入的低电压CMOS 5.0 V LVC 低电压CMOS 3.3 V 双极型 如同 CMOS 那样，双极型逻辑器件系列也有不同参数的种类。这些种类列在表3.15中，所有的不同种类都运行于典型的 5 V 电压 $V_{CC}$ 下。\nBiCMOS 表3.16给出了 BiCMOS 逻辑系列中的常用种类。工作电压 $V_{CC}$ 都是典型的5V。 $$ 表3.15~~~双极型逻辑器件的种类 $$\n名称 描述 ALS 高级低功率肖特基(Schottky) AS 高级肖特基 F 高速 LS 低功耗肖特基 S 肖特基 None 标准TTL $$ 表3.16~~~BiCMOS~逻辑器件的种类 $$\n名称 描述 ABT 高级BiCMOS ALB 高级低电压BiCMOS BCT 标准BiCMOS LVT 低电压BiCMOS 3.7.2 逻辑门 所有的逻辑功能一一非、与、或、与非、或非、异或和同或，都可以在CMOS和双极型中找到。除此之外,需要大电流驱动负载的缓冲输出门也有相应的逻辑功能。典型的集成电路(IC)封装具有的门的配置类型在系列的定义中由最后两位或三位数字进行区别。例如，74LS04是一块低功耗肖特基十六反相器。一些常用的逻辑门的配置和它们的标准鉴别数字如下所示:\n四 2 输人与非门一00 四 4 输人与非门一20 四 2 输人或非门一02 四 2 输人与门一21 十六反相器一04 三 3 输人或非门一27 四 2 输人与门一08 单 8 输入与非门一30 三 3 输人与非门一10 四 2 输人或门一32 三 3 输人与门一11 四异或门一86 四同或门一266 IC封装 所有 74 系列的 CMOS 和相同类型的双极型器件的引脚是兼容的。这就意味着 CMOS 数字 IC 芯片和相对应的双极型芯片的输入/输出引脚相同，例如 74HC00(四2输人与非门)，即在一块 IC 芯片上有 4 个 2 输人的与非门。对于典型的 IC 封装,双引线封装(DIP)用于插塞或穿通安装，小轮廓集成电路(SOIC)封装用于表面安装，如图3.49所示。在某些情况下还有其他类型的封装, SOIC 比 DIP 明显小得多。以上列出的大多数固定功能的逻辑芯片的引脚配置如图3.50所示。\n单个门的逻辑 CMOS 单个门的封装种类很有限。对于只有一个门的封装，该系列形成有 5 个极小引脚的封装，往往用于\u0026ndash;些特殊的场合,例如用于一些紧凑的、可用空间受到限制的地方，需要把这样的逻辑芯片挤进去以便达到最终的更改效果。\n逻辑符号 固定功能集成电路的逻辑符号使用标准的门的符号, IC 封装给出了芯片中门的数量及与每个门相关联的引脚编号,也给出了电源 $V_{CC}$ 和地线的引脚编号。图3.51给出了一个十六反相器和四2输人与非门的例子，其中给出特殊形状符号和矩形轮廓符号两种形式的图。不考虑逻辑系列，所有的芯片都有相同的前缀，也就是它们有相同的引脚排列。例如，7400、74S00、74LS00、74ALS00、74F00、74HC00和74AHC00都是四2输人与非门芯片,它们的引脚都兼容。\n3.7.3 工作特性和参数 高速逻辑芯片具有很小的传输延迟时间。 定义逻辑电路的几个工作特性，它们是按照传输延迟时间测量得到的开关速度、功率损耗、扇出或驱动能力、速度-功率乘积、直流供电电压和输人输出逻辑电平。\n传输延迟时间 此参数是在逻辑电路能够工作的最大开关速度或频率下得到的。对于逻辑电路，低速和高速是相对于传输延迟时间而言的。传输延迟时间越短，电路的速度就越高，工作频率也越高。\n传输延迟时间 $t_P$,即逻辑门的 $t_P$ 是输人脉冲的出现到此脉冲在输出出现的时间间隔。有两种测量与一个逻辑门有关的传输延迟时间的方法，它们适用于所有其他种类的基本门电路。\n$t_{PHL}$: 输入脉冲的特定参考点和对应传输得到的输出脉冲参考点之间的时间, 如输出从高电平变化到低电平(HL)的点。 $t_{PLH}$: 输入脉冲的特定参考点和对应传输得到的输出脉冲参考点之间的时间，如输出从低电平变化到高电平(LH)的点。 ","date":"2023-07-14T19:05:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/","title":"3.7 固定功能逻辑"},{"content":"3.6.1 异或门 异或门(XOR)的标准符号如图3.42所示。异或门只有两个输入。异或门的运算功能为模-2加法(第2章介绍过)。只有当两个输入处于相反的逻辑电平时，异或门的输出才是高电平。根据输入 A 和输入 B 及输出 X，它的运算可以做如下表述:\n对于异或门来说，如果输入 A 是低电平而输入 B 是高电平，或者输入 A 是高电平而输入 B 是低电平，那么输出 X 就是高电平; 如果 A 和 B 都是高电平或者都是低电平，那么输出 X 为低电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~(b)具有异或门的矩形轮廓 $$ $$ 图3.42~~~~异或门的标准逻辑符号 $$\n◇ 对于异或门来说,相反的两个输入产生高电平输出。 异或门的所有 4 个可能的输入组合及输出结果如图3.43所示。高电平是有效或者是确定电平，只有当两个输入相反时才会输出高电平。异或门的运算总结在表3.11中。 $$ 图3.43~~~异或门的所有输入逻辑电平和相应的输出电平。打开文件F03-43检验异或门操作 $$\n$$ 表3.11~~~异或门的真值表 $$\n输入A 输入B 输出X 0 0 0 0 1 1 1 0 1 1 1 0 3.6.2 同或门 同或门(XNOR)的标准符号如图3.45所示。和异或门相似，同或门也只有两个输入。同或门符号输出位置上的小圆圈指示它的输出和异或门的输出是相反的。当两个输人逻辑电平相反时，同或门的输出就是低电平。这个运算可以做如下表述(A 和 B 是输入,X 是输出):\n对于同或门来说，如果输入 A 是低电平而输入 B 是高电平，或者 A 是高电平，B 是低电平，输出 X 就是低电平;如果输入 A 和输入 B 都是高电平或者都是低电平，输出 X 就是高电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)长方形轮廓 $$ $$ 图3.45~~~同或门的标准逻辑符号 $$ $$ 图3.46~~~同或门的所有输入逻辑电平和相应的输出电平。打开文件F03-46检验同或门操作 $$\n$$ 表3.12~~~同或门的真值表 $$\n输入A 输入B 输出X 0 0 1 0 1 0 1 0 0 1 1 1 3.6.3 波形输入的运算 正如对其他门所做的运算一样，观察异或门和同或门在脉冲波形输人条件下的运算。和以前一样，在脉冲波形输入的每个特定时间段中，对如图3.47所示的异或门应用真值表进行运算。可以看到在时间段 $t_2$ 和 $t_4$ 期间，输入波形 A 和 B 为相反的电平。所以在这两个时间段，输出 X 是高电平。由于在时间段 $t_1$ 和 $t_3$ 期间，两个输入为相同电平，要么都是高电平要么都是低电平，所以这两个时间段的输出 X 是低电平，如时序图所示。\n$$ 图3.47~~~异或门脉冲波形输入的运算 $$\n3.6.4 应用举例 异或门可以用做 2 位 模-2加法器。在第 2 章中，二进制加法的基本规则是: 0+0=0, 0+1=1, 1+0=1，以及 1+1=10。观察异或门的真值表,就会发现输出是两个输入的和运算。在这种情况下，两个输人都是 1，输出的和是0，但是我们丢弃了进位 1。在第 6 章中,将会看到异或门怎样组合在一起形成完整的加法电路。表3.13说明了异或门用做模-2加法的运算,将其用在循环冗余校验码(CRC)系统中，以完成第 2 章描述的除法运算。 $$ 表3.13~~~异或门用做两位加法 $$ ","date":"2023-07-14T19:05:01+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/","title":"3.6 异或门和同或门"},{"content":" ◇ 除了输出反相之外，或非门和或门相同。 术语或非(NOR)是非-或(NOT-OR)的缩写，意指具有反相(反码)输出的或运算。2输入或非门和与之等价的或门后面再加反相器的标准逻辑符号，如图3.34(a)所示。图3.34(b)给出了矩形轮廓符号。\n$$ (a)特殊形状，2输入或非门和等价的非-或门~~~~~~~~~~~~~~~~~~(b)矩形轮廓,具有极性指示的2输入或非门 $$ $$ 图3.34~~~标准或非门逻辑符号(ANSI/IEEE标准91-1984) $$\n3.5.1 或非门的运算 当任何一个输入为高电平时，或非门就输出一个低电平。只有当所有的输入是低电平时，输出才是高电平。对于 2 输入或非门的情况，如图3.34所示，输人被标为 A 和 B，输出被标记为 X，该运算可以做如下表述:\n对于 2 输入或非门，如果输入 A 或 B 为高电平，或者 A 和 B 都是高电平，输出 X 就是低电平; 如果 A 和 B 都是低电平，输出X就是高电平。\n这个运算产生和或门相反的输出电平。在或非门中，低电平输出是有效的或者是确定的输出电平，由输出的小圆圈所表示。图3.35说明了2输入或非门的运算，包括所有可能的4种输入组合,而表3.9是2输入或非门的真值表。 $$ 图3.35~~~2输人或非门的操作。打开文件F03-35检验或非门操作 $$\n$$ 表3.9~~~2输入或非门的真值表 $$\n输入A 输入B 输出X 0 0 1 0 1 0 1 0 0 1 1 0 1=高电平, 0=低电平\n3.5.2 波形输入的运算 下面的两个例子给出了具有脉冲波形输人的或非门运算。和其他类型的门一样，只要遵循真值表就可以确定输出波形和输入的正确时间关系。\n或非门的非-与等价运算 或非门和与非门相似，但具有其运算的另一个方面，也就是固有的逻辑函数功能。表3.9给出了只有当所有的输入都是低电平时，才会产生高电平输出。从这一点来说，或非门可以用做需要所有的低电平输入来产生高电平输出的与运算。或非门的这个功能称为非-与。这里术语“非”意指低电平输入有效或低电平为确定状态。\n对非-与运算的 2 输入或非门来说，如果输入 A 和 B 都是低电平时, 输出 X 就是高电平。\n当一个或非门用来检测所有的低电平输入而不是一个或者多个高电平输人时，它就是在执行非-与运算,这由图3.38中的标准符号表示。图3.38中的两个符号表示相同的物理门并且仅用于区分两种运算模式，记住这一点很重要。下面的三个例子给出了说明。\n$$ 图3.38 ~~~表示或非门两种等价运算的标准符号 $$\n3.5.3 或非门的逻辑表达式 2 输入或非门输出的布尔表达式可以写为 $$ X=\\overline{A + B} $$ 这个等式说明，两个输入变量先进行或运算，然后再求反，求反由或运算表达式上方的横杠指示。运算这个表达式，就可以得到如表3.10所示的结果。该或非运算表达式可以扩\u0026quot;展到多于两个的输人变量,使用另外的字母表示其他变量即可。 $$ 表3.10 $$\nA B $\\overline{A+B}$ = X 0 0 $\\overline{0+0}$ =$\\overline{0}$= 1 0 1 $\\overline{0+1}$ =$\\overline{1}$= 0 1 0 $\\overline{1+0}$ =$\\overline{1}$= 0 1 1 $\\overline{1+1}$ =$\\overline{1}$= 0 ","date":"2023-07-14T19:04:51+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-5%E6%88%96%E9%9D%9E%E9%97%A8/","title":"3.5 或非门"},{"content":" ◇ 除了输出被反相之外，与非门和与门是一样的。 词汇与非(NAND)是非-与(NOT-AND)的缩写，意思是具有反码(反相)输出的与函数。2输入的与非门的标准逻辑符号和一个与门其后再加一个反相器的电路图等价，如图3.26(a)所示，其中符号=的意思是恒等于。图3.26(b)给出了矩形轮廓符号。\n$$ (a)特殊形状，2输入与非门及等价的与门+非门~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)矩形轮廓，具有极性指示 $$\n$$ 图3.26~~~标准与非门逻辑符号(ANSI/IEEE标准91-1984) $$\n3.4.1与非门的运算 只有所有的输入都是高电平时，与非门才会输出其低电平。当任何一个输入为低电平时，输出就是高电平。2输人与非门的一个具体例子如图3.26所示，其中输人被标为 A 和 B,输出被标为 X,该运算可以进行如下表述:\n对于一个2输入与非门，当输入 A 和 B 都是高电平时，输出X就是低电平; 当输入 A 或 B 为低电平，或者 A 和 B 都是低电平时,输出 X 就是高电平。\n注意，这个运算和与门输出电平的运算是相反的。在一个与非门中，低电平(0)是有双蚁确定的输出电平，由输出的小圆圈所表示。图3.27说明了 2 输入与非门的所有 4 种可能组合，而表3.7是把 2 输入与非门的所有逻辑运算汇总后的真值表。\n$$ 图3.27~~~2输入与非门的运算。打开文件F03-27检验与非门操作 $$\n$$ 表3.7~~~2输入与非门的真值表 $$\n输入A 输入B 输出X 0 0 0 0 1 0 1 0 0 1 1 1 1=高电平,0=低电平\n3.4.2波形输入的运算 现在来看与非门的波形运算。从真值表可以知道，仅当所有的输人为高电平时，输出才是低电平。\n与非门的非-或等价运算 与非门运算的内在特性是这样的: 一个或者多个低电平输人产生一个高电平输出。表3.7给出了当任何一个输入 A 和 B 是低电平(0)时，输出就是高电平(1)。从这个观点来看，与非门可用于需要一个或者多个低电平输入并且产生高电平输出的或运算。与非门运算的这个功能称为非-或运算。术语“非”在上下文中意思是当输入为低电平时，输人就被定义为处于有效或者确定状态。\n对于2输入与非门执行非-或运算，如果输入 A 或 B 是低电平，或者 A 和 B 都是低电平时，那么输出 X 就是高电平。\n当与非门用以检测一个或者多个低电平输入而不全是高电平输入时，它就是在执行非-或运算,并且由图3.30中的标准逻辑符号表示出来。虽然图3.30中的两个符号表示相同的物理门,但这是在特定的应用中用来定义的逻辑门或者运算模式，如例3.12和例3.13所示。\n$$ 图3.30~~~表示与非门的两个等效运算的标准符号 $$\n3.4.3 与非门的逻辑表达式 ◇ 变量上方的横杠就表示反相。 2输人与非门输出的布尔表达式为 $$ X = \\overline{AB} $$ 这个表达式指出，对于两个变量 A 和 B，首先进行与运算然后再取反,这由与运算表达式上的横杠来表示。这就是 2 输人与非门运算的方程表示形式。两个输入变量所有可能的值由此方程可以得到输出,结果如表3.8所给出。\n一旦给定的逻辑函数的表达式被确定下来，对应于变量所有可能的值,通过函数都可以得出运算结果。对于每一种输入组合，运算结果会准确地给出逻辑电路的输出，因此就对这个电路的逻辑运算做出了完整的描述。与非门表达式可以扩展到多于两个的输人变量，可以添加其他的字母来表示扩展的变量。 $$ 表3.8 $$\nA B $\\overline{AB}$ = X 0 0 $\\overline{0·0}$ =$\\overline{0}$= 1 0 1 $\\overline{0·1}$ =$\\overline{0}$= 1 1 0 $\\overline{1·0}$ =$\\overline{0}$= 1 1 1 $\\overline{1·1}$ =$\\overline{1}$= 0 ","date":"2023-07-14T19:04:42+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/","title":"3.4 与非门"},{"content":" ◇ 或门可以具有多于两个的输入。 或门(OR gate)具有两个或者更多的输入及一个输出，如图3.18所示的标准逻辑符号给出了具有两个输人的或门。或门可以具有多于一个的任意输入。虽然同时给出了特殊形状和矩形轮廓符号，但是本书使用的是特殊形状符号。\n$$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)具有OR(≥1)限定符号的矩形轮廓 $$ $$ 图3.18 ~~~或门的标准逻辑符号，图中给出了两个输入的或门(ANSI/IEEE标准91-1984) $$\n3.3.1 或门的运算 ◇ 有一个以上的输入是高电平时，或门的输出就是高电平。 当任意一个输人为高电平时，或门的输出就为高电平。当且仅当所有的输入是低电平时，输出才会是低电平。所以，或门用来判断它的输入是否有一个或者多个高电平,有高电平输入时，输出一个高电平以表明条件满足。图3.18中2输人或门的输入被标以A和B，输出则被标以X，或门的运算可以做如下表述:\n对于一个 2 输入或门来说，如果输入 A 和输入 B 中有一个是高电平，或者两者都为高电平,输出 X 就为高电平; 仅当 A 和 B 都是低电平时，X 为低电平。\n高电平是或门的有效或者肯定输出电位。图3.19给出了2输人或门的所有 4 种可能输人组合的输人和输出结果。\n$$ 图3.19 ~~~2输人或门的所有可能逻辑电位。打开文件F03-19检验或门操作 $$\n3.3.2 或门真值表 表3.5描述了2输入或门的运算。这个真值表可以扩展到任意个数的输入;但是不管有多少输入，当有一个或者多个输入是高电平时，输出就是高电平。 $$ 表3.5~~~2输入或门的真值表 $$\n输入 输入 输出 0 0 0 0 1 1 1 0 1 1 1 1 1=高电平,0=低电平\n3.3.3波形输入的运算 现在观察具有波形输入的或门运算，并请记住它的逻辑运算。再有，分析具有脉冲波形的或门运算的关键是涉及的所有波形的时间关系。例如，在图3.20 中，在时间间隔 $t_1$ 期间，A 和 B 都是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_2$ 期间,输入A是低电平0，但是输入 B 是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_3$ 期间,两个输入都是低电平 0,所以输出 X 为低电平 0。在时间间隔 $t_4$ 期间，两个输人都是高电平 1，所以输出 X 为高电平 1。\n$$ 图3.20~~~或门运算的时序图例子,图中给出了输入和输出之间的时间关系 $$ 在这个说明中，或门的真值表运算应用到了电平没有改变的时间间隔上。例3.7到例3.9将进一步说明输入有波形的或门运算。\n3.3.4 或门的逻辑表达式 ◇ 当两个变量之间由＋分开，那么它们是或的关系。 2 变量的逻辑或函数表示数学上两个变量的相加，例如 A＋B。符号＋读做“或”。\n布尔代数中的加法涉及的变量是它的值仅为二进制1或0。布尔代数的基本法则如下: $$ 0+0=0 \\\\ 0+1=1 \\\\ 1+0=1 \\\\ 1+1=1 $$ 布尔加法和或函数相同。\n注意，布尔加法和二进制加法的不同点在于两个 1 相加的情况，在布尔代数中没有进位。\n2 输人或门的运算可以做如下表述: 如果-个输人变量是 A,另一个输人变量是 B,输出变量是 X,那么布尔代数的表达式就是 $$ X=A+B $$ 图3.24(a)给出了 2 变量的或门逻辑符号，同时标出了输人和输出变量。 $$ (a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(c) $$\n$$ 图3.24~~~具有2个、3个、4个输入的或门布尔表达式 $$ 把或表达式扩展到多于两个的输入变量，就需要为每一个附加变量使用一个新字母。例如,3 输人或门的函数可以表示为 X=A+B+C，4 输人或门的表达式可以写成 X=A+B+C+D，以此类推。图3.24中的(b)和(c)分别给出了具有3个和 4 个变量的或门。\n或门的运算可以由布尔表达式确定，把输入变量的所有 1和 0 的可能组合代入输入变量,就可以得到输出 X，如表3.6的 2 输入或门所示。这个运算表明，当一个或两个输入是高电平时,输出 X 为高电平。相同的分析可以扩展到任意多个输入变量数的或门。 $$ 表3.6 $$\nA B A+B=X 0 0 0 + 0 = 0 0 1 0 + 1 = 1 1 0 1 + 0 = 1 1 1 1 + 1 = 1 3.3.5应用举例 一个入室盗窃检测和警报系统的部分简化图如图3.25所示。这个系统可以用于一间房屋——具有两扇窗户和一扇门的房间。传感器是磁性开关，它被打开时产生一个高电平输出，关闭时产生一个低电平输出。只要窗户和门是安全的，开关就是关闭的并且或门的三个输入都是低电平。当一扇窗户或者门被打开时,在或门的输入就会产生一个高电平,这样输出就是高电平。然后激活和开启警报电路，以发出人侵警报。\n$$ 图3.25~~~使用或门的一个简化入室盗窃检测和警报系统 $$\n","date":"2023-07-14T19:04:34+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-3%E6%88%96%E9%97%A8/","title":"3.3 或门"},{"content":"名词“门\u0026quot;用以描述运行基本逻辑运算的电路。与门(AND gate)由两个或者更多的输入和一个输出组成，由图3.8中的标准逻辑符号所表示。输入位于左边，而输出位于每个符号的右边。图中给出具有两个输入的与门;但是，与门可以有大于两个的任意输入。虽然给出了特殊形状符号和矩形轮廓符号，但是本书主要使用图3.8(a)中的特殊形状符号。\n(a)特殊形状_____________________________(b)具有与(\u0026amp;)限定符号的矩形轮廓\n$$ 图3.8~~~与门的标准逻辑符号，给出了两个输入(ANSI/IEEE标准91-1984) $$\n3.2.1与门的运算 ◇ 与门可以具有多于两个的输入。 当且仅当与门所有的输人都是高电平时，才会输出高电平。当任何一个输入为低电平时，输出就是低电平。所以，与门的基本用途即判断若干条件是否同时为真，为真时所有的输入是高电平,并且在输出产生高电平以表示所有的条件都为真。图3.8中的2输入与门的输入被标记为 A 和 B，而输出被标记为 X。与门运算可以表述为\n对于 2 输入与门，当输入 A 和 B 都是高电平时，输出 X 为高电平;当 A 或 B 是低电平，或者 A 和 B 都是低电平时, X 就是低电平。\n图3.9给出了一个 2 输人与门，同时列出了所有 4 种可能的输入组合，以及每个与门相对应的输出。\n$$ 图3.92~~~输入与门的所有可能逻辑电平。打开文件 F03-09检验与门操作 $$\n3.2.2与门真值表 ◇ 对于一个与门来说，输入都是高电平时才会产生高电平输出 $$ 表3.2 ~~~2输入与门的真值表 $$ 输入 输入 输出 A B X 0 0 0 0 1 0 1 0 0 1 1 1 1 = 高电平,0 = 低电平\n门的逻辑运算可以用真值表来表示，真值表列出了所有的输入组合及相应的输出，如表3.2的 2 输人与门所示。真值表可以扩展到任意个数的输入。虽然高电平和低电平往往指“物理”意义的输入和输出状态，但是真值表给出的却是 1 和 0;在正逻辑中,高电平就相当于 1，而低电平就相当于 0。对于任意的与门，不管有多少个输入，当且仅当所有的输入为高电平时，输出才是高电平。\n逻辑门输入的所有二进制组合的总数，由下面的公式确定: $$ N=2^n $$ 这里 N 是可能输入组合的个数，n是输入变量的个数。说明如下: $$ 2输入变量:N =2^2=4种组合 \\\\ 3输入变量:N =2^3=8种组合 \\\\ 4输入变量:N =2^4=16种组合 $$ 使用式(3.1)，可以为具有任意多个输入的门确定输人变量组合的个数。\n3.2.3波形输入运算 在多数应用实例中，门的输入不是固定的电平，而是在逻辑高电平和逻辑低电平之间频繁变化的电压波形。现在来看具有脉冲波形输人的与门运算，要记住与门遵循真值表的运算，而不用考虑输入电平是不变的还是高低来回变化的电平。\n检查一下与门的波形运算，通过观察相互关联的输入以确定任意给定时刻下的输出电平。在图3.10中，在时间间隔 $t_1$ 期间,输入 A 和 B 都是高电平(1)，因而在该期间的输出为高电平(1)。在时间间隔 $t_2$ 期间,输入 A 为低电平(0)而输人 B 为高电平(1)，所以输出是低电平。在时间间隔 $t_3$ 期间,输入又都是高电平(1)，所以输出是高电平(1)。在时间间隔 $t_4$ 期间,输入 A 是高电平(1)而输入 B 是低电平(0)，因此产生一个低电平(0)。最后，在时间间隔 $t_5$ 期间，输人 A 是低电平(0)，输人 B 是低电平(0)，所以输出就是低电平(0)。正如所知，输入和输出的波形图给出了一种时间关系,称为时序图。 $$ 图3.10~~~具有时序图的与门举例，图中给出了输入和输出的关系 $$ 记住，在分析逻辑门的波形运算时，注意输入之间的时间关系及输入和输出之间的时间关系是非常重要的。\n3.2.4与门的逻辑表达 两个变量的逻辑与函数在数学上可以表示为在两个变量之间放一个点，如$A·B$;或不使用点，仅仅写出两个相邻的字母，如AB。因为方便，通常使用后面的写法。\n布尔乘法遵循与二进制乘法相同的基本法则，在第2章已经讨论过了，如下所示:\n0 · 0 = 0 0 · 1 = 0 1 · 0 = 0 1 · 1 = 1 布尔乘法和与函数相同。\n◇ 当变量ABC写在一起时，表示的就是与运算。 2 输入与门的运算可以表示为如下的等式形式; 如果一个输人变量是 A，另一个是 B，输出变量是 X,那么布尔表达式就是 $$ X=AB $$ 图3.15(a)给出了2输入变量的与门逻辑符号并标出了输出变量。\n要把与表达式扩展到多于两个输人变量时，只要为每个输入变量使用一个新字母就可以了。例如，3 输入与门的函数可以表示为 X=ABC，其中 A、B、C 是输人变量。4输入与门的表达式为 X=ABCD，以此类推。图3.15中的(b)和(c)分别给出了 3 个和 4 个输入变量的与门。 $$ (a)2输入与门~~~~~~~~~~~~~~~~~~~~~~~(b)3输入与门~~~~~~~~~~~~~~~~~~~~~~~(c)4输入与门 $$ $$ 图3.15~~~具有2个3个和4个输入的与门布尔表达 $$ 可以使用输出的布尔表达式来求得与门运算。例如，输入的每个变量都可以是 1 或 0; 对于 2 输入与门，把公式 X = AB 代入就可以得到输出，如表3.4所示。这个计算表明仅当两个输入都是 1(高电平)时,与门的输出 X 才是 1(高电平)。可以对任意数目的输入变量做相似的分析。 $$ 表3.4 $$\nA B AB=X 0 0 0 · 0=0 0 1 0 · 1=0 1 0 1 · 0=0 1 1 1 · 1=1 3.2.5应用举例 与门作为使能/禁止设备 与门的一种常见应用是使能(也就是允许)信号(脉冲波形)在某个时间从一点传到另一点,并禁止(阻止)在其他时间传送。\n图3.16给出了与门这种特殊用途的一个简单例子,其中与门用来控制信号(波形 A)向数字计数器的传送。这个电路的目的是测量波形 A 的频率。使能脉冲有 1 毫秒( ms)的精确宽度。当使能脉冲是高电平时，波形 A 就会通过与门到达计数器，而当使能脉冲是低电平时不允许(禁止)信号通过。\n在使能脉冲的 1 ms时间间隔内，波形 A 中的脉冲通过与门到达计数器，脉冲在 1 ms 的时间间隔内通过的次数等于波形 A 的频率(单位为kHz)。例如，图3.16 给出了1 ms 中有 6 个脉冲，也就是频率为 6 kHz。如果在使能脉冲的 1 ms 时间间隔内，有 1000 个脉冲通过与门，这样就是 1000 脉冲/ms，或者为 1 MHz 的频率。 $$ 图3.16~~~频率计数器运行使能/禁止功能的一个与门 $$ 计数器记录每秒钟脉冲的个数，并产生一个二进制输出，进入解码和显示电路,显示可以读取的频率。使能脉冲在一定的间隔期间内重复，以产生一个新的计数值，所以如果频率变化,就会显示出新的数值。在两个使能脉冲之间，计数器被置0，因而在每个使能脉冲到来时，计数器从О开始计数。当前的频率计数值保存在一个寄存器中，这样显示值不会受到计数器的影响。\n安全带警报系统 在图3.17中，与门用在了一个简单的汽车安全带警报系统中，用来检测点火开关是否已开及安全带是否系上。如果点火开关处于打开的状态，与门的输人A上就会产生一个高电平。如果安全带没有系好，与门的输入B上就产生一个高电平。同样，当点火开关打开时，计时器就会启动并且在输入C上产生一个30秒的高电平。所有的这三个条件都存在——也就是如果点火开关处于打开的状态、安全带没有系好和计时器正在计时，这时与门的输出就是高电平，音响警报系统就会被激活以提醒司机。 $$ 图3.17~~~使用与门的简单安全带警报电路 $$\n","date":"2023-07-14T19:04:25+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-2%E4%B8%8E%E9%97%A8/","title":"3.2 与门"},{"content":"反相器的标准逻辑符号如图3.1所示,(a)图给出了特殊形状符号,(b)图给出了矩形轮廓符号.在这本书中,一般使用特殊形状符号;但是,矩形轮廓符号常常出现在许多工业出版物中,所以也应该熟悉它们.(逻辑门符号依据 ANSI/IEEE 标准 91-1984.)\n3.1.1 否定和极性指示 $$ (a)具有否定指示的特殊形状符号~~~~~~~~~~(b)具有极性指示的矩形轮廓符号 $$ 否定指示是一个小圆圈(o),当其出现在任何逻辑元件的输入或者输出位置时,为反相或者为反码,如图3.1(a)的反相器所示.一般情况下,输入位于逻辑符号的左侧而输出位于右侧.当出现在输人位置时,小圆圈就表示 0 电平有效或者是确定的输入状态,而这个输入称为低电平有效输人.当出现在输出位置时,该小圆圈就指明0有效或者是确定的输出状态,而这个输出称为低电平有效输出.当输人或者输出没有小圆圈时,就表示1是有效的或者是确定的状态,而这个输入或输出称为高电平有效.\n极性或者电平指示是一个\u0026quot;三角形\u0026quot;(◣),当其出现在任何逻辑元件的输人或者输出位置时,表示反相,如图3.1(b)所示.当其出现在输入位置时,就表示低电平是有效的或者是确定的输人状态.当其出现在输出位置时,就表示低电平是有效的或者是确定的输出状态.\n两种指示(小圆圈或三角形)都可以用在特殊形状符号和矩形轮廓符号中.图3.1(a)给出的是本书后面主要使用的反相器.注意反相或极性指示的不同放置并不意味着反相器运算方式的改变.\n3.1.2 反相器真值表 当反相器的输入是高电平时，它的输出就是低电平。当反相器的输入是低电平时，它的输出就是高电平。这种运算总结于表3.1中，表中以电平和对应的位值给出了每个可能的输入和与之对应的输出。这样的表称为真值表。 $$ 表3.1~~~反相器真值表 $$\n输入 输出 低(0) 高(1) 高(1) 低(0) 3.1.3 反相器运算 图3.2给出了反相器脉冲输入和相应的输出，其中 $t_1$ 和 $t_2$ 指明了在输人和输出波形上相对应的点。\n当输入为低电平时，输出就是高电平; 当输入是高电平时,输出就是低电平，因此产生反相的输出脉冲。\n$$ 图3.2~~~具有脉冲输入的反相运算。打开文件FO3-02检验反相操作 $$\n3.1.4 时序图 ◇ 时序图给出了两个或者更多的波形在时间上的相互关系。 回顾第1章我们知道，基本上时序图是基于时间的、准确显示两个或者更多波形相互之间关系的图形。例如，图3.2中输出脉冲和输人脉冲的时间关系，可以用一个时序图把两个脉冲对准,从而使得这些脉冲边沿的发生以正确的时间关系展现出来。输入脉冲的上升沿和输出脉冲的下降沿在相同的时间出现(理想状态)。类似地,输入脉冲的下降沿和输出脉冲的上升沿在相同的时间出现(理想状态)。这种时序关系如图3.3所示。实际上，从输入的变化到输出的变化有一个非常小的延迟。时序图在说明具有多个脉冲的数字波形之间的时间关系时特别有用。\n$$ 图3.3~~~在图3.2条件下的时序图 $$\n3.1.5 反相器的逻辑表达式 ◇ 布尔代数使用变量和运算符来描述逻辑电路。 在布尔代数(它是逻辑电路的数学基础并且将在第4章得到全面的介绍)中，变量可以由多个字母表示，但是通常由一个或两个字母表示。接近字母表中开始位置的通常表示输人，而接近结束位置的通常表示输出。变量的反码由字母上方的横杠来表示。变量可取的值是 1 或者 0。如果一个变量是 1，它的反码就是 0，反之亦然。\n反相器(非门电路)的运算可以用下面的方式表示: 如果输入变量为 A,输出变量为 X，那么 $$ X=\\overline{A} $$ 这个表达式说明输出是输入的反码,所以如果 A=0，那么 X =1; 而如果 A=1，那么 X =0。图3.6给出了这种情况。反变量 A 可以读做 A 杠或者 A 反。\n$$ 图3.6~~~反相器对输入变量求反 $$\n3.1.6 应用举例 图3.7给出了一个产生 8 位二进制数反码的电路。二进制数的位被加到反相器的输入上，二进制数的反码出现在输出中。\n$$ 图3.7~~~使用反相器的反码电路举例 $$\n","date":"2023-07-14T19:04:15+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/","title":"3.1 反相器"},{"content":"2.12.1错误检测的奇偶校验法 ◇ 奇偶校验位给出一个数中1的个数是奇数还是偶数. 许多系统都使用一个奇偶校验位,作为位错误检测的手段.任意的多位数组都包含奇数个 1或偶数个 1.将一个奇偶校验位附加到多位数组中,使得这组数中 1 的个数总是偶数或者总是奇数.一个偶校验位使得 1 的总数为偶数,而奇校验位使得 1 的总数为奇数.\n一个给定的系统运行于偶校验或者奇校验,而不是同时运行于两者.例如,如果某系统运行于偶校验,则对于所接收的每一个多位数组都做一个检查,以确保这个多位数组中 1 的总数是偶数.如果有奇数个 1,就有一个错误发生了.\n作为对奇偶校验位怎样附加到编码中的一个说明,表2.7列出了每个BCD码的偶校验和奇校验的奇偶校验位.每个BCD码的校验位处于P列上. $$ 表2.7~~带奇偶校验位的 ~BCD ~码 $$ $$偶校验$$\n校验位 P BCD 0 0000 1 0001 1 0010 0 0011 1 0100 0 0101 0 0110 1 0111 1 1000 0 1001 $$奇校验$$\n校验位 P BCD 1 0000 0 0001 0 0010 1 0011 0 0100 1 0101 1 0110 0 0111 0 1000 1 1001 奇偶校验位可以附加到码的开头或者结尾,这取决于系统的设计.注意,1 的总数 包括奇偶校位上的 1,对于偶校验总是偶数,对于奇校验总是奇数.\n检测一个错误奇 偶校验位提供了单个位错误的检测(或者任何奇数个错误,这种可能性较小),但是不能检测一组数中的两个错误.例如,假设我们希望传送 BCD 码 0101.(奇校验可以应用于任何位数的码;使用 4 位作为说明.)所传送的总的码,包括偶校验位如下所示\n现在,让我们假设从左边数第3位发生了错误(1变为0),如下所示:\n当该码被接收时,奇偶校验检测电路检测出只有一个 1(奇数),但是应当有偶数个 1.因为在码被接收时,偶数个 1 没有出现在码中,所以就指出了一个错误.\n奇校验位提供了相似的方式,用以检测给定位数的数组的单个错误.\n2.12.2循环冗余校验码(CRC) 在通信链路的数字数据的传送过程中,循环冗余校验码(CRC)广泛用于检测一位或两位传送错误.通信链路存在于两台通过网络相连的计算机之间,或者是一个数字存储装置(例如CD,DVD或硬盘)和一台PC之间.如果设计合理,循环冗余校验码还可以检测一组比特数中的多个连续的错误(区间误差).在循环冗余校验码中,检测位的数目有时称为校验和,它被加到传送的数据位中(加在最后).接收器使用循环冗余校验码来检测接收到的数据的错误.循环冗余校验码并不能检测出所有可能出现的错误,但是它比简单的奇偶校验要有效得多.\n循环冗余校验码在数学上通常描述为两个多项式相除,并产生一个余数.多项式就是一个数学表达式,这个表达式具有多个正指数项的和.如果各项系数仅为 1 和 0 时,就称为单变量多项式.单变量多项式的一个例子是 $1x^3+0x^2+1x^1+1x^0$,或简写为 $x^3+x^1+x^0$,这完全可以用 4 位二进制数 1011 来表示.大多数循环冗余校验码使用 16 位或较大的多项式,但是为了解释简单,这里使用 4 位.\n模-2运算 可以简单地认为,循环冗余校验码就是基于两个二进制数的相除,除法就是一系列的减法和移位.进行减法操作时,使用一个称为 模-2 加法的方法.模-2加法(或减法)和不考虑进位的二进制加法相同,如表2.8的真值表所示.如同第3章将要学习的那样,真值表广泛地用于描述逻辑电路的运算.两位数位在真值表中有四种可能的组合.这个特定的表描述的模-2运算,也称为异或运算,可以由第3章将要介绍的逻辑门来实现.模-2运算的一个简单规则就是如果两个输入不同,输出就是 1,否则输出为 0. $$ 表2.8 ~~模-2运算 $$\n输入位 输出位 0 0 0 0 1 1 1 0 1 1 1 0 循环冗余校验码的处理步骤 如下所示:\n选择一个固定的生成码,它可以比校验的数据位的位数少.这个生成码要事先让发送器和接收器都能识别,并且对于发送器和接收器必须都是相同的. 附加上若干个 0, 0 的个数和加到数据位的生成码的 0 的个数相同. 使用模-2方法,把数据位和附加的生成位合在一起除以生成码. 如果余数为 0,那么数据位和附加的位原样发送. 如果余数不为 0,那么为了使发送数据前余数为 0,附加的位改为余数位. 在接收端,接收器使用和发送器相同的生成数位除以接收到的附加的数据位. 如果余数为 0,就没有检测到错误(多个错误的可能性很小,使用时不考虑这种情况).如果余数不为 0,就检测到在传送过程中有一个错误,接收器会发出一个重传请求. 图2.7为循环冗余校验码的处理步骤的示意图. $$ (a)通信链路的发送端 $$ $$ (b)通信链路的接收端 $$ $$ 图2.7~~循环冗余校验码的处理步骤 $$\n","date":"2023-07-14T19:03:59+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/","title":"2.12 错误检测码"},{"content":"2.11.1格雷码 格雷(Gray)码是无权码,并不是算术编码;也就是没有赋予不同位的特足的权.恰雷俏的重要特征是,从一个码字到下一个接续码字仅有一位发生了变化.这个特征在许多应用程序中是非常重要的,例如对于轴位编码器,在两个相邻顺序数之间,错误敏感度随着位数改变数目的增加而增加.\n◇ 格雷码的一位改变的特征减小了出错概率. 表2.6列出了十进制数 0~15 所对应的 4 位格雷码,表中给出了二进制数以做参照.和二进制数相似,格雷码可以拥有任意的位数.注意两个相邻的格雷码字之间的一位变化.例如,从十进制数 3 到十进制数 4,格雷码从 0010 变为 0110,而二进制编码从 0011 变为 0100 改变了 3 个位.格雷码中唯一的位改变是从右数的第 3 位,其他位保持不变. $$ 表2.6 ~~~4位格雷码 $$\n10进制 2进制 格雷码 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 二进制数到格雷码的转换 二进制数和格雷码之间的转换有时很有用.下面的规则解释了怎样把二进制数变换为格雷码.\n格雷码中的最高有效位(最左边)等同于二进制数中相应的最高有效位. 从左到右,加上每一对相邻的二进制编码位,得到下一个格雷码位.舍去进位. 例如,二进制数 10110 到格雷码的转换如下:\n格雷码为11101.\n格雷码到二进制数的转换 为了把格雷码转为二进制数,可以使用相似的方法,但是有一些区别.可以应用下面的规则.\n二进制编码中的最高有效位(最左边)等于格雷码中相应的位. 将所产生的每个二进制编码位加上下一相邻位置的格雷码位.舍去进位. 例如,格雷码 11011 到二进制的转换如下: 二进制数是10010.\n2.11.2典型应用 3 位轴位编码器的示意图如图2.6所示.通常,有三个同心圆环被分成 8 个扇区.扇区越多,位置就能表示得越准确,但是为了解释的方便,仅仅使用了 8 个扇区.每个圆环的每个扇区分为能够反射光束或不能反射光束两种,当圆环随着轴转动时,处于红外线(IR)发射器下部的扇区分别接收红外线发射器所产生的 3 条光束.当扇区反射光束时表示 1,当扇区不反射光束时表示 0.红外线探测器检测是否存在反射光束,然后产生相应的 3 位编码.红外线发射器/探测器处于固定位置,当轴逆时针 360° 旋转时, 8 个扇区在3条光束下移动.每一条光束被扇区的表面反射或吸收,产生表示轴位编码器位置的二进制数或格雷码.\n在图2.6(a)中,这些扇区直接以二进制格式排列,所以探测器输出从 000 到001,再到 010,再到 011,等等.当光束处于反射扇区上部时,输出为 1;当光束处于非反射扇区上部时,输出为 0.如果从一个扇区到另一个扇区的转换瞬间,一条光束稍微先于其他光束被反射或吸收,就会产生一个错误的输出.考虑这 3 条光束从 111 扇区变换到 000 扇区所发生的情况.如果最高位的光束略微超前,那么由于 111 或 000 被 011 瞬间替代,轴位将被错误地显示.在这个应用中,要使得红外发射器/探测器的安装精确对齐,实际上是不可能的,因此在扇区之间瞬间变换时,通常会发生错误. $$ (a)二进制码~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)格雷码 $$ $$ 图2.6一个简单的例子,解释在轴位编码器中格雷码是如何解决出错问题的.虽然大多数 \\\\ 轴位编码器使用10位以上的编码以提高分辨率,但是使用3位就可以解释这种概念 $$ 格雷码用来消除二进制所固有的这类出错问题.如图2.6(b)所示,格雷码保证了在两个相邻的扇区中,只有一个位会发生改变.这就意味着即使光束没有精确对准,也绝对不会发生转移瞬间中的错误.例如,再一次考虑,当光束位于 111 扇区,准备进入下一个 101 扇区会发生什么情况.无论光束是否对准,在转移瞬间只有两个可能的输出 111 和 101.在其他扇区的转移瞬间中,也会产生相同的结果.\n","date":"2023-07-14T19:03:50+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/","title":"2.11 数字编码"},{"content":"2.10.1 8421 BCD码 ◇ 在 BCD码中,每个十进制数都由 4 位二进制编码表示. 8421 码是 BCD(二-十进制编码)码的一种类型.二-十进制编码的意思是,每一个十进制数,从 0~9,都由 4 位二进制编码表示.名称 8421 表明了 4 个位的二进制权($2^3,~2^2,~2^1,~2^0$).这种编码的主要优点是,8421 编码数和我们熟悉的十进制数之间很容易转换.只要记住 10 个十进制数的二进制组合,如表2.5所示.8421 码是主要的 BCD 码,所以当我们提及 BCD 码时,总是指 8421 码,除非有特殊的说明.\n$$ 表2.5~~10进制/BCD转换 $$\n10进制 0 1 2 3 4 5 6 7 8 9 BCD 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 无效码 应当认识到,使用4个位可以表示 16 个数(从0000 到1111),但是在 8421 码中,在这 16 个数中只使用了 10 个数.未使用的编码组合为 1010,1011,1100,1101,1110,1111,它们在 8421 BCD 码中是无效的.\n为了以 BCD 码表示任意十进制数,只要将每个十进制数位用相应的 4 位编码替代就可以了,如例2.33所示.\n同样,很容易根据一个 BCD 码确定一个十进制数.从最右边的一位开始,把 BCD 码分成 4 位一组.然后写出每个 4 位一组所表示的十进制数.例2.34给出了这个过程.\n应用 数字钟,数字温度计,数字仪表和一-些其他使用七段显示器的设备是典型的使用 BCD 码显示十进制数的装置.进行运算时BCD 码不如二进制数那么有效和直接,但是如果仅局限于所需要的处理(例如数字温度计),就显得特别有用.\n2.10.2 BCD码加法 BCD 码是一种数字码,并且可以使用在算术运算中.加法是最重要的运算,因为其他 3 种运算(减法,乘法,除法)可以用加法来完成.下面介绍了如何将两个 BCD 码相加.\n步骤1: 使用2.4节中二进制加法的规则,将两个 BCD 码相加.\n步骤2: 如果 4 位和等于或者小于 9,这个和就是一个合法 BCD 码.\n步骤3: 如果 4 位和大于 9,或者如果在4位一组之外产生了一个进位,那么这就是一个无效结果.在 4 位和上加 6(0110)以跳过 6 个无效状态,并将编码返回 8421 码.如果加上 6 时产生进位,就把这个进位加到下一个4位一组中.\n例2.35说明了 BCD 码的加法,在这个例子中, 4 位和等于或者小于 0,所以这些 4 位和都是有效的 BCD 码.例2.36说明了出现无效和(大于 9 或者有进位)的过程.\n进行 BCD 码运算的一个替换方法是把它们转换成十进制数,进行加法运算,然后把运算结果转换回 BCD 码.\n","date":"2023-07-14T19:03:37+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/","title":"2.10 二—十进制编码-BCD"},{"content":"八进制数字系统由8个数位组成,它们是\n$$ 0，~1,~2，~3,~4，~5,~6，~7 $$\n要计大于 7 的数，则从另一列重新开始:\n$$ 10,~11 ，~12，~13，~14，~15~，16，~17，~20，~21 ,… $$\n八进制数字系统的基是 8。 八进制计数和十进制计数比较相似，不同的是没有使用数字 8 和 9。为了区别八进制数和十进制数或者十六进制数，我们使用下标 8 来表示八进制数。例如，八进制 $15_8$ 等于十进制数 $13_{10}$ 和十六进制数D。有时会看到八进制数后面跟随“o”或者“Q”。\n2.9.1 八进制数到十进制数的转换 由于八进制数的基是 8,因此每一个相继的数位都是 8 的递增幂，从最右边 $8^0$ 开始, 计算八进制数的相应十进制数的数值，可以通过把每一个数字都乘以其相应的权，并把所得到的积加起来。下面展示了 $2374_8$ 的转换过程。\n2.9.2 十进制数到八进制数的转换 把十进制数转换为八进制数的方法，即重复除以 8 的方法，这和十进制数到二进制数或十六进制数的转换方法相似。为了给出这个过程，我们把十进制数 359 转换为八进制数，以 8 为除数的每一次相继相除都会产生一个余数，而这个余数就会成为相应八进制数的数位。所产生的第一个余数是最低有效数(LSD)。 2.9.3 八进制数到二进制数的转换 ◇ 八进制是表示二进制数的简洁方法，但是并没有十六进制数常用。 因为每一个八进制数位都可以由一个 3 位二进制数来表示，所以八进制数转换为二进制数很容易。每一个八进制数位由 3 位二进制数表示，如表2.4所示。 $$ 表2.4 ~~~8进制/2进制转换 $$\n8进制 0 1 2 3 4 5 6 7 2进制 000 001 010 011 100 101 110 111 为了把八进制数转换为二进制数，只要用相应的 3 位二进制数替换每个八进制数位就可以了。这个过程如例2.31所示。\n2.9.4 二进制数到八进制数的转换 二进制数到八进制数的转换是八进制数到二进制数的转换的逆过程。如下所述从最右边的 3 位数一组开始，从右向左移动，把每 3 位数一组变换为相应的八进制数。如果最左边的一组没有可用的 3 位数，就加上一个或者两个 0 以形成 3 位一组。前面的 0 不影响二进制数的值。\n","date":"2023-07-14T19:03:11+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.9 八进制数"},{"content":" ◇ 十六进制数字系统由数字 0~9 和字母 A~F 组成.\n十六讲制数字系统的基是 16,也就是它由 16 个数字和字母共同组成.大多数的数字系统都能成组处理二进制数,即多个4位的组合,这样使用十六进制非常方便,因为每一个十六进制数位就代表了一个 4 位二进制数(如表2.3所示).\n10 个数字和 6 个字母字符构成了十六进制数字系统.使用字母 A,B,C, D,E,F 表示数字,初看起来很奇怪,但是请记住任何一种数字系统都是有序符号的集合而已.如果已经理解这些符号表示哪些数,一旦习惯了它们的使用方式,这些符号本身就不重要了.我们将使用下标 16 来指明十六进制数以避免和十进制数相混淆.有时可能会看到十六进制数后面跟随一个\u0026quot;h \u0026ldquo;.\n$$ 表2.3 $$\n10进制数 2进制数 16进制数 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 2.8.1 十六进制计数 计数到F时,怎样在十六进制中计数呢?只要到左侧一列继续计数就可以了,如下所示:\n$$ …,~E,~F,~10,~11,~12,~13,~14,~15,~16,~17,~18,~19,~1A,~1B, ~1C,~1D,~1E, \\\\ ~1F,~20,~21,~22,~23,~24,~25,~26,~27,~28,~29,~2A,~2B,~2C,~2D,~2E,~2F,~30,~31,… $$\n利用两个十六进制数位,可以数到 $FF_{16}$,也就是十进制数中的 255.当大于 255 时就需要三个十六进制数位.例如, 100,在十进制数中就是 256, $101_{16}$,在十进制数中就是 257,以此类推.最大的 3 位十六进制数是 $FFF_{16}$,表示十进制数 4095.最大的4位十六进制数是 $FFFF_{16}$,也就是十进制数 65535.\n2.8.2 二进制数到十六进制数的转换 把二进制数转换为十六进制数是非常直接的过程.从最右边一位开始,将二进制数每 4 位分成一组,用对等的十六进制符号替代相应的每个 4 位的组合.\n2.8.3 十六进制数到二进制数的转换 ◇ 使用十六进制数来表示二进制数是一个很方便的方法. 把十六进制数转换为二进制数的过程和上述过程相反,使用对等的 4 位的组合替代每个十六进制符号.\n◇ 十六进制数和二进制数之间的转换直接且容易. 应该清楚,处理十六进制数要比处理相应的二进制数容易一些.因为它们之间的转换很容易,所以十六进制系统在程序设计,打印输出及显示中得到了广泛的应用.\n2.8.4 十六进制数到十进制数的转换 一种求十六进制数相应的十进制数的方法是,首先把十六进制数转换为二进制数然后再把二进制数转换为十进制数.\n◇ 一台计数器可以用来完成十六进制的算术运算. 另一种把十六进制数转换为十进制数的方法是,把每一个十六进制数位的十进制值都乘以该位的权,然后再把这些积加起来.十六进制数的权是 16 的递增幂(从右到左).对于4位十六进制数,它的权是\n$16^3$ $16^2$ $16^1$ $16^0$ 4096 256 16 1 2.8.5 十进制数到十六进制数的转换 用 16 重复除十进制数,就会生成相应的十六进制数,它由相除的余数构成.生成的第一个余数是最低有效数( LSD).以 16 作为除数的每一次相除都会生成一个余数,这个余数就是相应十六进制数的一个数位.这个过程和 2.3 节提到的十进制到二进制转换中重复除以 2 的方法相似.例2.28展示了这个过程.注意当商有小数部分时,用除数乘小数部分就会得到余数.\n2.8.6 十六进制加法 可以直接使用 十六 进制数进行加法运算,记住十六进制数 0~9 等同于十进制数 0~9,而十六进制数 A~F 等同于十进制数 10~15.当两个十六进制数相加时,使用下面的方法.(十进制数由下标10表示.)\n在加法问题任一给定的列中,把两个十六进制数看成它们的十进制值.例如,$5_{16} = 5_{10}$ 和 $C_{16} = 12_{16}$. 如果这两个数字的和是 $15_{10}$.或者小些,记下相应的十六进制数. 如果这两个数字的和大于 $15_{10}$,记下超出 $16_{10}$ 的量,并在下一列进 1. 2.8.7 十六进制减法 如同前面介绍的,补码允许利用二进制数相加来进行减法的运算.由于十六进制数可以表示二进制数,所以也可以表示二进制数的补码.\n有3种方法可以取得十六进制数的补码,方法1最常见也最容易使用,方法2和方法3是替代方法.\n方法1 将十六进制数转换为二进制数.取二进制数的补码,把结果转换为十六进制数,如图2.3所示. $$ 图2.3 ~~得到十六进制数的补码的方法1 $$\n方法2 从最大十六进制数减去当前十六进制数,并加1,如图2.4所示. $$ 图2.4~~~ 得到十六进制数的补码的方法2 $$\n方法3 写出单个十六进制数的序列.在这一行的下面,以相反的顺序写出这个序列.每个十六进制数的反码就是该数字正下方的数字,结果数加1得到补码,如图2.5所示. $$ 图2.5~~~得到十六进制数的补码的方法3 $$\n","date":"2023-07-14T19:03:03+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.8 十六进制数"},{"content":"2.7.1 加法 加法中的两个数就是加数和被加数,结果是和.当两个带符号二进制数相加时,有以下4种情况.\n两个数都是正的. 正数的数值大于负数的数值. 负数的数值大于正数的数值. 两个数都是负的. 这里使用 8 位带符号数,每次给出一种情况作为例子,也给出相应的十进制数作为对照\n◇ 两个正数相加产生一个正数.\n两个数都是正的:\n和是正的,因而是二进制原码(非补码).\n◇ 正数和负数相加产生一个正数.\n正数的数值大于负数的数值:\n最后的进位被舍去.和是正的,因而是二进制原码(非补码).\n◇ 一个正数加上一个较大的负数或者两个负数相加时,生成一个补码形式的负数.\n负数的数值大于正数的数值:\n和是负的,所以是补码形式.\n两个数都是负的:\n最后的进位被舍去.和是负的,所以是补码形式.\n在计算机中,负数是以补码形式保存的,所以正如所见,加法过程是很简单: 将两个数加起来,并舍去最后的任何进位.\n溢出条件 当两个数加在一起,而表示和所需的位数超出了这两个数的位数,这时就会发生溢出,并由一个错误符号位指明.溢出仅发生在两个都是正数或者两个都是负数的情况下.如果相加结果得到的符号位和相加的两个数的符号不同,就表明发生了溢出.下面的 8 位数例子将说明这种情况.\n在这个例子中,和 183 需要 8 个数值位.由于数中只有 7 个数值位(有一位是符号位),这时进位就会进人符号位,从而产生溢出指示.\n一次加两个数 现在让我们看看数字串相加的情况,即一次加两个数.可以这样操作,首先将前两个数相加,然后两数之和加第三个数,然后再在此和的基础上加第四个数,以此类推.这就是计算机中数字串的相加方法.一次加两个数的方法如例2.19所示.\n2.7.2 减法 ◇ 减法是将减数符号改变后的加法.\n减法是加法的一个特例.例如,从　＋9(被减数)中减去　＋6(减数)就相当于　+9　加上　-6.基本上,减法运算是改变减数的符号然后加上被减数的运算.减法的结果称为差.\n正二进制数或者负二进制数的符号通过求此数的补码而改变.\n例如,求取正数　00000100 (+4)的补码时,就会得到　11111100,这就是　–4,权和的计算如下: $$ -128~+64~+32~+16~+8~+4=-4 $$ 作为另一个例子,当取负数 11101101 (-19)的补码时,就会得到 00010011,这就是＋19,权和的计算如下: $$ 16~+2~+1~=~19 $$\n◇ 当用补码的方法进行二进制减法时,重要的是两个数要有相同的位数.\n由于减法仅仅是减数符号改变后的加法,所以该过程有如下的表述方式:\n要将两个带符号数相减,取减数的补码然后相加即可.舍去最后的任何进位.\n2.7.3 乘法 乘法中的数分别是被乘数,乘数及积.下面的十进制乘法运算说明了这些数:\n在大多数计算机中,乘法运算是通过加法来完成的.正如所见,减法是由加法器完成的,现在看看乘法运算是如何完成的.\n◇ 乘法相当于一个数加上它本身,相加的次数就是乘数.\n直接加法和部分积是使用加法完成乘法的两种基本方法.在直接加法的方法中,被乘数自身相加的次数等于乘数.在前面的十进制例子(3×8)中,三个被乘数相加: 8+8+8= 24.这种方法的缺点是,如果乘数很大,则运算会变得很冗长.例如,要运算 350×75,必须把 350 自身相加 75 次.顺便说一下,这就是为什么相乘的次数常用来指乘数.\n两个二进制数相乘时,这两个数都必须是原码(非补码)的形式.直接加法的方法如例 2.21 所示,每次进行两个二进制数的相加.\n部分积方法可能是最常用的一种方法,因为它反映了普通的手工乘法运算.从乘数的最低有效位开始,将被乘数乘以乘数的每一个位.被乘数乘以乘数每一位的结果称为部分积.每一个相继的部分积都向左移动(平移)一位,当产生所有的部分积时,把它们加起来就得到最后的积.这里有一个十进制例子.\n乘法运算的积的符号取决于被乘数和乘数的符号,依据下面两条规则:\n如果符号相同,积就是正值; 如果符号不同,积就是负值. 二进制乘法的部分积方法的基本步骤如下所示.\n步骤 1: 确定被乘数和乘数的符号是相同的还是相异的,这将决定积的符号.\n步骤 2: 把所有的负数变为原码(非补码)形式.因为大多数计算机郁以个吗形八休仔贝双,将负数变换为原码,需要进行补码运算.\n步骤 3: 开始于最低有效乘数位,生成部分积.当乘数的位是 1 时,部分积与被乘数就是一样的.当乘数的位是 0 时,部分积就是 0.将每一个相继的部分积向左移动一位.\n步骤 4: 将相继的部分积与其前面部分积的和相加,从而得到最终的积.\n步骤 5: 如果步骤 1 所确定的符号位是负的,就对积取补码.如果是正的,积就保持为原码.\n2.7.4 除法 除法中的数分别是被除数,除数及商.下面给出了标准的除法格式. $$ \\frac{被除数}{除数}=商 $$ 计算机中的除法运算是通过减法完成的.由于减法是由加法器完成的,所以除法也可以通过加法器来完成.\n除法的结果称为商; 商是除数可以进入被除数的次数.这就是被除数中可以减去多少次除数的次数等于商,如下面的 21 除以 7 所示.\n在这个简单的例子中,在余数为0之前除数从被除数中减去了三次,所以商是3.\n商的符号取决于被除数和除数的符号,依据以下两条规则:\n如果符号相同,商就是正的. 如果符号不同, 商就是负的. 当两个二进制数相除时,这两个数都必须是原码(非补码)形式.除法的基本过程如下.\n步骤1: 确定被除数和除数的符号是相同还是不同,这将确定商的符号.商的初始值是0. 步骤2: 使用补码加法把除数从被除数中减去,得到第一个部分余数,同时将商加 1.如果这个部分余数是正的,转到步骤3: 如果部分余数是 0 或者是负的,就完成了除法. 步骤3: 从部分余数中减去除数,商加上1.如果结果是正的,重复以上步骤得到下一个部分余数.如果结果是零或负的,完成除法.\n继续从被除数和部分余数中减去除数,直至出现0或者负数结果.计算除数被减的次数,就会得到商.例2.23使用 8 位带符号二进制数给出了这些步骤.\n","date":"2023-07-14T19:02:52+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/","title":"2.7 带符号数的算术运算"},{"content":"2.6.1 符号位 二进制符号数的最左边就是符号位,指出这个数是正数还是负数.符号位 0 表示正数,1 表示负数.\n2.6.2 符号数值的形式 当以符号数值的形式表示带符号二进制数时,最左边的一位是符号位,其余的都是数值位.数值位对于正数和负数来说都是二进制原码(非补码).例如,十进制数＋25表示为符号数值的形式就是一个 8 位带符号二进制数,使用符号数值的形式为\n十进制数-25表示为 $$ 10011001 $$ 注意 ＋25 和 –25 之间的唯一区别是符号位,因为对于正数和负数来说,数值位都是二进制原码.\n在符号数值的形式中,负数和其相应的正数具有相同的数值位,但其符号位为 1 而不是 0.\n2.6.3 反码形式 以反码形式表示正数的方法和以符号数值形式表示正数的方法是一致的.但是,负数却是其相应正数的反码.例如,使用 8 位数字,十进制数 -25 可以表示为 +25(00011001) 的反码 $$ 11100110 $$ 在反码形式中,负数就是其相应正数的反码.\n2.6.4 补码形式 正数的补码形式表示方法和符号数值与反码形式的表示方法是一致的.负数是相应正数的补码.再次使用 8 位数字,把十进制数 -25 表示为 +25(000011001) 的补码.按位取反再加 1,得到 $$ -25 =11100111 $$ 在补码形式中,负数是相应正数的补码.\n2.6.5 带符号数的十进制值 符号数值 在符号数值的形式中,正数和负数的十进制值,是由所有数值位为 1 的相应权加起来得到的,不考虑那些为 0 的位.符号通过检查符号位来确定.\n反码 在反码形式中,正数的十进制值是由所有为 1 的数值位相应的权加起来得到的,而不要考虑为 0 的位置.负数的十进制值是通过给符号位的权赋以负值,并把所有为 1 的数值位相应的权加起来再加上 1 得到的.\n补码 在补码形式中,正数和负数的十进制值,是把所有为 1 的数值位相应的权加起来得到的,而不要考虑为 0 的位置.负数中符号位的权被赋予负值.\n从这些例子中,可以看到为什么用补码形式来表示带符号整数比较好: 在转换为十进制数时,仅仅需要求权的和,而不用考虑是正数还是负数.对于负数而不是正数,反码形式需要给权的和再加上 1.当然反码形式并不是常用的,因为 0 的反码有两种可能的表示方式(00000000或11111111).\n2.6.6 带符号整数的表示范围 ◇ 二进制数的数值范围取决于数的位数(n).\n使用 8 位数给出说明,因为在大多数计算机中通常使用 8 位的组合,并被赋予特殊的名称,即字节(byte).使用一个字节或者 8位,可以表达 256 个不同的数.使用两个字节或者 16 位,可以表达 65536 个不同的数.使用 4 个字节或者 32 位,可以表达 $4.295 * 10^9$ 个不同的数.求解 n 位的不同组合个数的公式是 $$ 总组合数=2^n $$ 对于补码带符号数,n 位数的数值范围是 $$ -(2^{n-1})到+(2^{n-1} -1) $$ 其中对于每一个数,都有一个符号位和 n-1 个数字位.例如,使用 4 位数,并以补码表示的数的范围是从 $–(2^3) =-8$到$2^3-1 = +7$.类似地,利用 8 位,就可以从 –128 到 +127; 使用 16 位,就可以从 – 32 768 到 +32 767;等等.\n2.6.7 浮点数 为了表示很大的整数,就会需要多个位.当需要表示的数值同时具有整数和小数部分时(比如23.5618),就会有一个问题.基于科学计数法的浮点计数方法,可以表示很大及很小的数,而不用增加位数,当然也可以表示同时具有整数和小数部分的数.\n浮点数(也称为实数)由两部分组成再加上一个符号.尾数(mantissa)是浮点数中用以表示数字数值的部分,大小在 0 和 1 之间.指数(exponent)是浮点数中用以表示小数点(或者二进制小数点)要移动的位数的部分.\n十进制数的例子将有助于理解浮点数的基本概念.考虑一个十进制数,以整数形式表示为 241506800.尾数为.2415068,而指数是 9.当把这个整数表示为浮点数时,通过把小数点移动到数字的最左边而将其标准化,使得位数是一个小数,而指数是 10 的幂.这个浮点数写为 $$ 0.2415068 * 10^9 $$ 对于二进制浮点数来说,其格式由 ANSI/IEEE 标准 754-1985 定义为三种形式: 单精度,双精度及扩展精度.除了位数不同之外,它们都具有相同的基本格式.单精度浮点数具有 32 位,双精度浮点数具有64位,而扩展浮点数具有80位.我们的讨论将限于单精度浮点数格式.\n单精度浮点二进制数 在单精度浮点二进制数的标准格式中,符号位(S)是最左边的位,指数(E)包括了接下来的 8 位,尾数或者小数部分(F)包括了剩余的 23 位,如下所示:\n在尾数或者小数部分,一般认为二进制小数点位于 23 位的左边.为了有效起见,使尾数部分具有 24 位,因为在任何一个二进制数中最左边(MSB)总是为 1.所以,认为这个 1 位于最左边,尽管并没有占用实际的位置.\n指数中的 8 位表示的是偏移指数,在实际指数上加上 127 就可以得到.偏移指数的目的是允许表示很大或者很小的数,而不需要为指数赋予一个单独的符号位.偏移指数允许的实际指数范围是–126到+128 .\n为了说明二进制数怎样以浮点格式表示,使用1011010010001作为一个例子.首先,它可以表示为1加上一个二进制小数,把二进制小数点向左移动12位然后乘以适当的2的幂. $$ 1011010010001 = 1.011010010001 * 2^{12} $$ 假设这是一个正数,符号位(S)是 0.指数 12 表示为偏移指数的形式,将其加上 127(12+127 =139).该偏移指数(E)表示为二进制数 10001011.尾数是二进制数的小数部分(F),即.011010010001.因为在 2 的幂次表达式中,二进制小数点的左边总是为 1,它并不包含在尾数中.完整的浮点数是\n接下来,看看怎样计算以浮点格式表示的二进制数.确定浮点数数值的一般方法如下面的公式所示: $$ 数=(-1)(1+F)(2^{E-127}) $$ 为了说明这个公式,考虑下面的浮点二进制数:\n符号位是1.偏移指数是 10010001 = 145.应用这个公式,我们得到 $$ 数=(-1)^1(1.10001110001)(2^{145-127}) \\\\ =(-1)(1.10001110001)(2^{18})=-1100011100010000000 $$ 这个浮点二进制数等于十进制数的 -407688.因为指数可以是 -126和 +128 之间的任意数,所以最大和最小的数都可以表示出来.32 位的浮点数可以代替具有 129 位的二进制整数因为指数确定了二进制小数点的位置,所以也可以表示同时包含整数和小数部分的数.\n浮点数的这种格式有两个例外: 数 0.0 由全 0 来表示,而无穷大的数由指数全 1 和尾数全 0 来表示.\n","date":"2023-07-14T19:02:43+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/","title":"2.6 带符号数"},{"content":"2.5.1 求二进制数的反码 ◇ 改变数中的每一位以得到反码.\n二进制数的反码可以通过把所有的 1 变为 0 及把所有的 0 变为 1 而得到,如下所示:\n利用数字电路求二进制数反码的最简单方法是使用并行反相器(\u0026ldquo;非\u0026quot;电路),如图2.1所示,用以变换8位二进制数.\n2.5.2 求二进制数的补码 ◇ 反码加 1 就可以得到补码.\n二进制数的补码是通过在反码的最低有效位(LSB)上加1而获得的. $$ 补码=反码+1 $$\n◇ 改变最低有效1左边的全部位求得补码.\n求二进制数补码的另一种替代方法如下所示:\n从右边的最低有效位开始,写下它们实际的位,包括第一个 1. 剩下的位求反码. 使用反相器和加法器可以实现二进制负数的补码,如图2.2所示.该图说明了怎样把一个8位数转换为它的补码;首先每一个位取反(取得反码),然后使用加法器电路把反码加1. $$ 图2.2~~~ 获得二进制负数补码的例子 $$ 为了把反码或者补码变回二进制原码(非补码),可以应用和前面描述的一样的过程.为了从反码回到二进制数原码,可以反转所有的位.为了从补码回到二进制数原码,可以先取得补码的反码,然后在最低有效位上加 1.\n","date":"2023-07-14T19:02:15+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/","title":"2.5 二进制数的反码和补码"},{"content":"2.4.1 二进制加法 ◇ 在二进制中,1+1 = 10,而不是2.\n二进制数(位)加法的 4 条基本规则如下:\n0+0=0 和为0. 进位是0 0+1=1 和为1. 进位是0 1+0=1 和为1. 进位是0 1+1=10 和为10. 进位是1 注意: 前三条规则产生单个的位,而在第4条规则中,两个1相加生成二进制的2(10).二进制数在相加时,最后一种情况在低位的和为0,而在左边的高位产生了进位1,如下面的加法运算 11+1 所示:\n在最右列中,1+1=0,因而在此列的左侧一列,即中间一列产生进位1.在中间一列中,1+1+0=0,因而在此列的左侧一列中产生进位1.在最左列中,1+0+0 =1.\n当存在进位1时,就会遇到三个位进行加法的情况(两个数中的位和一个进位).这种情况如下所示: 2.4.2 二进制减法 ◇ 在二进制中,10 - 1 =1,而不是9.\n二进制数(位)减法的4条基本规则如下:\n0-0=0 1-1=0 1-0=1 10-1=1 0-1 产生借位1 进行减法运算时,有时必须从左边一列中借位.在二进制中,仅当0减去1时才需要借位.在这种情况下﹐从左边一列借来1,被减的列就会出现10,这时必须使用上面列出的4条基本规则中的最后一条.例2.8和例2.9说明了二进制减法,同时也给出了相应的十进制减法.\n2.4.3 二进制乘法 ◇ 两位的二进制乘法和十进制数О和1的乘法相同.\n位相乘的4条基本规则如下:\n0 * 0 = 0 1 * 1 = 0 1 * 0 = 1 10 * 1 = 1 ~~ 0 - 1 产生借位1 二进制乘法和十进制乘法的运算方法是一样的.这涉及部分积的形成,把相继的部分积向左移一位,然后把所有的部分积加起来.例2.10说明了这个过程,同时也给出了相应的十进制乘法作为参照.\n2.4.4 二进制除法 一个计数器可以用来进行二进制的算术运算,只要不超出计数器的运算范围.\n二进制中的除法遵循和十进制除法一样的过程, 如例2. 11所示,其中给出了相应的十进制除法.\n","date":"2023-07-14T19:02:06+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/","title":"2.4 二进制算术"},{"content":"2.3.1 权和的方法 ◇ 如果要把一个已知的十进制数转换为二进制数,只要求出二进制数的权,全部权加起来就是十进制数.\n想要得到一个给定十进制数的二进制数,只要确定二进制数权的和,它们等于相应的十进制数.记住二进制权的简单方法是最低位为1,也就是$2^0$,任何一个权乘以2,就会得到下一个更高位的权,因此7个二进制权的序列就是64,32,16,8,4,2,l,这和上一节学到的一样.例如,十进制数9就可以由二进制权的和表示如下: $$ 9=8+1或者9=2^3＋2^0 $$ 把1放在适当的权的位置上,即 $2^3$ 和 $2^0$,把0放在 $2^2$ 和 $2^1$ 的位置上,就确定了十进制数9.\n2^3 2^2 2^1 2^0 1 0 0 1 十进制数9的二进制数表达\n2.3.2 重复除以2的方法 ◇要得到一个给定十进制数的二进制数,可以用2除这个十进制数直至商为0,每次余数的全部便构成了二进制数.\n将十进制整数转换为二进制数的系统方法是重复除以2的过程.例如,把十进制数12转换为二进制数,首先12除以2.然后把每次得到的商都除以2,直到商为0.每次相除所得到的余数就构成了二进制数.第一个得到的余数是二进制数中的最低有效位(ISB),最后一个产生的余数是最高有效位(MSB).将十进制数12转换为二进制数的过程由下列步骤给出. 2.3.3 十进制小数转换为二进制数 例2.5和例2.6给出了整数的转换,现在来看小数的转换.记住小数二进制权的一个简单的方法是最高有效权是0.5,也就是$2^{-1}$,任何一个权除以2,就得到次低位的权;因此4个小数的二进制权的序列就是0.5, 0.25, 0.125,0.0625.\n权和 权和的方法可以应用于十进制小数,如以下的例子所示: $$ 0.625= 0.5 +0.125 = 2^{-1} + 2^{-3} =0.101 $$\n在$2^{-1}$位置上有一个1,在 $2^{-2}$ 位置上有一个0,而在$2^{-3}$位置上有一个1.\n重复乘2 正如所见,可以用重复除以 2 的方法把十进制整数转换为二进制数.二进制小数则可以用重复乘2的方法转换得到.例如,把十进制小数 0.3125 转换为二进制数,首先把 0.3125 乘以 2,然后把每次乘积的小数部分乘以 2,直到乘积的小数部分为 0,或者达到了所需要的小数位数. 由相乘产生的进位数字或者进位,就生成了二进制数. 所产生的第一个进位是最高有效位(MSB),最后一个进位是最低有效位(LSB).该过程如下所示: ","date":"2023-07-14T19:01:56+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/","title":"2.3 十进制数到二进制数的转换"},{"content":"2.2.1 二进制计数 ◇ 二进制数字系统有两个数字(位).\n下面学习二进制系统的计数方法.首先看一下十进制系统的计数方法.在用完数字之前,从О开始,依次计数到9.然后从另一个数位开始(左边),继续从10计数到99.此时已经用完了两位数字的所有组合,所以需要第三个数位,从100计数到999.\n二进制数在计数时,也会发生类似的情况,只是这时只有两个数字,称为位(比特).开始计数:0,1.此时,已经使用了两个数字,所以加入另一个数位继续计数:10,11.至此,已经使用了两个数字的所有组合,所以需要第3个数位.使用3个数位,可以继续计数:100,101,110,111.还要继续下去,就需要第4个数位,以此类推.从0到15的二进制计数方法如表2.1所示.注意在每一列中1和0的交替规律.\n◇ 二进制数字系统的基为2.\n如表2.1所示,从О计数到15需要4个数位.一般来说,对于 n 个数位,可以计数到2^n-1. $$最大十进制数=2^n-1$$ 例如,若有5个数位(n =5),就可以从0计数到31. $$2^5-1= 32-1 = 31$$ 若有6个数位(n =6),就可以从О计数到63. $$2^6-1=64-1 =63$$\n◇ 一个数中位的值由它在此数的位置确定.\n10进制数字 2进制数字 0 0 0 0 0 1 0 0 0 1 2 0 0 1 0 3 0 0 1 1 4 0 1 0 0 5 0 1 0 1 6 0 1 1 0 7 0 1 1 1 8 1 0 0 0 9 1 0 0 1 10 1 0 1 0 11 1 0 1 1 12 1 1 0 0 13 1 1 0 1 14 1 1 1 0 15 1 1 1 1 2.2.2 二进制数的加权结构 ◇ 位的权或值在二进制数中从右向左增加.\n二进制数是有权数.在二进制整数中,最右边的位是最低有效位( LSB),并且相应的权是$2^0$ = 1.权从右向左,每前进一位,2的幂次增加1.最左边的位是最高有效位(MSB).二进制数位的大小确定了它的权.\n利用二进制也可以表示小数,在二进制小数点的右边添加相应的位就可以了,就像把十进制数位添加在十进制小数点的右边一样.在二进制小数中,最左边的位是最高有效位,其相应的权是$2^{-1}$ = 0.5.小数的权从左向右减少,每位相差2的-1次幂.二进制数的加权结构是 $$ 2^{n-1}﹒﹒﹒2^{3}\\ 2^{2}\\ 2^1 2^0\\ .2^{-1}\\ 2^{-2}﹒﹒﹒2^{-n}\\ \u0026mdash;\u0026mdash;\u0026mdash;↑—二进制小数点 $$\n其中n是从二进制小数点开始的位数.因此,在二进制小数点左边的所有位,其相应的权是2的正数幂,就像前面所讨论的整数一样.在二进制小数点右边的所有位,其相应的权是2的负数幂,或称小数权.\n8位二进制整数和6位二进制小数所对应的2的幂次,以及它们对应的十进制权,如表2.2所示.注意对于2的正数幂,权将增大至两倍,而对于2的负数幂,权将减半.通过倍增2的最高有效正数幂,并二等分2的最低有效负数幂,就可以很容易地扩展这个表.例如,$2^9$= 512 和 $2^{-7}$ = 0.0078125.\n表2.2二进制权\n$2^8$ $2^7$ $2^6$ $2^5$ $2^4$ $2^3$ $2^2$ $2^1$ $2^0$ 256 128 64 32 16 8 4 2 1 $$ 2的正次幂(正整数) $$\n$2^{-1}$ $2^{-2}$ $2^{-3}$ $2^{-4}$ $2^{-5}$ $2^{-6}$ 1/2 1/4 1/8 1/16 1/32 1/64 0.5 0.25 0.125 0.625 0.03125 0.015625 $$ 2的负次幂(小数) $$\n2.2.3 二进制数到十进制数的转换 ◇把二进制数中所有位是1的权相加得到十进制数.\n对于二进制数转换成十进制数,只要把二进制数中的所有位是1的权加起来,不考虑所有位是0的权.\n","date":"2023-07-14T19:01:45+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.2 二进制数"},{"content":" 十进制数字系统有10个数字.\n在十进制数字系统中,10个数字中的每一个数字(从0到9)都表示某个数量.这10个符号(数字)并没有限制仅仅表示10个不同的数字量,因为可以在数字量相应的位置上分别使用这10个不同数字来表示这个数字量的大小.这10个数字的每一个最多可以从0到9表示10个数字.如果想要表示一个比9大的数字量,可以使用两个或者更多的数字位,而每一个数字所处的位置表示了这一位的大小.例如,想要表示23这个数字量,可以使用(根据它们在该数字量中相应的位置)数字2表示20这个数字量,用数字3表示3这个数字量,如下所示. 十进制数字系统的基为10.\n十进制数中每一个数字所在的位置表示了这一位的大小,称之为权.整数的权是10的正次幂,从右向左递增,开始于 $10^0$= 1. $$ \u0026hellip;10^5\\ 10^4\\ 10^3\\ 10^2\\ 10^1\\ 10^0 $$ 对于小数,权是10的负次幂,从左向右递减,开始于$10^{-1}$. $$ 10^2\\ 10^1\\ 10^0.10^{-1}\\ 10^{-2}\\ 10^{-3}\u0026hellip;\\ \\\\ \\\\ 个-小数点 $$\n数字的值取决于它在数中的位置.\n十进制数的值等于每个数字乘以相应位置上的权之后的和.\n","date":"2023-07-14T19:01:36+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"2.1 十进制数"},{"content":"单片集成电路(IC)是一个完全由单个小型的硅芯片组成的电子电路.组成电路的所有元件-晶体管,二极管,电阻和电容是单个芯片的一部分.固定功能的逻辑和可编程的逻辑是数字集成电路的两大类型.在固定逻辑功能的芯片中,逻辑功能已由开发商写入,不能改变. $$ 图1.15一个固定功能集成芯片封装类型的剖面图(双引线封装),给出了芯片的内部连接输入/输出引脚的封装部分 $$ 图1.15给出了一个固定功能集成芯片封装类型的剖面图,其中露出了封装内部的芯片电路,标出了芯片连接封装引脚用以连接外部的各种电路.\n1.3.1 集成电路封装 $$ (a)双引线封装(DIP) $$ 集成电路封装以它们安装在印制电路板(PCB)上的方法来分类,例如对穿孔封装和表面贴装等类型.对穿孔封装类型的引脚通过穿孔插入印制电路板,以便可以和另一边的导体焊接.最为普通的对穿孔封装是双引线封装(DIP),如图1.16( a)所示.\n另一种集成电路封装的类型是使用表面贴装技术(SMT).表面贴装相对于对穿孔封装节省空间.通过印制电路板的孔对于表面贴装技术是多余的.表面贴装的引脚直接焊接在印制电路板一面的导体上,留出另一面用于附加的电路.其次,对于有相同引脚数的电路,表面贴装与双引线封装相比尺寸更小,因为表面贴装的引脚分布更紧凑.一个表面贴装的例子就是小轮廓集成电路(SOIC),如图1.16(b)所示.\n$$(b)小轮廓集成电路(SOIC)$$ $$图1.16对穿孔和表面贴装芯片的例子.相同引脚数的 DIP比 SOIC的尺寸大, DIP大约为0.785英寸①长 , SOIC大约为0.385英寸长$$\n在一种尺寸范围内可用的表面贴装技术的不同类型,取决于引脚数(越复杂的电路和引线配置需要更多的引脚).图1.17给出了几种类型的例子.如图所见,收缩小轮廓封装( SSOP )的引脚形成鸥翼式形状.带引线的塑料芯片载体( PLCC )的引脚在封装下以J形翻转.无引线陶瓷芯片( LCC )具有金属接触面,焊接在它的陶瓷体上.薄型四侧引脚扁平封装( LQFP )也具有鸥翼式形状的引脚.片状刻度封装( CSP )和精密间距球形网格阵列( FBGA )的引脚嵌入在封装的底部相互接触. $$ 图1.17SMT封装配置,(e)和(f)给出的是底视图 $$\n1.3.2 引脚编号 所有集成电路的封装都具有一个标准形式的引脚编号.双引线封装(DIP)和收缩小轮廓封装(SSOP)的引脚都具有一定的编号排列方式,如图1.18( a)的16个引脚封装的芯片所示.观察芯片封装的顶部,引脚1有一个标识,可以是一个小圆点,一个缺口或是一个斜角边.小圆点总是紧靠着引脚1.同样,缺口方向朝上,引脚1总是在左上角的位置,如图所示.从引脚1开始,逐步向下引脚编号递增,然后跨越芯片在另一边编号向上递增.最大的引脚编号总是在缺口的右边小圆点对面的位置. $$ 图1.18集成电路封装引脚的标准类型.给出的是顶视图 $$ 带引线的塑料芯片载体(PLCC)封装和无引线陶瓷芯片(LCC)封装在全部的4个边上都具有引脚.引脚1由一个小圆点标记,或由其他的索引标记,它处于一边的中心位置.引脚的编号沿逆时针递增,图中看到的是封装顶部的视图.最大的引脚编号总是处于引脚1的右边.图1.18(b)给出了20个引脚的PLCC封装芯片的引脚分布.\n","date":"2023-07-14T19:01:23+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/","title":"1.3 固定功能的集成电路"},{"content":"1.2.1 二进制数 二进制系统中的两个数——1和0,称为位(比特,bit),是二进制数(binary digit)的缩写.在数字电路中,使用两个不同的电压电平表示这两个位.一般情况下,高电压用1来表示,低电压用0来表示.这称为正逻辑,本书将都使用正逻辑. $$ 高电压(H)=1低电压(L)=0 $$ 在另一种系统中,1表示低电压,0表示高电压,这称为负逻辑. 一组位(一些1和0的组合)称为码,用来表示数字,字母,符号,指令及任何给定应用中的对象.\n1.2.2 逻辑电平 用来表示1和0的电压称为逻辑电平.理想情况下,一个电平表示高电压,另一个电平表示低电压.在实际的数字电路中,这个高电压可以是指定的最小值和最大值之间的任意值.同样,低电压也可以是指定的最小值和最大值之间的任意值.在指定的高电平范围和低电平范围之间是不能有重叠的.\n图1.5给出了数字电路中高电平和低电平的通常范围.变量 $V_{H(max)}$ 表示高电平的最大值,变量 $V_{H(min)}$ 表示高电平的最小值.$V_{L(max)}$ 表示低电平的最大值,$V_{L(min)}$ 表示低电平的最小值.在正常的工作情况下,$V_{L(max)}$ 和 $V_{H(min)}$ 之间的电压值是不可以出现的.对于一个给定的电路,在此范围内的电压既可以是高电平,也可以是低电平.例如,在CMOS 数字电路中,高电平值在2~3.3 V,低电平压值在0~0.8 V,也就是说,如果使用2.5 V,电路将把它看成是高电平或二进制1.如果使用0.5 V,那么就是低电平或二进制0.对于这种类型的电路,0.8~2 V的电平值是不可以出现的.\n1.2.3 数字波形 数字波形由两种不同的电平值组合而成,它们在高,低电平或状态之间不断地变化.图1.6(a)给出一个正向脉冲,是在电压(或电流)从低电平变到高电平,再从高电平变回到低电平时产生的.图1.6(b)给出一个反向脉冲,是在电压从高电平变到低电平,再从低电平变回到高电平时产生的.数字波形由这一系列的脉冲组成. 脉冲 如图1.6所示,脉冲有两个边沿:在t时刻首先出现的为前沿,在t,时刻随后出现的为后沿.对于一个正向脉冲,前沿是上升沿,后沿是下降沿.图1.6所示的脉冲是理想状态下的脉冲,因为假设上升沿和下降沿的变化是没有时间范围的(瞬间).实际情况是,这些变化是有时间范围的,尽管大多数的数字波形可以假定为理想脉冲.\n图1.7给出了一个非理想的脉冲.实际上,所有脉冲或多或少都存在这些非理想的特性.通常,杂散电感和电容效应会产生超调量和振荡.杂散电容和电路电阻会产生下调量,形成时间常数不大的RC电路. $$ 图1.7非理想脉冲的特性 $$\n从低电平到高电平所需的时间称为上升时间t,,从高电平到低电平所需的时间称为下降时间t.在实际运用中,通常测量的上升时间是从脉冲幅度(相对于基线的高度)的10%处到脉冲幅度的90%处的时间宽度,测量的下降时间则是从幅度的90%处到幅度的10%处的时间宽度.如图1.7所示,上升时间和下降时间不包括脉冲顶部和底部的10% ,因为这部分区域的波形是非线性的.脉冲的宽度tw就是脉冲的持续时间,通常把上升沿和下降沿幅度50%处的时间间隔定义为脉冲宽度,如图1.7所示.\n波形特性 在数字系统里,遇到的大多数波形都是由一系列的脉冲组成的,有时称为脉冲序列,它们可以分为周期的和非周期的.周期波形就是在一个固定的时间间隔里不断重复自身,这个时间间隔称为周期( $T$ ).频率( $f$ )是重复的速率,测量单位是赫兹( $Hz$ ).而一个非周期性脉冲波形则不会在一个固定的时间间隔里重复,它可能由脉冲宽度不确定的脉冲组成,也有可能由时间间隔不确定的脉冲组成,图1.8给出两种波形的例子.\n$$ (a)周期(方波) $$ $$ (b)非周期 $$ 脉冲(数字)波形的频率(f)就是其周期(T)的倒数,它们之间的关系如下所示: $$ (1.1) f = \\frac{1}{T} $$ $$ (1.2) T = \\frac{1}{f} $$ 周期数字波形的一个重要特性就是它的占空比,它是脉冲宽度( $t_w$ )和周期( $T$ )的比值,可以用百分比来表示 $$ (1.3)占空比=(\\frac{t_w}{T})×100\\% $$\n1.2.4 数字波形携带二进制信息 数字系统处理的二进制信息以波形的形式出现,它表示顺序序列的二进制位.当波形为高电平时,表示二进制1;当波形为低电平时,表示二进制0.每个位在一个序列里所占的固定时间间隔称为位时间.\n时钟 在数字系统中,所有的波形都与一个基本时序波形同步,称之为时钟( clock).时钟是周期波,每个脉冲之间的间隔(周期)等于一个位时间.\n$$ 图1.10时钟波形和位序列表示的波形同步的例子 $$ 图1.10所示为一个时钟波形的例子.注意,在这种情况下,波形A的电平变化都发生在时钟波形的前沿.在其他情况下,电平的变化发生在时钟的后沿.在每个位时间之内,波形A可为高电平也可为低电平.这些高电平和低电平组成了图1.10所示的位序列.若干位组成—组就可作为一个二进制信息来使用,如表示数字或字母.而时钟波形本身并不携带任何信息.\n时序图时序图就是数字波形的图形,它表示两个或两个以上波形的实际时间关系,还表示波形和波形之间的相互变化关系.图1.11给出了4个波形组成的时序图的例子.从这个时序图可以确定相互关系.例如,波形A,B和C仅在位时间7时同为高电平(阴影部分),在位时间7结束时变回到低电平.\n1.2.5 数据传送 数据是指一组可以用来传递某种信息的位.使用数字波形表示的二进制数据,必须在数字系统中从一个电路传送到另一个电路,或者从一个系统传送到另一个系统,以实现某个设定的目的.例如,计算机存储器中的数字是以二进制的形式存储的,它必须传送到计算机的中央处理器才能实现加法运算.然后加法运算的结果必须传送到显示器显示并且/或者回送到存储器中.如图1.12所示,二进制数据的传送方式有两种——串行和并行.\n$$ (a)从计算机到调制解调器串行传送8位二进制数据.第一个间隔为 t_0 到 t_1 $$ 图1.12(a)为计算机传送数据到调制解调器的例子,这时位以串行的方式从一个点传送到另一个点,沿着一条导线每次传送一位.在 $t_0$ 到 $t_1$这段时间间隔里,送出第一位.在 $t_1$ 到 $t_2$ 这段时间间隔里,送出第二位,以此类推.若要串行输出8位,则需花费8个时间间隔.\n$$ (b)从计算机到打印机并行传送8位 二进制数据.开始时间为t_0 $$ 当若干位以并行的方式传送时,一组位中的每一个位可以同时通过不同的线路传送.图1.12(b)为8位数据从计算机传送到打印机的例子.和串行传送需要8个时间间隔相比,并行方式传送8个位只需要一个时间间隔.\n综上所述,二进制数据串行传送的优点是所需要的数据线最少,即只需要一条线路.而在并行传送中,线路的数量等于一次传送的位的数量.串行传送的缺点是相对于并行传送,它需要更长的时间来完成一个给定位数的传送.例如,如果1 us可以传送一位,那么需8 us来完成串行传送8个位,但并行传送8个位只需1 us.并行传送的缺点是和串行相比,需要更多的线路\n","date":"2023-07-14T19:01:12+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/","title":"1.2 二进制数,逻辑电平和数字波形"},{"content":"模拟量具有连续的数值,数字量具有离散的数值.自然界中大多数可以测量的事物都以模拟量的形式出现.例如,空气温度在一个连续的范围内变化.在给定的一天里,温度不会立即从70°F下上升到71°F;这中间经历无数个温度值.如果绘制一个典型的夏季温度图,将会得到一个平滑和连续的曲线(类似于图1.1的曲线).其他模拟量的例子是时间,压力,距离和声音.\n相对于一个连续的温度图,假设每小时测量一次温度.现在有一个24小时内每隔一小时采样测量到的离散温度值,如图1.2所示,这样就可以有效地将模拟量转换成数字量的形式,即用一个个数字码对应于每个采样到的温度值.注意,图1.2本身并不是模拟量的数字表示.\n数字量的优点,在电学应用方面,数字量表示法和模拟量表示法相比有一定的优势.其,数字数据和模拟数据相比,前者在处理和传输方面更有效,更可靠.其二,数字数据在需要保存时,更显示了它的优越性.例如,转换成数字形式的音乐,要比相对应的模拟形式更简洁,复制时更精确,更清晰.噪声(不需要的电压波动)几乎不会影响数字数据,但会影响模拟信号.\n1.1.1 模拟电子系统 扩音系统用于把声音放大,从而让更多的听众听到,这是模拟电子应用的一个简单例子.图1.3的基本图示给出了自然界中的模拟量,即声波,它由麦克风接收,并将其转换为较弱的模拟电压,称为声频信号.这个电压随着声波的音量大小和频率变化而连续变化,随即加到线性放大器的输入中.放大器的输出,也就是放大的输入电压,随即传人扬声器.扬声器将放大的音频信号再变回声波,而这时的声波音量比话简接收到的原始声波的音量大很多.\n","date":"2023-07-14T18:57:32+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/","title":"1.1 数字量与模拟量"},{"content":"电子电路的一个有用应用是控制负载上的功率。本节将学习在功率控制应用中两种泛使用的器件，晶闸管整流器(SCR)和双向晶闸管(triac)。这些器件属于晶闸管类型的器件，广泛用于电动机工业控制、加热器、相位控制和其他许多应用中。可以认为晶闸管是一种电子开关，能够快速打开和关闭流向负载的大电流。集成电路经常用来确定何时打开和关闭 SCR 或双向晶闸管。\n学完本节后，你应该掌握以下内容:\n描述如何控制负载上的功率 描述 SCR 和双向晶闸管 解释如何打开和关闭 SCR 解释零电压开关 定义微控制器 15.5.1 晶闸管整流器 $$ a)基本结构~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)电路符号 $$\n$$ 图15-40~~~晶闸管整流器(SCR) $$\n晶闸管是一种半导体开关，由四层或多层交替的 pnpn 材料组成。有几种不同类型的晶闸管，类型主要取决于层数和每层的特定连接。对于一个四层晶闸管，当从第 1、2 和层进行连接时，就形成一种称为 SCR(晶闸管整流器)的闸二极管形式。这是晶闸管家族中最重要的器件之一，因为它相当于一个能够在需要时打开的二极管。SCR 的基本结构和电路符号如图15-40所示。对于 SCR，三个连接分别为阳极(A)、阴极(K)和栅极(G)。\n$$ a)当I_G=0时，必须大于V_{BR(F)}才能进入导通区域~~~~~~~~~~~~b) I_G控制SCR能够导通所需要的V_{BR(F)}值 $$\n$$ 图15-41~~~ SCR特性曲线 $$\n当栅极电流为 0 时，SCR 的特性曲线如图15-41a所示。特性曲线中有4个区域。反向特性(第三象限中的曲线)与一般二极管相同，包含一个反向阻断区域和一个反向雪崩区域。反向阻断区域等效于一个断开的开关。加到 SCR 上使它能够进入雪崩区域的反向电压一般为几百伏或者更高。SCR 一般不工作在反向雪崩区域。\n正向特性(画在第一象限)分成两部分。第一部分是正向阻断区域，其中 SCR 基本截止，阳极和阴极之间阻抗非常高，近似相当于一个断开的开关。第二个区域为正向导通域，其中产生阳极电流，如一般的二极管一样。为了让 SCR 进入这个区域，必须超过正向击穿电压 $V_{BR(F)}$。当 SCR 工作在正向导通区域时，阳极和阴极之间近似为一个闭合的开关。可以看到它与一般二极管特性(见图2-10)具有相似性，除了正向阻断区域之外。\n打开SCR 有两种方法让 SCR 进入正向导通区域。在这两种情况下，阳极到阴极必须正向偏置，即阳极相对于阴极必须为正。第一种方法已经提到过，它要求加上一个超过正向击穿电压 $V_{BR(F)}$ 的正向电压。击穿电压触发通常不常用。第二种方法需要在栅极上加上一个正的脉冲电流(触发)。这个脉冲使正向击穿电压减小，如图15-41b所示，并使得 SCR 导通。栅极电流越大， $V_{BR(F)}$ 越小。这是打开 SCR 的一般常用方法。\n一旦 SCR 打开，栅极就失去了控制。结果是 SCR 被锁住，只要阳极电流一直维持 SCR 将继续相当于一个闭合的开关。当阳极电流下降到小于一个称为保持电流的值时 SCR 会离开导通区域。保持电流如图15-41所示。\n关闭SCR 两种关闭 SCR 的基本方式是阳极电流中断和强制换流。通过断开阳极电路中的通路可以中断阳极电流，这会导致阳极电流变为0，从而关闭 SCR。中断阳极电流一种常用的自动方法是将 SCR 连接在一个交流电路中。交流波形的负半周会使 SCR 闭合.\n强制换流方法要求立刻加上一个与正向导通方向相反的强制电流流过 SCR，这使得向电流会下降到小于保持电流。这可以用各种不同的电路来实现。可能最简单的方法是自动打开或关闭一个以反方向连接在 SCR 两端的充好电的电容。\n15.5.2 双向晶闸管 $$ 图15-42~~~双向晶闸管特性曲线 $$ 双向晶闸管是具有双向通电流能力的晶闸管，因此是一个交流功率控制器件。虽然它是一个器件，但它的性能与两个以相反方向并联在- -起却共用一个栅极的 SCR 性能等效。双向晶闸管的基本特性曲线如图15-42所示。因为双向晶闸管类似于两个背靠背的 SCR,所以它没有反向特性。\n同 SCR 的情况一样，栅极触发是断开双向晶闸管的常用方法。双向晶闸管的栅极上所加的电流启动了前面讨论的锁机制。一旦导通启动，双向晶闸管会在两个极性的其中一个上导通，因此它可以作为交流控制器。可以触发双向晶闸管使得只有在部分交流周期内向负载提供交流功率。这可以使晶闸管能够向负载提供更多或更少的功率，而这取决于触发点。图15-43给出了基本的工作原理。\n$$ 图15-43 ~~~基本双向晶闸管的相位控制。栅极触发的时间决定能够通向负载的交流周期部分 $$\n15.5.3 零电压开关 当 SCR 或双向晶闸管在交流周期内处于断开状态时，触发它们会产生一个问题: 由于开关的暂态过程，会产生 RFI(射频干扰)。例如，如果 SCR 或双向晶闸管在交流周期接近峰值的时候突然打开，则会有一个瞬间冲击电流流过负载。当电压或电流有一个瞬间转换时，会产生许多高频分量。这些高频分量会进人敏感电路中，产生严重的干扰，甚至会产生崩溃。当 SCR 或双向晶闸管两端电压为 0 时，打开 SCR 或双向晶闸管可以避免电流的突然增加，因为电流会与交流电压同时增加。零电压开关也可以阻止使负载缩短寿命的热冲击，而这取决于负载的类型。\n并不是所有应用都能使用零电压开关，但如果可以，那么可以大大减小噪声问题。例如，负载可能是一个电阻性加热器件，电源在交流的几个周期内打开，然后几个周期内关掉来维持-一个特定的温度。零电压开关利用一个感应电路来确定什么时候打开电源。零电压开关的概念如图15-44所示。\n$$ a)负载电流的零电压开关~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)负载电流的非零电压开关， \\\\ 它产生输出暂态过程，从而引起射频千扰 $$\n$$ 图15-44~~~负载功率的零电压开关和非零电压开关的比较 $$\n当交流波形在正方向跨越零坐标轴时能够产生触发脉冲的一一个基本电路如图15-45所示。电阻R以及二极管 $D_1$ 和 $D_2$ 防止比较器的输入超过电压摆幅。比较器的输出电压电平是一个方波。$C_1$ 和 $R2$ 组成一个差分电路来将该方波输出转换成触发脉冲。二极管 $D_3$ 限制输出只有正触发。\n15.5.4 微控制器 SCR 和双向晶闸管经常用于有许多额外要求的系统中。例如，像洗衣机一样的基本系统可能需要有定时功能、速度或转速调整，电动机保护、序列产生、显示控制等。像这类系统可以用一类称为微控制器的专用计算机来进行控制。微控制器是一个简单集成电路，具有各种微处理器所具备的基本特点，以及具有专门的输入/输出(I/O)电路、ADC(模-数转换器)、计数器、定时器、振荡器、存储器以及其他特性。微控制器可以配置成一个专用系统来实现一种低成本的方法，用这种方法可以替换为 SCR 或双向晶闸管提供触发的传统方法。\n一种专用微控制器是德州仪器生产的 MSP430。数据手册可在www.ti.com上查阅。MSP430 是一种采用 RISC 指令集的低成本 16 位控制器。它能在超低功耗下高速运行。它可以执行小型系统中需要的所有控制功能，还能直接驱动小型双向晶闸管和SCR的栅极。可以为 MSP430 构建一个过零输人。实际上，与图15-45所示相同的输人保护电路与 MSP430 其中的一个输人端口相连。\n$$ 图15-45~~~当交流波形在正方向跨越零坐标轴时能够产生触发脉冲的一个电路. $$\n","date":"2023-07-14T18:30:27+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-5%E5%8A%9F%E7%8E%87%E6%8E%A7%E5%88%B6/","title":"15.5功率控制"},{"content":"本节将讨论三种与力相关的参数(应变、压力和运动)的测量方法。许多应用都需要量这三种参数。此外，其他参数(例如液体的流速)也可以间接通过测量应变、压力或者动而得到。\n学完本节后，你应该掌握以下内容:\n描述应变、压力和运动测量的方法 解释应变计如何工作 讨论应变计电路 解释压力传感器如何工作 讨论压力测量电路 列出几种压力传感器应用 15.4.1 应变计 $$ a)~~~当加上一个力时，发生应变，长度从L变到L+△L $$ $$ b)~~~当平板发生弯曲时，发生应变，上表面扩张，下表面压缩 $$\n$$ 图15-29~~~应变例子 $$\n应变是由于作用在材料，上面的力量产生的材料变形，或者扩张或者压缩。例如，金属杆或金属棒当加上一个合适的力时，它会稍稍变长，如图15-29a 所示。此外，如果金属盘弯曲，那么上表面会有一个膨胀，称为拉伸应变，下表面会有一个压缩，称为压缩应变，如图15-29b所示。\n应变计的原理是: 如果材料的长度增加，它的电阻值增大;如果长度缩短，它的电阻值减小。这可以用下面的式子表示(回顾 DC/AC 电路课程)。 $$ R=\\frac{\\rho L}{A}~~~(15-3) $$ 这个式子说明:对于一种材料，比如一段线，它的电阻值与电阻率($\\rho$)和长度(L)成正比，和横截面积(A)成反比。\n$$ a)典型的应变计结构 \\\\ b)沿着作用力的方向把应变计放置到被测量物体表面。当表面被拉长时，应变计也被拉伸 $$\n$$ 图15-30~~~一个简单的应变计和它的放置方式 $$\n应变计基本上是一个长而薄的电阻性材料条，它黏合在需要测量应变的物体的表面，比如放在测试的飞机机翼或尾翼上。当一个力作用在物体上引起微微的拉伸时，应变计也按比例拉长，电阻值增大。大多数应变计以类似于图15-30a 所示的形式来实现小区域范围内有足够电阻值的长度。然后如图15-30b所示将它沿着应变线方向放置。\n$$ 图15-31~~~应变系数的说明。欧姆表符号并不表示测量△R的实际方法 $$\n应变计的应变系数 应变计的一个重要特性是应变系数(GF)，GF定义为沿应变轴方向电阻值的相对变化与长度的相对变化之比。对于金属应变计，GF一般约为2。应变系数的概念在图15-31中说明，并可以用式(15-4)表示，其中R为标称电阻，$△R$ 为由应变引起的电阻变化。长度的相对变化($△L/L$)用应变($\\epsilon$)来表示，一般表示为百万分率，称为微应变($μ\\epsilon$)。 $$ GF=\\frac{△R/R}{△L/L}~~~(15-4) $$\n15.4.2 基本的应变计电路 $$ a)恒流电路~~~~~~~~~~~~~~~b)三线电桥电路 $$\n$$ 图15-32~~~基本的应变测量电路 $$\n因为当应变计感应量发生变化时，其电阻值会发生一个微弱变化，所以它通常用于与 RTD 类似的电路中。基本的差别是应变计测量应变，而不是温度。因此，应变计一般用在电桥电路中，或者用在恒流源驱动的电路中，如图15-32所示。它们的应用方式与 RTD 和热敏电阻相同。1B31 是应变计信号调理器的例子。它的数据手册见网站 www.analog.com。\n15.4.3 压力传感器 $$ a)基本的压力计结构~~~~b)当膜片上没有净压力时，应变计电阻为其标称值(侧面图) \\\\ c)净压力使得膜片扩张，应变计被拉伸，因此电阻增大 $$\n$$ 图15-33~~~包含黏合在柔软膜片上的应变计的简化压力传感器 $$\n压力传感器是其电阻变化与压力变化成正比的器件。一般来讲，压力感应可以使用依附在一个柔软膜片上的应变计来完成，如图15-33a 所示。图15-33b为一个没有承受净压力的膜片。当膜片一边存在一个正的净压力时，如图15-33c所示，会向上推膜片，它的表面也产生扩张。该扩张会使应变计被拉伸，因此电阻值增大。\n一般使用黏合在不锈钢膜片上的箔应变计或者在一个硅膜片中集成半导体应变计(电阻)来制造压力传感器。对于这两种方法，基本原理一样。\n$$ a)绝对压力传感器~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)标准压力传感器~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c)差分压力传感器 $$\n$$ 图15-34~~~三种基本类型的压力传感器 $$ 根据压力测量，压力传感器有三种基本的配置。绝对压力传感器测量相对于真空所加的压力，如图15-34a所示。标准(gage)压力传感器测量相对于周边(环境压力)所加的压力，如图15-34b所示。差分压力传感器测量所加的两个压力的差值，如图15-34c所示。一些传感器电路包括电桥完整电路和运放，并将它们与传感器一起封装在一起，如图15-35所示。\n$$ 图15-35~~~基本的压力传感器电路和符号 $$\n15.4.4 压力测量电路 因为压力传感器的电阻随着被测量的变化而变化，所以它通常位于电桥电路中，如图15-35a中的基本运放电桥式电路所示。在某些情况中，会把完整电路造到传感器封装中，而在其他有些情况下，电路位于传感器外部。图15-35b~d中的符号有时用来表示具有放大输出的完整压力传感器。图15-35b中的符号表示绝对压力传感器，图15-35c中的符号表示标准压力传感器，图15-35d中的符号表示差分压力传感器。\n$$ 图15-36~~~流速测量的基本方法 $$ 流速测量 测量液体流过管道 的流速的一种常见方法是差分压力方法。一个限流设备，如文丘里(Venturi)管(或其他类型的限流设备，如限流孔)放在需要监测流速的管道中。文丘里管是一段较窄的管道，如图15-36所示。虽然液体流过较窄通道时的流速增大，但是每分钟流过管道的流量是固定不变的。\n因为液体流过受限区域时流速增大，所以压力也增大。如果在较宽的地方和较窄的地方都对压力进行测量，那么可以确定流速，因为流速与差分压力的平方根成正比，如图15-36所示\n压力传感器应用 压力传感器用于任何需要测量材料压力的场合中。在医疗应用中，压力传感器用于血压测量;在飞机中，压力传感器用于测量高度压力、舱内压力和水压。在汽车中，压力传感器用于测量燃油流动、油压、制动系统压力、管道压力，以及转向系统压力，还有其他一些应用.\n15.4.5 运动测量电路 位移传感器 位移用来表示身体或点的位置变化。角度位移指能够用度或弧度来测量的旋转。位移传感器要么是接触式的要么是非接触式的。\n$$ a) LVDT图~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)响应~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c)标准LVDT $$\n$$ 图15-37~~~ LVDT 位移传感器 $$ 接触式传感器一般用具有耦合器件的感应轴来跟随被测量的位置。线性可变差分变压器( LVDT )就是一种接触式位移传感器，它能够将电感的变化与位移相关联。感应轴连接到专用绕组变压器中的一个移动磁心上。典型的 LVDT 如图15-37所示。变压器的一次绕组接人被测系统中，它位于两个相同的二次绕组之间。一次绕组由交流(一般频率范围为 1~5kHz)激励。 当磁心位于中心时，两个二次绕组上生成的电压相等。当磁心离开中心位置时，其中一个二次绕组上的电压要大于另一个上的电压。对于图15-37所示的解调电路，当磁心通过中心位置时，输出的极性发生改变。该传感器有很好的灵敏度、线性度和可重复性。\n非接触式位移传感器包括光学和电容传感器。可以通过对光电池进行排列来观察通过要测量的编码盘上小孔的光线，或者来对要测量的表面上的边缘进行计数。光学系统速度很快，但包括背景光源等噪声会在光学传感器上产生干扰信号。如果噪声会产生问题，那么在系统中加人迟滯环节非常有用(见8.1节)。\n$$ 图15-38~~~光纤近程检测器 $$ 光纤传感器是用于近距离测量的非常好的近程检测器。反射性传感器使用两个光纤束，一个用于发射光，另一个用于从反射面上接收光，如图15-38所示。光能够在光纤中几乎没有明显衰减地进行传输。当它离开发射光纤后，它在目标上形成一个斑点，它与距离的平方成反比。接收光纤对准斑点，并将反射光收集到光传感器。由接收光纤检测到的光强度取决于光纤的物理尺寸和排列以及到斑点和反射面的距离，但是这种技术能够对接近 1 微英寸的距离作出响应。主要的缺点是动态范围有限。\n电容性传感器可以做成非常灵敏的位移传感器或近程传感器。对电容中其中一个平板进行移动可以来改变电容值。移动的平板可以是任何金属表面，如电容性麦克风的膜片或者要测量的表面。电容能够用来控制谐振电路的频率来将该电容变化转换为有用的电子输出(实验手册中的实验37给出了一个例子)。\n速度传感器 速度定义为位移的变化速率，它可以通过位移传感器和测量两个位置之间的时间来间接求得。也可以利用特定传感器来直接测量速度，这种传感器的输出与被测速度成正比。这些传感器要么对线速度作出响应，要么对角速度作出响应。线速度传感器在同心线圈中使用一个永久磁铁，形成一个简单的电动机，产生一个与速度成正比的电压。线圈和磁铁中，其中一个固定，另一个相对于固定的元件进行移动。从线圈中取出输出信号。\n有各种各样的传感器来测量角速度。转速计是一类角速度传感器，它能够产生一个直流或交流电压输出。直流转速计基本.上是一个小型的发电机，里面的线圈在一个固定不变的磁场中旋转。当线圈在固定不变的磁场中旋转时，线圈上会产生一个电压。所产生电压的平均值与旋转速度成正比，而极性反映了旋转方向，这是直流转速计的优点。交流转速计可以设计成发电机，能够得到频率与旋转速度成正比的输出。\n另外一种测量角速度的方法是在一个光敏元件上旋转一个遮光器。遮光器会干扰光源到达光电池，使得光电池的输出以与旋转速度成正比的速率变化。\n$$ 图15-39~~~一个基本的加速度传感器。通过可变电阻将运动转换成电压 $$\n加速度传感器加速 度通常用安装在一个合适容器内的弹簀支撑的震动块来测量，如图15-39 所示。用一个减震器来实现阻尼，它是一个减小振动的机械装置。盒子和震动块之间的相对运动与加速度成正比。第二个传感器(比如电阻性位移传感器或 LVDT )用来将相对运动转换成一个电子量输出。理想情况下，盒子加速时，震动块由于惯性而不会移动;实际情况下，由于通过弹簧有作用力加到它上面，因此它会移动。加速计有一个内在的频率，它的周期小于所测加速度发生改变所需的时间。用来测量振动的加速计使用的频率也应该小于这个内在频率。\n使用 LVDT 基本原理的加速计可以构造成来测量振动。震动块由周围用线圈环绕的磁铁制成。线圈上产生的电压是加速度的函数。\n另一种加速计使用一个与震动块接触的压电晶体。晶体对震动块的加速度产生的作用力作出响应并产生一个输出电压。压电晶体尺寸很小，并有一个非常高的内在频率; 它能够用来测量高频振动。压电晶体的缺点是输出非常小，晶体的阻抗很高，使得它很容易由于噪声而产生问题。\n","date":"2023-07-14T18:30:17+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-4%E5%BA%94%E5%8F%98%E6%B5%8B%E9%87%8F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E9%87%8F%E5%92%8C%E8%BF%90%E5%8A%A8%E6%B5%8B%E9%87%8F/","title":"15.4 应变测量、压力测量和运动测量"},{"content":"","date":"2023-07-14T18:30:08+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-3%E6%B8%A9%E5%BA%A6%E6%B5%8B%E9%87%8F/","title":"15.3 温度测量"},{"content":"","date":"2023-07-14T18:30:00+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-2%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/","title":"15.2 角度测量"},{"content":"","date":"2023-07-14T18:29:51+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/15-1rms-dc%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"15.1 RMS-DC转换器"},{"content":"","date":"2023-07-14T18:29:31+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-7v-f%E5%92%8Cf-v%E8%BD%AC%E6%8D%A2%E5%99%A8/","title":"14.7 V/F和F/V转换器"},{"content":"","date":"2023-07-14T18:29:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-6a-d%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","title":"14.6 A/D转换方法"},{"content":"","date":"2023-07-14T18:26:29+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-5a-d%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"14.5 A/D转换的基本概念"},{"content":"","date":"2023-07-14T18:26:19+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-4d-a%E8%BD%AC%E6%8D%A2/","title":"14.4 D/A转换"},{"content":"","date":"2023-07-14T18:26:07+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-3%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%95%B0%E5%AD%97%E6%8E%A5%E5%8F%A3/","title":"14.3 模拟和数字接口"},{"content":"","date":"2023-07-14T18:25:55+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-2%E9%87%87%E6%A0%B7%E4%BF%9D%E6%8C%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"14.2 采样保持放大器"},{"content":"","date":"2023-07-14T18:25:46+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/14-1%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/","title":"14.1 模拟开关"},{"content":"","date":"2023-07-14T18:25:37+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-9%E5%85%89%E7%BA%A4/","title":"13.9 光纤"},{"content":"","date":"2023-07-14T18:25:29+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-8pll/","title":"13.8 PLL"},{"content":"","date":"2023-07-14T18:25:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-7%E9%A2%91%E7%8E%87%E8%B0%83%E5%88%B6/","title":"13.7 频率调制"},{"content":"","date":"2023-07-14T18:25:11+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-6if%E5%92%8C%E9%9F%B3%E9%A2%91%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"13.6 IF和音频放大器"},{"content":"","date":"2023-07-14T18:25:02+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-5am%E8%A7%A3%E8%B0%83/","title":"13.5 AM解调"},{"content":"","date":"2023-07-14T18:24:53+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-4%E6%B7%B7%E9%A2%91%E5%99%A8/","title":"13.4 混频器"},{"content":"","date":"2023-07-14T18:24:46+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-3%E5%B9%85%E5%BA%A6%E8%B0%83%E5%88%B6/","title":"13.3 幅度调制"},{"content":"","date":"2023-07-14T18:24:36+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-2%E7%BA%BF%E6%80%A7%E4%B9%98%E6%B3%95%E5%99%A8/","title":"13.2 线性乘法器"},{"content":"","date":"2023-07-14T18:24:26+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/13-1%E5%9F%BA%E6%9C%AC%E6%8E%A5%E6%94%B6%E6%9C%BA/","title":"13.1 基本接收机"},{"content":"","date":"2023-07-14T18:24:08+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-4%E5%AF%B9%E6%95%B0%E5%92%8C%E5%8F%8D%E5%AF%B9%E6%95%B0%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.4 对数和反对数放大器"},{"content":"","date":"2023-07-14T18:23:57+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-3ota/","title":"12.3 OTA"},{"content":"","date":"2023-07-14T18:23:47+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-2%E9%9A%94%E7%A6%BB%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.2 隔离放大器"},{"content":"","date":"2023-07-14T18:23:37+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/12-1%E4%BB%AA%E8%A1%A8%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"12.1 仪表放大器"},{"content":"","date":"2023-07-14T18:23:23+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-6ic%E7%A8%B3%E5%8E%8B%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/","title":"11.6 IC稳压器的应用"},{"content":"","date":"2023-07-14T18:23:13+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-5ic%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.5 IC稳压器"},{"content":"","date":"2023-07-14T18:23:03+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-4%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.4 基本开关稳压器"},{"content":"","date":"2023-07-14T18:22:54+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-3%E5%9F%BA%E6%9C%AC%E5%B9%B6%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.3 基本并联稳压器"},{"content":"","date":"2023-07-14T18:22:44+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-2%E5%9F%BA%E6%9C%AC%E4%B8%B2%E8%81%94%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"11.2 基本串联稳压器"},{"content":"","date":"2023-07-14T18:22:34+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/11-1%E7%A8%B3%E5%8E%8B/","title":"11.1 稳压"},{"content":"","date":"2023-07-14T18:21:32+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-7555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"10.7 555定时器作为单稳态触发器"},{"content":"","date":"2023-07-14T18:21:22+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-6555%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%9C%E4%B8%BA%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.6 555定时器作为振荡器"},{"content":"","date":"2023-07-14T18:21:12+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-5%E5%BC%9B%E8%B1%AB%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/","title":"10.5 弛豫振荡器原理"},{"content":"","date":"2023-07-14T18:21:01+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-4%E5%85%B7%E6%9C%89lc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.4 具有 LC 反馈电路的振荡器"},{"content":"","date":"2023-07-14T18:20:17+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-3%E5%85%B7%E6%9C%89rc%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.3 具有 RC 反馈电路的正弦波振荡器"},{"content":"反馈振荡器的工作基于正反馈原理，本节将验证这个概念并观察振荡发生的一般条件。反馈振荡器广泛用于产生正弦波。\n学完本节后，你应该掌握以下内容:\n解释反馈振荡器的工作原理 解释正反馈 描述振荡的条件 讨论振荡启动的条件 10.2.1 正反馈 $$ 图10-3~~~正反馈产生振荡 $$ 正反馈的特点是将输出信号的同相部分反馈到输入端，用正弦波振荡器来阐述其基本原理，如图10-3所示。你可以看到，同相反馈电压被放大后产生输出电压，依次又产生反馈电压。也就是说，通过建立循环来维持信号本身，产生连续的正弦波输出，这个现象称为振荡。\n10.2.2 振荡条件 图10-4阐述了维持振荡的两个条件:\n反馈环路上的相移实际上必须为$0°$。 环绕闭环反馈环路(环路增益)的电压增益 $A_{cl}$ 必须等于 1(单位)。环绕闭环反馈环路上的电压增益 $A_{cl}$ 是放大器增益 $A_v$ 和反馈电路衰减 $B$ 的乘积。 $$ 图10-4~~~~振荡条件 $$ $$ A_{cl}=A_vB $$ 如果希望输出正弦波，大于1的环路增益将很快地使得波形的两个峰值处于饱和，产生严重的失真。为了避免这种情况，一旦振荡开始，必须使用一些增益控制以保持增益精确地保持在1。例如，如果反馈网络的衰减是0.01，放大器必须恰好具有100增益来克服衰减同时又不产生严重的失真(0.01×100=1)。大于100的放大器增益将会产生两个波形峰值受限的振荡。 10.2.3 开始条件 到目前为止，你已经看到什么条件可以让振荡器产生连续的正弦波输出现在我们检查当直流电压源闭合时振荡开始的条件。你知道，维持振荡必须满足单位-增益条件，为了启动振荡，环绕正反馈环路上的电压增益必须大于1，使得输出维持在想要的值。然后增益必须下降到1，使得振荡输出保持在希望的电平并能维持振荡。(在下一节会讨论，振荡开始后，有许多方法可以降低增益。)开始和维持振荡的电压增益条件如图10-5阐述。 $$ 图10-5~~~~当振荡在t_0开始时，条件A_{cl}\u0026gt;1产生正弦波输出电压幅度以建立期望的电平。 \\\\ 然后，A_{cl}减小到1，把输出电压维持在期望的幅度上 $$ 通常会提出这样的问题: 如果振荡器开始时是关闭的，并没有输出电压，反馈信号是如何启动开始建立正反馈过程的? 起初, 在电阻或其它原件中产生的宽带噪声, 或在电源闭合的瞬间，会产生一个小的正反馈电压，反馈电路只允许频率等于所选振荡频率的电压同相地出现在放大器的输入端。初始的反馈电压经过放大，并且不断地加强，从而产生如前所讨论的输出电压。\n","date":"2023-07-14T18:20:06+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-2%E5%8F%8D%E9%A6%88%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%8E%9F%E7%90%86/","title":"10.2 反馈振荡器原理"},{"content":"振荡器是产生周期波形来实现定时、控制或通信功能的电路。在几乎所有的电子系统中都可以找到振荡器，包括模拟和数字系统、大多数的测试仪器，如示波器和函数发生器。\n振荡器需要某种正反馈，将部分输出信号反馈到输人，使得输人信号加强，从而维持连续不断的输出信号。尽管外部输入不是严格必需的，但是许多振荡器使用外部信号来控制频率或使它与另一个源同步。可以用以下两种方法之一来设计振荡器产生受控制的振荡信号: 使用反馈振荡器的单位增益方法和使用弛豫振荡器的定时方法。这两种方法都将在本章讨论。\n不同类型的振荡器产生不同类型的输出，如正弦波、方波、三角波和锯齿波。本章介绍几种类型的基本振荡电路，它们使用运算放大器和分立晶体管作为增益元件，还会介绍一块称为 555 定时器的非常通用的集成电路。\n10.1 振荡器 振荡器是能在其输出端产生周期波形的电路，它仅使用直流电源作为必需的输人。重复的输入信号并不是必需的，但可以用来同步振荡输出。输出电压要么是正弦波，要么是非正弦波，这取决于振荡器的类型。振荡器主要分为反馈振荡器和弛豫振荡器两大类。\n学完本节后，你应该掌握以下内容:\n描述所有振荡器的基本工作原理 解释振荡器的目的 讨论振荡器两种重要的分类 列出反馈振荡器的基本元件 10.1.1 振荡器的类型 $$ 图10-1~~~~基本振荡器概念给出三种常见类型的输出波形 $$ 本质上，所有振荡器都将来自直流电源的电能转换为周期波形，这些周期波形可以用于各种定时、控制或信号产生应用。一个基本的振荡器如图10-1 所示，振荡器可以根据产生信号所采用的技术进行分类。\n反馈振荡器 有一类振荡器是反馈振荡器， 它将输出信号的一部分无净相移地反馈到输入端来加强输出信号。振荡开始后，环路增益保持在 1.0 来维持振荡。反馈振荡器由一个放大器(或者分立晶体管，或者运算放大器)和一个正反馈网络组成，其中放大器提供增益，正反馈网络产生相移并提供衰减，如图10-2所示。\n$$ 图10-2~~~~反馈振荡器的基本元件 $$ 弛豫振荡器 振荡器的第二种类型是弛豫振荡器。弛豫振荡器使用一个 RC 定时电路来产生波形，通常是方波或非正弦波。典型地，弛豫振荡器使用施密特触发器或其他器件交替地通过电阻向电容充电和放电来改变状态。弛豫振荡器将在10.5节中讨论。\n","date":"2023-07-14T18:19:51+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/10-1%E6%8C%AF%E8%8D%A1%E5%99%A8/","title":"10.1 振荡器"},{"content":"本节讨论通过测量确定滤波器响应的两种方法——离散点测量和扫频测量。\n学完本节后，你应该掌握以下内容:\n讨论测量频率响应的两种方法 解释离散点测量方法 解释扫频测量方法 9.7.1 离散点测量 $$ 图9-26~~~滤波器响应的离散点测试方法(图中的读数是任意的且只用于示意) $$\n使用实验室常用仪器，在输入频率的离散值处测量滤波器输出的电压，测量方法如图9-26所示。其一般过程如下:\n设置正弦波产生器的幅度为所需的电压电平。\n设置正弦波产生器的输出频率远低于待测滤波器的预期截止频率。对低通滤波器，设置频率尽可能地接近 0Hz。对带通滤波器，设置频率远低于预期的下限频率。\n在预测步骤，逐渐增加频率产生足够多的数据点以获得精确的响应曲线。\n当改变频率时，保持输入电压幅度不变。\n在每个频率处，记录下输出电压值。\n在记录了足够多的测量点后，画出输出电压-频率曲线图。\n如果被测量的频率超出了 DMM 的响应，就必须使用示波器来代替。\n9.7.2 扫频测量 与离散点测试方法相比，扫频方法需要更复杂的测试设备，但是这种方法更为有效，能够得到更加精确的响应曲线。使用扫频发生器和频谱分析器的通用测试方法如图9-27a所示，图9-27b给出了如何用示波器替代频谱分析器来进行测试。 $$ 图9-27~~~滤波器响应的扫频测试方法 $$\n扫频发生器可以产生恒定幅度的输出信号，这个信号的频率在两个预先设置的范围内线性增加，如图9-27所示。在图9-27a中, 频谱分析仪是一台仪器, 它可以对所需的频率间隔/每格进行校准, 而不是采用常用的时间/每格。因此，当送到滤波器的输人频率扫过预先设置的范围时，在频谱分析仪的屏幕上就会画出其响应曲线。使用示波器来显示响应曲线的测试方法如图9-27b所示。\n","date":"2023-07-14T18:19:41+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-7%E6%B5%8B%E9%87%8F%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/","title":"9.7 测量滤波器响应"},{"content":"带阻滤波器阻止指定频带内的频率通过，允许其他频率通过。带阻滤波器的响应与带通滤波器的响应相反。\n学完本节后，你应该掌握以下内容:\n理解有源带阻滤波器 识别多重反馈带阻滤波器 解释状态可变带阻滤波器的工作原理 9.6.1 多重反馈带阻滤波器 $$ 图9-23~~~多重反馈带阻滤波器 $$\n图9-23是多重反馈带阻滤波器。注意，这种配置与带通滤波器的配置相似，只是去掉了$R_3$，并加人了$R_4$。\n9.6.2 状态可变带阻滤波器 将9.5节介绍过的状态可变滤波器的低通响应和高通响应进行求和，就可以产生带阻响应，如图9-24所示。 $$ 图9-24~~~状态可变带阻滤波器 $$\n","date":"2023-07-14T18:19:29+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-6%E6%9C%89%E6%BA%90%E5%B8%A6%E9%98%BB%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.6 有源带阻滤波器"},{"content":"如前所述，带通滤波器让下限频率和上限频率之间的频率通过，拒绝所有位于通带范围外的频率通过。带通响应可以看作低频响应曲线和高频响应曲线的重叠部分。\n学完本节后，你应该掌握以下内容:\n理解有源带通滤波器 描述由低通和高通滤波器构成的带通滤波器 确定级联带通滤波器的截止频率和中心频率 确定多重反馈带通滤波器的中心频率、带宽和增益 解释状态可变带通滤波器的工作原理 9.5.1 低通和高通滤波器的级联形成带通响应 实现带通滤波器的一种方法是将一个高通滤波器和一个低通滤波器级联，如图9-17a所示，只要截止频率分得足够开。每个滤波器都是二极点 Sallen-Key 巴特沃斯结构，下降率为一40dB/十倍频程，如图9-17b中的复合响应曲线所示。如图9-17b所示，每个滤波器截止频率的选择使得响应曲线充分重叠，而且，高通滤波器的截止频率必须比低通滤波器的截止频率足够低。 $$ 图9-17~~~通过二极点高通滤波器和二极点低通滤波器级联形成的带通滤波器 \\\\ (与两个级联滤波器的级联次序无关) $$\n带通滤波器的下限频率 $f_{c1}$ 是高通滤波器的截止频率，上限频率是低通滤波器的截止频率 $f_{c2}$ 。理想情况下，如前所述，通带的中心频率 $f_0$ 是 $f_{c1}$ 和 $f_{c2}$ 的几何平均值。下面的公式给出了图9-17中带通滤波器三个频率之间的关系。 $$ f_{c1}=\\frac{1}{2\\pi \\sqrt[]{R_{A1}R_{B1}C_{A1}C_{B1}}} \\\\ f_{c1}=\\frac{1}{2\\pi \\sqrt[]{R_{A2}R_{B2}C_{A2}C_{B2}}} \\\\ f_0=\\sqrt[]{f_{c1}f_{c2}} $$\n当然，如果在实现每个滤波器时使用等值元件，截止频率的公式可以简化为 $f_c = 1/2\\pi RC$.\n9.5.2 多重反馈带通滤波器 另一种类型的滤波器结构是多重反馈带通滤波器，如图9-18所示。通过 $R_2$ 和 $C_1$ 有两条反馈路径，元件 $R_1$ 和 $C_1$ 提供低通响应，$R_2$ 和 $C_2$ 提供高通响应。最大增益 $A_0$ 在中心频率处产生。Q 值小于 10 的滤波器属于这种类型。从 $C_1$ 反馈路径看，$R_1$和 $R_3$ 并联(将$V_{in}$源用短路替代)，中心频率的表达式可以表示为: $$ f_0=\\frac{1}{2\\pi \\sqrt[]{(R_1||R_3)R_2C_1C_2}} $$ $$ 图9-18~~~多重反馈带通滤波器 $$\n令 $C_1=C_2=C$，得到(推导见附录): $$ f_0=\\frac{1}{2\\pi C}\\sqrt[]{\\frac{R_1+R_3}{R_1R_2R_3}}~~~(9-7) $$\n给电容器选择一个方便的值以便于计算，然后根据期望的 $f_0、BW$ 和 $A_0$ 来计算三个电阻的值。你知道，Q 值可以通过 $Q=f_0/BW$ 计算，电阻可以通过如下公式计算得到(没有给出具体的推导过程)。 $$ R_1=\\frac{Q}{2\\pi f_0CA_0} \\\\ R_2=\\frac{Q}{\\pi f_0C} \\\\ R_3=\\frac{Q}{2\\pi f_0C(2Q^2-A_0)} $$\n为了得到增益表达式，从前面两个公式中推出Q。 $$ Q=2\\pi f_0A_0CR_1 \\\\ Q=\\pi f_0CR_2 $$ 于是, $$ 2\\pi f_0A_0CR_1=\\pi f_0CR_2 $$ 中心频率处的最大增益为 $$ A_0=\\frac{R_2}{2R_1}~~~(9-8) $$\n为了让公式 $R_3=Q/[2\\pi f_0C(2Q^2-A_0)]$ 的分母为正, $A_0\u0026lt;2Q^2$, 这使得增益受到限制.\n9.5.3 状态可变带通滤波器 状态可变或通用有源滤波器广泛用于带通应用。如图9-20所示，它由一个求和放大器和两个运放积分器(作为单极点低通滤波器)通过级联方式构成的二阶滤波器。尽管状态可变结构主要用作带通(BP)滤波器，但它也可用作低通(LP)和高通(HP)输出，中心频率由两个积分器中的 RC 网络决定。当用作带通滤波器时，通常把积分器的截止频率设置为相等，这样就设置了通带的中心频率。 $$ 图9-20~~~状态可变的带通滤波器 $$\n基本工作原理 当输入端频率低于 $f_c$ 时，输入信号通过求和放大器和积分器，并反馈180°的相位。因此，对所有低于 $f_c$ 的频率，反馈信号和输入信号相互抵消。随着积分器的低通响应下降，反馈信号减小，因此允许输入信号通过带通输出。当频率高于 $f_c$ 时，低通响应逐渐消失，因此阻止输入信号通过积分器。所以，带通输出在 $f_c$ 达到峰值，如图9-21所示。这种类型的滤波器可以得到直至 100 的稳定 Q 值。Q 值由反馈电阻 $R_5$ 和 $R_6$ 决定，公式如下。 $$ Q=\\frac{1}{3}(\\frac{R_5}{R_6}+1) $$ $$ 图9-21~~~状态可变滤波器的通用响应曲线 $$\n状态可变滤波器不能同时优化低通、高通和带通性能，这是因为: 为了优化低通或高通巴特沃斯响应，DF 必须等于 1.414。因为 Q=1/DF，所以 Q 为 0.707。这样低的 Q 值提供的带通响应非常差(大的 BW 和较差的选择性)。若当作带通滤波器来优化，Q 值必须设置成很大。\n","date":"2023-07-14T18:19:18+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-5%E6%9C%89%E6%BA%90%E5%B8%A6%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.5 有源带通滤波器"},{"content":"在高通滤波器中，RC 网络中的电容与电阻的作用相反。除此之外，高通滤波器的基本参数与低通滤波器相同。\n学完本节后，你应该掌握以下内容:\n理解有源高通滤波器 识别单极点滤波器并确定它的增益和截止频率 识别二极点 Sallen-Key 滤波器并确定它的增益和截止频率 解释如何通过级联高通滤波器获得更高的下降率 9.4.1 单极点滤波器 图9-13a给出了一个下降率为一20dB/十倍频程的高通有源滤波器。注意，输入电路是一个单极点的高通 RC 网络。负反馈网络与前面讨论的低通滤波器的负反馈网络相同。高通响应曲线如图9-13b所示。 $$ 图9-13~~~单极点有源高通滤波器和响应曲线 $$\n理想情况下，高通滤波器让大于 $f_c$ 的所有频率通过而无任何限制，如图9-14a所示，尽管在实际中并不是这种情况。正如你已经学过的，所有运算放大器都固有内部的 RC 网络，限制了运算放大器在高频处的响应。因此，对高通滤波器的响应有上限频率的限制。事实上，这使得它成为一个具有很大带宽的带通滤波器。在大多数应用中，因为内部高频限制比滤波器的 $f_c$ 要大得多，所以这种限制可以忽略。在一些应用中，为了提高它的高频限制频率，采用特殊的电流反馈运算放大器或分立式晶体管用作增益元件,而不是采用标准的运算放大器来实现。 $$ 图9-14~~~高通滤波器响应 $$\n9.4.2 Sallen-Key 高通滤波器 图9-15是一个高通二阶Sallen-Key结构的滤波器。元件RA、CA、Rs和CB形成二极点频率选择网络。注意，在频率选择网络中，电阻和电容的位置与它们在低通滤波器结构中的位置相反。与其他滤波器一样，通过恰当地选择反馈电阻 $R_1$ 和 $R_2$ 响应特性可以优化。 $$ 图9-15~~~基本 Sallen-Key二极点高通滤波器 $$\n9.4.3 级联高通滤波器 和低通时的配置一样，一阶和二阶高通滤波器可以通过级联形成三极点或者多极点的滤波器，可以产生更快的下降率。图9-16是一个六极点的高通滤波器，它由三级二极点电路组成。通过这种结构可以优化巴特沃斯响应，获得一120dB/十倍频程的下降率。 $$ 图9-16~~~六阶高通滤波器 $$\n","date":"2023-07-14T18:19:08+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-4%E6%9C%89%E6%BA%90%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.4 有源高通滤波器"},{"content":"与无源滤波器(仅使用 R、L 和 C 元件)相比，使用运算放大器作为有源元件的滤波器具有一些优势。运算放大器提供增益，使得信号穿过滤波器时不会衰减。运算放大器的高输入阻抗防止过度增加电源的负载，并且运算放大器的低输出阻抗防止滤波器被所驱动的负载影响。有源滤波器也很容易在很宽的频率范围内调整而不会改变所期望的响应。\n学完本节后，你应该掌握以下内容:\n理解有源低通滤波器 识别单阶滤波器并确定它的增益和截止频率 识别二阶 Sallen-Key 滤波器并确定它的增益和截止频率 解释如何通过级联低通滤波器获得较高的下降率 9.3.1 单极点滤波器 图9-9a是一个含有单极点低通 RC 网络的有源滤波器，大于截止频率时它的下降率为一20dB/十倍频程，如图9-9b中的响应曲线所示。一阶滤波器的截止频率为 $f_c=1/2\\pi RC$。滤波器中的运算放大器连接成同相放大器，通带内的闭环电压增益由 $R_1$ 和 $R_2$ 决定。 $$ A_{cl(NI)}=\\frac{R_1}{R_2}+1 $$ $$ 图9-9~~~单极点有源低通滤波器及其响应曲线 $$\n9.3.2 Sallen-Key低通滤波器 $$ 图9-10~~~基本Sallen-Key二阶低通滤波器 $$\nSallen-Key 是最常见的二阶(两极点)滤波器中的一种，它通常也称为 VCVS(电压控制电压源，voltage-controlled voltage source)滤波器。一个低通Sallen-Key滤波器如图9-10所示。注意，其中有两个低通 RC 网络，当大于截止频率时它的下降率为一40dB/十倍频程(假设是巴特沃斯响应特性)。一个 RC 网络由 $R_A$和$C_A$组成，另一个 RC 网络由 $R_B$ 和 $C_B$ 组成。一个独特的特性是电容 $C_A$ 提供反馈，在接近通带边缘附近可以调整响应。二阶 Sallen-Key 滤波器的截止频率为 $$ f_c=\\frac{1}{2\\pi \\sqrt[]{R_AR_BC_AC_B}}~~~(9-6) $$\n为了简化，把元件值设置成一样，即 $R_A=R_B=R，C_A=C_B=C$，这样，截止频率的表达式就简化成 $f_c=\\frac{1}{2\\pi RC}$\n与单极点滤波器中一样，二阶 Sallen-Key 滤波器中的运算放大器是同相输人的，由 $R_1/_2R$ 提供负反馈网络。已经学过，阻尼系数是由 $R_1$ 和 $R_2$ 的值决定，可以使滤波器响应要么是巴特沃斯响应，要么是切比雪夫响应或贝赛尔响应。例如，从表9-1中可知，对一个二阶巴特沃斯响应要产生1.414的阻尼系数， $R_1/_2R$ 之比应为0.586。\n9.3.3 级联低通滤波器以获得更高下降率 如果需要一个三极点滤波器来获得三阶低通响应(一60dB/十倍频程)，如图9-12a所示，可以通过级联一个二极点低通滤波器和一个单极点低通滤波器来实现。图9-12b给出了一个四极点滤波器，它是通过级联两个二极点滤波器实现的。 $$ 图9-12~~~级联的低通滤波器 $$\n","date":"2023-07-14T18:18:56+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-3%E6%9C%89%E6%BA%90%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"9.3 有源低通滤波器"},{"content":"每种滤波器(低通、高通、带通、带阻)可以通过电路元件值定制而具有巴特沃斯、切比雪夫或贝赛尔特性。每一种特性都是由响应曲线的形状来识别的，每种特性在特定的应用中具有各自的优势。\n学完本节后，你应该掌握以下内容:\n描述三类基本滤波器响应特性和其他滤波器参数 描述巴特沃斯特性 描述切比雪夫特性 描述贝赛尔特性 定义阻尼系数并讨论它的重要性 计算滤波器的阻尼系数 讨论滤波器的阶数和它对下降率的影响 巴特沃斯、切比雪夫或贝赛尔响应特性可以通过恰当地选择有源滤波器电路的元件值来实现，对低通滤波器响应曲线的三个响应特性的一般比较如图9-5所示。同样可以设计具有其中任何一种特性的高通、带通和带阻滤波器。 $$ 图9-5~~~三类滤波器响应特性的比较图 $$\n巴特沃斯特性 巴特沃斯特性在通带内提供非常平坦的幅值响应，并且下降率为一20dB/十倍频程/每极点。相位响应是非线性的，然而，通过滤波器的信号相移(因此有时延)会随着频率而非线性变化。因此，加到具有巴特沃斯响应的滤波器上的脉冲将在输出端引起超调，因为脉冲上升沿和下降沿中的每个频率分量经历了不同的时延。具有巴特沃斯响应的滤波器通常用于当通带内的所有频率必须具有相同的增益时。巴特沃斯响应通常指最平坦响应。\n切比雪夫特性 当要求下降率非常快时，具有切比雪夫响应特性的滤波器非常有用，因为切比雪夫滤波器可以提供大于一20dB/十倍频程/每极点的下降率。因为这个下降率比具有巴特沃斯特性响应特性的滤波器的下降率要大，所以对给定的下降率，滤波器可以用较少极点和较简单的电路来实现切比雪夫响应。这种类型的滤波器响应在通带内超调或波动(取决于极点的数量)，产生的线性相移比巴特沃斯产生的少。\n贝赛尔特性 贝塞尔响应呈现线性相位特性,意味着相移随着频率线性增加。结果就是当输入是脉冲信号时，输出几乎没有超调。由于这个原因，具有贝塞尔响应的滤波器常用于过滤脉冲波形，而不会产生波形失真。\n9.2.1 阻尼系数 如前所述，不论滤波器是低通、高通、带通还是带阻类型，有源滤波器都可以设计为具有巴特沃斯、切比雪夫或贝赛尔响应特性。有源滤波器电路的阻尼系数(DF)决定这个滤波器呈现哪种响应特性。为了解释这个基本概念，图9-6给出了一个广义的有源滤波器。它包含一个放大器、一个负反馈网络和一个滤波器部分。在一个同相放大器中，放大器和反馈网络相连接阻尼系数由负反馈网络决定，并且定义为: $$ 图9-6~~~有源滤波器的一般框图，注意，如同在第6章中的定义，R_1对应R_f，R_2对应于R_i; $$\n$$ DF=2-\\frac{R_1}{R_2}~~~(9-5) $$\n基本上，阻尼系数通过负反馈的作用影响滤波器响应。任何试图增加或减小输出端电压的行为都将被负反馈的相反作用抵消。如果阻尼系数的值准确设置，这使得响应曲线在滤波器的通带内趋于平坦。通过高等数学，可以推导出不同阶数滤波器的阻尼系数(不在本书中介绍)，以获得巴特沃斯特性的最大平坦响应。\n产生所需响应特性的阻尼系数值取决于滤波器的阶数(极点的数量)。回顾一下，滤波器的极点数越多，滤波器的下降率越快。例如，为了获得一个二阶巴特沃斯响应，阻尼系数必须为1.414。为了实现这个阻尼系数，反馈电阻率应为: $$ \\frac{R_1}{R_2}=2-DF=2-1.414=0.586 $$ 这个比率给出了一个同相滤波器放大器的闭环增益 $A_{cl(NI)}$ 为1.586，推导如 $$ A_{cl(NI)}=\\frac{1}{B}=\\frac{1}{R_2/(R_1+R_2)}=\\frac{R_1+R_2}{R_2}=\\frac{R_1}{R_2}+1=0.586+1=1.586 $$\n9.2.2 截止频率和下降率 截止频率由 RC 网络中的电阻和电容值决定，如图9-6所示。对一个单极点(一阶)滤波器，如图9-7所示，截止频率为 $$ 图9-7~~~一阶(单极点)低通滤波器 $$\n$$ f_c=\\frac{1}{2\\pi RC} $$ 尽管给出的是低通配置，对一个单极点高通滤波器, $f_c$ 的计算公式是相同的。极点数量决定滤波器的下降率。一个巴特沃斯响应的下降率为一20dB/十倍频程/每极点。所以一个一阶(单极点)滤波器的下降率为一20dB/十倍频程，二阶(二极点)滤波器的下降率为一40dB/十倍频程，三阶(三极点)滤波器的下降率为一60dB/十倍频程，以此类推。\n通常，为了获得三阶及以上的滤波器，采用单级或两级滤波器级联组成，如图9-8所示。例如，为了得到三阶滤波器，将一个二阶滤波器和一个一阶滤波器级联起来。为了得到一个四阶滤波器，将两个二阶滤波器级联，等等。在级联结构中，每个滤波器称为一级或一节。 $$ 图9-8~~~通过级联可以增加滤波器阶数 $$\n由于巴特沃斯特性的最平坦响应，它使用最为广泛。因此，我们将主要通过巴特沃斯响应来阐述基本滤波器的概念。表9-1列出了1～6阶巴特沃斯滤波器的下降率、阻尼系数和反馈电阻比值。 $$ 表9-1~~~巴特沃斯响应的值 $$ ","date":"2023-07-14T18:18:30+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-2%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7/","title":"9.2 滤波器的响应特性"},{"content":"电源滤波器在第⒉章中已经介绍，本章介绍用于信号处理的有源滤波器。滤波器可以让某些特定频率的输入信号达到输出端，让其他频率的输入信号不能通过。这种特性称为选择性。\n有源滤波器使用的器件，如带无源 RC 网络、RL 网络或 RLC 网络的晶体管或运算放大器。有源器件提供电压增益，无源网络用于频率选择。一般根据响应，有源滤波器有种基本类型:低通、高通、带通和带阻。本章将学习使用运算放大器和 RC 网络实现的源滤波器。\n滤波器通常按照输出电压随输人电压频率变化的方式分类，有源滤波器的种类有低通、高通、带通和带阻。本节将学习各种滤波器的一般响应。\n学完本节后,你应该掌握以下内容:\n描述基本滤波器的增益-频率响应 解释低通响应 确定低通滤波器的截止频率和带宽 解释高通响应 确定高通滤波器的截止频率 解释带通响应 解释品质因数的重要性 确定带通滤波器的截止频率、带宽、品质因素和阻尼系数 解释带阻响应 9.1.1 低通滤波器响应 滤波器是一个允许某些频率通过，衰减或阻止所有其他频率的电路。一个滤波器的通带是滤波器允许通过的频率区域，在这些区域中信号的损耗最小(通常定义为小于一3dB)。截止频率 $f_c$(通常也称为截断频率)定义为通带的终端，通常指响应自通带下降—3dB(70.7%)。通带后的区域称为过渡区，接着是阻带。过渡区和阻带之间没有精确的分界点。\n低通滤波器允许从直流到 $f_c$ 之间的频率通过并大幅衰减所有其他的频率。理想低通滤波器的通带如图9-1a中阴影区域所示，当频率在通带以外时响应降为零。理想的响应有时如同“砖墙”，因为没有任何东西可以穿过墙。理想低通滤波器的带宽等于 $f_c$ 。 $$ BW=f_c~~~(9-1) $$\n任何实际的滤波器都不可能实现图9-1a所示的理想响应。实际滤波响应取决于极点的数量，极点是滤波器的一个术语，用于描述滤波器中所包含的旁路电路数量。大多数基本低通滤波器是一个简单的 RC 网络，它仅由一个电阻和一个电容器组成，输出在电容器上产生，如图9-1b所示。这种基本 RC 滤波器具有一个单极点，超过截止频率后增益以一20dB/十倍频程的速度衰减，实际的响应在图9-1a中用加粗的线画出。为了显示曲线增益下降的细节，滤波器的响应曲线画在标准的对数坐标中。注意，增益几乎是常量，直到频率达到截止频率为止。在此之后，增益以固定的下降率迅速下降。\n$$ 图9-1~~~低通滤波器响应 $$\n基本 RC 滤波器增益以一20dB/十倍频程下降意味着在频率 $10f_c$ 处，输出是输入的一20dB(10%)。这种相当平缓的下降并不是特别好的滤波器特性，因为太多不期望的频率(通带以外的频率)可以通过这个滤波器。\n简单低通RC滤波器的截止频率在Xc=R处，其中 $$ f_c=\\frac{1}{2\\pi RC} $$\n回顾一下基本的直流/交流课程，截止频率处的输出是输入的70.7%。这种响应等价于衰减了一3dB。\n图9-1c给出了几种理想低通响应曲线，包括基本单极点响应(一20dB/十倍频程)。近似的增益曲线表明，通带内的响应是平坦的直至截止频率，在截止频率后响应以常量速率下降。真实的滤波器在截止频率内没有如此好的平坦响应，但如前所述的那样，在截止频率处有一3dB的衰减。\n为了使滤波器有更陡的过渡区(因此可以形成更有效的滤波器)，在基本滤波器上增加电路是很有必要的。由于负载效应，简单地级联理想的RC电路不能使过渡区的响应比一20dB/十倍频程更陡。然而，通过将运算放大器与频率选择反馈网络组合，设计后的滤波器的下降率可以达到一40dB/十倍频程、一60dB/十倍频程甚至更大的下降率。在设计中包含一个或多个运算放大器的滤波器称为有源滤波器。通过特殊的滤波器设计，这些滤波器可以优化下降率或其他属性(如相位响应)。通常，滤波器使用的极点越多，滤波器响应的过渡区将越陡。确切的响应取决于滤波器的类型和极点的数量。\n9.1.2 高通滤波器响应 $$ 图9-2~~~高通滤波器响应 $$\n高通滤波器极大地衰减或不让低于 $f_c$ 的频率通过，并让所有高于 $f_c$ 的频率通过，如图9-2a所示。再重复一下，在截止频率处的输出为通带的70.7%(或一3dB)。理想的响应由阴影区域标出，可以看出，响应在 $f_c$ 处瞬间下降，当然，这是不可能实现的。理想情况下，高通滤波器的通带是大于截止频率的所有频率。实际电路的高频响应受到运算放大器或构成滤波器的其他元件的限制。\n由一个电阻和电容器组成的简单 RC 网络可以构成高通滤波器，输出取自电阻，如图9-2b所示。和低通滤波器的情况一样，基本的RC网络有一20dB/十倍频程的下降，如图9-2a中加粗的线所示。同样，基本高通滤波器的截止频率发生在 $X_C=R$ 处，其中 $$ f_c=\\frac{1}{2\\pi RC} $$ 图9-2c画出了几种理想的高通响应曲线，包括基本RC网络的单级点响应(一20dB/十倍频程)。如同低通滤波器，近似的增益曲线显示了大于截止频率时啊厘是一卫的，小丁截止频率时响应以恒定速率下降。实际高通滤波器没有如图9-2C 所小的理NB的T炽的且一精确的下降率。采用有源高通滤波器使过渡区的响应陡峭程度大于一20dB/十倍频程是可行的，特定的响应依赖于滤波器的类型和极点的数量。\n9.1.3 带通滤波器响应 $$ 图9-3~~~一般带通响应曲线 $$\n带通滤波器允许位于下限频率和上限频率之间的频率信号通过，阻止指定带宽以外的所有其他频率信号通过。5.2节介绍的高频调谐放大器使用调谐电路作为带通滤波器。图9-3给出了一般的带通滤波器响应曲线。带宽(BW)定义为上截止频率($f_{c2}$)和下截止频率($f_{c1}$)的差。 $$ BW=f_{c2}-f_{c1}~~~(9-2) $$\n截止频率是响应曲线降到它最大值的 70.7% 时的频率点，这些截止频率同样称为3dB频率。通带中心的频率称为中心频率 $f_0$，它定义为两个截止频率的几何均值. $$ f_0=\\sqrt[]{f_{c1}f_{c2}}~~~(9-3) $$\n品质因数\n回顾一下5.2节介绍的带通滤波器的品质因数(Q)定义为中心频率与带宽之比。 $$ Q=\\frac{f_0}{BW}~~~(9-4) $$\n$Q$ 的值是带通滤波器选择性的指标。对 $f_0$ 一个给定的值，$Q$ 的值越高，带宽越窄并且选择性越好。带通滤波器有时分为窄带($Q\u0026gt;10$)或宽带($Q\u0026lt;10$)，$Q$ 也可以用滤波器的阻尼系数来表示 $$ Q=\\frac{1}{DF} $$ 9.2节将介绍阻尼系数。\n9.1.4 带阻滤波器响应 还有一种有源滤波器是带阻滤波器，也称为陷波滤波器、频带抑制滤波器等。带阻滤波器的一般响应曲线如图9-4所示。注意，带宽是3dB频率点之间的宽度，和带通滤波器响应的情况一样。可以认为带阻滤波器的原理与带通滤波器相反，因为在某段带宽内的频率被拒绝，而在该带宽之外的频率能够通过。 $$ 图9-4~~~一般带阻滤波器响应 $$\n","date":"2023-07-14T18:18:20+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/9-1%E5%9F%BA%E6%9C%AC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%93%8D%E5%BA%94/","title":"9.1 基本滤波器响应"},{"content":"本节介绍几个运算放大电路，它们代表了运算放大器的基本应用。你将学习恒流源、电流-电压转换器、电压-电流转换器和峰值检波器。当然，这并没有全面覆盖所有可能的运算放大器电路，仅仅是介绍了一些常见的基本使用。\n学完本节后,你应该掌握以下内容:\n理解一些特殊运算放大器电路的工作原理 识别和解释运算放大器恒流源的工作原理 识别和解释运算放大器电流-电压转换器的工作原理 识别和解释运算放大器电压-电流转换器的工作原理 解释如何将一个运算放大器用作峰值检波器 8.4.1 恒流源 $$ 图8-34~~~基本恒流源 $$\n当负载电阻变化时，恒流源提供的负载电流保持恒定。图8-34是一个基本电路，稳压源($V_{in}$)通过输入电阻($R_i$)提供恒定电流($I_i$)。因为运算放大器反相输入端虚地(0V)，所以 $I_i$ 的值由 $V_{IN}$ 和 $R_i$ 决定 $$ I_i=\\frac{V_{IN}}{R_i} $$ 现在，因为运算放大器的内部输入电阻非常大(理想情况下是无穷大)，所以实际上所有$I_i$通过反馈支路流过$R_L$。因为$I_i=I_L$，所以 $$ I_L=\\frac{V_{IN}}{R_i}~~~(8-8) $$\n如果$R_L$变化，只要$V_{IN}$和$R_i$保持不变，$I_L$就保持不变。\n8.4.2 电流-电压转换器 电流-电压转换器把变化的输入电流变为成正比的输出电压，基本电路如图8-35a所示。因为几乎所有 $I_i$ 流过反馈路径，所以$R_f$的电压降为 $I_iR_f$。因为 $R_f$ 的左端虚地(0V),所以输出电压就等于 $R_f$ 上的电压，该电压与 $I_i$ 成正比。 $$ V_{OUT}=I_iR_f~~~(8-9) $$ $$ a)基本电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)感光电路，电路输出电压与光强度成正比 $$\n$$ 图8-35~~~电流-电压转换器 $$\n这个电路的一种特殊应用如图8-35b所示，其中，光敏元件用来探测光强度变化。当光强度发生变化时，流过光敏元件的电流随着发生变化，这是因为元件的电阻发生了改变。输出电压的变化与这个电阻的变化成正比($△V_{OUT}= △I_iR_f$)。\n8.4.3 电压-电流转换器 $$ 图8-36~~~电压-电流转换器 $$\n基本电压-电流转换器如图8-36所示。这个电路用于输出(负载)电流需要由输入电压控制的应用中。\n忽略输入失调电压，运算放大器的反相和同相输入端的电压都是 $V_{IN}$。因此，$R_1$ 上的电压等于 $V_{IN}$。因为反相输入端的电流可以忽略，所以 $R_1$ 上的电流与 $R_L$ 上的电流相等。因此， $$ I_L=\\frac{V_{IN}}{R_1}~~~(8-10) $$\n8.4.4 峰值检测器 $$ 图8-37~~~基本的峰值检测器 $$\n运算放大器的一个有趣应用是峰值检测器电路，如图8-37所示。这种情况下，运算放大器用作比较器。这个电路的目的是检测输入电压的峰值，并且将峰值电压存储在电容器上。例如，这个电路可以用于检测和存储浪涌电压的最大值，然后可以在输出端用电压表和记录设备来测量它。基本的工作原理如下: 当正极性电压通过 $R_i$ 连接到运算放大器的同相输人端时，运算放大器的高电平输出电压使二极管正向偏置导通并向电容器充电。电容器持续充电，直到它的电压等于输人电压为止，因此运算放大器的两个输入端具有相同的电压。此时，运放比较器输出状态切换，它的输出变为低电平。现在二极管反向偏置,电容器停止充电，它达到的电压等于$V_{in}$的峰值，并将此电压一直维持在这个值直到电荷漏光。如果输入有更大的峰值，电容器将充电到这个新的峰值。\n","date":"2023-07-14T18:17:53+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-4%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%94%B5%E8%B7%AF/","title":"8.4 转换器和其他运算放大器电路"},{"content":"运算放大积分器模拟数学积分，数学积分本质上是一个求和过程，积分的值是函数曲线下覆盖的总面积。运算放大微分器模拟数学微分，数学微分是确定函数瞬时变化率的过程。为了展示基本原理，本节学习的积分器和微分器是理想的。为了阻止饱和，实际的积分器常常有一个额外的电阻或其他电路在反馈电容器的并联电路中。为了减小高频噪声实际的微分器可能包含一个串联电阻。\n学完本节后,你应该掌握以下内容:\n理解积分器和微分器的工作原理 判别积分器 讨论电容器如何充电 确定积分器输出变化率 判别微分器 确定微分器的输出电压 8.3.1 运算放大器积分器 $$ 图8-24~~~理想运放积分器 $$\n一个理想积分器如图8-24所示。注意，反馈元件是一个电容器，这个电容器与输电阻构成 RC 电路。\n电容器如何充电 为了明白积分器是如何工作的，需要复习一下电容器的充电过程。回顾一下，电容器上的电量 Q 与充电电流($I_C$)和时间($t$)成正比。 $$ Q=I_Ct $$ 同样地，考虑到电压，电容器上的电量为 $$ Q=CV_C $$ 从这两个关系式可以得到，电容器电压可以表示成 $$ V_C=(\\frac{I_C}{C})t $$ 这个表达式是一条直线的方程，直线开始于 0 并且斜率为 $I_C/C$。(从线性代数可知，直线的一般表达式为 $y=mx十b$。这里，$y=V_C$，$m=I_C/C$，x=t，并且b=0。)\n我们知道，在简单 RC 网络上的电容电压是非线性的，是指数的。这是因为当电容充电时引起电压变化率的连续减小，充电电流是连续下降的。使用具有 RC 网络的运算放大器构成的积分器的关键之处是电容器的充电电流是恒定的，因此产生直线(线性)的电压而不是指数电压。现在我们看看为什么是这样的。\n$$ 图8-25~~~积分器中的电流 $$\n在图8-25中，运算放大器的反相输人端虚地(0V)，所以 $R_i$ 两端的电压等于$V_{in}$。因此，输入电流为 $$ I_{in}=\\frac{V_{in}}{R_i} $$ 电容器电压 因为$I_{in}$是恒定的，所以 $I_C$ 也是恒定的。常量 $I_C$ 线性地向电容器充电，在 C 上产生线性电压。电容器的正极通过运算放大器虚地维持在 0V，电容器的负极电压随着电容器充电从 0 开始线性减小，如图8-26所示。这个电压称为负斜坡，它是恒定正极性输入的结果。\n$$ 图8-26~~~由恒定充电电流在C上产生的线性斜坡电压 $$\n输出电压 $V_{out}$ 与电容器负极电压相同。当常量正极性输入电压是阶跃形式或脉冲形式时(脉冲在高电平处幅度是常量)，输出斜坡在负方向一直减小，直到运算放大器在最大负电平处饱和为止，如图8-27所示。\n$$ 图8-27~~~恒定输入电压在积分器输出端产生斜坡 $$\n输出变化率 你已经发现，电容器充电速率和输出斜坡斜率由比率 $I_C/C$ 决定。因为 $I_C=V_{in}/R_i$，所以积分器输出电压的变化率或斜率为 $$ \\frac{△V_{out}}{△t}=-\\frac{V_{in}}{R_iC}~~~(8-6) $$\n你将会在第10章中看到，积分器在三角波发生器中特别有用。\n8.3.2 运算放大器微分器 $$ 图8-29~~~理想运放微分器 $$\n理想微分器如图8-29所示。注意，电容器和电阻的位置与它们在积分器中的位置不同。现在，电容器是输入元件。微分器产生的输出与输入电压的变化成正比。尽管通常用小阻值电阻与电容器串联来限制增益，但是这并不影响基本的工作原理，这里的分析不考虑这个问题。\n$$ 图8-30~~~斜坡输入微分器 $$\n为了弄清微分器是如何工作的，如图8-30所示，将正向斜坡电压加在输入端。这种情况下，$I_C=I_{in}$，因为反相输入端虚地，任何时候电容器上的电压都等于$V_{in}(V_C=V_{in})$。\n从基本公式$V_C=(I_C/C)t$，有 $$ I_C=(V_C/t)C $$ 因为反相输人端的电流可以忽略，所以 $I_R=I_C$。因为电容器电压斜坡($V_C/t$)是常量，所以电流是常量。由于反馈电阻的一端总是0V(虚地)，所以输出电压同样是常量，并等于 $R_f$ 上的电压。 $$ V_{out}=I_RR_f=I_CR_f \\\\ V_{out}=-(\\frac{V_C}{t})R_fC~~~(8-7) $$\n$$ 图8-31~~~输入端连续加入正向和负向斜坡(三角波)时的微分器输出 $$\n如图8-31所示，当输人是正向斜坡时，输出是负值。当输出是负向斜坡时，输出是正值。在输人为正斜坡期间，具有恒定电流的输入源通过反馈电阻向电容器充电。在输人是负向斜坡时，由于电容器放电,恒定电流反向。\n注意，在式(8-7)中，$V_C/t$ 是输入的斜率。如果斜率增加，$V_{out}$ 将负得更多。如果斜率减小，$V_{out}$ 将正得更多。所以输出电压与输入的负向斜率(变化率)成正比，这个比例常量是时间常量$R_fC$。\n","date":"2023-07-14T18:17:37+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-3%E7%A7%AF%E5%88%86%E5%99%A8%E5%92%8C%E5%BE%AE%E5%88%86%E5%99%A8/","title":"8.3 积分器和微分器"},{"content":"求和放大器是第6章中讨论的反相运算放大器组态的一种变化形式。求和运算放大器有两个或两个以上的输入端，输出电压与输人电压的代数总和的负值成正比。本节学习求和放大器是如何工作的，并了解均值放大器和比例放大器，它们都是基本求和运算放大器的变化形式。\n学完本节后，你应该掌握以下内容:\n理解多种类型求和放大器的工作原理 描述单位增益求和放大器的工作原理 讨论如何获得大于单位增益的任意增益 描述均值放大器的工作原理 描述比例加法器的工作原理 讨论用作数模转换器的比例加法器 讨论求和放大器在其中起重要作用的模拟系统 8.2.1 单位增益求和放大器 一个两输入的求和放大器如图8-18所示，实际上任意数量的输入都是可以的.\n$$ 图8-18~~~两输入反相求和放大器 $$\n电路的工作原理和输出表达式的推导如下: 电压 $V_{IN1}$和$V_{IN2}$用于输入端，并产生电流$I_1$和$I_2$，如图8-18所示。从无穷大输入阻抗和虚地的概念可知，运算放大器反相端(一)输入电压接近于 0V，因此输入端没有电流。这意味着输人电流 $I_1$ 和 $I_2$ 在这个求和点处相加，形成总电流，这个电流$I_T$流过$R_f(I_T=I_1＋I_2)$。因为$V_{out}=-I_TR_f$，则 $$ V_{OUT}=-(I_1+I_2)R_f=-(\\frac{V_{IN1}}{R_1}+\\frac{V_{IN2}}{R_2})R_f $$ 如果三个电阻的电阻值相等($R_1=R_2=R_f=R$)，则\n$$ V_{OUT}=-(\\frac{V_{IN1}}{R}+\\frac{V_{IN2}}{R})R=-(V_{IN1}+V_{IN2}) $$ 从前面的公式可以看出，输出电压的幅值等于两个输入电压幅值的和，但是带有负号。式(8-3)是具有 n 个输入求和放大器的通用表达式，如图8-19所示，其中所有电阻的电阻值相等。 $$ 图8-19~~~具有n个输入的求和放大器 $$\n$$ V_{OUT}=-(V_{IN1}+V_{IN2}+\u0026hellip;+V_{INn})~~~(8-3) $$\n8.2.2 增益大于单位增益的求和放大器 当 $R_f$ 大于输人电阻时，放大器的增益为 $一R_f/R$，其中，$R$ 是每个输人电阻的电阻值。输出的一般表达式为 $$ V_{OUT}=-\\frac{R_f}{R}(V_{IN1}+V_{IN2}+\u0026hellip;+V_{INn})~~~(8-4) $$ 从公式可以看出，输出电压的幅值等于所有输入电压的和乘以一个由 $一R_f/R$ 决定的常量。\n8.2.3 均值放大器 求和放大器可以用来对输入电压产生数学平均。只需要把比率 $R_f/R$ 设置为输入个数的倒数即可，即 $R_f/R=1/n$。\n可以得到若干数字的平均值，首先把这些数相加，然后除以这些数字的总个数。观察式(8-4)，并稍加思考，就可以看出求和运算放大器可以实现求数学均值的功能。下面的例子对此进行了阐述。\n8.2.4 比例加法器 通过简单地调整输入电阻的电阻值，可以给求和运算放大器的各个输人赋予不同的权重系数。输出电压可以表示为 $$ V_{OUT}=-(\\frac{R_f}{R_1}V_{IN1}+\\frac{R_f}{R_2}V_{IN2}+\u0026hellip;\\frac{R_f}{R_n}V_{INn})~~~(8-5) $$ 每个输入的权重系数由 $R_f$ 与这个输入的电阻值比率决定。例如，如果一个输入电压的权重为 1，那么 $R=R_f$。或者，如果权重为0.5，那么 $R=2R_f$。$R$的值越小，权重系数越大，反之亦然。\n","date":"2023-07-14T18:17:24+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-2%E6%B1%82%E5%92%8C%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"8.2 求和放大器"},{"content":"在前两章学习了运算放大器的原理、运算和特性。运算放大器的应用范围非常宽广很难在一章或一本书内将这些应用都一一覆盖。因此，本章将通过一些基本的应用来阐述运算放大器的应用多样性，并且帮你建立基本运算放大器电路的基础。\n运算放大器经常用作非线性器件来比较两个电压的幅值。在这种应用中，运算放大器用作开环配置，输人的一.端是输入电压，输人的另一端是参考电压。\n学完本节后，你应该掌握以下内容:\n理解几类基本比较器电路的工作原理 描述过零检测器的工作原理 描述非过零检测器的工作原理 讨论输人噪声是如何影响比较运算的 定义滞回 解释滯回是如何降低噪声影响的 描述施密特触发电路 描述限幅比较器的工作原理 描述窗口比较器的工作原理 讨论比较器在包含模数转换器的系统中的应用 8.1.1 过零检测 运算放大器的一个应用是用作比较器，用来判断输人电压是否超过某个值。图8-1a给出了一个过零检测器。注意，反相(-)输入端接地产生零电平，输人信号电压接到同相(+)输人端。由于很高的开环电压增益，两个输人端之间非常小的电压差使得放大器饱和，从而使得输出电压达到它的极限。\n打开配套网站上的文件F08-01。这个仿真演示过零检测器的工作原理。\n例如，一个运算放大器的 $A_{ol}= 100 000$。输入端仅 0.25mV 的电压差能够产生 $0.25mV\\times 100 000=25V$ 的输出电压，前提是这个输出电压没有超过运算放大器的输出上限。然而，因为绝大多数运算放大器的输出电压的范围在 $\\pm 15V$ 甚至更小，所以超过这个极限器件将达到饱和。在许多需要比较的应用场合，常选择专门的运放比较器。为了达到最高的速度，这些集成电路通常未做补偿。在一些不太严格的应用中，一个通用运算放大器就可以很好地用作比较器了。\n$$ 图8-1~~~运算放大器用作过零检测器 $$\n图8-1b展示了正弦波输入电压接入过零检测器的同相端。如图8-1b所示，当正弦波为负时，输出电压在最大负电平处。当正弦波跨过 0 时，放大器变为相反状态，输出变为最大正电平值。过零检测器可以用于从正弦波产生方波的方波产生电路。\n8.1.2 非过零检测 $$ 图8-2~~~非过零检测器 $$\n通过在反相端(一)接入一个固定的参考电压，图8-1所示的过零检测器经过改进后可以用于检测正、负电压，如图8-2a所示。一个更为实际的接法如图8-2b所示，使用分压器来设置参考电压: $$ V_{REF}=\\frac{R_2}{R_1+R_2}(+V)~~~(8-1) $$ 式中，$＋V$ 是运算放大器电源的正极。图8-2c中的电路使用齐纳二极管来设置参考电压( $V_{REF} = V_Z$)。只要输人电压 $V_{in}$小于$V_{REF}$，输出就保持在最大负电平。当输入电压超过参考电压时，输出变为最大正值，图8-2d是正弦波输入电压时的示意图。\n8.1.3 输入噪声对比较器工作的影响 $$ 图8-5~~~叠加噪声的正弦波 $$\n在许多应用中，噪声(不期望的起伏不定的电压或电流)可能会出现在输人引线上。噪声电压叠加到输人电压上，如图8-5所示，会使比较器的输出状态无规律地来回切换变化。\n$$ 图8-6~~~噪声对比较器电路的影响 $$\n为了理解噪声电压的潜在影响，考虑将一个低频正弦电压连接到运放比较器的同相输入端(＋)作为过零检测器，如图8-6a所示。图8-6b给出了叠加噪声的输入正弦波和对应的输出。你可以看到，当正弦波接近0时，由于噪声引起的电压起伏使得总输入多次大于或小于0，因此会产生不稳定的输出电压。\n8.1.4 用滞回减小噪声影响 在输人端有噪声的情况下，比较器的开关输出会在正电平和负电平之间产生不稳定的跳变，这是因为输入端引起正负变化的参考电压值是同一个值。当输入电压在参考电压值附近变化时，输入端任何很小的噪声都会使得比较器不停地改变工作状态，这种不稳定的情况就会发生。\n为了使得比较器对噪声不那么敏感，可以使用一种包含正反馈的技术，称为滞回。本质上，滞回意味着当输入电压从较低向较高变化时的参考电压要高于当输入电压从较高向较低变化时的参考电压。常见的家用恒温调节器是滞回的一个范例，在一个温度上打开，在另一个温度上关闭。\n两个参考电压称为上触发点( upper trigger point，UTP)和下触发点(lower trigger point，LTP)。两电平的滞回是通过正反馈实现的，如图8-7所示。注意，同相(＋)输入端连接到电阻分压器，使得输出电压的一部分反馈到输入端，输入信号连接到反相(一)输入端。\n具有滞回功能比较器的基本工作原理如下所述，并在图8-8中说明。假设输出电压达到它的正最大值 $＋V_{out(max)}$，反馈到同相输入端的电压是 $V_{UTP}$，可以表示为 $$ V_{UTP}=\\frac{R_2}{R_1+R_2}(+V_{out(max)}) $$ 当输入电压 $V_{in}$ 超出 $V_{UTP}$，输出电压就跳变到负的最大值 $一V_{out(max)}$。此时反馈到同相输入端的是 $V_{LTP}$，可以表示为 $$ V_{LTP}=\\frac{R_2}{R_1+R_2}(-V_{out(max)}) $$ $$ 图8-8~~~滞回比较器的工作原理 $$\n现在，输人电压必须低于 $V_{LTP}$ 才能使得比较器的输出切换到另一个电压值，这就意味着小的噪声电压对输出不会造成影响，如图8-8所示。\n滞回比较器有时也称为施密特触发器(Schmitt trigger)。滞回的值定义为两个触发电平间的差。\n8.1.5 输出限幅 $$ 图8-10~~~有输出限幅的比较器 $$\n在一些应用中，必须将比较器的输出电压限制在小于运算放大器饱和电压值的范围内。如图8-10所示，齐纳二极管可以在一个方向上将输出电压限制在稳压电压上，在另一个方向上是二极管的正向压降。这个限制输出范围的过程称为限幅。\n$$ 图8-11~~~限幅比较器的工作原理 $$\n工作原理如下所述:因为齐纳二极管的正极连接到反相(一)输入端，所以当它导通时为虚地($\\approx 0V$ )。因此，输出电压的正电压就等于齐纳管的稳压值，输出电压被限制在这个值了，如图8-11所示。当输出开关值为负值时，齐纳二极管像普通二极管那样工作，有 0.7V 的正向偏置电压，所以把负输出电压限制在了 $一0.7V$。改变齐纳二极管的连接方向可以在相反方向上把输出电压限制在这些值的附近。\n$$ 图8-12~~~双限幅比较器 $$\n两个齐纳二极管的限幅比较器如图8-12所示，正负输出电压都被限制在齐纳稳压值加上正向偏置电压(0.7V)上，如图8-12所示。\n8.1.6 窗口比较器 $$ 图8-15~~~基本的窗口比较器 $$\n$$ 图8-16~~~窗口比较器工作原理的例子 $$\n将两个单独的运算放大比较器按照图8-15所示的方式连接形成窗口比较器( windowcomparator)，它可以检测出输人电压在上下两个限幅值之间(称为“窗口”)的变化。\n上、下限 $V_U$ 和 $V_L$ 是由参考电压设置的。这些电压可以通过分压器、齐纳二极管或任何类型的电压源设置。只要 $V_{in}$ 在窗口之内(小于 $V_U$ 并且大于 $V_L$ )，每个比较器的输出就处于它的低饱和水平。在这种条件下，两个二极管都反向偏置，并且通过电阻接地 $V_{out}$ 保持在0。当 $V_{in}$ 大于 $V_U$ 或低于 $V_L$ 时，这两个比较器的输出达到它的高饱和状态，二极管处于正向偏置，输出为高电平 $V_{out}$。图8-16表示了 $V_{in}$。任意变化时的情况。\n","date":"2023-07-14T18:17:13+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/8-1%E6%AF%94%E8%BE%83%E5%99%A8/","title":"8.1 比较器"},{"content":"上一节指出，当运算放大器响应的下降率超过 一20dB/十倍频程，并且运算放大器运行在闭环配置中，增益曲线与开环响应相交于更高的下降率时，就会出现不稳定。正如上节讨论的情况中，闭环电压增益被限制在非常高的值。在许多应用中，较低的闭环增益是很有必要或者非常希望的。为了让运算放大器能够运行在较低的闭环增益处，需要进行相位滞后补偿。本节可作为选学内容。\n学完本节后，你应该掌握以下内容:\n解释运算放大器相位补偿 描述相位-滞后补偿 解释补偿电路 应用单电容器补偿 应用前馈补偿 7.5.1 相位滞后补偿 正如你所看到的，不稳定的原因是运算放大器内部滞后网络的额外相移。当这些相移等于或超过 180° 时，放大器就会振荡。要么通过补偿的方法来去除开环下降率大于 一20dB/十倍频程的部分，要么通过补偿将 一20dB/十倍频程下降的线段延伸到更低的增益处。这些概念在图7-15中进行了阐述。 $$ 图7-15~~~用伯德图说明对典型运算放大器开环增益进行相位补偿的效果 $$\n7.5.2 $$ a)电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) 理想输出电压20dB/十倍频程 $$\n$$ 图7-16~~~基本补偿网络的作用 $$\n对集成电路运算放大器进行补偿有两种基本的方法: 内部的和外部的。两种方法都需要加入 RC 网络。基本补偿操作如下所述: 首先考虑 RC 网络，如图7-16a 所示。补偿电容的电抗 $X_{C_c}$ 在低频处非常大，输出电压几乎等于输人电压。当频率达到其截止频率时，$f_c= 1/[2\\pi(R_1 + R_2)C_c]$, 输出电压按 一20dB/十倍频程下降，这个下降率会一直持续到 $X_{C_c}≈0$。在 $X_{C_c}≈0$ 时，输出电压大小由 $R_1$ 和 $R_2$ 决定，如图7-16b所示。这是运算放大器相位补偿中使用的原则。\n$$ 图7-17~~~带补偿的运算放大器 $$\n为了看清补偿网络如何改变运算放大器的开环响应，参照图7-17。此图是一个二级的运算放大器，每一级和紧跟着的滞后网络都用灰色阴影块表示，补偿网络连接到第一级电路的输出端 A 点处。\n把补偿网络截止频率的值设置为小于内部滞后网络的主(最小的)截止频率，这就使得在补偿网络的截止频率处开始以一20dB/十倍频程下降。补偿网络的下降从截止频率开始一直持续到主滞后网络的截止频率处，到该点后，补偿网络的响应呈平稳状态,由主滞后网络的一20dB/十倍频程来接管继续下降，最终的结果是开环响应向左平移，因此压缩了带宽，如图7-18a所示。补偿网络的响应曲线与总开环响应曲线之间的正确关系如图7-18b所示。\n$$ 图7-18~~~~补偿运算放大器频率响应的例子 $$\n7.5.3 补偿范围 $$ a)部分补偿~~~~~~~~~~~~~~~~~~~~~b)全补偿 $$\n$$ 图7-21~~~补偿范围 $$\n较大的补偿电容会使得开环响应从较低的频率就开始下降，因此会将 一20dB/十倍频程的下降延伸到较低的增益值，如图7-21a所示。通过足够大的补偿电容可以使得运算放大器无条件地稳定，如图7-21b所示，这里的 一20dB/十倍频程线段一直延伸到单位增益一般这种内部的补偿是由制造商在生产时就实现的，一个内部的、全补偿的运算放大器可以用于任意值的闭环增益并保持稳定。741就是内部全补偿的一种器件。\n内部全补偿放大器的缺点是牺牲了带宽，因而降低了转换速率。所以，许多集成运算放大器会提供外部补偿。图7-22给出了 LM101A 运算放大器的典型封装图，带有外补偿的引脚，通过这些引脚可以用小电容提供外部补偿。通过提供外部连接，对特定的应用只需要提供正好够用的补偿，从而避免了性能上不必要的损失。\n$$ 图7-22~~~~运算放大器典型的封装布局 $$\n7.5.4 单电容补偿 $$ 图7-23 ~~~~LM101A运算放大器的单个电容补偿例子 $$\n如图7-23a所示，作为补偿集成运算放大器的一个例子，LM101A在放大器组态中，电容 $C_1$ 连接到引脚 1 和 8。图7-23b针对 $C_1$ 两个不同的值分别给出了各自的开环频率响应曲线。3pF的补偿电容产生的单位增益带宽接近于10MHz。注意，一20dB/十倍频程线段延伸到一个非常低的增益值。当 $C_1$ 扩大10倍，达到30pF时，带宽也减小了10倍。注意，此时一20dB/十倍频程线段延伸到了单位增益处。\n在运算放大器用于闭环组态时，如图7-23c所示，有效的频率范围取决于补偿电容。例如，如图7-23c所示的闭环增益为40dB，当 $C_1$ =30pF时带宽接近10kHz，当 $C_1$ 减小为3pF时带宽增加到接近100kHz。\n7.5.5 前馈补偿 $$ 图7-24~~~在高频段旁路掉第一级的前馈补偿 $$\n相位补偿的另一种方法是前馈补偿。使用这种补偿方法的结果是比前面讨论的补偿方法对带宽的压缩要小。基本的原理是: 在高频段旁路掉运算放大器内部的输入电路，驱动更高频率的第二级，如图7-24所示。\n$$ a）制造商推荐的配置~~~~~~~~~~~~~~~~~~~~b）响应 $$\n$$ 图7-25 ~~~LM101A运算放大器的前馈补偿和响应曲线 $$\nLM101A的前馈补偿如图7-25a所示。前馈电容 $C_1$ 从反相输人端连接到补偿端，$R_f$ 两端需要一个小电容来保证稳定。图7-25b所示的伯德图中给出了前馈补偿响应和前面讨论的标准补偿响应，前馈补偿只能用于反相放大器组态。其他的补偿方法也可以使用，通常制造商会在数据手册中给出建议.\n","date":"2023-07-14T18:16:59+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-5%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E8%A1%A5%E5%81%BF/","title":"7.5 运算放大器的补偿"},{"content":"使用运算放大器时，稳定性是需要考虑的。稳定运行是指运算放大器在任何情况下都不会振荡。不稳定会产生振荡，当输人端没有信号时，由于输人端的噪声和瞬态电压，输出端会有不期望的电压波动。本节可以作为选读内容。\n学完本节后，你应该掌握以下内容:\n讨论正反馈和运算放大器的稳定性 定义正反馈 定义环路增益 定义相位裕量并讨论它的重要性 判定运算放大器是否稳定 总结稳定性判据 7.4.1 正反馈 为了理解稳定性，必须先检查不稳定性及其原因。大家知道，通过负反馈，反馈到放大器输人端的信号与输人信号相抵，因此减去反馈信号可以有效地减小电压增益。只要反馈是负的，放大器就是稳定的。\n当从输出端反馈到输人端的信号的相位与输入信号的相位一致时，正反馈条件就成立了，放大器就会发生振荡。也就是说，当通过运算放大器和反馈网络的总相移是 360°(这也等价于无相移(0°))时，正反馈就会发生。\n7.4.2 环路增益 要产生不稳定: (a)必须有正反馈，(b)闭环放大器的环路增益必须大于1。闭环放大器的环路增益定义为运算放大器的开环增益乘以反馈网络的衰减因子。 $$ 环路增益=A_{ol}B~~~(7-7) $$\n7.4.3 相位裕量 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c) $$\n$$ 图7-10~~~反馈环相移 $$\n注意，对图7-10中的每个放大器配置，反馈环连接到反相输入端。由于反相，在输人端和输出端之间存在着固有的 180° 相移。此外，放大器中的 RC 滞后网络(图7-10中没画出来)会产生附加的相移($φ_{tot}$)，因此反馈环的总相移为 $180°+φ_{tot}$。\n相位裕量$φ_{pm}$ 是使得反馈环的总相移为 360°(360° 等价于 0°)时的额外相移。 $$ 180°+φ_{tot}+φ_{pm}=360° \\\\ φ_{pm}=180°-|φ_{tot}|~~~(7-8) $$ 如果相位裕量是正的，则总相移小于 360°，放大器是稳定的。如果相位裕度是 0 或负的，则反馈信号是以输人信号同相反馈的，放大器有潜在的不稳定。从式(7-8)可以看出，当总的滞后网络相移($φ_{tot}$)等于或超过 180° 时，相位裕量是 0° 或负值，存在不稳定状态，这将会引起放大器振荡。\n7.4.4 稳定性分析 因为大多数运算放大器实际使用的配置是大于1的环路增益($A_{ol}B\u0026gt;1$)，所以稳定性判断准则基于内部滞后网络的相角。如前所述，运算放大器由多级电路组成，每级有一个截止频率。对补偿运算放大器，只有一个截止频率占主导地位，反馈的稳定性不是一个问题。稳定性问题一般表现为不期望的震荡，对运算放大器，在接近单位-增益频率处的反馈是稳定的。\n$$ 图7-11~~~一个三级运算放大器响应的伯德图 $$\n为了阐述反馈稳定性的概念，我们以非补偿三级运算放大器为例子，其开环响应如图7-11中的伯德图所示。在这种情况下，有三个不同的截止频率，它们分别对应于三个内部RC滞后网络。在第一个截止频率 $f_{c1}$ 处，增益开始以一20dB/十倍频程下降。当达到第二个截止频率 $f_{c2}$ 处，增益以一40dB/十倍频程开始下降。当达到第三个截止频率 $f_{c3}$ 处，增益以一60dB/十倍频程开始下降。\n为了分析非补偿闭环放大器的稳定性，需要确定相位裕量。对闭环增益的一个给定值，如果是正相位裕量表明放大器是稳定的。为了给出不稳定性的条件，下面将给出三种情况。\n$$ 图7-12~~~闭环增益和开环增益在-20dB/十倍频程线段上相交的情况(稳定工作) $$\n情况1 如图7-12所示，闭环增益和开环增益响应在-20dB/十倍频程线段上相交。中频闭环增益为 106dB，闭环截止频率为5kHz。如果我们假设放大器不会在它的中频范围以外工作，106dB 放大器的最大相移发生在中频范围的最高处(这种情况时是5kHz)。在这个频率处由三个滞后网络产生的总相移为: $$ φ_{tot}=-arctan(\\frac{f}{f_{c1}})-arctan(\\frac{f}{f_{c2}})-arctan(\\frac{f}{f_{c3}}) $$ 式中，$f=5kHz$，$f_{c1}=1kHz$，$f_{c2}= 10kHz$, $f_{c3}= 100kHz$。因此， $$ φ_{tot}=-arctan(\\frac{5kHz}{1kHz})-arctan(\\frac{5kHz}{10kHz})-arctan(\\frac{5kHz}{100kHz}) \\\\ =-78.7°-26.6°-2.9°=-108.1° $$ 相位裕量 $φ_{pm}$ 为 $$ φ_{pm}=180°-|φ_{tot}|=180°-108.1°=+71.9° $$ 因为相位裕量是正的，所以放大器在它的中频范围内的所有频率处都是稳定的。通常，如果闭环增益与开环响应曲线在 -20dB/十倍频程线段上相交，则在所有的中频范围放大器都是稳定的。\n$$ 图7-13~~~闭环增益和开环增益在-40dB/十倍频程线段上相交的情况(临界稳定状态) $$\n情况2 如图7-13所示，闭环增益被降低到与开环响应在-40dB/十倍频程线段上相交，这种情况下的中频闭环增益是 80dB,闭环截止频率约为 30kHz。在 $f=30kHz$ 处由三个滞后网络产生的总相移如下: $$ φ_{tot}=-arctan(\\frac{30kHz}{1kHz})-arctan(\\frac{30kHz}{10kHz})-arctan(\\frac{30kHz}{100kHz}) \\\\ =-88.1°-71.6°-16.7°=-176.4° $$ 相位裕量为 $$ φ_{pm}=180°-176.4°=+3.6° $$ 因为相位裕量是正的，所以放大器在这个中频范围内仍是稳定的，但是频率稍大于 $f_c$ 时就会引起放大器的振荡。因此，它处于临界稳定，并且由于其他原因很可能引起振荡。因为不稳定发生在 $φ_{pm} = 0°$，所以它非常接近于不稳定。作为一般规则，建议采用最小 45° 相位裕量，避免使放大器处于临界稳定状态。\n$$ 图7-14~~~闭环增益和开环增益在 -60dB/十倍频程线段上相交的情况(不稳定状态) $$\n情况3 如图 7-14 所示，闭环增益将进一步减小，直到它与开环增益在 一60dB/十倍频程线段上相交。这种情况下，中频闭环增益为 18dB，闭环截止频率为 500kHz。在 $f=500kHz$ 处由三个滯后网络引起的总相移为 $$ φ_{tot}=-arctan(\\frac{500kHz}{1kHz})-arctan(\\frac{500kHz}{10kHz})-arctan(\\frac{500kHz}{100kHz}) \\\\ =-89.9°-88.9°-78.7°=-257.5° $$ 相位裕量为 $$ φ_{pm}=180°-257.5°=-77.5° $$ 这里的相位裕量是负的，放大器在这个中频范围的上界处是不稳定的。\n稳定性准则小结 上面三种情况的稳定性分析已经表明放大器的闭环增益必须要与开环增益曲线在 一20dB/十倍频程线段上相交，才能保证在中频范围内所有频率处的稳定性。如果闭环增益降低到与 一40dB/十倍频程线段上相交的话，那么就会发生临界稳定或完全不稳定。在前面的情况(情况1. 2和3)，闭环增益应该大于 72dB。\n如果闭环增益与开环增益响应在 一60dB/十倍频程线段上相交，除非使用专门设计的反馈网络，否则在放大器中频范围内的某些频率处，一定会发生不稳定。因此，为了确保在中频范围内所有频率处的稳定性，工作时运算放大器的闭环增益必须使得从主截止频率处开始的下降率不超过 一20dB/十倍频程。\n7.4.5 检测不期望的振荡 本节提到的稳定性问题是可以通过专门设计的反馈网络加以控制的，即使在负相位裕量的情况下(情况3)。在反馈路径上可以采用超前网络来增大相位裕量，从而提高稳定性。在一些情况下，通过加入含有放大器的复杂反馈网络或者其他有源器件来提高稳定性。\n并不是所有的稳定性问题都是由反馈网络引起的。如果振荡并不接近于放大器的单位增益频率，反馈回路很可能不是罪魁祸首。振荡的原因包括存在外部反馈路径、接地问题或者外来的噪声信号耦合进电源线。当振荡成为问题时，可以做个简单的测试，增加增益看看振荡是否消失(这就意味着闭环增益与开环增益相交在更高的点处)。如果振荡仍然存在，那么这个问题很可能是其他原因引起的，而不是由负相位裕量引起的。\n为了排除不期望的振荡，检查接地路径(尽量使用单点接地)，增加电源的旁路电容，尽量消除外部电容耦合到输人端的路径。耦合路径很可能不明显，如由于面包板引起，尤其当它没有接地线时，或者由于电路中的长导线产生(导线是有电容特性的)。电源噪声在放大器中会产生反馈，从而引起振荡。在低频处，一个简单的旁路电容(1~10μF钽电容)就可以解决这个问题。在高频处，单独一个旁路电容可能会有自谐振，因此需要再并一个旁路电容。\n有时，振荡来自附近源的干扰，需要加以屏蔽。低电平信号与高电平信号共享接地路径时，或者电路布线中的长导线，同样都可能会引起振荡。如果可能的话，试着用更短的导线连接电路，注意接地路径，并确保接地良好。\n","date":"2023-07-14T18:16:45+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-4%E6%AD%A3%E5%8F%8D%E9%A6%88%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/","title":"7.4 正反馈和稳定性"},{"content":"为了能够精确地控制增益和带宽，运算放大器通常用于带有负反馈的闭环配置中。本节你将看到反馈是如何影响运算放大器的增益和频率的。\n学完本节后，你应该掌握以下内容:\n理解运算放大器的闭环响应 确定闭环增益 解释负反馈对带宽的影响 解释增益-带宽积 回顾一下第6章讲过负反馈会减小中频增益，前面讨论过的三种结构的闭环增益表达式如下。对同相放大器， $$ A_{cl(NI)}=\\frac{R_f}{R_i}+1 $$ 对电压跟随器， $$ A_{cl(VF)}\\approx 1 $$ 对反相放大器， $$ A_{cl(I)}\\approx -\\frac{R_f}{R_i} $$\n7.3.1 负反馈对带宽的影响 我们已经学习了负反馈是如何影响增益的，现在将学习负反馈如何影响放大器的带宽。一个闭环运算放大器的截止频率为 $$ f_{c(cl)}=f_{c(ol)}(1+BA_{ol(mid)})~~~(7-4) $$ 从表达式可以看出，由于因子 $1+BA_{ol(mid)}$，闭环截止频率 $f_{c(cl)}$ 要大于开环截止频率$f_{c(ol)}$。B 是反馈衰减因子，等于 $R_i/(R_i+R_f)$。式(7-4) 的详细推导过程见附录。\n因为 $f_{c(cl)}$ 等于闭环放大器的带宽，所以带宽同样随着相同的倍数增加。 $$ BW_{cl}=BW_{ol}(1+BA_{ol(mid)})~~~(7-5) $$\n$$ 图7-8~~~闭环增益和开环增益的比较 $$ 图7-8用图形方式说明了补偿运算放大器闭环响应的概念。当负反馈减小运算放大器的开环增益时，带宽会增加。在两个增益曲线交叉点上方的增益，闭环增益与开环增益是彼此独立的。对闭环响应，交叉点处的频率是截止频率 $f_{c(cl)}$。注意，超过闭环截止频率后，闭环增益和开环增益具有相同的下降率。\n7.3.2 增益-带宽积 由于增益和带宽的乘积是常量，闭环增益的增加会引起带宽的下降，反之亦然。只要下降率是固定的 一20dB/十倍频程，这就成立。如果 $A_{cl}$ 表示任意闭环配置中的增益， $f_{c(cl)}$ 表示闭环截止频率(等于带宽)，于是 $$ A_{cl}f_{c(cl)}=A_{ol}f_{c(ol)} $$ 增益-带宽积始终等于运算放大器开环增益为 1 时的频率(单位增益带宽)。 $$ A_{cl}f_{c(cl)}=单位-增益带宽~~~(7-6) $$\n","date":"2023-07-14T18:16:34+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-3%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E9%97%AD%E7%8E%AF%E5%93%8D%E5%BA%94/","title":"7.3 运算放大器闭环响应"},{"content":"本节学习开环频率响应和开环相位响应，开环响应的运算放大器没有外部反馈。频率响应表明电压增益是如何随频率而变化的，相位响应表明输人信号和输出信号之间的相移是如何随频率而变化。与晶体管的β参数类似，同一型号的各个器件之间开环增益的值差别很大。\n学完本节后，你应该掌握以下内容:\n理解运算放大器的开环响应 讨论内部电路级联数如何影响整体响应 讨论截止频率和下降率 确定总的相位响应 7.2.1 频率响应 在7.1节中，大于截止频率时，假设运算放大器的下降率是常量，即 一20dB/十倍频程。对大多数运算放大器来说，这是成立的。从$f_c$ 到单位增益，下降率为一20dB/十倍频程的运算放大器称为补偿运算放大器(compensated op-amp)。一个补偿运算放大器有一个 RC 网络，用来确定它的频率特性。因此，补偿运算放大器的下降率与基本 RC 网络相同。\n对一些运算放大器电路，情况就更为复杂了。频率响应可能由内部许多级的电路决定，每级电路都具有自己的截止频率。因此，总的响应受到多个级联电路影响，它是各个级联电路响应的合成。具有多个截止频率的运算放大器称为非补偿运算放大器。\n非补偿运算放大器需要特别注意反馈网络以避免振荡。例如，图7-7a所示的一个三级运算放大器，每级的频率响应如图7-7b所示。我们都知道，dB 增益是相加的，于是运算放大器总的频率响应如图7-7c所示。因为总的下降率是相加的，所以每到一个截止频率总下降率就增加 一20dB/十倍频程(一6dB/八倍频程)。\n7.2.2 相移响应 在多级放大电路中，每级电路对总的相移都会有贡献。正如你看到的一样，每个 RC 滞后网络产生的相移最高可达 一90°。 因为一个运算放大器的每级电路包含一个 RC 滞后网络，所以例如一个三级运算放大器的相移滞后最大可达 一270°。同样地，当频率小于截止频率时，每级电路的相移滞后小于 一45°。当频率等于截止频率时，每级电路的相移滞后等于 一45°。当频率大于截止频率时，每级电路的相移滞后大于 一45°。将运算放大器每级电路的相移滞后加起来就可得到总的相移滞后，一个三级运算放大器的相移滞后如下: $$ φ_{tot}=-arctan(\\frac{f}{f_{c1}})-arctan(\\frac{f}{f_{c2}})-arctan(\\frac{f}{f_{c3}}) $$\n","date":"2023-07-14T18:16:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-2%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%BC%80%E7%8E%AF%E5%93%8D%E5%BA%94/","title":"7.2 运算放大器开环响应"},{"content":"本章学习运算放大器的频率响应、带宽、相移和其他一些与频率相关的参数。进一步研究负反馈的作用，了解稳定性的要求和如何补偿运算放大电路以确保稳定工作。\n第6章学习了如何确定基本配置的运算放大器的闭环电压增益，以及开环电压增益和闭环电压增益之间的区别。因为这两种不同类型的电压增益很重要，所以本节将它们的定义再次列出。\n学完本节后，你应该掌握以下内容:\n讨论运算放大器响应的基本领域 解释开环增益 解释闭环增益 讨论增益的频率依赖性 解释开环带宽 解释单位增益带宽 确定相移 7.1.1 开环增益 $$ a)开环~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)闭环 $$\n$$ 图7-1~~~开环和闭环运算放大器的配置 $$\n运算放大器的开环增益($A_{ol}$)是器件内部的电压增益，等于输出电压和输人电压的比,如图7-1a所示。注意，因为图7-1中没有外部元件，所以开环增益完全由内部设计决定。不同运算放大器的开环电压增益变化非常大。表6-1列出了一些有代表性的运算放大器的开环增益。数据手册中的开环增益通常是指大信号电压增益。\n7.1.2 闭环增益 运算放大器的闭环增益($A_{cl}$)是运算放大器具有外部反馈时的电压增益。放大器配置由运算放大器和外部负反馈网络组成，外部负反馈网络把输出端连接到反相输人端(一)。闭环增益由外部元件值决定，反相放大器的配置如图7-1b所示。闭环增益可以由外部元件值精确控制。\n可编程增益放大器 可编程增益放大器(programmable gain amplifier, PGA)是一种可通过数字输人选择增益的运算放大器。可编程增益放大器常用于数据采集系统，在数据采集系统中，有各种不同信号电平的输入。典型地，一个给定的信道是由来自计算机或控制器的数字信号选定的，并且 PGA 将会有 2 ~ 10 个甚至更多的输人。根据 PGA 的型号和它的配置方式，每个信道可以将它的增益设置成能使其传感器输人得到优化，或者可以通过数字化编程来选择预定的增益。例如，PGA116 具有 10 个模拟输人，每个输人可以有 8 个任意选定的二进制增益(1~128)。PGA116 和类似型号 PGA117 有一个内置的多路复用器(通道选择电路)和其他功能，包括内部校准能力。\n7.1.3 增益的频率依赖性 第 6 章中所有的增益表达式适用于中频增益，并且认为是与频率无关的。运算放大器的中频开环增益可以从 0 频(dc，直流)延伸到截止频率，在截止频率处的增益比中频增益小 3dB。这里的区别是运算放大器是直流放大器(在电路各级之间没有耦合电容)，因此没有低频端的截止频率。这就意味着中频增益向下延伸至 0 频(dc)，直流电压也可以与中频信号一样得以放大。\n$$ 图7-2~~~一个典型运算放大器的开环电压增益与频率的理想曲线，频率标尺是对数 $$\n图7-2 是一个运算放大器的开环响应曲线(伯德图)。大多数运算放大器的数据手册给出了这种类型的曲线或者规定了中频开环增益。注意，这个曲线每十倍频程减小 20dB(每八倍频程减小 6dB)。中频增益是20 0000，即 106dB，截止频率约为 10Hz。\n7.1.4 3dB开环带宽 交流放大器的带宽是指增益比中频增益小 3dB 时两点之间的频率范围。一般地，带宽等于上限频率($f_{cu}$)减去下限频率($f_{cl}$)。 $$ BW=f_{cu}-f_{cl} $$ 因为运算放大器的 $f_{cl}$ 是0，所以带宽就简单地等于，上限频率。 $$ BW=f_{cu}~~~(7-1) $$\n从现在开始，将 $f_{cu}$ 简单地记为 $f_c$，用下标符号 $ol$ 和 $cl$ 分别标记开环和闭环。例如，$f_{c(ol)}$ 是开环上限频率，$f_{c(cl)}$ 是闭环上限频率。\n7.1.5 单位增益带宽 注意，在图7-2中增益稳步下降到等于 1(0dB)的点。在单位增益处的频率值就是单位增益带宽。\n7.1.6 增益频率分析 一个运算放大器中的 RC 滞后(低通)网络负责使增益随频率的增加而下降。根据基本电路理论，如图7-3所示的 RC 滞后网络的衰减可表示为 $$ \\frac{V_{out}}{V_{in}}=\\frac{X_C}{\\sqrt[]{R^2+X^2_C}} $$ 等号右边的分子和分母同时除以 $X_C$, $$ \\frac{V_{out}}{V_{in}}=\\frac{1}{\\sqrt[]{1+R^2/X^2_C}} $$ RC网络的截止频率为 $$ f_c=\\frac{1}{2\\pi RC} $$ 等式两边同时除以 $f$ 得到 $$ \\frac{f_c}{f}=\\frac{1}{2\\pi RCf}=\\frac{1}{(2\\pi fC)R} $$ 因为 $X_C=\\frac{1}{2πfC}$，所以上面的公式可以写成 $$ \\frac{f_c}{f}=\\frac{X_C}{R} $$ 把这个公式代人第二个公式就可以得到 RC 滞后网络的衰减公式: $$ \\frac{V_{out}}{V_{in}}=\\frac{1}{\\sqrt[]{1+f^2/f^2_c}} $$ 如果将一个运算放大器表示成一个具有增益 $A_{ol(mid)}$ 的电压增益元件和一个 RC 滞后网络，如图7-4所示，那么运算放大器的总开环增益是中频开环增益 $A_{ol(mid)}$ 和 $RC$ 网络衰减的乘积。\n$$ 图7-4~~~ 运算放大器 $$ $$ A_{ol}=\\frac{A_{ol(mid)}}{\\sqrt[]{1+f^2/f^2_c}}~~~(7-2) $$ 从式(7-2)可以看出，开环增益随着信号频率 $f$ 的增加而减小，当信号频率 $f$ 远远小于截止频率 $f_c$ 时，开环增益等于中频增益。由于 $f_c$ 是运算放大器开环响应的一部分，因此将它记为 $f_{c(ol)}$。\n下面的例题说明了当频率增加超出 $f_{c(ol)}$ 后开环增益减小的情况。\n7.1.7 相移 $$ 图7-5 ~~~输出电压滞后输人电压 $$\n我们都知道，RC 网络会引起输人端到输出端的传输延迟，因此输人信号和输出信号之间会产生相移。例如在一个运算放大电路中的 RC 滞后网络会引起输出信号电压滞后于输人信号，如图7-5所示。根据基本交流电路理论，相移 $φ$ 为 $$ φ=-arctan(\\frac{R}{X_C}) $$ 因为$\\frac{R}{X_C}=\\frac{f}{f_c}$, 所以 $$ φ=-arctan(\\frac{f}{f_c})~~~(7-3) $$ 式中，负号表明输出滞后于输人。上式表明相移随着频率而增加，当 $f$ 远远大于 $f_c$ 时，相移接近 $一90°$。\n","date":"2023-07-14T18:16:09+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"7.1 基本概念"},{"content":"本节将会介绍负反馈连接如何影响运放的输入与输出阻抗。我们将会对反相放大器和同相放大器都进行讨论。\n学完本节后，你应该掌握以下内容:\n描述三种运放组态的阻抗 求同相放大器的输入和输出阻抗 求电压跟随器的输入和输出阻抗 求反相放大器的输入和输出阻抗 6.6.1 同相放大器的输入阻抗 已经知道: 负反馈使得反馈电压 $V_f$ 几乎等于输入电压 $V_{in}$. 输入电压与反馈电压的差值 $V_{diff}$ 接近于零，在理想情况下可假设它为零。此假设表明运放的输入信号电流也为零。因为输人阻抗为输入电压与输入电流的比值，所以同相放大器的输入阻抗为: $$ Z_{in}=\\frac{V_{in}}{I_{in}}\\approx \\frac{V_{in}}{0} =无穷大(oo) $$ 在很多实际电路中，此假设有利于获得对运放工作原理的基本认识。更准确的分析需要考虑输入信号电流不为零的事实。\n$$ 图6-27~~~同相放大器 $$ 利用图6-27，计算此运放电路的精确输入阻抗。在此分析中，假设两个输人端之间存在一个小的差分电压 $V_{diff}$，如图6-27所示。这意味着你不能假设运放的输入阻抗为无穷大，或者输入电流为零。输入电压可表示为 $$ V_{in}=V_{diff}+V_f $$ 用 $BV_{out}$代替$V_f$，有 $$ V_{in}=V_{diff}+BV_{out} $$ 因为 $V_{out} ≈ V_{ol}V_{diff}$($A_{ol}$为运放的开环增益)，所以 $$ V_{in}=V_{diff}+V_{ol}BV_{diff}=(1+A_{ol}B)V_{diff} $$ 因为 $V_{diff}=I_{in}Z_{in}$, 所以 $$ V_{in}=(1+A_{ol}B)I_{in}Z_{in} $$ 式中，$Z_{in}$是运放的开环输人阻抗(无反馈连接时)。 $$ \\frac{V_{in}}{I_{in}}=(1+A_{ol}B)Z_{in} $$\n$V_{in}/I_{in}$为此闭环同相放大器的总输入阻抗。\n$$ Z_{in(NI)}=(1+A_{ol}B)Z_{in}~~~(6-9) $$\n此式表明: 带有负反馈的这个运放电路的输人阻抗远大于运放自身的内部输人阻抗(无反馈)。\n6.6.2 同相放大器的输出阻抗 除输人阻抗之外，负反馈也能改进运放的输出阻抗。无反馈放大器的输出阻抗非常小。加人反馈后，输出阻抗会变得更小。在很多应用中，假设带反馈的输出阻抗为零，这可以非常好地满足精度要求，即 $$ Z_{out(NI)}\\approx 0 $$ $$ 图6-28~~~带反馈的同相放大器 $$\n利用图6-28，可以精确分析带反馈的输出阻抗。对输出电路应用基尔霍夫定律，\n$$ V_{out}=V_{ol}V_{diff}-Z_{out}I_{out} $$\n差分输人电压为 $V_{in}-V_f$; 因此，假设$V_{ol}V_{diff}\u0026raquo;Z_{out}I_{out}$，输出电压可表示为 $$ A_{out}\\approx A_{ol}(V_{in}-V_f) $$ 用 $BV_{out}$ 代替 $V_f$, $$ V_{out}\\approx A_{ol}(V_{in}-BV_{out}) $$ 请记住，B为负反馈网络的衰减系数。展开，分解，整理后可得: $$ A_{ol}V_{in}\\approx V_{out}+A_{ol}BV_{out}=(1+A_{ol}B)V_{out} $$ 因为同相放大器的输出阻抗为 $Z_{out(NI)} =V_{out}/I_{out}$,可以用 $I_{out}Z_{out(NI)}$ 代替 $V_{out}$，所以， $$ A_{ol}V_{in}=(1+A_{ol}B)I_{out}Z_{out(NI)} $$ 将上式两端同时除以 $I_{out}$，可得 $$ \\frac{A_{ol}V_{in}}{I_{out}}=(1+A_{ol}B)Z_{out(NI)} $$ 上式左端为运放的内部输出阻抗($Z_{out}$)，因为无反馈时，$A_{ol}V_{in}=V_{out}$， 所以， $$ Z_{out}=(1+A_{ol}B)Z_{out(NI)} $$ 即 $$ Z_{out(NI)}=\\frac{Z_{out}}{1+A_{ol}B}~~~(6-10) $$ 此式表明，这个带有负反馈的运放电路的输出阻抗远小于运放自身内部输出阻抗(无反馈),因为除以系数 $1+A_{ol}B$.\n6.6.3 电压跟随器阻抗 因为电压跟随器是特殊的同相放大器，所以阻抗公式相同，其中B=1。 $$ Z_{in_{(VF)}}=(1+A_{ol})Z_{in}~~~(6-11) $$\n$$ Z_{out(VF)}=\\frac{Z_{out}}{1+A_{ol}}~~~(6-12) $$\n可以看到: 在给定 $A_{ol}$ 与 $Z_{in}$ 的情况下，与带有分压反馈网络的同相放大器相比，电压跟随器的输入阻抗更大。同样，输出阻抗会减小很多，因为对同相放大器而言，B 通常比 1 小很多。\n6.6.4 反相放大器的阻抗 $$ 图6-30 ~~~反相放大器 $$ 利用图6-30，可以计算反相放大器的输入与输出阻抗。输人信号和负反馈都通过电阻加到反相端。\n输入阻抗 反相放大 器的输人阻抗为 $$ Z_{in(I)}\\approx R_i~~~(6-13) $$ $$ 图6-31~~~反相放大器 $$ 这是因为运放的反相输人端为虚地(0V),输人信号源只看到 $R_i$ 连接到地，如图6-31所示。\n输出阻抗 与同相放大器类似， 反相放大器的输出阻抗也因负反馈而减小。实际上，其表达式也与同相放大器相同。 $$ Z_{out(I)}\\approx \\frac{Z_{out}}{1+A_{ol}B}~~~(6-14) $$ 同相放大器与反相放大器的输出阻抗都非常低;实际上，几乎为零。因为输出阻抗接近于零，所以连接到运放输出端的负载阻抗可以在很大范围内变化，且不会改变输出电压。\n6.6.5 噪声 在电子学中，噪声是指电信号中不期望的随机波动。我们将介绍运放噪声规范和如何计算运放的信噪比。虽然来自外部源的干扰也被视为噪声，但运放噪声规范只考虑运放内部产生的噪声。噪声有两种基本形式。在低频时，噪声与频率成反比; 这称为 1/f 噪声或“粉红噪声”。超过临界噪声频率(有时称为 1/f 转角频率)后，噪声在频谱图上为水平线; 这称为“白噪声”。此临界噪声频率为运放性能指标之一越低越好。\n噪声的功率分布以瓦特每赫兹来衡量(W/Hz)。功率与电压平方成正比，因此噪声电压密度可以通过对噪声功率密度求平方根得到，得到的单位为伏特每平方根赫兹( $V/\\sqrt[]{Hz}$ )。对运放而言，在特定频率下，单位通常为 $nV/\\sqrt[]{Hz}$。但是，即使是极低噪声放大器，低于 10Hz 时，由于粉红噪声的贡献，噪声电压密度也可能达到 $μV/\\sqrt[]{Hz}$ 的噪声单位。不同运放的额定白噪声电压密度的值可能在 $1nV/\\sqrt[]{Hz} ~ 20nV/\\sqrt[]{Hz}$ 之间，甚至更高。双极管运放的电压噪声小于 JFET 运放。制造低噪声 JFET 运放是可能的，但是要以增大输人电容为代价，因此限制了带宽。\n$$ 图6-33~~~电压噪声与频率的函数关系 $$ 某低噪声运放的电压噪声图如图6-33所示。在 1kHz, 运放的输入电压噪声密度为 $1.1nV/\\sqrt[]{Hz}$，这是非常低的值。从图6-33中可以看出，在低频段，噪声密度因 1/f 噪声贡献而增大。\n6.6.6 求信噪比 $$ 图6-34~~~运放 $$ 为简化运算，我们只求来自运放的噪声分布。参考图6-34 所示电路。假设运放工作在20Hz到20kHz的音频带，超过 1/f 转角频率。假设额定白噪声为 $2.9nV/\\sqrt[]{Hz}$, 输人\n第一步是求解 $\\sqrt[]{Hz}$ 部分: $$ \\sqrt[]{20000-20}=141.4 $$\n将此值与噪声值 $\\frac{2.9nV}{\\sqrt[]{Hz}}$ 相乘得到噪声输人: $$ \\frac{2.9nV}{\\sqrt[]{Hz}}\\times 141.4\\sqrt[]{Hz}=410nV $$ 将噪声输入与闭环电压增益相乘得到噪声输出为 $$ 410nV\\times (-200)=-82\\mu V $$ 求得输出信号为: $12.5mV \\times (-200)=-2.5V$。 最后得到信噪比(dB)为 $$ 20log(-2.5V\\div (-82\\mu V))=89.7dB $$ 需要注意的是，上述计算只考虑了运放本身。来自电路电阻的噪声也会叠加到运放噪声。来自电阻的噪声称为热噪声或约翰逊(Johnson)噪声。值较小的电阻可以减小总噪声，但会增大电路电流，降低系统效率一这其中需要权衡。热噪声是白噪声，与阻值、温度和带宽成正比。热噪声为 $$ E_{th}=\\sqrt[]{4kTRB} $$ 式子中,\n$E_{th}=$ 热噪声，单位为$V_{rms}$(电压有效值); k = 值为 $1.38\\times 10^{-23}$ 的常量; T=温度，单位为K; R=电阻，单位为Ω; B=带宽，单位为Hz。\n当噪声源不止一个时，总噪声($N_T$)是所有噪声源的几何和，公式为 $$ N_T=\\sqrt[]{N^2_1+N^2_2+\u0026hellip;+N^2_n} $$ 实际运放电路的完整噪声分析非常复杂，这已经超出了本书的讨论范围。\n","date":"2023-07-14T18:15:40+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-6%E8%BF%90%E6%94%BE%E9%98%BB%E6%8A%97%E5%92%8C%E5%99%AA%E5%A3%B0/","title":"6.6 运放阻抗和噪声"},{"content":"本节将讨论三种利用负反馈稳定增益并增强频率响应的运放连接方式。如前所述，运放的极高开环增益会造成不稳定的情况，因为输入端的小噪声信号能被放大到使运放超出线性区工作。也可能发生不希望的振荡。此外，不同运放器件的开环增益参数可能会相差很大。负反馈将输出的一部分以与输入信号反相的方式返回输入端，能有效减小增益。闭环增益通常远小于开环增益，并与它无关。 学完本节后，你应该掌握以下内容:\n分析三种运放电路组态\n认识同相放大器组态\n确定同相放大器的电压增益\n认识电压跟随器\n认识反相放大器组态\n确定反相放大器的电压增益\n6.5.1 闭环电压增益 $A_{cl}$ 闭环电压增益是带有负反馈的运放的电压增益。放大器电路包括运放和一个外部反馈网络，它将输出与反相输人端相连。那么闭环电压增益由反馈网络的元器件值决定，并能由它们精确控制。\n6.5.2 同相放大器 图6-20所示是运放的一种闭环连接，称为同相放大器。输入信号加到同相(＋)输入端。输出的一部分通过反馈网络加到反相(一)输人端。这构成了负反馈。反馈系数B是返回反相输入端的输出电压的比例，它决定了放大器的增益，正如你将要看到的。反馈电压 $V_f$，可以写为\n$$ V_f = BV_{out} $$\n$$ 图6-20~~~同相放大器 $$\n运放输入端之间的差分电压 $V_{diff}$ 如图6-21所示，可表示成 $$ V_{diff} = V_{in} - V_f $$\n$$ 图6-21~~~差分输入V_{in}-V_f $$\n因为负反馈和高开环增益 $A_{ol}$,输入差分电压非常小。所以，有 $$ V_{in} ≈ V_f $$\n代入可得： $$ V_{in} ≈ BV_{out} $$ 重整理得： $$ \\frac{V_{out}}{V_{in}} ≈ \\frac{1}{B} $$ 反馈系数由分压网络中的 $R_i$ 与 $R_f$ 决定。对反馈网络使用分压定律，可以从输出电压 $V_{out}$ 中计算得到返回到输入端的部分电压。 $$ V_{in} ≈ BV_{out} ≈ (\\frac{R_i}{R_i + R_f})V_{out} $$ 重整理得： $$ \\frac{V_{out}}{V_{in}} = (\\frac{R_i + R_f}{R_i}) $$ 可表示成： $$ A_{cl(NI)} = \\frac{R_f}{R_i} + 1~~~(式子6-6) $$\n上式子表明同相(NI)放大器的闭环电压增益 $A_{cl(NI)}$ 与运放的开环增益无关，但可通过选择 $R_i$ 与 $R_f$ 的值来设置。此公式基于一个假设，即开环增益与反馈电阻比值相比非常大，使得输人差分电压 $V_{diff}$ 很小。在几乎所有的实际电路中，这都是极好的假设。\n在极少情况下需要更精确的方程，输出电压可表示为 $$ V_{out} = V_{in}(\\frac{A_{cl}}{1 + A_{cl}B}) $$\n下式给出了闭环增益的精确值: $$ A_{cl(NI)} = \\frac{V_{out}}{V_{in}} = (\\frac{A_{cl}}{1 + A_{cl}B}) $$\n电压跟随器 电压跟随器电路是一种特殊的同相放大器，其中输出电压直接连接到反相输人端，如图6-23所示。可以看到，直接反馈连接的电压增益接近于 1。之前已经推导出，同相放大器的闭环电压增益为 1/B 。因为 B=1，所以电压跟随器的闭环增益为: $$ A_{cl(VF)} = 1~~~(式子6-7) $$\n电压跟随器最重要的特性是输入阻抗非常高，输出阻抗非常低。这样的特性使得它是一个近乎理想的缓冲放大器，能连接高阻抗源与低阻抗负载。这将在6.6节进一步讨论。\n$$ 图6-23~~~运放电压跟随器 $$\n6.5.3 反向放大器 $$ 图6-24~~~反相放大器 $$ 图6-24所示为一个运放连接成的电压增益可控的反相放大器。输入信号通过串联输入电阻($R_i$)加到反相输人端。同时，输出通过 $R_f$ 反馈回到反相输入端。同相输人端接地。\n此时，之前学习的理想运放参数可用于简化电路分析。特别是无穷大输入阻抗的概念很重要。无穷大输入阻抗说明反相输入端没有电流输出。如果没有电流流过输入阻抗，那么同相与反相输入端之间就没有压降。这意味着反相(一)输入端的电压为 0，因为同相(＋)输人端接地。反相输人端的零电压称为虚地。此情况如图6-25a所示。 $$ a)~~~虚地 $$\n由于反相输入端(-)没有电流，因此流过$R_i$与$R_f$的电流相等，如图6-25b所示。 $$ b) ~~~I_{in}=I_f,并且反相(-)输入端电流为0 $$\n$R_i$ 两端的电压等于 $V_{in}$，因为电阻的另一端为虚地。因此， $$ I_{in} = \\frac{V_{in}}{R_i} $$ 同时，因为虚地，$R_f$两端电压等于 $-V_{out}$，因而, $$ I_f = \\frac{-V_{out}}{R_f} $$ 因为 $I_f = I_{in}$,所以 $$ \\frac{-V_{out}}{R_f} = \\frac{V_{in}}{R_i} $$ 整理的 $$ \\frac{V_{out}}{V_{in}} = -\\frac{V_f}{R_i} $$ $V_{out}/V_{in}$ 就是反相放大器的总增益。\n$$ A_{cl(I)} = -\\frac{R_f}{R_i} $$\n$$ (式子6-8) $$ 式(6-8)表明反相放大器的闭环电压增益 $A_{cl}$ 是反馈电阻 $R_f$ 与输人电阻 $R_i$ 的比值。闭环增益与运放的内部开环增益无关。因此，负反馈稳定了电压增益。负号表明反相。\n","date":"2023-07-14T18:15:27+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-5%E8%B4%9F%E5%8F%8D%E9%A6%88%E8%BF%90%E6%94%BE%E7%BB%84%E6%80%81/","title":"6.5 负反馈运放组态"},{"content":"负反馈是电子学尤其是运放应用中最有用的概念之一。负反馈是将输出电压中的一部分以与输人信号反相(或者减去)的方式返回到输入端的过程。\n负反馈如图6-18所示。反相(一)输入使得反馈信号与输入信号有180°的相位差。运放具有极高的增益，将加到同相与反相输入端的信号的差值放大。所有运放只需要这两个信号之间有非常微小的区别，就能产生所需的输出。当使用负反馈时，同相输入与反相输入端几乎相同。这一概念可以帮助你理解运放电路中会产生什么样的信号。 现在来讨论负反馈是如何工作的，以及理解为何当使用负反馈时，为什么同相和反相输人端的信号几乎相同。假设在同相输入端加入1.0V的输入信号，运放的开环增益为100 000。运放对同相输入信号做出响应，使输出趋于饱和。同时，输出的一部分通过反馈通路返回到反相输人端。但是，如果反馈信号达到1.0V，运放将无信号可放大!因此，`反馈信号只是试图(但永远不会成功)与输入信号匹配``,增益由反馈的量所控制。当你对带有负反馈的运放电路进行故障检测时，请记住虽然这两个信号在示波器上看起来是相同的，但其实还是有细微区别。\n现在假设由于某些原因使运放内部增益减小。这会使得输出信号减小一些，通过反馈通路返回到反相输人端的信号也减小。这意味着两个信号之间的差值变大，因此输出增大，补偿了之前的增益减小。输出端的信号变化很小，几乎测量不出来。这说明运放不论发生何种变化，都会很快通过负反馈得到补偿，从而产生稳定的、可预测的输出。\n6.4.1 为什么使用负反馈 如你所见，一个典型运放的内部开环增益非常高(通常大于100 000)。因此，两个输人电压之间的极小差别就能使运放进入饱和输出状态。实际上，甚至是输入失调电压也能使运放饱和。例如，假设 $V_{in}$=1mV，$A_{ol}$=100 000，那么\n$$ V_{in}A_{ol} = (1 mV) \\times 100~000 = 100V $$\n由于运放的输出不可能达到 100V，因此其进入饱和状态，输出被限制在它的最大输出电平，图6-19给出了输入电压分别为正(+)负(-) lmV 的情况。\n$$ 图6-19~~~~没有负反馈时，两个输人电压之间的极小差别即可使运放达到输出极限，变成非线性 $$\n没有负反馈时，两个输人电压之间的极小差别即可使运放达到输出极限，变成非线性\n以这种方式工作的运放用途非常有限，通常只限于比较器应用(将在第8章中学习)。利用负反馈，总闭环电压增益($A_{cl}$) 可以减小并且可以控制，使得运放能作为线性放大器工作。除了提供可控、稳定的电压增益之外，负反馈也能实现对输人和输出阻抗、运放带宽的控制。表6-2总结了负反馈对运放性能的一般影响。 $$ 表6-2总结了负反馈对运放性能的一般影响 $$\n电压增益 输入阻抗 输出阻抗 带宽 无负反馈 对线性放大器而言，$A_{ol}$太高 非常高(参见表6-1) 非常低 非常窄(因为增益太高) 有负反馈 通过负反馈网络使 $A_{cl}$达到期望值 利用不同种类的电路，能增加或减小到期望值 能减小到期望值 明显变宽 ","date":"2023-07-14T18:15:17+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-4%E8%B4%9F%E5%8F%8D%E9%A6%88/","title":"6.4 负反馈"},{"content":"6.3.1输入失调电压 理想运放具有零输入零输出的特性。但是，在实际运放中，当没有加上差分输人电压时，输出端也会产生一个小直流电压 $V_{OUT(error)}$。其主要产生原因为运放差分输人级的基极-发射极电压存在轻微失配，如图6-11a 所示。 差分输入级的输出电压可表示为 $$ V_{OUT(error)}= I_{C2}R_C-I_{C1}R_C $$ $Q_1$ 与 $Q_2$ 基极-发射极电压的微小差别会导致集电极电流上的微小差别。这使得 $V_{OS}$ 不为零，这是一个误差电压。（集电极电阻相等。)\n在运放数据手册中，输入失调电压($V_{OS}$)是两个输人端之间所需的差分直流电压，它使得差分输出为 0V。$V_{OS}$ 如图6-11b所示。输入失调电压的典型值为 2mV 范围之内或更小。理想情况下为 0V。 b)输入失调电压为能消除输出误差电压（使得 $V_{OUT}=0$）所需的输入端的电压差值\n6.3.2输入失调电压温漂 输入失调电压温漂是与 $V_{OS}$ 相关的参数，表示温度每变化一度，对应输入失调电压的变化值。其典型值为 5～50μV/℃。通常，运放的输入失调电压越高，温漂越大。\n6.3.3输入偏置电流 如你所见，双极型差分放大器的输人端为晶体管的基极，因此输入电流为基极电流。\n输入偏置电流为放大器能在第一级正常工作时，输入端所需的直流电流。根据定义，输入偏置电流为两个输入电流的平均值，并计算如下: $$ I_{BIAS} = \\frac{I_1+I_2}{2}$$ 输入偏置电流的概念如图6-12所示。 6.3.4 输入阻抗 定义运放输入阻抗的两种基本方式为差分模式与共模模式。差分输入阻抗为反相输入端和同相输入端之间的总电阻，如图6-13a所示。在给定差分输人电压变化下，确定对应的偏置电流变化，可得到差分输人阻抗。共模输入阻抗为每个输入端与地之间的阻抗。其可通过在给定共模输入电压变化下，确定对应的偏置电流变化来得到，如图6-13b所示。 6.3.5输入失调电流 理想情况下，两个输入偏置电流相等，差值为零。但是，在实际运放中，偏置电流完全相等。\n输入失调电流 $I_{OS}$ 是输入偏置电流的差，用绝对值表示。 $$ I_{OS}=| I_1-I_2 | $$ 失调电流的实际幅度通常至少比偏置电流小一个数量级(十倍)。多数情况下，失调电流可以忽略。但是，对于高增益、高输入阻抗放大器而言，$I_{OS}$ 应尽可能小，因为即使电流差别很小，通过大输入电阻，也会产生较大的失调电压，如图6-14所示。 输入失调电流导致的失调电压为 $$ V_{OS}=|I_1-I_2| R_{in} = I_{OS}R_{in} $$ Ios导致的误差被运放增益Av放大，因此输出为 $$ V_{OUT(error)}= A_vI_{OS}R_{in} $$ 失调电流会随温度变化，进而影响误差电压。失调电流的温度系数通常在0.5nA/℃范围之内\n6.3.6 输出阻抗 输出阻抗为从运放输出端看进去的电阻，如图6-15所示。 6.3.7 共模输入电压范围 所有运放都有正常工作的电压范围的限制。共模输入电压范围是在不会造成削波失真或其他输出失真的情况下，能够加入到两个输人端的输入电压范围。计多运放在直流电压为$\\pm$15V的情况下，共模输人电压范围不超过$\\pm$10V。但也有运放的输出能达到与电源电压一样大(这称为轨到轨(rail-to-rail))。\n6.3.8开环电压增益 运放的开环电压增益 $A_{ol}$ 指的是器件的内部电压增益，也就是当没有外部元件时，运放输出电压与输入电压的比值。开环电压增益完全由内部设计决定。开环电压增益通常能超过 200 000，但不是能严格控制的参数。数据手册中通常称开环电压增益为大信号电压增益。\n6.3.9运放的共模抑制比 共模抑制比(CMRR)在之前与差分放大器一起介绍了。和差放情况类似，对运放而言，CMRR 是衡量运放抑制共模信号能力的参数。若CMRR 值为无穷大，意味着当个两输入端加上相同信号(共模)时，输出为零。\n在实际中，CMRR 不可能达到无穷大，但是性能较好的运放，具有很高的 CMRR 值。如前所述，共模信号是不想要的干扰电压，例如 60Hz 供电线纹波，以及辐射能量造成的噪声电压等。高 CMRR 使得运放在输出端基本消除了这些干扰信号。\n运放 CMRR 的定义为开环电压增益($A_{ol}$)除以共模增益。 $$ CMRR=\\frac{A_{ol}}{A_{cm}}~~~(6-3) $$\n通常用分贝表示为:\n$$ CMRR\u0026rsquo;=20log(\\frac{A_{ol}}{A_{cm}})~~~(6-4) $$\n6.3.10 转换速率 响应阶跃输人电压时，输出电压的最大变化率称为运放的转换速率。转换速率取决于运放放大级的高频响应。\n测量转换速率时的运放连接方式如图6-16a所示。这一连接方式为单位增益、同相组态，后面会讨论。它给出了最坏情况(最慢)下的转换速率。已经知道阶跃电压的上升沿包含它的高频分量，放大器的上限截止频率影响其对阶跃输入的响应。上限截止频率越低，阶跃输入对应的输出信号斜坡越平缓。 $$ a)测试电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)阶跃输入电压与对应的输出电压 $$\n$$ 图6-16~~~~转换速率的测量 $$\n将脉冲施加到输人端，如图6-16b所示，其中也给出了理想输出电压。输入脉冲宽度必须足以使其输出能从下限“转换”到上限，如图6-16b所示。可以看到，加上输入阶跃信号后，输出电压从下限 $-V_{max}$ 变化到上限 $＋V_{max}$，需要一定的时间间隔$△t$。转换速率表示为: $$ 转换速率=\\frac{△V_{out}}{△t}~~~(6-5) $$ 式中，$△V_{out}=＋V_{max}-(-V_{max})$。转换速率的单位是伏特每微秒($V/\\mu s$)。\n6.3.11 频率响应 对于组成运放的内部放大器级，其电压增益受到结电容的限制。虽然运放中使用的差分放大器与我们讨论的基本放大器有所区别，但原理相同。然而，运放没有内部耦合电容，因此低频响应可以到达直流(0Hz)。运放的频率特性将在下一章中讨论.\n6.3.13 其他特性 大多数运放有三个重要特性:短路保护，无门锁效应，输人失调调零。短路保护使得输出短路时，电路不会损坏。无门锁特性使得运放在特定输入条件下，输出不会保持一个状态不变(高或低电平)。输入失调调零通过外部电位器，使得零输入条件下输出电压精确为零。\n","date":"2023-07-14T17:41:00+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-3%E8%BF%90%E6%94%BE%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/","title":"6.3 运放数据手册中的参数"},{"content":"运放通常至少包含一个差分放大器级。因为差分放大器(差放)是运放的输人级，所以它是运放内部操作的基础。因此，有必要了解差分放大器。\n学完本节后，你应该掌握以下内容:\n讨论差分放大器及其工作原理 解释单端输入工作原理 解释差分输入工作原理 解释共模工作原理 定义共模抑制比 讨论差分放大器在运放中的使用 $$ a)电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)框图符号 $$\n$$ 图6-4~~~~基本的差分放大器 $$\n基本差分放大器(差放)的电路及其符号如图6-4所示。运放中的差放级提供了高电压增益和共模抑制(本节稍后给出定义)。\n6.2.1 基本工作原理 下列讨论与 图6-5 相关，包括差分放大器工作原理的基本直流分析。\n首先，当两个输人端都接地(0V)时，发射极电压为 $一0.7V$，如图6-5a 所示。假设晶体管 $Q_1$ 和 $Q_2$ 通过制造中的精密过程控制已达到一致匹配，这样当无输入信号时，两者的发射极直流电流也相等。因此， $$ I_{E1}= I_{E2} $$ 因为两个发射极电流在 $R_E$ 处汇合，所以 $$ I_{E1}= I_{E2}= \\frac{I_{R_E}}{2} $$ 式中， $$ I_{R_E}= \\frac{V_E-V_{EE}}{R_E} $$ 基于$I_C \\approx I_E$的近似，可以得到 $$ I_{C1}=I_{C2} \\approx \\frac{I_{R_E}}{2} $$ 由于两集电极电流和两集电极电阻相等(当输入电压为零时)，有 $$ V_{C1}=V_{C2}=V_{CC}-I_{C1}R_{C2} $$ 此情况如图6-5a所示。\n$$ 图6-5~~~~差分放大器的基本工作原理(地为0V)，其中给出了电流和电压的相对变化 $$ 其次，输人端 2 保持接地，向输入端 1 施加正偏置电压，如图6-5b所示。$Q_1$ 基极的正电压使 $I_{C1}$ 增大，并使发射极电压增加到 $$ V_E=V_B-0.7V $$ 这使得 $Q_2$ 的正向偏置($V_{BE}$)减小，因为 $Q_2$ 基极保持在0V(地)，这使得 $I_{C2}$ 减小，如图6-5b所示。整个结果是 $I_{C1}$ 增大使得 $V_{C1}$ 减小，$I_{C2}$ 减小使得 $V_{C2}$ 增大，如图6-5b所示。\n最后，输入端 1 保持接地，向输人端 2 施加正偏置电压，如图6-5c所示。$Q_2$ 基极的正电压使 $Q_2$ 更加导通，$I_{C2}$ 增大。此外，发射极电压增加，这使得 $Q_1$ 的正向偏置减小，因为 $Q_1$ 基极保持在0V，所以使得 $I_{C1}$ 减小。结果是，$I_{C2}$ 增大使得 $V_{C2}$ 减小，$I_{C1}$ 减小使得 $V_{C1}$ 增大，如图6-5c所示。\n6.2.2 信号工作模式 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$\n$$ 图6-6~~~差分放大器的单端输入工作原理 $$\n单端输入 在单端模式下，一个输入端接地，信号电压只加在另一输入端，如图6-6所示。当信号电压加到输人端 1 时，如图6-6a所示，输出端 1 上会产生一个反相放大的信号电压。此外，$Q_1$ 发射极也会出现一个同相信号电压。因为$Q_1$ 与$Q_2$ 的发射极是公共端﹐所以发射极信号成为$Q_2$ 。的输入，而$Q_2$ 为共基放大器。信号由$Q_2$ 放大，并在输出端 2 上产生同相输出。以上过程如图6-6a所示。\n当信号电压加到输入端 2，输人端 1 接地时，如图6-6b所示，输出端 2 会产生一个反相放大信号电压。在此情况下，$Q_1$ 为共基放大器，输出端 1 会产生同相放大信号。以上过程如图6-6b所示。\n$$ a)差分输入~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)V_{in1}单独作用下的输出 $$ $$ c)V_{in2}单独作用下的输出~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~d)差分输入下的总输出 $$\n$$ 图6-7~~~~差分放大器的差分输入工作原理 $$ 差分输入 在差分模式下，两个极性相反(反相)的信号加到两个输人端，如图6-7a所示。这种类型的工作模式也称作 双端输入 模式。如你所见，每个输入都会影响输出。\n图6-7b给出了输人端 1 作为单端输人、独立工作时的输出信号。图6-7c给出了输人端 2 作为单端输人、独立工作时的输出信号。注意，图6-7b与c中输出端 1 的信号极性相同。输出端 2 也是如此。通过将输出端 1 和输出端 2 的两个信号叠加，可得到差分工作模式的总输出，如图6-7d所示。\n共模输入 差分放大器最重要的工作模式之一为共模输入模式，此时施加到两个输端的信号电压的相位、频率和幅度均相同，如图6-8a所示。同样，通过考虑每个输人信号单独工作的情况，可以理解共模输入的基本工作原理。 $$ a)共模输入~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)V_{in1}单独作用下的输出 $$\n$$ c)V_{in2}单独作用下的输出~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~d)当加上共模信号 \\\\ 时输出抵消。输出信号幅度相等,相位相反，互相抵消，使得两个输出端口均为0V $$\n$$ 图6-8~~~~差分放大器的共模工作原理 $$ 图6-8b为只有输入信号 1 时的输出信号，图6-8c为只有输人信号 2 时的输出信号注意，输出端 1 的对应信号极性相反，输出端 2 的信号亦如此。当输入信号加到两个输人端时，输出叠加并互相抵消，使得输出电压为0，如图6-8d所示。\n这称为共模抑制。其重要性体现在不期望的信号同时出现在差分放大器的两个输人端的情况。共模抑制意味着不期望的信号不会出现在输出端，不会导致期望信号的失真。共模信号(噪声)通常由输人线上的辐射能量导致，来源有相邻线、60Hz电力线等。\n6.2.3 共模抑制比 有用信号只出现在一个输入端，或者以相反极性出现在两个输人端上。这些有用信号被放大并出现在输出端，如前所述。无用信号(噪声)以相同极性出现在两个输入端上，因差分放大器的作用，这些无用信号基本被抵消，不会出现在输出端。评价放大器抑制共模信号能力的指标，是一个称为共模抑制比(CMRR)的参数。\n理想情况下，差分放大器对期望信号(单端或差分)提供非常高的增益，对共模信号提供О增益。但是，实际差分放大器会有一个值很小的共模增益(通常远小于1)，而其差分电压增益却很高(通常为几千)。差分增益与共模增益的比值越高，差分放大器在共模信号抑制方面表现越好。这意味着衡量差分放大器抑制无用共模信号能力的一个好的度量，是差分增益 $A_{v(d)}$ 与共模增益 $A_{cm}$ 的比值。这一比值即为共模抑制比CMRR。\n$$ CMRR=\\frac{A_{v(d)}}{A_{cm}}~~~(6-1) $$\nCMRR 越高越好。CMRR 的值非常高意味着差分增益 $A_{v(d)}$ 很高，共模增益 $A_{cm}$ 很低。CMRR 通常以 dB 表示为\n$$ CMRR\u0026rsquo;=20log(\\frac{A_{v(d)}}{A_{cm}})~~~(6-2) $$ 例如，CMRR 值为 10 000 意味着期望输入信号(差分)放大倍数是无用噪声(共模)放大倍数的 10 000 倍。因此，如果差分输人信号与共模噪声的幅度相等，那么输出端的差分信号的幅度是噪声幅度的 10 000 倍。从而，噪声或干扰基本被消除。\n例6-2进一步说明了共模抑制的概念，以及差分放大器对一般信号的工作原理。\n6.2.4 运放的内部框图 $$ 图6-10~~~~运放的基本内部结构 $$ 一个典型的运放由三类放大电路组成: 差分放大器、电压放大器和推挽放大器，如图6-10所示。\n差分放大器是运放的输出级; 它有两个输人端，并能放大两个输人端之间的差值电压。电压放大器通常为 A 类放大器，提供额外的运放增益。有些运放可能有不止一级的电压放大器。输出级使用 B 类推挽放大器。\n","date":"2023-07-14T17:40:49+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-2%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"6.2 差分放大器"},{"content":"目前为止，已经学习了很多重要的电子器件。这些器件(例如二极管和晶体管)都是自独立封装的器件，在电路中与其他器件相互连接，以形成完整的功能单元。这样的器件为分立元器件。\n现在将会学习更多的模拟(线性)集成电路，这些电路由很多晶体管、二极管、电阻和电容组成，在一块半导体材料微芯片上制造，并单独封装在一个壳中，形成一个功能电路。第5章已经介绍了一种专用集成电路(IC)，此电路专用于音频放大。\n本章将介绍一种通用 IC，即运算放大器(运放)，它是最广泛使用的线性集成电路。虽然运放由很多电阻、电容和晶体管组成，但可以把它看成单一器件。这意味着你更关心从外部来看而不是从内部的元器件级角度来看它能够做什么。\n6.1 运算放大器介绍 早期的运算放大器(运放)主要用于完成数学运算，例如加法、减法、积分和差分，因此称为运算放大器。这些早期器件用真空管制造，工作在高电压下。现在的运放是线性集成电路，使用较低的电源电压，并且可靠、便宜。\n学完本节后，你应该掌握以下内容:\n描述基本的运放及其特性 认识运放符号 识别运放封装上的端子 描述理想运放 描述实际运放 6.1.1 符号及端子 $$ a)符号~~~~~~~~~~~~~~~~~~~~b)标有直流电源接口的符号 $$ $$ c)~~~~典型封装。在双列直插(DIP)封装和表面贴装技术(SMT)上由缺口或圆点指示的是引脚1 $$\n$$ 图6-1~~~~运放符号与封装 $$\n标准运算放大器(运放)电路符号如图6-1a所示。它有两个输人端————反相(一)输入端和同相(＋)输人端，以及一个输出端。典型的运放需要两个直流电压供电以正常工作，其中一个为正，另一个为负，如图6-1b所示。为简单起见，在电路符号中通常会忽略直流电压端子，但应理解实际上它们存在。几种典型运放 IC 封装如图6-1c所示。\n6.1.2 理想运放 为了说明运放究竟是什么，首先考虑其理想特性。当然，实际运放达不到这些理想标准，但从理想角度看，对器件的理解与分析更加简单。\n首先，理想运放具有无穷大的电压增益与无穷大的输入阻抗(开路)，因此不会对驱动源产生负载效应。此外，运放具有零输出阻抗。这些特性如图6-2所示。两个输人端之间的电压 $V_{in}$ 为输入电压，输出电压为 $A_vV_{in}$，如内部电压源符号所示。无穷大输入阻抗的概念是很多运放电路的非常重要的分析工具，这将在6.5节中讨论。\n6.1.3 实际运放 虽然现代集成电路(IC)运放在许多情况下可以使参数值接近理想值因而被当成理想运放，但没有实际运放能达到理想状态。所有器件都有其限制，运放也不例外。运放既具有电压限制也具有电流限制。例如，输出电压峰峰值通常被限制为略小于两个电源电压的差值。输出电流也被内部约束所限制，例如功率消耗和器件额定值等。\n实际运放的特性有高电压增益、高输入阻抗、低输出阻抗和宽带宽。其中一些特性如图6-3所示。 $$ 图6-2~~~~理想运放表示 $$\n$$ 图6-3~~~~实际运放表示 $$\n","date":"2023-07-14T17:40:35+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/6-1%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E4%BB%8B%E7%BB%8D/","title":"6.1 运算放大器介绍"},{"content":"集成电路(IC)是在单个硅片上由许多互联的电路元器件(电阻、二极管、晶体管)组成的具有一定功能的电路。对于模拟电子来说，第6章介绍的运算放大器是最常见的 IC。本节将会介绍为负载提供功率而专门设计的 IC 电路，还会介绍两种专用 IC 音频放大器:美国国家半导体公司的 LM384 和飞思卡尔半导体公司的 MC34119。\n学完本节后，你应该掌握以下内容:\n给出IC功率放大器的主要特性并描述它的应用 描述集成电路功率放大器的主要指标 说明如何将LM384音频功率放大器配置成一个基本的放大器 解释为什么LM384可以用作对讲系统的放大器 最初，小型集成电路功率放大器是为音频应用而设计，它们将扬声器直接连接到输出。随着应用的扩大，设备种类也不断扩大。今天已有许多专门用于功率放大器的 IC 放大器。与小的分立功率放大器相比，它们具有更高的可靠性和更低的价格。\nIC 功率放大器应用广泛，从小型消费类产品到电源、工业电动机控制和稳压设计。大多数都包含A或者AB类功率放大器级和相关的驱动级以及通常会包括一定的电压增益。\n虽然有些 IC 电路能给负载提供 100W 甚至更大功率，但功率 IC 的典型输出功率为几瓦。任何功率放大器的最大输出功率都取决于合适的散热。制造商的数据手册中会提供 IC 功率放大器所要求的散热信息。\n","date":"2023-07-14T17:40:23+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-8ic%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.8 IC功率放大器"},{"content":"本章将要讨论的最后两类放大器在很多方面性能会有很大差别，但是它们都有很高的效率。C 类放大器主要应用于射频电路，比如 FM 发射器。它们一般都是围绕 BJT 和 JEFT 来搭建。D 类放大器是非线性开关放大器，主要利用 MOSFET 来搭建电路。在过去某一段时间，D 类放大器主要用于开关应用，例如电机控制。但是现在市场上已经出现了各种高质量的 D 类音频放大器。我们将首先介绍 C 类放大器。\n学完本节后，你应该掌握以下内容:\n解释 C 类和 D 类放大器的工作原理 解释基本的 C 类工作原理 描述 C 类偏置 解释 C 类放大器的调谐工作原理 求 C 类放大器的最大功率输出 讨论 D 类放大器的工作原理 解释脉冲宽度调制(PWM) 讨论 D 类放大器中的谐波和频谱 解释 D 类放大器中低通滤波器的作用 5.7.1 C类放大器的基本工作原理 $$ 图5-40~~~~基本的C类放大器工作原理(同相) $$\n$$ 图5-41~~~~基本C类放大器工作原理 $$\nC 类放大器工作原理的基本概念如图5-40所示。图5-4la给出了一个具有电阻性负载的共发射极C类放大器。C类放大器一般和谐振电路负载一起工作，因此使用的电阻性负载只为了来说明概念。利用负的 $V_{BB}$ 电源使放大器偏置在截止电压以下。交流源电压的峰值略大于 $|V_{BB}|+V_{BE}$，这样只有在每个周期接近正峰值的那一小段时间内，基极电压会超过发射结的势垒电势，如图5-41b所示。在这个短暂的间隔内，晶体管导通。当使用整个交流负载线时，如 图5-41c 所示，理想的最大集电极电流为 $I_{c(sat)}$，理想的最小集电极电压为 $V_{ce(sat)}$.\n5.7.2功耗 $$ a）集电极电流脉冲~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）理想C类放大器的波形 $$\n$$ 图5-42~~~~C类放大器的波形 $$\nC 类放大器中晶体管的功耗很低，因为在整个输人周期中，晶体管只在一个很小的时间段内导通。图5-42a 给出了集电极电流脉冲。两个脉冲之间的时间为交流输入电压的周期(T)。在晶体管导通期间，集电极电流和集电极电压如 图5-42b 所示。为了避免复杂的数学运算，假设了理想的脉冲近似。通过这个简化，如果输出在整个负载线上波动，那么在晶体管导通期间，最大电流幅值为 $I_{c(sat)}$，最小电压幅值为 $V_{ce(sat)}$。因此，导通期间的功耗为\n$$ P_{D(avg)}=(\\frac{t_{on}}{T})P_{D(on)}=(\\frac{t_{on}}{T})I_{c(sat)}V_{ce(sat)} $$\n5.7.3 调谐工作原理 $$ a）基本电路~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）输出波形 $$\n$$ 图5-43~~~~调谐C类放大器 $$\n因为集电极电压(输出)不是输人的复制，所以电阻性负载 C 类放大器本身在线性应用中是没有价值的。因此必须采用一个具有并联谐振电路(储能电路)的 C 类放大器，如图5-43a所示。储能电路的谐振频率由公式 $f_r= l/(2\\pi r\\sqrt[]{LC})$ 来给出。输入信号每个周期的集电极电流短脉冲产生和维持谐振电路的振荡，因此产生正弦电压的输出，如图5-43b所示。储能电路只有在谐振频率附近有很高的阻抗，因此只有在谐振频率处的增益很高。\n$$ 图5-44~~~~共振电路 $$\n最初电容充电至约为 $+V_{CC}$，如图5-44a所示。红色箭头表示电荷的流动。脉冲过后，电容快速放电，电感充电。然后，当电容完全放电后，电感的磁场消失，然后快速对电容充电至接近 $V_{CC}$，但是与之前的充电有相反的极性。这样就完成了半个周期的振荡，如图5-44b和c所示。接下来，电容再次放电，增大了电感的磁场。电感然后再次对电容充电，充电至正的峰值，该峰值略小于前一次的峰值，因为有部分能量消耗在线圈电阻上。如此完成了整个周期，如图5-44d和e所示。因此输出电压的峰峰值约为 $2V_{CC}$。\n每个周期的振荡幅度会比上一个周期的振荡幅度小，因此能量会在储能电路的阻抗上损耗，如图5-45a所示，振荡最终会停止。但是，集电极电流脉冲周期性地再现会重新激励谐振电路并使振荡维持在一个固定不变的幅度。\n$$ 图5-45~~~~储能电路振荡。V_r是储能电路两端的电压 $$ 当储能电路调谐到输人信号的频率(基频)时，在储能电路电压 $V_r$ 的每个周期都会发生重新激励，如图5-45b所示。当储能电路调谐到输入信号的第二谐波时，则会间隔一个周期发生重新激励，如图5-45c所示。在这种情况下，C 类放大器作为倍频器工作($\\times 2$)。通过将储能电路调谐到更高的谐波，可以实现更高的倍频系数。\n5.7.4最大输出功率 因为储能电路两端的电压峰峰值约为 $2V_{CC}$，所以最大输出功率可以表示为: $$ P_{out}=\\frac{V^2_{rms}}{R_c}=\\frac{(0.707V_{CC})^2}{R_c} \\\\ P_{out}=\\frac{0.5V^2_{CC}}{R_c} $$ 式中，$R_c$ 是集电极储能电路在谐振时的等效并联电阻，它代表绕圈电阻和负载电阻的并联组合，它的值往往比较小。因为晶体管只在输人信号周期的一小部分内导通，并且没有偏置电流，所以 C 类放大器效率非常高。实际的 C 类放大器的效率可达到 90% 以上。\n5.7.5类放大器的钳位偏置 图5-46所示电路是一个带有基极偏置钳位电路的 C 类放大器。发射结相当于二极管。\n$$ a)~~~~~~~~~~~~~~~~~~~~~~~~b) $$\n$$ c)~~~~~~~~~~~~~~~~~~~~~~~~d) $$\n$$ e)~~~~~~~~~~~~~~~~~~~~~~~~f) $$\n$$ 图5-47~~~~钳位偏置过程 $$\n当输入信号为正时，电容 $C_1$ 充电至峰值，极性如图5-47a所示。这个过程在基极产生一个平均值约为$-V_p$的电压。当晶体管只在很短的时间间隔内导通时，前面产生的基极电压使晶体管处于截止状态，除了在正峰值之外。为了得到更好的钳位效果，钳位电路的 $R_1C_1$ 时间常数必须远大于输入信号的周期。图5-47b～f更详细地解释了钳位偏置过程。在输入信号到达正峰值的时间里($t_0～t_1$)，电容通过发射结二极管充电到$V_p-0.7V$，如图5-47b所示。在图5-47c所示的$t_1～t_2$时间段，电容缓慢放电，因为$RC$时间常数很大。因此，电容保持了一个平均电压，该电压略小于$V_p-0.7V$。\n因为输人信号的直流量为0($C_1$的正端)，所以基极的直流电压($C_1$的负端)比$一(V_p-0.7V)$往正的方向略大，如图5-47d所示。如图5-47e所示，电容将交流输入信号耦合到基极，因此晶体管基极电压是交流信号加上一个比一($V_p-0.7V$)往正方向略大的直流电平。在接近输人电压的正峰值时，基极电压略为大于0.7V，并导致晶体管在短暂的时间内导通，如图5-47f所示。\n5.7.6 D类放大器的基本工作原理 在 D 类放大器中，输出晶体管作为开关工作，而不是像 A、B、AB 中那样线性工作。D类放大器在音频应用中一个优势是它的工作效率可以达到理论上的 100%，而 A 类放大器只有 25%，B/AB 类放大器只有 79%。实际中，D 类放大器可以实现大于 90% 的效率。\n$$ 图5-49~~~~D类基本音频放大器 $$ 图5-49是一个 D 类放大器驱动扬声器的基本框图。它包括一个脉冲宽度调制器，用来驱动作为开关工作的互补 MOSFET 输出晶体管，还包括一个低通滤波器。大部分 D 类放大器由双极性电源供电。MOSFET 基本上是推挽放大器，它作为开关器件工作，而不是作为类似于 B 类放大器中的线性器件工作。\n5.7.7 PWM $$ 图5-50~~~~脉宽调制正弦波 $$\n脉宽调制(PWM)是将输人信号转换为一系列脉冲的过程，脉冲宽度与输入信号的幅度成比例变化。图5-50以一个周期的正弦波为例给出了解释。注意，当幅度为正时，脉冲宽度较宽;而幅度为负时，脉冲宽度较窄。如果输入为 0，则输出是一个方波。\n$$ 图5-51~~~~基本的脉冲宽度调制器 $$ PWM 信号一般利用比较器电路来产生。比较器会在第8章中详细讨论，在这里简单介绍一下比较器最基本的工作原理。比较器有两个输入端，一个输出端，如图5-51所示。标有 “+” 的输人端称为同相输人端，标有 “-” 的输人端为反相输入端。当反相输人端电压大于同相输人端电压时，比较器切换到负饱和输出状态。如果同相输人端电压大于反相输人端电压，则比较器切换至正饱和输出状态。图5-51 说明了这个概念，其中同相端加上了一个周期的正弦波电压，反相端加上了一个更高频率的三角波。\n比较器的输入一般来讲都比较小(mV量级)，比较器的输出为“轨到轨”的，即正的最大值接近于正的直流电源电压，负的最大值接近于负的直流电源电压。±12V 或 24V 峰峰值是比较常见的输出。从中可以看出增益非常高。例如，如果输入信号为 10mV pp，则电压的增益为: 24V pp/10mV pp=2400。因为比较器输出幅度针对一个特定范围内的输人电压是常数，所以增益取决于输入信号电压。如果输入信号为 100mV pp，则输出仍为 24v pp，则增益是 240，而不是 2 400。\n频谱 所有非正弦波形都可以由谐波频率组成。一个特定波形包含的频率称为频谱。当三角波调制输人正弦波的时候，得到的频谱包含正弦波频率 $f_{input}$，加上三角调制信号的基波频率 $f_m$ 以及在基波频率上下的谐波频率。这些谐波频率是由于 PWM 信号的快速上升下降时间以及脉冲之间的平坦区域造成的。一个 PWM 信号的简化频谱如图5-52所示。三角波的频率必须大大高于输入信号的最高频率，这样最低谐波频率会高于输入信号频率的范围。\n$$ 图5-52~~~一个PWM信号的频谱 $$\n5.7.8 互补MOSFET $$ 图5-53~~~~互补MOSFET作为开关电路来放大功率 $$ 将 MOSFET 设置成在一个共源互补组态来提供功率增益。每个晶体管在导通和截止状态之间切换，并且当一个晶体管导通时，另一个截止，如图5-53所示。当一个晶体管导通时，它两端的电压非常小，因此它的功耗也很小，即使它上面流过很大的电流。记住，MOSFET 的导通电阻非常小。当晶体管处于截止状态时，没有电流通过，因此就没有功率损耗。晶体管里功耗只发生在很短的切换时间里。传输给负载的功率可以非常高，因为负载两端的电压几乎等于电源电压，并且有一个高的电流流过它。\n效率 当 $Q_1$ 导通时，它提供电流给负载。但是，理想情况下，负载两端的电压为 0，所以 $Q_1$ 的内部功耗为 $$ P_{DQ}=V_{Q1}I_L=0V\\times I_L=0W $$ 与此同时，$Q_2$ 截止，通过的电流为 0，因此内部功率为 $$ P_{DQ}=V_{Q2}I_L=V_{Q2} \\times 0A=0W $$ 理想情况下，到负载的输出功率为 $2V_QI_L$。因此，理想最大效率为 $$ eff_{max}=\\frac{P_{out}}{P_{tot}}=\\frac{P_{out}}{P_{out}+P_{DQ}}=\\frac{2V_QI_L}{2V_QI_L+0W}=1 $$ 以百分比表示为 $eff_{max}=100$%。\n实际情况中，每一个 MOSFET 在导通状态会有十分之几伏的电压。在比较器和三角波发生器中也会有一个小的内部功率损耗。此外，在有限的开关切换时间里也会有功率损耗，因此理想的 100% 的效率在实际中永远也达不到。\n5.7.9 低通滤波器 $$ 图5-54~~~~低通滤波器去除PWM信号中除了输入信号频率以外的所有频率 $$ 低通滤波器除去调制频率和谐波，只传递原始信号到输出端。滤波器具有仅允许通过输入信号频率的带宽，如图5-54所示。\n5.7.10 信号流 $$ 图5-55~~~~D类放大器中的信号流 $$ 图5-55给出了 D 类放大器中每个点的信号。一个小的音频信号被加入到系统中并进行脉宽调制后在调制器输出端生成一个 PWM 信号。其中调制器也实现了电压增益。PWM 驱动互补 MOSFET 级实现功率放大。PWM 信号经过滤波，在输出端产生一个放大的音频信号，它拥有足够的功率来驱动扬声器。\n","date":"2023-07-14T17:40:12+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-7c%E7%B1%BB%E5%92%8Cd%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.7 C类和D类功率放大器"},{"content":"当放大器的偏置使其在输入信号的半个周期内处于线性工作区域，而在另外半个周期内处于截止状态时，该放大器就属于B类放大器。相比于A类放大器，B类放大器的优势是它的效率更高。在给定大小的输入功率下，B类放大器能获得更多的输出功率。一般来说，B类放大器至少需要两个有源器件，它们交替来放大输人波形中正的部分和负的部分。这种方式称为推挽。\n学完本节后，你应该掌握以下内容:\n计算 B 类放大器的交流和直流参数，包括双极型和 FET 型放大器 描述推挽放大器的两种组态 描述交越失真以及如何克服交越失真 解释 AB 类放大器与 B 类放大器的区别 描述如何避免双极型 AB 类放大器中的温度问题 讨论 MOSFET B 类放大器的特性 B 类工作指当 Q 点位于截止区时，导致输出电流只在输入信号的半个周期内变化。在线性放大器中，需要两个器件来完成整个周期工作; 一个放大正半周，而另一个放大负周期。就像你将会看到的，这种工作方式对于功率放大器来说有极大的优点，因为它极大地提高了效率。正是由于这个原因，它们广泛地用于功率放大器。\n5.6.1 点位于截止区 $$ 图5-27~~~共集电极B类放大器 $$ B类放大器偏置在截止区，因此 $I_{CQ}=0，V_{CEQ}=V_{CE(cutoff)}$。这样，当没有信号时, 就没有直流电流或者功率损耗。当某信号驱动B类放大器进入导通后，它运行在线性区域。图5-27利用射极跟随器来说明这个情况。\n5.6.2 推挽工作 可以看到图5-27中的电路只在正半周期导通。为了放大整个周期信号，必须增加第二个 B 类放大器，并使它在负半周期工作。将两个 B 类放大器组合在一起工作称为推挽工作。\n有两种使用推挽放大器来复制完整信号的常见方法。第一种方法使用变压器耦合。第二种使用两个互补对称的晶体管﹔可以是一对匹配的 $npn/pnp$ BJT或者一对匹配的 n 沟道/p沟道 FET。\n$$ 图5-28~~~变压器耦合的推挽放大器。Q_1在正半周导通， \\\\ Q_2在负半周导通。输出变压器将这两个信号整合起来 $$ 变压器耦合 变压器耦合如图5-28所示。输入端变压器的二次绕组是中间抽头的，中间抽头接地，因此二次侧两端的信号互为反相。这样输入端变压器将输入信号转变成两路反相的输出信号后传输给晶体管。注意,两个晶体管都是 npn 型。因为信号的反相，所以 $Q_1$ 将在正周期部分导通，而 $Q_2$ 将在负周期部分导通。输出变压器在两个方向上都允许电流流过，因此它可以将晶体管的两个输出信号整合起来，即使一个晶体管始终处于截止状态。正电源信号连接到输出变压器的中间抽头。\n$$ a）正半周期~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）负半周期 $$\n$$ 图5-29~~~B类推挽工作方式 $$\n互补对称晶体管 图5-29给出了一个最常用的推挽B类功率放大器，它使用两个射极跟随器，以及两个正负电源供电。这是互补放大器，因为一个射极跟随器使用 npn 晶体管，而另一个使用 pnp，分别在输入信号的两个半周期内交替导通。注意，没有直流偏置电压($V_B=0$)。因此，只有信号电压才能驱动晶体管进入导通状态。$Q_1$ 在输入的正半周导通，$Q_2$ 在输入的负半周导通。\n5.6.3 交越失真 当基极直流电压为0时，输入信号电压必须大于 $V_{BE}$ 才能使晶体管导通。结果是在输入信号正负交替的一个时间间隔内，两个晶体管都不导通，如图5-30所示。此时在输出波形上产生的失真叫作交越失真。 $$ 图5-30~~~B类放大器的交越失真 $$\n5.6.4 推挽放大器的偏置 $$ 图5-31~~~对推挽放大器进行偏置来消除交越失真 $$ 为了克服交越失真，将偏置调整到恰好克服晶体管的 $V_{BE}$ 这样修改后的工作方式称为 AB 类。在 AB 类的工作状态下，即使在没有信号输人的情况下，推挽级被偏置在微导通状态。这可以通过分压器和二极管来完成，如图5-31所示。当二极管 $D_1$ 和 $D_2$ 的特性与晶体管发射结的特性相匹配时，二极管中的电流与晶体管的电流相同，这称为镜像电流。这个镜像电流使放大器工作在 AB 类并消除了交越失真。\n在偏置电路中，$R_1$ 和 $R_2$ 值相等，正负电源电压值也相等。这使得 A 点的电压为 0V, 因此不需要耦合电容。输出端的直流电压也为0。假设两个二极管和两个晶体管相同，$D_1$ 两端的压降等于 $Q_1$ 的 $V_{BE}$，$D_2$ 两端的压降等于 $Q_2$ 的 $V_{BE}$。由于两者匹配，因此二极管电流将等于 $I_{CQ}$。对 $R_1$ 或 $R_2$ 应用欧姆定律可求得二极管电流和 $I_{CQ}$ 为: $$ I_{CQ}=\\frac{V_{CC}-0.7V}{R_1} $$ 这个小电流满足了 AB 类放大器消除交越失真的工作要求。但如果晶体管的 $V_{BE}$ 与二极管压降不匹配，或二极管与晶体管没有保持热平衡，就会存在潜在的热不稳定性。功率管由于发热会使发射结电压下降，并导致电流增大。如果二极管上升同样的温度，电流仍会平衡。但如果二极管处于较冷的环境中，那么会使 $I_{CQ}$ 增加得更多些。如果不加以控制就会产生更多的热，从而产生热击穿。为了从一开始就保持平衡，应该将二极管与晶体管放在同样的环境中。在更严格的场合下，在晶体管的发射极加一个小电阻就能减少热击穿。\n交越失真同样也存在于如图5-28所示的变压器耦合放大器中。为了消除交越失真，在变压器的二次侧加上 0.7V 的电压，来使所有的晶体管都能够刚刚导通。可以利用图5-32中所示的单个二极管从电源中推导出产生这个压降的偏置电压。 $$ 图5-32~~~在变压器耦合推挽式放大器中消除交越失真。 \\\\ 二极管补偿了晶体管的发射结电压并使放大器处于AB类工作方式 $$\n5.6.5 交流工作原理 考虑图5-31中 AB 类放大器的 $Q_1$ 的交流负载线。Q 点在截止区略偏上的位置(在 B 类放大器中，Q 点恰好在截止点)。双电源供电的交流截止电压为 $V_{CC}$，双电源供电的推挽放大器的交流饱和电流为: $$ I_{c(sat)}=\\frac{V_{CC}}{R_L}~~~(5-9) $$ $$ 图5-33 ~~~互补对称推挽放大器的负载线。仅仅给出了npn管的负载线 $$\nnpn 晶体管的交流负载线如图5-33所示。可以通过在 $V_{CEQ}$ 和直流饱和电流 $I_{c(sat)}$ 之间画出一条直线来得到直流负载线。直流饱和电流就是当两个晶体管的集电极和发射极之间短路时的电流. 假设两个直流电源短路，电流达到最大值，这意味着直流负载线几乎垂直通过截止区，如图5-33所示。如果沿着这样的直流负载线工作，就像发生热漂移一样，会产生极高的电流而损坏晶体管。\n$$ a)Q_1的交流负载线~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）电路 $$ $$ 图5-34B类放大器的交流负载线及电路 $$\n图5-34a 给出了图 5-34b 中 B 类放大器 $Q_1$ 的交流负载线。如图5-34所示，所加信号在交流负载线上粗线表示的区域内摆动变化。在交流负载线的最上端，晶体管电压($V_{ce}$)最小，输出电压最大。\n在最大工作状态下，$Q_1$ 和 $Q_2$ 交替在接近截止与接近饱和之间工作。在输入信号的正半周期，$Q_1$ 的发射极从 Q 点(0)到接近 $V_{CC}$，产生一个正峰值电压略小于 $V_{CC}$ 的信号。同样，在输入信号的负半周期， $Q_2$ 的发射极从 Q 点(0)到接近 $-V_{CC}$，产生一个负峰值电压几乎等于 $-V_{CC}$ 的信号。尽管在接近饱和电流时电路可以工作，但这会增加信号的失真。\n式(5-9)给出的交流饱和电流也是输出峰值电流。本质上每个晶体管可以在它的整个负载线上工作。已经知道，在 A 类工作状态下，Q 点位于中点的位置。即使没有信号，晶体管中也有较大的电流。但在 B 类放大器的工作状态下，没有信号时，晶体管只有很小的电流，因此，只损耗很小的功率。所以 B 类放大器的效率大大高于A类放大器从理论上说，B 类放大器的最大效率可以达到 79%。\n5.6.6单电源工作 互补对称推挽放大器可以组成单电源工作方式，如图5-35所示。电路工作原理与前面描述的相同，只是此偏置方式会使得发射极输出电压为 $V_{CC}/2$，而不是双电源时的 0V。因为输出不是偏置在 0V，所以必须在输入和输出采用电容耦合来将偏置电压与信号源和负载电阻相隔离。理想情况下，输出电压可以从 0 变到 $V_{CC}$，但实际上达不到这个理想值。 $$ 图5-35~~~单电源推挽放大器 $$\n5.6.7 MOSFET推挽放大器 当 MOSFET 刚开始进入商业领域时，不能处理功率器件所需的大电流。近年来，随着 MOSFET 技术的不断提高，出现了高功率的 MOSFET，它们在数字电路和模拟电路的功率放大器的设计中表现出了很多优点。MOSFET 非常可靠，只要不超过明确的额定电压、额定电流，以及额定温度。\n与 BJT 相比较，MOSFET 有很多优点但是同时也有一些缺点。与 BJT 相比，MOSFET 主要的优点是偏置电路更加简单，驱动要求更加简单，并且可以通过并联来增加电路的驱动能力。除此之外，MOSFET 一般不容易出现热不稳定性; 随着 MOSFET 温度升高，电流会减小(恰恰与双极型晶体管相反)。在开关应用中(4.7节已经讨论过)，MOSFET 比 BJT 的转换速度更快。MOSFET 开关广泛用于数字逻辑和高功率开关电路。\nBJT 的优势体现在当晶体管两端压降较重要时，于是，它在某些情况下比 MOSFET 更加有效。另外，双极型晶体管不易发生静电释放，而静电释放(ESD)会损坏 MOSFET。大部分 MOSFET 在运输时会通过金属环将引脚短路在一起，这些引脚需要在短路金属环去除之前焊接到电路中。\n一个使用互补对称 E-MOSFET 和双端电源的简化 B 类型放大器如图5-37a所示. 已经知道一个 E-MOSFET 器件通常是截止的，但当输人超过门限电压时 E-MOSFET 可以导通。对于逻辑器件而言，导通电压的典型值介于 1～2V 之间; 对于标准器件，门限电压会更高一些。当信号超过 $Q_1$ 的正门限电压时，器件导通;同理，当信号低于 $Q_2$ 的负门限电压时，器件导通。因此，n 沟道器件在正周期内导通，p 沟道器件在负周期内导通。 $$ a) ~B类~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）AB类 $$ $$ 图5-37 ~~~MOSFET推挽放大器 $$\n和 BJT 推挽放大器一样，晶体管在刚超过零信号电压时并不导通，这样就会产生交越失真。如果每个晶体管的偏置电压刚好为门限电压，那么 MOSFET 将会工作于 AB 类状态，如图5-37b中电路所示。这个放大器的驱动源为双极型晶体管放大器，其他一些器件用于确保 E-MOSFET 推挽级有合理的线性输出。显然，基于该设计的商用放大器还拥有某些其他特性。\n图5-37b所示的基本 AB 类推挽放大器包含一个共发射极来放大输人信号并将信号耦合到推挽级(由 $Q_2$ 和 $Q_3$ 组成)的栅极。注意，$C_3$ 将 $R_6$ 旁路，这样可以允许相同的交流信号被加到推挽级。电位器 $R_6$ 能够提供合适的直流电压，为 $Q_2$ 和 $Q_3$ 的门限设置提供相应的偏置。可以适当调整 $R_6$ 使得交越失真最小。调整电位器 $R_1$ 使没有输入信号时直流输出电压为零。\n这种类型的放大器可以通过简单地并联另一对 MOSFET 管来提供更大的功率; 但是，这种方法有时也会带来不期望的振荡。为了避免振荡，可以使用栅极电阻将 MOSFET 进行相互隔离。尽管在这个简化的放大器中并不是必需的，但是图5-37中还是给出了 $R_8$ 和 $R_9$ 具有并联 E-MOSFET 的功率放大器能够提供高达 100W 的功率。\n","date":"2023-07-14T17:39:59+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-6b%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.6 B类功率放大器"},{"content":"当放大器所加的偏置始终使它工作在线性区，即输出信号是输入信号的放大复制时，它就是 A 类放大器。前面章节的讨论和式子都适用于 A 类工作状态。功率放大器是指将功率传送给负载的放大器。这意味着必须考虑到这些元件的散热能力。\n学完本节后，你应该掌握以下内容:\n计算 A 类功率放大器关键的交流和直流参数，并讨论交流负载线的工作 解释为什么对于 A 类放大器来说 Q 点位于中心很重要 确定多级放大器的电压增益和功率增益 确定 A 类放大器的效率 在小信号放大器中，交流信号只在交流负载线的极小范围内移动。当输出信号比较大并且接近交流负载线的上下限时，它就是一个大信号类型的放大器。只在所有时候内以大器都工作在线性区，就认为大信号和小信号放大器都是A类放大器。A 类功率放大器是指提供功率(而不是电压)给负载的大信号放大器。根据经验，如果需要考虑元件的散热问题(\u0026gt;1/4W)，那么这个放大器就可能是一个功率放大器。\n5.5.1 散热 功率晶体管(和其他功率器件)必须驱散内部产生的过量热量。对于双极型功率晶体管，集电极是最关键的部位，所以晶体管外壳始终与集电极相连。所有功率晶体管的外壳都在管子和散热槽之间设计有一个较大的接触面积。晶体管产生的热流过外壳到达散热槽，然后散发到周围的空气中。散热槽的尺寸、鳍板的数量、材料的种类等都会有所不同，尺寸取决于散热要求和晶体管工作环境的最高温度。在大功率(几百瓦)应用场合，还需要冷却扇。\n5.5.2中心Q点 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$\n$$ 图5-22~~~当Q点位于交流负载线的中心时A类放大器有最大输出 $$ 3.4节曾提到，直流负载线和交流负载线在 Q 点相交。当 Q 点位于交流负载线的中点时，就能得到 A 类信号的最大值。查看图5-22a中给定放大器的负载线图，就能理解这个概念。该图给出了交流负载线，其中 Q 点位于其中心。集电极电流可以从 Q 点值 $I_{CQ}$ 向上最大变化到饱和值 $I_{c(sat)}$，向下最小变化到截止值 0。同样，集电极-发射极电压可以从其 Q 点值 $V_{CEQ}$ 增大到最大截止值 $V_{ce(cutoff)}$，减小到最小饱和值(近似为 0)。这个工作过程如图5-22b所示。集电极电流的峰值等于 $I_{CQ}$，相应的集电极-发射极电压的峰值等于 $V_{CEQ}$。这个信号就是 A 类放大器中可以获得的最大信号。实际上，输出不能完全达到饱和和截止，所以实际最大值要小一些。\n$$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$\n$$ 图5-23~~~Q点靠近截止区 $$ 如果 Q 点不在交流负载线的中心，输出信号就会受到限制。图5-23给出了Q点从中心移向截止时负载线的情况。本例中，输出范围受截止的限制。集电极电流只能在向下到接近于 0 和大于 $I_{CQ}$ 向上等量的范围内摆动，集电极-发射极电压只能在向上到截止值和小于 $V_{CEQ}$ 向下等量范围内摆动变化，如图5-23a所示。如果放大器工作范围超过此区域，则就会在截止处被“削顶”，如图5-23b所示。\n$$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$\n$$ 图5-24~~~Q点靠近饱和区 $$ 图5-24给出了 Q 点从中心移向饱和时负载线的情况。此时输出变化范围受饱和限制。集电极电流只能在向上到接近饱和值与 $I_{CQ}$ 下等量的范围内摆动，而集电极-发射极电压也只能在向下到接近饱和值和 $V_{CEQ}$ 上等量的范围内摆动变化，如图5-24a所示。如果超出该范围，将在饱和处被“削顶”，如图5-24b所示。\n5.5.3 功率增益 功率放大器向负载传输功率。放大器的功率增益是传输到负载的功率与输入功率之比。一般来讲，功率增益为: $$ A_p=\\frac{P_L}{P_{in}}~~~(5-5) $$ 式中，$A_p=$ 功率增益; $P_L=$ 传输到负载的信号功率; $P_{in}$ 一进入到放大器的信号功率\n根据已知条件，可以通过几个公式来求得功率增益。通常情况下，求功率增益最简单的方法就是根据输人入电阻、负载电阻和电压增益来计算。已经知道功率可以通过电压和电阻来表示: $$ P=\\frac{V^2}{R} $$ 对于交流功率，电压用有效值表示。传输到负载端的输出功率为 $$ P_L=\\frac{V^2_L}{R_L} $$ 传输到放大器的输入功率为 $$ P_{in}=\\frac{V^2_{in}}{R_{in}} $$ 代入到式(5-5)中，可以得到下面的关系式: $$ A_p=\\frac{V^2_L}{V^2_{in}}(\\frac{R_{in}}{R_L}) \\\\ A_p=A^2_v(\\frac{R_{in}}{R_L})~~~(5-6) $$ 式(5-6)表明放大器的功率增益是电压增益的平方乘以输人电阻与输出负载电阻的比值。此式适用于任何放大器。例如，某 CC 放大器的输人电阻为 10kΩ，负载电阻为 100Ω。因为 CC 放大器的电压增益近似为 1，所以功率增益为: $$ A_p=A^2_v(\\frac{R_{in}}{R_L})=1^2(\\frac{10k\\Omega}{100\\Omega})=100 $$ 对于 CC 放大器，$A_p$近似等于输入电阻和输出负载电阻的比值。\n5.5.4 直流静态功率 没有信号输入时，晶体管的功耗是 Q 点电流与电压的乘积: $$ P_{DQ} = I_{CQ}V_{CEQ}~~~(5-7) $$ A 类功率放大器能够提供功率给负载的唯一方法是使静态电流至少等于负载电流所要求的峰值电流。信号不会增加晶体管的功耗，相反会引起总功耗减小。式(5-7)给出的静态功率是 A 类放大器必须处理的最大功率。晶体管的额定功率通常应该大于这个值。\n5.5.5 输出功率 一般情况下，输出的信号功率是负载电流有效值与负载电压有效值的乘积。当 Q 点位于交流负载线中点时，可获得最大不失真交流信号。对于 Q 点在中点的 CE 放大器，最大峰值电压是 $$ V_{c(max)}=I_{CQ}R_c $$ 有效值是$0.707V_{c(max)}$ 。\n最大峰值电流是 $$ V_{c(max)}=\\frac{V_{CEQ}}{R_c} $$ 有效值是$0.707I_{c(max)}$ 。\n为了求得信号的最大输出功率，使用最大电压和最大电流的有效值。A 类放大器的最大输出功率为 $$ P_{out(max)}=(0.707I_c)(0.707V_c) \\\\ P_{out(max)}=0.5I_{CQ}V_{CEQ}~~~(5-8) $$\n5.5.6效率 任何放大器的效率都是提供给负载的信号功率与直流电源中获得的功率之比。能够获得的最大信号功率由式(5-8)给出。电源平均电流 $I_{CC}$ 等于 $I_{CQ}$，而电源电压至少是 $2V_{CEQ}$. 因此，直流功率为 $$ P_{DC}=I_{CC}V_{CC}=2I_{CQ}V_{CEQ} $$ 电容耦合的负载的最大效率是: $$ eff_{max}=\\frac{P_{out}}{P_{DC}}=\\frac{0.5I_{CQ}V_{CEQ}}{2I_{CQ}V_{CEQ}}=0.25 $$ 电容耦合 A 类放大器的最大效率不能比 0.25 或 25% 高，而且，在实际中，通常还要小(大约 10%)。虽然可以利用变压器来耦合信号到负载来提高效率，但变压器耦合有许多缺点。这些缺点包括变压器的尺寸、变压器的成本以及潜在的失真问题。总的来说， A 功率放大器的低效率限制了它们在小功率应用中的使用。\n","date":"2023-07-14T17:39:41+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-5a%E7%B1%BB%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.5 A类功率放大器"},{"content":"另一种耦合信号的重要方式是直接耦合。采用直接耦合，级间没有耦合电容和变压器。根据输人和输出信号的耦合方式，某些放大器可以放大低至直流的任何频率的信亏。本节将介绍直接耦合放大器，然后加入负反馈来稳定偏置和增益。直接耦合也将应用在功率放大器中，这在5.5节中讨论。\n学完本节后，你应该掌握以下内容:\n确定直接耦合放大器基本的直流和交流参数，并描述负反馈如何稳定放大器的增益 描述直接耦合级如何得到偏置 计算直接耦合放大器的直流和交流参数 解释负反馈如何稳定偏置和增益 $$ 图5-17~~~无反馈的直接耦合放大器 $$ 图5-17是一个直接耦合放大器。信号从 $Q_1$ 的集电极直接耦合到 $Q_2$ 的基极。由于是直接耦合， $Q_2$ 的基极电流是由 $Q_1$ 提供，因此对于 $Q_2$ 不需要任何偏置电阻，以及级间不需要耦合电容。虽然级间是直接耦合，但在这个放大电路中，为了避免外部信号源和负载干扰直流电压，有必要在输入、输出端对交流信号进行耦合(通过电容)。\n$Q_2$ 的偏置通过 $Q_1$ 的集电极电阻 $R_{C1}$ 来提供。由于 $Q_1$ 是分压式偏置，所以与 $\\beta$ 无关，但 $Q_2$ 采用的是基极偏置，这种偏置方法在线性放大器中使用不太理想，因为会随 $\\beta$ 参数变化。另外，温度变化会引起电路的漂移。虽然这款放大器所用的元件少于电容耦合放大器，但存在的缺点比优点多。不过，只要对它做些简单的改动——加人负反馈就能解决随 $\\beta$ 变化和漂移的问题。\n5.4.1负反馈增强偏置稳定性 $$ 图5-18~~~一个带负反馈的直接耦合放大器，能够稳定偏置 $$\n图5-18所示的电路是将图5-17中的放大器减少元件数量后修改得到的放大器，它能够大大改善偏置稳定性。为了避免对偏置电压造成干扰，输入和输出信号采用电容耦合。因为电路中有两个晶体管，所以红色显示的反馈网络利用了相对于单个晶体管产生的额外增益，使电路相对于 $\\beta$ 的变化和温度的变化非常稳定。这和3.2节集电极负反馈偏置中的负反馈是类似的。\n下面来看图5-17中的反馈如何工作。从 $Q_2$ 开始，注意， $Q_2$ 的基极通过 $R_{C1}$ 正向偏置，从而产生 $Q_2$ 的集电极电流 $I_{C(Q2)}$。该电流会使 $Q_2$ 的发射极电压升高，从而使 $Q_1$ 导通。随着 $Q_1$ 导通程度越来越深， $Q_1$ 集电极电压下降，使 $Q_2$ 的偏置减少。 $Q_2$ 偏置减少的结果是将该偏置稳定在由专门设计的值确定的稳定点。\n通过对由$V_{CC}、R_{C1}、V_{BE(Q2)}、R_F、V_{BE(Q1))}$和 $R_{E1}$ 组成的回路应用基尔霍夫电压定理(KVL)求得 $Q_1$ 的集电极电流，约为: $$ I_{C(Q1)}=\\frac{V_{CC}-2V_{BE}}{R_{C1}+\\frac{R_F}{\\beta}+R_{E1}} $$ 设计电路使得 $R_{C1}$ 远大于 $R_F/\\beta$ 或 $R_{E1}$。这样，$I_{C(Q1)}$ 几乎完全与 $\\beta$ 无关，在 $Q_1$ 集电极上产生一个稳定的电压，以及在 $Q_2$ 产生一个稳定的基极电压。因此，与基极偏置相关的 $\\beta$ 依赖性不再是一个问题。\n$Q_1$ 集电极电流产生的 $Q_1$ 集电极电压为: $$ V_{C(Q1)}=V_{CC}-I_{C(Q1)}R_{C1} $$ 这也是 $Q_2$ 的基极电压。 $Q_2$ 发射极电压是 $V_{C(Q1)}-0.7V$。根据欧姆定理可以求出发射极电流为: $$ I_{E(Q2)}=\\frac{V_{C(Q1)}-0.7V}{R_{E2}} $$ 在计算 $I_{E(Q2)}$ 时，并没有包含反馈电阻 $R_F$，因为它远大于 $R_{E2}$。$I_C$ 和 $I_E$ 近似相同，因此可以求出 $Q_2$ 的集电极电流。$V_{CC}$ 减去 $R_{C2}$ 两端的电压就可以得到 $V_{C(Q2)}$。下面的例题说明了这种电路的一组典型参数设置。\n5.4.2负反馈增强增益稳定性 例5-5中给出的放大器具有高增益，但其增益在一定程度上与 $\\beta$ 相关。负反馈提高了偏置稳定性，使其与 $\\beta$ 无关。那么，将负反馈用于交流信号是否也能提高增益稳定性，并且与 $\\beta$ 无关?将会看到，负反馈会产生自校正行为来稳定电压增益。修改后的电路如图5-20所示，并说明如何达到稳定电压增益的目的。\n$$ 图5-20~~~例5-5中电路改进后的电路图，可以稳定增益 $$ 首先，旁路电容 $C_2$ 和 $R_{E2}$ 并联，目的是进一步提高电压增益。加入反馈后，会使增益更加稳定。无反馈时的增益叫做开环电压增益，在第6章介绍运算放大器时会进一步说明这一点。对于图5-20中的放大器，发射极电容的加入会使得开环电压增益增大两倍。新加人的由 $C_3$ 和 $R_{F2}$ 组成的通路将一部分输出交流信号返回到$Q_1$。返回部分的大小由分压器决定($R_{F2}$和$R_{E1}$组成)。对于图5-20中的放大器，反馈电压 $V_f$ 等于输出电压乘以反馈系数， $$ V_f=(\\frac{R_{E1}}{R_{E1}+R_{F2}})V_{out} $$ 这个反馈电压试图减少原来的输入信号。由开环电压增益放大的信号是输人和负反馈的差值。因此，放大器的净电压增益受反馈量控制。这个带反馈的净增益称为闭环电压增益。如前所述，闭环电压增益由返回的输出信号的大小确定。\n开环电压增益非常大意味着 $Q_1$ 输入端的反馈和输入信号的差值非常小。对于图5-20所示的放大器，$Q_1$ 基极和发射极上的交流信号几乎有相同的幅度。\n下面介绍负反馈稳定增益的工作原理。假设由于温度升高(引起 $r\u0026rsquo;_e$ 减少)使电压增益增大。开环增益增大使输出电压增大，反过来也增大了负反馈电压，这又减小了 $Q_1$ 上的差值电压。因此，增益的初始变化几乎完全被负反馈的自校正作用抵消。\n现在假设技术员用一个较低 $\\beta$ 值的晶体管替换原电路中晶体管。这会引起放大器开环增益减少。现在，将有一个更小的反馈电压，它导致差值电压增大。由于差值电压增大，降低 $\\beta$ 产生初始影响对输出电压产生的影响变小，从而达到稳定增益的目的。\n放大器的净增益近似等于反馈系数的倒数。对于图5-20的放大器，净增益为: $$ A_v=(\\frac{R_{E1}+R_{F2}}{R_{E1}})=(\\frac{100\\Omega+4.7k\\Omega}{100\\Omega})=48 $$ 可以看出，改变 $R_{F2}$ 的值就能非常容易地改变增益。事实上，在 $R_{F2}$ 的位置上放置可变电阻就可以容易达到控制增益的目的。\n$$ 图5-21~~~系统例子~4-2~中的直流耦合前置放大器 $$ 另外一个直流耦合放大器的例子是第4章系统例子4-2中引入的电路。作为参考，再次给出，如图5-21所示。该电路的一个重要优点是能够放大所有的低频甚至直流信号。当输入电压为 0 时，调节电位计 $R_5$ 可以使输出电压也为 0。对于这个设计，在最后一级使用一个 pnp 晶体管可以使输出电压为 0。\n图5-21中的放大器使用未被旁路的发射极电阻($R_4$ 和 $R_8$)来实现增益稳定。这是负反馈产生增益稳定性(以降低增益为代价)的一种形式，正如你在第 3 章和第 4 章所看到的。FET 输入级增加了高输入电阻的优点。\n","date":"2023-07-14T17:39:25+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-4%E7%9B%B4%E6%8E%A5%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.4 直接耦合放大器"},{"content":"变压器可以用来将信号从一级耦合到另一极。虽然主要用于高频设计中，但它也可用于低频功率放大器中。当信号频率位于RF范围内(\u0026gt;100kHz)时，放大器的各级之间常用调谐变压器来进行耦合，该变压器形成一个谐振电路。在本节中，将会看到变压器耦 合放大器的例子，包括低频和高频调谐放大器。\n学完本节后，你应该掌握以下内容:\n描述变压器耦合放大器、调谐放大器和混频器的特性 描述变压器耦合放大器一般如何工作 确定变压器耦合放大器的交流和直流负载 线解释如何利用混频器将高频转换成低频 给出在高频应用中使用IF放大器的优势 5.3.1 低频应用 大多数放大器要求直流信号应该与交流信号隔离。5.1节已经提及电容具有隔直流通交流的作用。变压器也具有隔直流(没有提供直接的通路)通交流的性能。 此外，变压器提供了电路中阻抗匹配的方法。在基本直流/交流课程中已经知道从变压器一次侧来看，二次侧的负载会被变压器改变。降压变压器会使负载在一次侧看起来变得更大，可以表示为:\n$$ R\u0026rsquo;_L~~(a) $$\n$$ (a)=(\\frac{N_{pri}}{M_{sec}})^2R_L~~~(5-4) $$ 式中，(a)是一次侧等效电阻，$N_{pri}/N_{sec}$是一次绕组对二次绕组的匝数比，$R_L$为二次侧的负载电阻。\n变压器可以用在输人端、输出端，或者各级之间来耦合电路中各部分之间的交流信号。在功率变压器中，通过阻抗匹配可以进行最大功率传输(将在5.4节中讨论)。变压器也能用来进行信号源和传输线之间的阻抗匹配。线匹配变压器主要用于低阻抗电路($\u0026lt;200\\Omega$)。对于电压放大器，变压器也可以用来实现升压以传输给下一级(但功率永远不会变化)。\n$$ 图5-11~~~一个变压器耦合的基本放大器，给出了输人变压器、耦合变压器和输出变压器 $$ 图5-11给出了一个变压器耦合的两级放大器。小的低频变压器偶尔也会用在某些传声器或其他传感器中来将信号耦合到放大器。\n虽然变压器耦合比 RC 耦合具有更高的效率，但由于存在两个缺点，变压器耦合不能广泛应用于低频电路。首先，与电容相比，变压器价格比较昂贵，并且比较笨重;其次，由于绕组电抗的作用而使其高频响应变差。由于上述原因，低频变压器耦合并不常用，但在某些 A 类功率放大器中会有使用。\n5.3.2高频应用 在高频段，变压器会比较小，并且也相对便宜。对于在一定带宽范围内耦合信号而言具有重要的优势。正如在上一节中所看到的，在高频段，变压器初级可以接上一个并联电容来形成一个高 Q 值的谐振电路。接有合适电容的二次绕组也经常连接成一个谐振电路。\n从基本交流和直流知识已经知道，并联谐振电路是一个LC电路，它在谐振频率处有最大的阻抗。谐振频率处的高阻抗意味着放大器增益在谐振频率附近可以非常高，而直流时增益却很低。这就形成了一个增益可高达1000(甚至更高)的窄带(典型为10kHz)放大器。此外，放大器可以选择只放大包含有用信号的非常窄范围内的频率信号，而不放大其他频率的信号。\n在信号处理中，通常要通过将 RF 和振荡器混合来将无线频率转换成较低的频率。得到的这个新低频称为中频(IF)。调谐变压器耦合在RF和IF放大器中都很重要。\n使用 IF 的主要优点是它是一个固定频率，并且对于任何给定的RF信号(在设计范围内)，调谐电路无需改变。这可以通过让振荡器跟踪RF信号来完成。因为IF固定，所以用固定的调谐电路来进行放大就很简单，无须用户进行任何调整。这一思想首先由MajorEdwin Armstrong在第一次世界大战期间提出，并在大多数的通信设备中使用，此外也用于频谱分析仪，它是高频测试设备的重要部分。\n$$ 图5-13~~~一个调谐放大器，包括一个RF放大器和一个混频器 $$ 图5-13是一个两级调谐放大器的例子，它在第一级的输人端和第二级的输出端都使用谐振电路。两级之间采用变压器耦合。与此类似的电路是大多数通信设备的组成部分，由一个RF放大器和一个混频器组成。RF放大器用于调谐并放大来自信号站的高频信号。混频器是非线性电路，它将信号与振荡器产生的正弦波混合在一起。\n振荡器的频率设置与 RF 之间有一个固定差值。当 RF 与振荡器信号中在非线性电路中混合时，会产生两个新频率: 两个输入信号的和以及两个输人信号的差。第二个谐振电路调谐到差值频率，同时对其他频率进行抑制。这个差值频率就是IF信号，会在IF放大器中进一步放大。IF 放大器的优点在于它是专门用来处理单一频率的放大器。\n进一步来看图5-13中的电路。第一个调谐电路包括变压器 $T_1$ 的一次侧，它与 $C_1$ 构成谐振回路来接收信号。非谐振频率的信号被谐振回路抑制。注意，$Q_1$ 的偏置方式是分压式偏置，它没有集电极电阻，而是信号将变压器 $T_2$ 的一次侧看成负载。这一级的增益由集电极电路的电阻除以由 $R_3$和 $r\u0026rsquo;_e$ 组成的发射极电阻确定。\nRF 信号通过变压器 $T_2$ 送到 $Q_2$ 的栅极，并与来自振荡器(图5-13中未给出)的信号进行混合。注意， $Q_2$ 对 RF 信号来说是 CS 放大器，但对振荡信号来说是CG放大器。 $Q_2$ 输出端的谐振电路调谐到设定的差值频率，因此 $Q_2$ 的输出是中频(IF)，被送到下一级作进一步放大。为了产生中频，$Q_2$ 必须在非线性放大状态下工作。FET 可以很好地实现这个功能。经常利用两级 MOSFET 将混频器和 RF 放大器结合在一起，如前所述。\n可以看到在图5-13中电阻 $R_6$ 与直流电源相串联，与 $C_5$ 形成一个称为去耦网络的低通滤波器。它有助于将电路与其他放大器相隔离并有助于避免有害振荡的产生。这个电阻值很小(典型值为100Ω)，电容的选择原则是使其在工作频率时电抗\u0026lt;10%的电阻值(例如，100Ω电阻可以用电抗近似为10Ω的电容旁路)。\n$$ 图5-14~~~一个双栅极MOSFET混频器 $$ 图5-14是图5-13中的 JFET 混频器电路的 MOSFET 实现。该混频器由4.5节中讨论的双栅极 MOSFET 实现。来自 RF 放大器的输出被加到其中一个栅极，来自振荡器的信号被加到另一个栅极。类似于 JFET，MOSFET 组成非线性器件来产生中频。\n$$ 图5-15~~~一个IF放大器 $$ 图5-15为一个 IF 放大器。IF 变压器专门针对所选择的中频进行设计。IF 放大器与 RF 放大器几乎完全相同，唯一的差别是它在给定电路中所发挥的作用。IF 放大器使用一个调谐输人电路和调谐输出电路来选择性地放大中频信号。组成一次谐振电路的电容和变压器位于一个提供屏蔽的金属保护盒内。精确的中频可以用调谐条在铁心内外移动来进行调整。此外，电路中还包含去耦网络($R_3$和$C_3$)。在对IF电路进行调谐时，利用高阻抗、低电容的测试仪器以避免由于仪器的负载效应改变电路的响应，这一点很重要。\n图5-14中电路的直流参数的计算和任何共射放大器的计算方法一样。但是，调谐电路对电路交流参数的影响与一个仅含有集电极电阻的电路不同。由于集电极上并联的谐振电路，放大器的电压增益是谐振电路的阻抗与发射极电路的交流电阻之比。 $$ A_v=\\frac{Z_c}{R_e} $$ 式中，$Z_c=$ 集电极电路的阻抗; $R_e=$ 发射极电路的电阻。\n调谐电路的阻抗取决于调谐电路的频率和 Q 值。如果已知 $X_L$ 和 Q 值，则可以求得谐振处的阻抗$Z_c$。 $$ Z_c=QX_L $$ 由于变压器的缘故，负载电阻也是一次等效电路的一部分，并影响调谐电路的频率响应;负载电阻越小，Q 值越小，响应的频率范围更宽。例5-4说明了这一点。\n","date":"2023-07-14T17:39:11+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-3%E5%8F%98%E5%8E%8B%E5%99%A8%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.3 变压器耦合放大器"},{"content":"一般来说，射频(RF)是指用来进行无线传输的频率，范围包括从大约10kHz的实际低频到 300GHz 以上。在 100kHz 以上，放大器经常在输人端、输出端或负载端采用调谐电路，因此很多人喜欢将工作在 100kHz 以上的放大器称作RF放大器。在高频，放大器只用来为那些在一定频段内的频率提供增益。本节将给出高频放大器的一些实际考虑因素。下一节将会介绍高频信号如何通过变压器从一级耦合到另一级。\n学完本节后，你应该掌握以下内容:\n描述高频放大器的特性并给出实现高频电路时的实际考虑因素 解释当在高频工作时传输线的需求 在给定每单位长度电感和电容的情况下，求电缆的特性阻抗 解释终止电缆的正确方法以避免反射 描述 RF 放大器重要的交流参数 解释中和的意思 解释 AGC 如何工作 5.2.1传输线 当高频信号或者快速上升的数字信号从某一点传输到另一点时，传输线将会产生很多不利的影响，比如信号的衰减、高频响应的下降和噪声的增加。对于几英寸长的信号路径来说，当信号频率在大约100MHz以上或数字信号的上升时间小于约4ns时，这些影响将尤为重要。\n考虑由两条电线组成传输线，用它来将一个高频信号从一个点发送到另一个点。电线会有一个电感L，它沿着电线方向为串联形式，同时也会有一个电容C，它在两个传导线之间以并联方式存在。(两个导体用一个绝缘体来分隔形成一个电容。)在高频时，串联的电感上升，而并联的电容下降。电线上的电感和电容不是集中在某一点的，它是分布在整个导线上。\n$$ a）一小段传输线的等效电路~~~~~~~~~~~~~~b）三段等效传输线串联 $$\n$$ 图5-6~~~高频传输线的等效电路 $$ 图5-6a描述了一小段传输线的等效电路，其中电感和电容画成了分立元件，但是要知道的是，电感和电容是平均分布在整个导线上的。电感被分成了 4 个小电感，每个小电感的电感值是 $L/4$。电容值为C。此外还存在电阻值，但是在高频时，电阻对阻抗产生较小的贡献，因此可以忽略。\n为了帮助理解传输线，对一小段等效电路进行扩展，扩展到由一系列小段分立电感和电容连接在一起的情况，如图5-6b所示。如果加长等效电路，会发现一个很有趣的现象;当段数大于10后，再继续增加段数，传输线的阻抗几乎不变。也就是说，阻抗不取决于传输线的长度。这个固定的阻抗值称为传输线的特征阻抗。在高频时，传输线的特征阻抗可表示为: $$ Z_0=\\sqrt[]{\\frac{L}{C}}~~~(5-1) $$ 式中，$Z_0$ 为传输线的特征阻抗，单位为欧姆(Ω); L为单位长度的电感值。单位为亨利(H); C为单位长度的电容值。单位为法拉(F)。\n注意，L和C必须是相同长度的数值。由于公式取的是比值，因此使用多少长度没有关系，只要电感和电容使用的长度一样就可以。电缆的阻抗是几何尺寸和用来构造电缆的介质类型的函数。对于高频应用来讲，有各种不同类型的电缆。它们应该都有较大的带宽和一个与长度无关的固定阻抗。\n一类常见的高频传输线是同轴电缆。同轴电缆由一根轴芯和包围在轴芯外面的导体屏蔽层组成。在高频时，这个屏蔽层可以起到屏蔽的作用，可以用来屏蔽轴芯内的信号向外辐射而导致信号的衰减，同时也可以防止外部的信号对轴芯内的信号造成干扰。不同的同轴电缆有不同的特性，比如功率、高频特性和特征阻抗等。\n在给定系统中，安装所要求的电缆类型非常重要。比如，视频系统标准中使用 75 欧姆的同轴电缆。不同的电缆有不一样的特征阻抗，对于同轴电缆来说，典型范围为 50~100Ω，对于并联导体可以达到几百欧姆。\n由于它的带宽比较宽，因此同轴电缆用于很多通信系统中，其中许多不同的声音频道可以放在相同的电缆上。频分滤波器允许在同一时刻进行双向传输。\n5.2.2终止传输线 在高频下，即使一小段传输线相对于信号波长来说也可能是很长的。当来自信号源的信号(入射波)到达传输线终端时，它会被反射回到信号源(反射波)。入射波和反射波沿着线长互相作用，在线上形成驻波。驻波是由人射波和反射波相互作用形成的稳态波。\n驻波会对电视信号产生诸如叠影之类的不期望影响而且会增加噪声。为了防止驻波需要在终端加上一个和传输线特征阻抗相同的电阻负载。当传输线以该方式终止时，整个传输线对于信号源而言呈现电阻特性。当传输线正确终止时，所有信号功率都消耗在终端的负载电阻上。不正确的终止可能会产生反射以及导致错误的信号电平。\n5.2.3 高频考虑 电感效应 在高频(大约10MHz以上)时，传输线不再是一条简单的导电通路，而成为一个有效的电感。这是由于趋肤效应造成的，趋肤效应会导致电流移动到导体的外表面。这种电感通常不是我们所需要的，因为它会增加传输线的电抗并增加电路中的噪声. 为了避免电感的不利影响，高频电路中的电线应该尽可能的短.\n电容效应 在高频的时候，由于电容效应不断增加，晶体管放大器可能会越来越无效。所有有源器件在它们的各极之间都有内部电容。这些内部电容对于高频模拟信号而言相当于低阻抗通路，因此降低了这些器件的有效性。在数字电路中，内部电容限制了脉冲从一个电平变化到另一个电平的速度。因此专门设计了高频晶体管来减小内部电容。\n电容的不利影响会被反相放大器(如共源或共射放大器)放大，因为它会形成一种称为米勒效应的正反馈。因此在高频电路中要尽量减小电容值，这可以通过让传输线尽可能短以及避免使用高增益的反相放大器来实现。\n电容的另外一个影响是在高频放大器中产生不期望的振荡。振荡可以通过中和的办法来消除，这在后面将会详细讲述。\n5.2.4 调谐放大器 带谐振电路的放大器在通信系统中很常见，因为通信系统采用很高的频率。大于 100kHz 的频率通常称为射频或RF。工作在这些频段的放大器被称为射频(RF)放大器对于低频放大器求直流偏置状态的方法同样适用于射频放大器，但对于交流分析需要做些修正。低频放大器是非谐振的，它们用来放大较宽频率范围的信号。\n调谐放大器则不同，它们用来放大特定的频段，并消除频段之外的信号。它们使用并联 LC 谐振电路作为负载，在谐振频率时，它对交流信号呈现较高的阻抗，因此产生较高的增益。谐振电路的中心频率(假设 Q 很大)可利用基本的谐振频率方程计算得到。 $$ f_r=\\frac{1}{2\\pi \\sqrt[]{LC}}~~~(5-2) $$\n调谐放大器的带宽是由谐振电路的 Q(品质因数)决定的。品质因数(Q)是一个无量纲的数值，它是一个周期内储存的最大能量和一个周期内损耗的能量的比值。从实际角度来讲，品质因数几乎总是由电感决定，因此 Q 经常表示为电感 $X_L$ 和电阻R的比值。它也可以表示为中心频率 $f_r$ 和带宽 BW 的比值: $$ Q=\\frac{X_L}{R}=\\frac{f_r}{BW}~~~(5-3) $$\n$$ 图5-7~~~并联谐振电路中阻抗与频率的函数关系 $$ 并联电路的响应取决于电路的 Q 值，如图5-7所示。RF电路的 Q 值取决于电感的类型，对于铁氧体磁心电感来讲，Q 的范围为50～250; 而对于空气磁心的电感来讲，则更高。\n$$ 图5-8~~~调谐射频放大器 $$ 一个使用 JFET 的基本调谐射频放大器如图5-8所示。栅极和漏极电路都包含并联谐振电路，该谐振电路由变压器绕组和电容组成。(变压器耦合在5.3节中讨论。)栅极和漏极之间的虚线电容代表晶体管的内部电容，其电容值只有几皮法。漏极电路对交流信号有很高的阻抗，但直流静态电流能够很容易穿过变压器一次绕组，对于直流来讲，它相当于一个很小的电阻。\n`虽然栅极和漏极之间的内部电容很小，但在高频下它可能在输出和输入之间产生较大的正反馈(同相)，从而使放大器产生振荡。为了防止这样的现象发生，有必要采用中和电路，特别是在高阻抗电路中。\n$$ 图5-9~~~哈泽泰中和电路。C_n抵消了内部电容 $$ 中和是加入相同量的负反馈(反相)来抵消放大器中由于内部电容所产生的正反馈相的过程。图5-9给出了一个常见的中和电路，叫哈泽泰中和电路。哈泽泰中和电路的原理就是通过调节中和电容 $C_n$ 产生适当的负反馈来抵消不期望的正反馈。可以看到漏极电源通过一个中心抽头变压器进行连接。\n$$ 图5-10~~~使用双栅极D-MOSFET的射频放大器 $$ 图5-10给出了另一个常见的 RF 放大器，它利用双栅极 D-MOSFET 来放大天线号。双栅极配置简化了向电路增加自动增益控制(AGC)的过程，因为信号已经结合在 MOSFET 中。当接收到一个大信号的时候，AGC 会减小增益﹔当收到一个小信号时 AGC 会增大增益。RF 信号连接到双栅极器件下面的栅极，而上面的栅极用来控制增益 AGC 信号是一个来自于放大器后级的负直流电压。AGC 电压和输入信号强度成正比。个大的输人信号会产生一个大的 AGC 电压，从而趋向于夹断沟道并因此减小增益。\n","date":"2023-07-14T17:38:59+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-2rf%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.2 RF放大器"},{"content":"前面两章介绍了单级放大器，其主要功能是放大信号电压。你应该已经熟悉了 BJT 与 FET 的偏置和交流参数。\n当必须放大一个非常小的信号(如来自天线的信号)时，Q 点上的变化也会相对较小。用于放大这些信号的放大器称为小信号放大器。它们也可能专门用于高频情况。通常来讲，包含额外的增益级会非常有用，特别是在高频通信系统中，其中感兴趣的频率被限制在一定的带宽范围之内。\n本章将学习各种不同类型的多级放大器，特别强调高频时的一些考虑，包括噪声、布线，以及消除不必要的振荡。然后将重点转向功率传输的重要要求。对于这些应用，需要功率放大器。最后将介绍集成电路(IC)功率放大器。\n5.1电容耦合放大器 两个或多个晶体管可以连接在一起组成一个放大器，该放大器称为多级放大器。1.4节已经介绍了一个简化的放大器模型。现在可以将该简化模型应用到实际放大器电路中来确定它们的整体性能。本节将学习电容耦合放大器，也称为 RC(阻容)耦合放大器。电容耦合是将交流信号传输到后一级最常使用的方法。\n学完本节后，你应该掌握以下内容:\n确定电容耦合多级放大器的交流参数 计算两级电容耦合放大器的总增益、输入电阻和输出电阻 讨论多级放大器中如何减小振荡和噪声问题 两个或多个晶体管可以连接在一起来提高放大器的性能。放大信号的每个晶体管都称为一级。一般来讲，放大器的第一级必须有非常高的输入电阻来避免对信号源产生的负载作用。另外，第一级需要设计成低噪声工作，因为这些微弱信号电压很容易会被噪声所淹没。后续级的目的是在不产生失真的前提下来增加信号的幅度。\n$$ \\beta_{DC}=\\beta_{ac}=150，对于Q_1和Q_2 \\\\ 图5-1~~~一个两级CE放大器 $$\n提高放大器增益最简单的方法可以是两级通过电容耦合在一起，如图5-1所示。在本例中，两级都是相同的 CE 放大器，第一级的输出连接到第二级的输入端。由于电容具有隔直流的作用，因此电容耦合会阻止其中一级的直流偏置影响另一级的直流偏置。虽然直流通路为开路，但是耦合电容可以让交流信号顺利地传输到下一级。\n该电路的分析首先需要分析直流工作状态，如3.2节所述。利用分压原理来计算每级的基极电压。\n$$ V_B\\approx (\\frac{R_2}{R_1+R_2})V_{CC}=(\\frac{10K\\Omega}{47K\\Omega+10K\\Omega})10V=1.7V $$\n该估计值会略高于实际值，因为没有考虑分压器的负载。减去发射结二极管两端的0.7V电压后，可得到发射极电压为1.0V，因此计算得到发射极电流为:\n$$ I_E=\\frac{V_E}{R_E}=\\frac{1.0V}{1.0K\\Omega}=1.0mA $$\n发射极电流也约等于集电极电流。\n5.1.1负载效应 $$ a）单级放大器模型~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）图5-1中一级放大器的值 $$\n从1.4节已经知道放大器可以用框图来表示，框图中只包含重要的参数。交流模型仅仅是一个受控电压源与一个电阻串联(戴维南电路)。为了计算放大器的总增益，图5-2中的每个晶体管级都可以用类似的方式建立模型。只需要知道三个参数: 空载时的电压增益($A_{v(NL)}$)、总输入电阻($R_{in(tot)}$)、输出电阻($R_{out}$)。可以看到空载输出电压等于输入电压乘以空载增益。\n首先求一级的空载增益。因为两级相同，所以两级的空载增益也相同。第二级的输入电阻相当于第一级的负载。因此，第一级的负载增益可以通过假设其负载电阻等于第二级的输入电阻 $R_{in(tot)}$ 来计算得到。这会降低第一级的增益，但可以与空载增益计算分开来考虑。该概念的说明会让我们更清楚地认识到基本放大器模型可以简化总增益的计算。\n已经知道 CE 放大器的空载增益是集电极交流电阻和发射极交流电阻的比值，空载增益与 $r\u0026rsquo;_e$ 有关，而这个参数又与 $I_E$ 有关，所以应作近似处理。\n因为要计算空载增益，交流集电极电阻 $R_e$与实际的集电极电阻 $R_C$ 相同，为 4.7kΩ;\n交流发射极电阻约为:\n$$ r\u0026rsquo;_e\\approx \\frac{25mV}{I_E}=\\frac{25mV}{1.0mA}=25\\Omega $$\n空载增益 $A_{v(NL)}$ 约为:\n$$ A_{v(NL)}=-\\frac{R_C}{R_e}=-\\frac{R_C}{r\u0026rsquo;_e}=-\\frac{4.7k\\Omega}{25\\Omega}=-188 $$\nCE放大器的输人电阻在3.4节中已经讨论过，采用分压式偏置和没有扩量程电阻的放大器的输入电阻表达式为:\n$$ R_{in(tot)}=R_1||R_2(\\beta_{ac} r\u0026rsquo;_e) $$\n设 $\\beta_{ac}$ 为150，并代人相应的数值，图5-1中的放大器的输入电阻为:\n$$ R_{in(tot)}\\approx 47k\\Omega||10k\\Omega||[150(25\\Omega)]\\approx 2.58k\\Omega $$\n输出电阻是集电极电路往回看的电阻，并且就是集电极电阻:\n$$ R_{out}=R_C=4.7K\\Omega $$\n可以将这些数值放进图5-2b所示的模型中。\n$$ 图5-3~~~完整两级放大器的交流模型 $$\n组成放大器的两级电路现在连接成图5-3所示。其中，每一级的空载增益都标示在戴维南电源的下面。用该模型来求总增益。总增益是下面三项的乘积:\n第一级的空载增益。 包含第二级输入电阻的分压器相对于第一级输出电阻的增益。 第二级的空载增益。 如果输出端上加有一个负载电阻，那么应该把它作为另一个分压项包括进去(见例5-1)。\n前面计算得到每一级的空载增益为 -188，两级之间的分压器产生了负载效应。它由第二级的 $R_{in(tot)2}$ 和第一级的 $R_{out1}$ 组成。该分压器的增益(衰减)为:\n$$ A_{v(divider)}=\\frac{R_{in(tot)2}}{R_{out1}+R_{in(tot)2}}=\\frac{2.58k\\Omega}{4.7k\\Omega + 2.58k\\Omega}=0.35 $$\n这三个增益的乘积即为总电压增益:\n$$ A_{v(tot)}=A_{v1}A_{v(divider)}A_{v2}=(-188)\\times 0.35 \\times (-188)\\approx 12400 $$\n该乘积表明电压增益相当大。例如: 如果将 $100\\mu V$ 的输入信号加到第一级，并忽略输入基极电路的衰减影响，可得到第二级的输出电压为 $100\\mu V \\times 12400=1.24V$。必须记住这样一个概念，即这个结果是近似的，因为增益的大小依赖于 $r\u0026rsquo;_e$ 及所用的晶体管。以减少增益为代价，可以在发射极电路上加上一个扩量程电阻来增加电路的稳定性。这时电路的增益与所用的晶体管无关，是个固定值。\n放大器的增益通常用分贝电压增益来表示。对于刚刚考虑的放大器，每一级的空载分贝电压增益为:\n$$ A\u0026rsquo;_v=10log|A_v|=20log(188)=45.5dB $$\n两级之间的分压器增益(衰减)为:\n$$ A\u0026rsquo;_{v(divider)}=20log(0.35)=-9.1dB $$\n总的分贝电压增益是单个分贝电压增益的总和。\n$A\u0026rsquo;_{v1}~~(a)$\n$A\u0026rsquo;_{v(divider)}~~(b)$\n$A\u0026rsquo;_{v2}~~(c)$\n$$ A\u0026rsquo;_{v(tot)}=(a)+(b)+(c)=45.5dB-9.1dB+45.5dB=81.9dB $$\n5.1.2 不期望的振荡和噪声 多级放大器需仔细设计以防产生振荡。当大小信号存在于同一个电路中时，由于存在不期望的反馈通路，大信号会对小信号产生不利的影响。这个问题在高频放大器中更为严重，因为反馈通路的电抗会更低，引起更多不期望的反馈。例如，原型机板存在寄生电容，当将它们组成多级放大器时会引起反馈及噪声问题;如果在每一级的 $V_{CC}$ 与地之间用电容连接，就能将各级隔离，这会有助于问题的解决。这一技术可以在商用的印制电路板上经常看到。电容应该尽可能连接到接近每一级的 $V_{CC}$ 的位置，并且接线长度应尽可能短.\n除了振荡外，噪声电压(电子干扰)也是多级放大器中存在的问题。信噪比确定了噪声是否足以干扰信号。当信号较小时，一个小噪声电压造成的影响可能比信号较大时的影响更大。这说明放大器的第一级是最重要的一级，因为此时输入信号很小。对于高阻抗源来说，FET 有更大的优势，但是当信号源阻抗较低时(\u0026lt;1MΩ)，双极型晶体管能提供更好的低噪声性能。\n关于电路中噪声问题已经有很多的研究。噪声问题的解决方法取决于噪声源、噪声进人电路的途径、噪声的类型，以及其他一些细节。许多时候，对噪声问题没有一个解决方法。噪声可能从信号源外部通过电容或电感耦合进入电路，也可能来自电源，或来自电路内部(热噪声)。以下是避免噪声问题的一些建议。\n尽量缩短连线以避免电路出现天线现象(尤其是低电平输入线)，并尽量减少反馈回路。 在每一级的电源与地之间加上电容，并确认电源经过正确滤波。 尽可能减少噪声源，将噪声源与电路隔开或屏蔽。对低电平信号使用屏蔽线、双绞线或者屏蔽双绞线。 所有电路的接地都在同一个点上，并通过独立的地线将大电流的地和小电流的地分开，源自大电流的地电流由于导电通路的 IR 压降会在电路的另一部分产生噪声。 让放大器的带宽不超过放大所需信号所要求的带宽。 ","date":"2023-07-14T17:38:49+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/5-1%E7%94%B5%E5%AE%B9%E8%80%A6%E5%90%88%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"5.1 电容耦合放大器"},{"content":"虽然 BJT 和 JFET 都能用于开关电路，但 MOSFET 是目前大多数开关应用的首选器件。 MOSFET 具有很低的导通电阻，非常高的断开电阻，很快的切换时间，因此它是极好的开关器件。有两种基本类型的 MOSFET 开关电路:模拟和数字。本节将介绍数字和模拟 MOSFET 开关电路。\n学完本节后，你应该掌握以下内容:\n描述如何将 MOSFET 用于模拟和数字开关电路中 解释如何让 MOSFET 像开关一样工作 描述 MOSFET 模拟开关 讨论模拟开关应用 描述开关电容电路 描述 MOSFET 如何在数字开关电路中应用 讨论互补 MOS(CMOS) 逻辑 解释几种 CMOS数字门的工作原理 讨论几种功率 MOSFET 结构 4.7.1 MOSFET 开关工作原理 $$ 图4-52~~~在负载线上的开关工作 $$ 通常将 E-MOSFET 用于开关应用，因为其具有阈值特性，$V_{GS(th)}$。当栅源电压小于阈值时，MOSFET 处于关闭状态。当栅源电压大于阈值时， MOSFET 导通。当 $V_{GS}$ 在 $V_{GS(th)}$ 与 $V_{GS(on)}$ 之间变化时， MOSFET 就以开关方式工作，如图4-52所示。在关闭状态， $V_{GS}$ \u0026lt; $V_{GS(th)}$ ，器件工作在负载线的下端，相当于一个打开的开关(非常高的 $R_{DS}$)。当$V_{GS}$ 足够大于 $V_{GS(th)}$ 时，器件工作在负载线上端的可变电阻区，相当于一个闭合的开关(非常低的 $R_{DS}$）。 $$ a) ~n沟道MOSFET和等效开关~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) ~p沟道MOSFET和等效开关 $$\n$$ 图4-53~~~MOSFET开关 $$ 理想开关参考图4-53a。当 n 沟道 MOSFET 的栅极电压为 ＋V时，栅极电压相对于源极电压为正，并比源极电压高超过 $V_{GS(th)}$ 的值。此时，MOSFET 导通，漏极与源极之间相当于闭合开关。当栅极电压为零时，栅源电压为零。此时 MOSFET 处于关闭状态，漏极与源极之间的相当于打开的开关。\n参考图4-53b。当 p 沟道MOSFET的栅极电压为 0 时，栅极电压相对于源极电压为负，并且两者绝对差值超过 $V_{GS(th)}$。MOSFET 导通，漏极与源极之间相当于闭合的开关。当栅极电压为 +V 时，栅源电压为零。MOSFET 处于关闭状态，漏极与源极之间相当于打开的开关。\n4.7.2模拟开关 MOSFET 通常用于模拟信号开关。一般来讲，一个加到漏极上的信号可以通过栅极上的电压来接通或断开与源极的相连。主要限制在于源极的信号大小不能导致栅源电压小于 $V_{GS(th)}$ . $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) $$ $$ 图4-54 ~~~n沟道MOSFET模拟开关的工作原理 $$ 一个基本的 n 沟道 MOSFET 模拟开关如图4-54所示。当由于正 $V_{GS}$ 使得 MOSFET导通时，漏极上的信号连接到源极，当 $V_{GS}$ 为 0 时，漏极上的信号与源极断开，如图4-54所示。\n$$ 图4-55~~~信号幅度被V_{GS(th)}限制 $$ 当模拟开关导通时，如图4-55所示，在信号的负峰值栅源电压有最小值。 $V_G$ 与 $V_{p(out)}$ 的差值是信号为负峰值瞬时时刻的栅源电压，它必须等于或大于 $V_{GS(th)}$ 以保证 MOSFET 处于导通工作。 $$ V_{GS}=V_G-V_{p(out)}\\geq V_{GS(th)} $$\n4.7.3模拟开关应用 采样电路模拟开关的应用之一是模数转换。模拟开关用于采样保持电路，来以特定速率对输入信号进行采样。然后每个采样信号值暂时存储在电容中，直到被一个模-数转换器(ADC)转换成数字编码。为了实现这个目标，MOSFET 通过加在栅极上的脉冲在输入信号的一个周期内的短时间内导通。基本工作原理如图4-56所示，为清晰起见，其中只显示了几个采样。 $$ a）电路行为~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）波形图 $$\n$$ 图4-56~~~模拟开关作为采样电路 $$ 信号采样以及能从采样的信号中重构的最小速率必须大于信号最大频率的两倍。这最小采样频率称为奈奎斯特频率。 $$ f_{sample(min)}\u0026gt;2f_{signal(max)} $$ 当栅极脉冲为高电平时，开关闭合，该脉冲期间的一小部分输入波形出现在输出上。当栅极脉冲为0V时，开关断开，输出也为0V。\n$$ 图4-57~~~模拟复用器交替采样两个信号，并在单一输出线上实现交错传输 $$ 模拟复用器模 拟复用器用于需要将两路或多路信号传输到同一目标的应用中。例如，图4-57所示为一双通道模拟采样复用器。两个 MOSFET 交替导通和截止，这样信号采样先后连接到输出。脉冲信号加到开关 A 的栅极，反相脉冲信号加到开关 B 的栅极。一个称为反相器的数字电路用来实现这个目标。当脉冲为高电平时，开关 A 闭合，开关 B 断开。当脉冲为低电平时，开关 B 闭合，开关 A 断开。这称为时分复用，因为脉冲为高电平的时间间隔内，信号 A 出现在输出，脉冲为低电平的时间间隔内，信号 B 出现在输出。也就是说，这两个信号在时间上交错以便在一条线上进行传输。\n开关电容电路 MOSFET 的另一应用是开关电容电路，它通常用于称为模拟信号处理器的集成电路可编程模拟器件中。因为电容在集成电路中比电阻更容易实现，所以它用来模拟电阻。此外，电容在芯片上占据的空间比IC电阻也要少，也不会消耗功率。许多类型的模拟电路利用电阻来确定电压增益和其他特性，通过开关电容模拟电阻，可以实现模拟电路的动态编程。\n$$ 图4-58~~~一种IC放大器 $$\n例如，在后面会学到的一种IC放大器电路中，需要两个外部电阻，如图4-58所示。这些电阻值确定了放大器的电压增益为 $A_v=R_2/R_1$。\n$$ 图4-59~~~开关电容模拟电阻 $$\n利用机械开关类推(把 MOSFET实际上当成开关)，可以使用开关电容来模拟一个电阻，如图4-59所示。开关 1 和开关 2 以一定频率交替闭合和断开，来对电容进行充电或放电，这一过程取决于电压源的值。对于图4-58中的 $R_1，V_{in}$和 $V_1$ 分别用 $V_A$ 和 $V_B$ 表示。对于 $R_2，V_1$和 $V_{out}$ 分别用 $V_A$ 和 $V_B$ 表示。\n可以看出电容模拟电阻的阻值取决于开关闭合断开的频率和电容容值。 $$ R=\\frac{1}{fC} $$ 通过改变频率，可以改变有效阻值。\n$$ 图4-60~~~图4-58中IC放大器，其中电阻用开关电容电路代替 $$\n互补 E-MOSFET 和电容可以代替放大器中的电阻，如图4-60所示。当 $Q_1$ 导通时， $Q_2$ 截止, 反之亦然。选取合适的 $f_1$ 与 $C_1$ 来得到所需的 $R_1$ 值。同样，$f_2$ 和 $C_2$ 提供所需的 $R_2$ 值。要编程改变放大器的增益，改变频率就可以。\n4.7.4 CMOS:数字开关应用 $$ a)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c) $$ $$ 图4-61 ~~~CMOS反相器原理 $$ CMOS 将 n 沟道与 p 沟道 E-MOSFET 以串联方式组合在一起，如图4-61a所示。栅极上的输入电压为 0V 或者 $V_{DD}$。注意， $V_{DD}$ 和地都连接到两个晶体管的源极。为避免混淆，规定 $V_{DD}$ 为正电压，连接到 p 沟道器件的源极。当 $V_{in}=0V$ 时，$Q_1$ 导通，$Q_2$ 截止，如图4-61b所示。由于 $Q_1$ 相当于闭合的开关，因此输出约为 $V_{DD}$。当 $V_{in}=V_{DD}$ 时，$Q_2$ 导通，$Q_1$ 截止，如图4-61c所示。由于 $Q_2$ 相当于闭合的开关，因此输出本质上为接地(0V)。\nCMOS的主要优点是它的直流消耗功率非常小。由于两个 MOSFET串联，且其中一个始终处于断开状态，因此在静止状态时，直流电源中基本上没有电流流过。当 MOSFET 开关时，只有在非常短的时间内会有电流，因为只有在这个极短的状态转变的时间间隔内,两个晶体管会同时导通,\n反相器 注意，图4-61所示的电路实际上会使输入反相，因为当输人为 0V 或者低电平时，输出为 $V_{DD}$ 或者高电平。当输入为 $V_{DD}$ 或者高电平时，输出为 0V 或低电平。因此，该电路在数字电子中称为反相器。 $$ a) $$\n$$ 图4-62~~~CMOS 与非门工作原理 $$\n与非门 在图4-62a中，在 CMOS 对的基础上增加了两个额外的 MOSFET 和第二个输入，得到一个称为与非门的数字电路。$Q_4$ 与 $Q_1$ 并联，$Q_3$ 与 $Q_2$ 串联。当两个输入 $V_A$ 和 $V_B$ 均为 0 时，$Q_1$ 和 $Q_4$ 导通，而 $Q_2$ 和 $Q_3$ 截止，使得 $V_{out}=V_{DD}$。当两个输入均等于 $V_{DD}$ 时，$Q_1$ 和 $Q_4$ 截止，而 $Q_2$ 和 $Q_3$ 导通，使得$V_{out}=0$。可以验证，当两个输入不同，即一端为 $V_{DD}$ 另一端为0时，输出等于 $V_{DD}$。工作状态可总结为如图4-62b中的表，并表述如下:\n$V_A$ $V_B$ $Q_1$ $Q_2$ $Q_3$ $Q_4$ $V_{out}$ 0 0 导通 截止 截止 导通 $V_{DD}$ 0 $V_{DD}$ 截止 截止 截止 导通 $V_{DD}$ $V_{DD}$ 0 导通 截止 截止 截止 $V_{DD}$ $V_{DD}$ $V_{DD}$ 截止 导通 导通 截止 0 当 $V_A$ 与 $V_B$ 为高电平时，输出为低电平; 否则，输出为高电平。\n$$ 图4-63~~~CMOS或非门工作原理 $$\n或非门 在图4-63a中，在 CMOS 对的基础上增加了两个额外的 MOSFET 和第二个输入端，得到一个称为或非门的数字电路。$Q_4$ 与 $Q_2$ 并联，$Q_3$ 与 $Q_1$ 串联。当两个输入 $V_A $和 $V_B$均为0时， $Q_1$和 $Q_3$导通，而 $Q_2$和 $Q_4$截止，使得 $V_{out} =V_{DD}$。当两个输入均等于 $V_{DD}$ 时，$Q_1$ 和 $Q_3$ 截止，而 $Q_2$ 和 $Q_4$ 导通，使得 $V_{out}=0 $。可以验证，当输入不同，即一端为 $V_{DD}$ 另一端为 0 时，输出等于 0。工作状态可总结为图4-63b中的表，并表述如下:\n$V_A$ $V_B$ $Q_1$ $Q_2$ $Q_3$ $Q_4$ $V_{out}$ 0 0 导通 截止 导通 截止 $V_{DD}$ 0 $V_{DD}$ 截止 导通 导通 截止 0 $V_{DD}$ 0 导通 截止 导通 截止 0 $V_{DD}$ $V_{DD}$ 截止 导通 截止 导通 0 当 $V_A$ 或 $V_B$ 或二者均为高电平时，输出为低电平; 否则，输出为高电平。\n4.7.5 功率开关应用中的 MOSFET 在大多数高功率开关应用中，功率 MOSFET 大量代替了 BJT，其中原因很多。MOSFET 截止更快，不需要驱动电流，导通电阻更低(消耗功率更小)，并且具有正温度系数——变热时电阻增大。这意味着与 BJT(具有负温度系数)相比，MOSFET 更不容易发生热漂移。功率 MOSFET 用于电机控制，直流到交流和直流到直流转换，负载开关，或其他需要高功率和精确数字控制的任何场合。例如，2SK4124的额定漏源电压($V_{DSS}$)为500V，额定连续漏极电流为20A，脉冲漏极电流60A。若安装合适的散热器，则额定功率可以达到170W。\n4.7.6 功率 MOSFET 结构 $$ 图4-64~~~传统E-MOSFET结构横截面。白色区域为沟道 $$ 传统的增强型 MOSFET 具有薄且长的横向沟道，如图4-64的结构图所示。其中红色箭头表示多数载流子从源极到漏极的移动。这使得漏源电阻相当高，并限制了 E-MOSFET 的低功耗应用。当栅极电压为正时，在源极和漏极之间靠近栅极处形成沟道，如图4-64所示。\n横向扩散 MOSFET(LDMOSFET) LDMOSFET 具有横向沟道结构，是一种用于功率应用的增强型 MOSFET。与传统 E-MOSFET 相比，器件在漏极和源极间的沟道更短。沟道更短使得电阻更小，因此允许更大的电压和电流。\n$$ 图4-65 ~~~LDMOSFET横向沟道结构横截面 $$ 图4-65给出了 LDMOSFET 的基本结构。当栅极为正时，在轻掺杂的源极和 $n^-$ 区域之间的 p 层内会感应出一个很短的 n 沟道。多数载流子通过 n 区域和感应沟道从源极移动到漏极，如图4-65所示。\nVMOSFET V形槽MOSFET是另一种用于更高功率的E-MOSFET，它利用垂直沟道结构，实现了漏极与源极之间更短、更宽且电阻更低的沟道。这样的沟道能允许更大的电流，从而允许更大的功耗。频率响应也有所改善。\n$$ 图4-66~~~VMOSFET垂直沟道结构的横截面 $$ VMOSFET 顶部有两个源极，一个栅极，底部有一个漏极，如图4-66 所示。在漏极($n^+$ 衬底，其中 $n^+$ 意味着比 $n^-$ 更高的掺杂)与源极之间的 V 形槽的两侧垂直感应出沟道。沟道长度由层的厚度决定，而厚度由掺杂浓度和扩散时间决定。\n$$ 图4-67~~~TMOSFET垂直沟道结构的横截面 $$ TMOSFET TMOSFET的垂直沟道结构如图4-67所示。栅极结构被嵌入到二氧化硅层中，源极覆盖了整个表面区域。漏极位于底部。TMOSFET比VMOSFET具有更高的封装密度，同时保持了短垂直沟道的优点。\n","date":"2023-07-14T17:38:25+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-7mosfet%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF/","title":"4.7 MOSFET开关电路"},{"content":"虽然 MOSFET 主要用于开关电路，但 JFET 和MOSFET 都能在类似于之前学习的 BJT 的CE、CC 和CB 放大器的三种电路组态中用作线性放大器。FET 组态有共源(CS)、共漏(CD)和共栅(CG)。CS 与 CD 放大器具有高输人阻抗和低噪声的特性，是第一级放大器的最佳选择。共栅放大器的应用不多，因此本书只对其进行简要介绍。\n学完本节后，你应该掌握以下内容:\n描述FET线性放大器的工作原理 描述三种 FET 线性放大器的组态:共源(CS)、共漏(CD)和共栅(CG) 在给定跨导的情况下计算任何 FET 放大器的增益 解释为什么具有电流源偏置的 CD 放大器比单级 CD 放大器更好 4.6.1 FET的跨导: FET的传输特性，即跨导曲线，如图4-9a所示。FET 和 BJT 有本质区别，因为 FET 是电压控制器件。输出的漏极电流由输入的栅极电压控制。跨导为交流参数，定义为:\n$$ g_m=\\frac{I_d}{V_{gs}} $$\n考虑到上式是输出电流($I_d$)除以输人电压($V_{gs}$)，因此跨导本质上是 FET 自身的增益。但和 $\\beta_{ac}$ 是纯数字不同，跨导有单位，为西门子(电阻的倒数)。许多数据手册会继续沿用旧单位姆欧(mho，将ohm反向拼写)。如图4-37a所示，一个特定 FET 的跨导可以直接测量得到。可以看到跨导是传输曲线的斜率，它不是一个常数，但取决于漏极电流。\n图4-37b给出了 BJT 输入的类似情况。基极电压加在发射结 pn 结上，它会看到一个取决于发射极直流电流的交流电阻。这个小的交流电阻对 BJT 放大器的增益发挥着重要影响，如3.4节所述。\n$g_m$ 的倒数与 BJT 的$r\u0026rsquo;_e$。类似。大多数 FET 的交流模型都将 $g_m$ 作为一个重要参数。但是，要从 BJT 放大器转变到FET 放大器，定义一个表示 FET 交流源电阻的参数还是很有用的.\n$$ r\u0026rsquo;_s=\\frac{1}{g_m} $$\n$$ a) n沟道FET传输曲线~~~~~~~~~~~~b) BJT传输曲线 $$\n$$ 图4-37~~~n沟道FET和BJT传输曲线的比较 $$\n$r\u0026rsquo;_s$ 的概念可以引出类似于第 3 章中推导得到的 BJT 的电压增益方程。JFET 的 $r\u0026rsquo;_s$ 的概念图如图4-38所示。栅极以虚线表示，用来表明从栅极来看，输人电阻接近无穷大(因为输人是反向偏置的二极管)。虽然栅极电压控制漏极电流，但利用的是可以忽略的栅极电流。遗憾的是，FET 的 $r\u0026rsquo;_s$ 并不像 BJT 的 $r\u0026rsquo;_e$ 那样容易预测，而且它通常比 $r\u0026rsquo;_e$\n大。数据手册并不会给出这一参数，但会给出 $g_m$ 的取值范围(有时也以 $y_{fs}$ 给出)，因此可以通过求典型 $g_m$ 值的倒数来获得 $r\u0026rsquo;_s$\n的近似值。例如，如果数据手册中的 $y_{fs}$ 为2 000μS，那么$r\u0026rsquo;_s= 500\\Omega$.\n4.6.2 共源放大器 JFET 图4-39为具有自给偏置的 n 沟道 JFET 的共源(CS)放大器。交流源通过电容耦合到栅极。电阻 $R_G$ 有两个作用: (a)保持栅极电压约为 0V 直流(因为 $I_{GSS}$ 非常小)，(b)它的值很大(通常几兆欧)，阻止对交流信号源产生负载作用。偏置电压通过 $R_S$ 上的压降来获得。旁路电容 $C_2$ 使 FET 源极为有效的交流地。\n信号电压使栅源电压在 Q 点附近上下波动，并造成漏极电流的波动。漏极电流增大时，$R_D$ 两端的压降也增大，从而造成漏极电压(对地)减小。\n漏极电流在 Q 点值附近上下波动，与栅源电压同相。漏源电压在 Q 点值附近上下波动，与栅源电压相位差180°，如图4-39所示。\nD-MOSFET 图 4-40为一个零偏置 n 沟道 D-MOSFET,交流源通过电容耦合到栅极。栅极电压约为直流 0V，源极接地，因此有$V_{GS}=0V$。\n$$ 图4-39~~~ JFET 共源放大器 $$\n$$ 图4-40~~~ 零偏置D-MOSFET共源放大器 $$\n信号电压使得 $V_{gs}$ 在 0 值附近上下波动，并引起 $I_d$ 的波动。$V_{gs}$ 往负方向的波动使得器件进入耗尽模式，并且使得 $I_d$ 减小。 $V_{gs}$ 往正方向的波动使得器件进人增强模式，并使得 $I_d$增大。\n$$ 图4-41~~~分压式偏置的E-MOSFET共源放大器 $$\nE-MOSFET 图 4-41为一个分压式偏置的 n 沟道 E-MOSFET，交流源通过电容耦合到栅极。栅极以正电压偏置，使得 $V_{GS}\u0026gt; V_{GS(th)}$。与 JFET 和 D-MOSFET 情况相同，信号电压使得 $V_{gs}$ 在 Q 点值附近上下波动。这一波动又引起 $I_d$ 的波动。器件完全工作在增强模式。\n电压增益 放大器的电压增益 $A_v$ 始终等于 $V_{out}/V_{in}$. 对 CS 放大器而言，$V_{in}$ 等于 $V_{gs}$(因为旁路电容的作用)，$V_{out}$ 等于交流漏极电阻 $R_d$ 两端产生的信号电压。对于空载的 CS 放大器来说，交流和直流漏极电阻相等，$R_d=R_D$。因此，$V_{out}= I_dR_d$.\n$$ V_v=\\frac{V_{out}}{V_{in}}=\\frac{I_dR_d}{V_{gs}} $$\n因为 $g_m=I_d/V_{gs}$，所以共源电压增益为:\n$$ V_v=-g_mR_d~~~(4-7) $$\n这是 CS 放大器传统的电压增益方程。式(4-7)中的负号表示 CS 放大器为反相放大器。CS 放大器的增益可以以与共射(CE)放大器类似的形式表示为交流电阻的比值。用$1/r\u0026rsquo;_s$代替$g_m$，电压增益可以写为:\n$$ V_v=-\\frac{R_d}{r\u0026rsquo;_s}~~~(4-8) $$\n与给出CE放大器的电压增益的式(3-10)进行比较: $A_v=-R_c/R_e$。两式中电压增益均为交流电阻的比值。\n输入电阻 因为 CS 放大器从栅极输人，所以晶体管的输人电阻非常高。已经知道在JFET中由于反向偏置 pn 结导致输入电阻很高，而在 MOSFET 中是由于绝缘栅结构产生。在实际中，通常可以将晶体管的输人电路看成开路。\n当忽略晶体管的内阻时，由信号源看到的输人电阻仅由偏置电阻决定。在自给偏置情况下，它就是栅极电阻 $R_G$，如图4-42中从栅极看进去的交流等效电路所示。\n$$ a)自给偏置~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)分压式偏置 $$\n在分压式偏置情况下，电源为交流接地，栅极仍然为开路。从交流源看过去，两个分压电阻为并联。所以输入电阻是$R_1$和 $R_2$ 的并联组合。\n$$ R_{in}\\approx R_1||R_2 $$\n4.6.3共漏放大器 共漏(CD)JFET 放大器如图4-44所示，其中标明了电压。电路中使用了自给偏置。输入信号通过耦合电容加到栅极，在源极端输出信号。电路中没有漏极电阻。此电路与 BJT 的射极跟随器类似，有时也称为源极跟随器. 这是一种广泛使用的 FET 电路，因为其具有很高的输入阻抗。\n$$ 图4-44~~~ JFET共漏放大器(漏极跟随器) $$\n电压增益 如同所有放大器中一样，电压增益为 $A_v=V_{out}/V_{in}$. 类似于射极跟随器,源极跟随器的理想电压增益为 1，但实际中会更小(通常介于0.5～1之间)。为了计算电压增益，可对如图4-45a所示的电路应用分压原理。首先，将电路简化为如图4-45b所示的交流等效电路。栅极电阻并不影响交流信号，所以并未画出。负载和源极电阻并联，并可合并为一个等效交流源极电阻 $R_s$，它与内阻 $r\u0026rsquo;_s(1/g_m)$ 串联。输人信号加在 $R_s$ 与 $r\u0026rsquo;_s$ 两端，但输出只从 $R_s$ 两端取出。因此，输出电压为\n$$ V_{out}=V_{in}(\\frac{R_s}{r\u0026rsquo;_s+R_s}) $$ $$ a)基本的自给偏置CD放大器~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)计算增益的简化交流电路 $$\n$$ 图4-45~~~电压增益的计算 $$ 除以 $V_{in}$ 就可以得到电压增益公式。\n$$ A_v=\\frac{R_s}{r\u0026rsquo;_s+R_s}~~~(4-9) $$ 同样，可以看到增益可以写成交流电阻比值的形式。如果你记住它基于分压定律，那么很容易记住这个式子。\n附录中推导得到的另一个电压增益公式为: $$ A_v=\\frac{g_mR_s}{1+g_mR_s}~~~(4-10) $$ 此式与式(4-9)有相同的结果。\n输入电阻 因为输人信号加在栅极，所以由输入信号源看到的输入电阻与之前讨论的 CS 放大器情况下的输人电阻相同。实际中，可以忽略晶体管输人的高电阻。输入电阻由偏置电阻决定，和 CS 放大器情况一样。对自给偏置而言，输入电阻等于栅极电阻 $R_G$。 $$ R_{in}\\approx R_G $$ 对于分压式偏置来说，由电源看到的分压电阻并联接地。因此对分压偏置而言，输入电阻为 $$ R_{in}\\approx R_1||R_2 $$ $$ 图4-47~~~电流源偏置的CD放大器 $$ 电流源偏置的CD放大器 通过加入电流源，CD放大器性能可显著提高，如图4-47所示。电流源不仅提供偏置(参见4.3节有关叙述)，还是CD放大器的负载。已经知道，电流源对交流信号而言相当于一个高阻值电阻，因此电压增益非常接近于理想值1.0。\n电流源负载带来的显著优势还包括有更高的输人电阻，更低的失真，以及在输人和输出端(没有耦合电容)直接耦合信号。常规的源极跟随器(在之前的例子中已给出)的输出电压叠加在一个与 $V_{GS}$(栅极电压为0V)大小相等的直流电平上。对于 p 沟道器件，直流偏移为负; 对 n 沟道器件，直流偏移为正。理想情况下，电流源偏置不会在输出上加上任何直流偏移。这一特性在一些场合非常有用，例如，示波器的前置放大器，它需要让信号的所有直流分量都能通过并传输到后面的垂直扫描放大器。\n为了获得最优结果，图4-47中的两个 FET 和两个电阻应该互相匹配。这意味着两个晶体管应该具有相同的传输和输出特性。两个晶体管具有相同的 $V_{GS}$(因为具有相同的漏极电流)。该漏极电流在两个电阻上产生相同的压降( $V_{GS}$ )，这就对偏置进行了补偿。这确保了当输入为 0V 时，输出接近于 0V。确保晶体管匹配的一种方法是使用双器件(在一个封装中有两个匹配晶体管)。\n4.6.4共栅放大器 $$ 图4-50~~~JFET共栅放大器 $$ 在本章引言中已经提到，共栅(CG)放大器因自身原因应用有限，但可以用于 FET 差分放大器的第二级(在第 6 章讨论)。CG 放大器在高频中也有应用。虽然其电压增益与 CS 放大器相当，但其输入电阻很低，失去了 FET 的主要优势之一。图4-50为一个基本的 CG 放大器。输入信号通过 $C_1$ 被加到源极，输出信号通过 $C_2$ 从漏极端取出。电压增益和 CS 放大器相同，但没有反相。 $$ A_v=\\frac{R_d}{r\u0026rsquo;_s} $$ 另一增益公式为: $$ A_v=g_mR_d $$ FET 的线性应用的主要优势是其高输入电阻。观察 CG 放大器，可以看到源极电阻与 $r\u0026rsquo;_s$ 并联。通常源极电阻非常大，可以忽略。因此输人电阻约为:\n$$ R_{in}\\approx r\u0026rsquo;s $$ 另外，输入电阻也可以表示为: $$ R{in}\\approx \\frac{1}{g_m} $$ 从此结果可以看出为何CG放大器的输入电阻很小。 $$ a) ~JFET共源共栅放大器~~~~~~~~~~~~~~~~~~~~~~~~~~~~b) ~MOSFET共源共栅放大器 $$\n$$ 图4-51~~~共源共栅放大器 $$ 共栅放大器的一个应用是共源共栅放大器。一个共源共栅放大器由共源和共栅放大器串联而成。JFET 共源共栅放大器如图4-51a所示。由两个匹配 D-MOSFET 构成的低电压共源共栅放大器如图4-51b所示。共源共栅放大器主要用于射频(RF)应用。\n","date":"2023-07-14T17:38:15+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-6fet%E7%BA%BF%E6%80%A7%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"4.6 FET线性放大器"},{"content":"如同 BJT 和 JFET，偏置电路确定合适的直流工作条件，为交流信号提供一个稳定的工作点。MOSFET 的偏置电路与之前介绍的 BJT 和 JFET 的偏置电路类似。特定的偏置电路取决于是否使用一个或者两个电源，以及 MOSFET 的类型(耗尽型或者增强型)。\n学完本节后，你应该掌握以下内容:\n讨论和分析 MOSFET 偏置电路 解释为什么 D-MOSFET 比其他任何类型的晶体管有更多的偏置选择 解释 0 偏置 讨论 E-MOSFET 的三种偏置方法 4.5.1 D-MOSFET偏置 D-MOSFET 在正或负的 $V_{GS}$ 下都能工作。当 $V_{GS}$ 为负时，器件工作在耗尽模式; 当 $V_{GS}$ 为正时，器件工作在增强模式。D-MOSFET 的优点是在这两种模式下都能工作，也是唯一一种具有此特性的晶体管。\n$$ 图4-31~~~~D-MOSFET的零偏置 $$ 零偏置 最基本的偏置方式是使 $V_{GS} =0V$，这样栅极上的交流信号使得栅源电压在该偏置点附近上下变化。图4-31 给出了这种偏置电路。因为该电路非常简单高效，所以它是最常用的 D-MOSFET 偏置方式。工作点设置在耗尽工作和增强工作之间。由于 $V_{GS} =0V$,因此 $I_D=I_{DSS}$，如图 4-31 所示。漏源电压可表示为: $$ V_{DS}=V_{DD}-I_{DSS}R_D $$ $$ a)~包含自给偏置的分压器 ~b）源极偏置~c)电流源偏置 $$\n$$ 图4-33~~~~D-MOSFET的其他偏置电路 $$ 其他偏置方式 D-MOSFET 能工作在耗尽或增强模式。因为这种多功能性，所以之前学习的 BJT 和 JFET 的任何偏置电路都能用于D-MOSFET。图4-33 给出了三种常见的偏置方法，但实际中可能还有其他偏置方法。\n图4-33a 中的偏置电路使用之前介绍的 JFET 的分压式偏置和自给偏置的组合。栅极电压可通过分压公式计算得到，这对所有 FET 器件都是准确的，因为可以忽略负载效应。栅极电压与 JFET 给出的相同(见式(4-5)): $$ V_G=(\\frac{R_2}{R_1+R_2})V_{DD} $$ 组成分压电路的电阻通常非常大(在兆欧级)，因为栅极的高输人电阻。其他电极的电压取决于特定的器件参数。\n当采用正负电源供电时，通常会采用如图4-33b所示的源极偏置。这与 BJT 的发射极偏置类似。理想状态下，栅极电路为开路，因此栅极电压为地电势。\n电流源偏置是运算放大器普遍采用的偏置方式，图4-33c 以 BJT 作为电流源的偏置方式。此外也可以采用其他电流源，如 FET 等。电流源设置源极和漏极电流的值。通过分析电流源(如例4-8)，根据欧姆定律可以计算漏极电阻上的压降。\n4.5.2 E-MOSFET偏置 $$ a）~漏极反馈偏置 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）~分压式偏置 $$\n$$ 图4-34~~~E-MOSFET的偏置方法 $$\nE-MOSFET 的 $V_{GS}$ 必须大于阈值电压 $V_{GS(th)}$。各种 BJT 偏置电路(除了基极偏置)通过设置合适的值，都能够用于 E-MOSFET。图4-34给出了两种常见的 n 沟道 E-MOSFET 的偏置方法。(D-MOSFET 也可以用这些方法进行偏置。)无论是漏极反馈偏置还是分压式偏置，目的都要使栅极电压和源极电压的差值大于 $V_{GS(th)}$.\n在图 4-34a 的漏极反馈偏置电路中，栅极电流可以忽略，因此 $R_G$ 上没有压降。于是，$V_{GS}=V_{DS}$。\n分压式偏置是对分压原理的直接应用。此外，由于高输人电阻，分压电路相当于没有负载，这样就可以利用式(4-5)准确计算栅极电压。\n4.5.3 IGBT $$ 图4-36~~~IGBT电路符号 $$ IGBT(绝缘栅双极晶体管)是-种具有 MOSFET 输入特性和 BJT 输出特性的器件. 其电路符号如图 4-36 所示。IGBT 本质上可看做一个电压控制的 BJT。由于它具有绝缘栅极而不是基极，因此没有输入电流，并且不会对驱动电路产生负载效应。IGBT 在某些方面优于 MOSFET，在另一些方面优于BJT。IGBT主要用于高压大电流开关应用中。\n","date":"2023-07-14T17:38:02+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-5mosfet%E5%81%8F%E7%BD%AE/","title":"4.5 MOSFET偏置"},{"content":"金属-氧化物半导体场效应管( MOSFET )是另一种重要的场效应管。MOSFET 和 JFET 的区别在于它没有 pn 结结构，而是 MOSFET 的栅极与沟道之间用非常薄的二氧化硅(SiO$_2$)层来相互绝缘。MOSFET 的两种基本类型为: 耗尽型(D)和增强型(E)。这两者中，E-MOSFET 使用更为广泛。由于现在栅极材料用多晶硅取代金属，因此有时也称 MOSFET 为 IGFET(绝缘栅 FET)。\n学完本节后，你应该掌握以下内容:\n解释 MOSFET 的工作原理 描述 MOSFET 在构造上的不同 画出 n 沟道和 p 沟道 D-MOSFET 和 E-MOSFET 的符号 解释 MOSFET 在耗尽模式和增强模式下如何工作 解释 MOSFET 的漏极特性曲线 描述 MOSFET 的跨导曲线，并解释它与漏极特性曲线的关系 讨论 MOSFET 器件的特定处理预防措施 4.4.1 D-MOSFET $$ a）n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ b) p沟道 $$ $$ 图4-22~~~~~~~~D-MOSFET的基本结构 $$ 耗尽型 MOSFET (D-MOSFET )是 MOSFET 的一种，其基本结构如图4-22所示。漏区和源区扩散到衬底材料中，然后通过靠近绝缘栅的窄沟道相连。图4-22给出了 n 沟道和 p 沟道 D-MOSFET，但是，p 沟道 D-MOSFET 并不广泛使用。这两种类型器件的工作原理相同，除了 p 沟道的电压极性与 n 沟道的相反。为了简单起见，本节只讨论n沟道器件。\nD-MOSFET 可以工作在两种模式: 耗尽模式或增强模式，因此有时又称为耗尽-增强 MOSFET。由于栅极与沟道绝缘，因此栅极电压可正可负。对 n 沟道 D-MOSFET 而言,当栅源电压为负时，器件工作在**耗尽模式**; 当栅源电压为正时,器件工作在增强模式。通常这些器件工作在耗尽模式。\n$$ a)耗尽模式:V_{GS}为负并且小于V_{GS(off)}~~~~~~~~~~~~~~~~~~~~~~~~b)增强模式:V_{GS}为正 $$ 耗尽模式 将栅极看成平板电容器的-个平板，沟道为另一个平板，二氧化硅绝缘层为电介质。当加上负的栅极电压时，栅极上的负电荷会排斥沟道中的导电电子，并在该位置上留下正离子。因此 n 沟道耗尽了部分电子，使得沟道的导电性下降。栅极上的负电压越大，n 沟道电子的耗尽就越严重。在一个足够大的栅源负电压，即 $V_{GS(off)}$ 下，沟道完全耗尽，漏极电流为 0。图4-23a 说明了这种耗尽模式。类似于 n 沟道 JFET，n 沟道 D-MOSFET 在介于 $V_{GS(off)}$ 和 0V 之间的栅源电压下传导漏极电流。此外， D-MOSFET 在 $V_{GS}$ 大于 0V 时也能传导电流。\n增强模式 当 n 沟道 D-MOSFET 加上正的栅极电压时，更多的传导电子被吸引到沟道，因此增强了沟道的导电性,如图4-23b所示。\n$$ a）n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）p沟道 $$\n$$ 图4-24~~~~D-MOSFET的电路符号 $$\nD-MOSFET 的电路符号 图 4-24 为 n 沟道和 p 沟道D-MOSFET 的电路符号。由箭头指示的衬底一般(但不总是)在内部与源极相连。有时也从衬底引出另一个电极。指向衬底的箭头表明是 n 沟道器件，从衬底指出的箭头表明是 p 沟道器件。\n由于 MOSFET 和 JFET 类似，都是场效应器件，因此你可能会认为 MOSFET 与 JFET 有类似的特性。这的确是事实。n 沟道 D-MOSFET 的传输特性($I_D$对$V_{GS}$)如图4-25所示。该曲线形状和之前学习的 n 沟道 JFET 的曲线(参见图4-9a)形状相同，但传输特性中 $V_{GS}$ 既有负电压，又有正电压，分别表示器件工作在耗尽区和增强区。图4-25所示曲线中，当 $V_{GS}$ 为 0V 时， $I_{D}$ 大约为 4.0mA。由于 $V_{GS}=0V$，因此这一点就是 $I_{DSS}$ 。可以看到 D-MOSFET 可以工作在电流大于 $I_{DSS}$ 的情况下，而 JFET 却不能。\n$$ 图4-25~~D-MOSFET的转移特性 $$\n4.4.2 E-MOSFET $$ a）基本结构~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)感应沟道(V_{GS}\u0026gt;V_{GS(th)}) $$\n$$ 图4-26~~E-MOSFET的结构和工作原理(n沟道) $$ 这种类型的 MOSFET 只能工作在增强模式，没有耗尽模式。和 D-MOSFET 的结构不同，它没有物理沟道。在图 4-26a 中可以看出，衬底完全延伸到 SiO$_2$ 层。\n对于 n 沟道器件，一个大于阈值电压 $V_{GS(th)}$ 的正栅极电压，能够在衬底与 SiO$_2$ 层相邻的区域产生薄的负电荷层，从而感应出一个沟道，如图 4-26b 所示。沟道的导电性可以通过增大栅源电压来提高，因为这可以使更多的电子进入沟道。对于任何低于阈值电压的栅极电压，不会产生沟道。\n$$ a）n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）p沟道 $$\n$$ 图4-27~~~~E-MOSFET的电路符号 $$ n 沟道和 p 沟道 E-MOSFET 的电路符号如图4-27所示。其中不连续的线表示器件没有物理沟道。\n因为如果栅极上没有加上电压则没有沟道存在，所以E-MOSFET可以被看成一个常关器件。此外，它的传输特性与JFET和 D-MOSFET的有相同的形状，但是现在 n 沟道器件的栅极必须为正以使得器件导通。这意味着对于 n 沟道E-MOSFET来说 $V_{GS(off)}$ 是一个正电压。典型的特性如图4-28所示。将它与图4-25中的 D-MOSFET 特性进行比较。 $$ 图4-28~~~典型E-MOSFET的传输特性 $$\n4.4.3双栅极MOSFET $$ a)D-MOSFET~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)E-MOSFET $$ $$ 图4-29~~~~双栅极n沟道MOSFET电路符号 $$ 双栅极 MOSFET 要么是耗尽型，要么是增强型。唯一的区别是它有两个栅极，如图 4-29 所示。FET 的一个缺陷是输入电容很大，这限制了其在高频中的应用。使用双栅极器件可以减小输人电容，这样器件就可以在高频射频放大器应用中有更好的使用。双栅极组态的另一个优点是它可以在射频放大器中实现自动增益控制(AGC)输入系统例子4-1 中给出了另外一个应用，其中第二个栅极上的偏置用来调整跨导曲线。\n4.4.5预防措施 由于 MOSFET 的栅极与沟道绝缘，因此输入电阻非常高(理想情况下为无穷大)。对一个典型 MOSFET 来说，它的栅极泄漏电流 $I_{GSS}$ 为皮安级，而典型 JFET 的栅极反向电流为纳安级。当然，输人电容来源于绝缘栅的结构。因为输入电容与非常高的输入电阻组合在一起会积累过量的静电，并可能会因为静电放电(ESD)而造成器件损坏。事实上，ESD 是 MOSFET 损坏的最大原因。为了避免 ESD 和可能带来的损坏，应该要采取以下预防措施。\n金属-氧化物半导体(MOS)器件应该用导电泡沫运输和存储。 用于组装和测试的所有仪器与金属台必须接到地球地(墙外用圆形针) 组装者或操作者的手腕必须用长电线和高阻值串联电阻接地。 永远不要在电源接通的情况下移除 MOS 器件(或者其他任何器件)。 不要在直流电源关闭的时候向 MOS 器件加上任何信号。 ","date":"2023-07-14T17:37:50+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-4mosfet%E7%89%B9%E6%80%A7/","title":"4.4 MOSFET 特性"},{"content":"利用前几节学习的 JFET 的相关特性，现在我们将会看到如何对 JFET 进行直流偏置。偏置的目的是选择合适的栅源电压来获得期望的漏源电流。由于栅极反向偏置，因此 BJT 的偏置方式并不适用于 JFET。\n学完本节后，你应该掌握以下内容:\n描述 JFET 的三种偏置方法并解释它们的工作原理 利用`跨导曲线来选择自给偏置电阻的合理值`` 解释分压式偏置或电流源偏置如何产生更稳定的 Q 点 4.3.1JFET的自给偏置 FET 的偏置相对简单。接下来以 n 沟道 JFET 为例。记住，p 沟道 JFET 只需要改变极性。对于 n 沟道 JFET，建立反向偏置需要负的 $V_{GS}$。这可以利用如图4-11所示的自给偏置电路来实现。注意，通过电阻 $R_G$ 接地，将栅极偏置在 0V。虽然反向泄漏电流 $I_{GSS}$ 在 $R_G$ 两端产生一个非常小的电压，但在大多数情况下都可忽略它。可以假设 $R_G$ 上面没有电流流过，两端也没有压降。 $R_G$ 的作用是使得栅极电压稳定在 0V，且不影响之后施加的任何交流信号。由于栅极电流可以忽略， $R_G$ 可以非常大(通常取 1.0M$\\Omega$ 甚至更大)，从而对低频交流信号会呈现非常高的输入电阻。\n$$ 图4-11~~~ n沟道JFET的自给偏置 $$ 如果栅极电压为 0，如何获取所需的栅源结的反向偏置? 答案是使源极相对于栅极为正，以达到需要的反向偏置。对于图4-11中的 n 沟道 JFET 而言，$I_D$ 在 $R_S$ 两端产生一个压降(极性如图4-11所示)，使得源极相对于栅极为正。因为 $V_G=0V，V_S=I_DR_S$，所以栅源电压为: $$ V_{GS}=V_G-V_S-I_DR_S $$ 因此有: $$ V_{GS}=-I_DR_S $$ 该结果表明栅源电压为负，得到了所需的反向偏置。在本分析过程中，以 n 沟道 JFET 为例来说明。同样 p 沟道 JFET 也需要反向偏置，但所有电压的极性都和 n 沟道 JFET 中的相反。\n漏极相对于地的电压为: $$ V_D=V_{DD}-I_DR_D~~~(4-3) $$ 由于 $V_S=I_DR_S$，因此漏源电压为: $$ V_{DS}=V_D-V_S \\\\ V_{DS}=V_{DD}-I_D(R_D+R_S)~~~(4-4) $$\n4.3.2图解法 已经知道电阻 $R$ 的 $Ⅰ-V$ 曲线是斜率为 $1/R$ 的直线。为了比较自给偏置电阻曲线和跨导曲线，将两条曲线都画在第二象限中，其中电阻曲线的斜率为 $-1/R$。\n$$ 图4-13~~~自给偏置的图解分析 $$ 本节利用 MPF3821 的跨导特性曲线来说明如何选择合适的自给偏置电阻($R_S$)的阻值。假设 MPF3821 的跨导曲线如图4-13所示。从原点到 $V_{GS(off)}(-4V)$ 与 $I_{DSS}(2.5mA)$ 的交点画一条直线。这条直线的斜率的倒数就是 $R_S$ 的合适取值。 $$ R_S=\\frac{|V_{GS(off)}|}{I_{DSS}}=\\frac{4V}{2.5mA}=1.6k\\Omega $$ 其中利用了 $V_{GS(off)}$ 的绝对值。这两条曲线的交点就是 Q 点。Q 点表示 $V_{GS}$ 和 $I_D$，本例中 $V_{GS(off)} =-1.5V$， $I_D=0.95mA$。\n自给偏置是一种负反馈，能够补偿不同 JFET 之间不同器件特性的影响。例如，假设用一个低跨导的晶体管替换现有晶体管，那么新的漏极电流会减小，使得 $R_S$ 上的压降减小。电压的减小会使 JFET 导通更多，补偿了新晶体管的低跨导的影响。下述两例很好地说明了一系列跨导曲线的影响。\n4.3.3分压式偏置 虽然自给偏置方法在多数情况下令人满意，但可以看出，工作点取决于跨导曲线。通过在栅极电路上增加分压电路，使得栅极电压为正，可以使偏置更稳定。由于 JFET 一定由要在栅源间是反向偏置的条件下才能工作，因此要使用一个比一般自给偏置中更大的源极电阻。电路如图 4-17 所示。\n$$ 图4-17~分压式偏置 $$ 对 $R_1$ 和 $R_2$ 利用分压定律可求得栅极电压为: $$ V_G=(\\frac{R_2}{R_1+R_2})V_{DD}~~~(4-5) $$ 记住,如果正在对任何 JFET 电路进行故障检测，那么源电压必须等于或大于栅极电压。$R_D$ 和 $R_S$ 中都有漏极电流流过。由于 $I_D$ 取决于 JFET 的跨导，因此无法仅仅从电路值中来确定 $V_D$ 和 $V_S$ 的精确值,因为 JFET 的制造中存在差异。通常，在 JFET 线性放大器的设计中，$V_{DS}$ 一般在 $V_{DD}$ 的 25%～50% 的范围内。即使不知道晶体管的参数,你也能通过检查 $V_{DS}$ 的值,来确认正确设置了偏置。\n4.3.4电流源 $$ a)理想电流源的I-V曲线 $$ $$ b)理想电路模型 $$ $$ c)实际电路模型 $$ $$ 图4-19~~电流源。电流源符号中的箭头始终指向电源正极 $$\n在讨论电流源偏置之前，首先复习一下电流源。理想电流源是一种无论连接任何负载，都能提供一个固定电流的器件。理想电流源的 $I-V$ 曲线如图 4-19a 所示，这是一条水平直线。已经知道，$I-V$ 曲线的斜率与电阻值成反比。 $I-V$ 曲线为水平直线，意味着理想电流源的内阻为无穷大。理想电流源的电路模型如图 4-19b 所示。\n已经看到 FET 和 BJT 的特性曲线上都有恒流区。该区域中的特性曲线几乎是一条水平直线，表明内阻确实非常高。对于大多数应用，可假定 FET 或者 BJT 是理想电流源。在那些需要考虑内阻的情况下，可以使用1.3节讨论的诺顿模型。实际电流源的诺顿模型如图 4-19c 所示，其中诺顿电阻表示电流源的内阻。\n4.3.5 电流源偏置 这种偏置形式在集成电路中广泛使用，但需要一个额外的晶体管。一个晶体管作为电流源来使 $I_D$ 保持固定不变，它是一种非常稳定的偏置形式。电流源偏置也能提高增益，后面会看到。\n图4-20给出了电流源偏置的两个例子。在图4-20a中，$Q_2$是 JFET 恒流源，为 $Q_1$ 提供电流。电流大小由 $Q_2$ 的 $I_{DSS}$ 和 $R_S$决定。由于不同的晶体管 $I_{DSS}$ 不同，因此电流大小取决于所选择的特定晶体管。电流源不能提供大于 $Q_1$ 的 $I_{DSS}$ 的电流，以确保 $Q_1$ 的 $V_{GS}$ 为负。\n对于晶体管间的一-致性，图4-20b中的组态更好。此时 BJT 提供电流。因为基极接地，并且发射结正向偏置，所以发射极电压为 $-0.7V$。这意味着 $R_E$ 两端有恒定电压，也就是 JFET 中有恒定电流。同样，此电流要小于$Q_1$ 的 $I_{DSS}$ 。\n","date":"2023-07-14T17:37:37+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-3jfet%E5%81%8F%E7%BD%AE/","title":"4.3 JFET偏置"},{"content":"本节将介绍 JFET 是如何作为电压控制、恒流器件工作的，也将讨论漏极特性曲线和跨导曲线，以及 JFET 的截止、夹断与 JFET 的输入电阻和电容等内容。\n学完本节后，你应该掌握以下内容:\n描述结型场效应管(JFET)的结构和工作原理 画出 n 沟道或 p 沟道 JFET 的符号 解释 JFET 的漏极特性曲线，包括可变电阻区和恒流区 解释参数 $g_m、I_{DSS} 、I_{GSS} 、C_{iss} 、V_{GS(off)}和 V_P$ 描述 JFET 的跨导曲线并且解释它与漏极特性曲线的关系 4.2.1 JFET 工作原理 $$ a) n沟道~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b)p沟道 $$\n$$ 图4-2~~~~~两种JFET的基本结构 $$ 图4-2a给出了 n 沟道结型场效应管(JFET)的基本结构。电线连接到 n 沟道的两端，在图4-2中漏极位于上端，源极位于下端。沟道是一个导体: 对 n 沟道 JFET 而言,电子是载流子;对 p 沟道 JFET 而言，空穴是载流子。在没有外加电压的情况下，沟道在两个方向都能导通电流。\n在 n 沟道器件中，将 p 型材料掺杂到 n 沟道中来形成 pn 结，并连接到栅极。图 4-2a 显示的是将 p 型材料掺杂进两个区域，这两个区域一般由制造商在内部进行连接形成单个栅极。(一种专用JFET，也称为双栅 JFET，有独立的电极连接到两个区域。)在结构图中，为了简单起见，两个 p 型区域之间的连接被省略掉，只给出到其中一个区域的连接。图4-2b给出了力沟道 JFET。\n如前所述，JFET 中的沟道是栅极和源极之间的一个窄导电通路。沟道的宽度, 也就是沟道的导电能力，是由栅极电压控制的。当没有栅极电压时，沟道能通过最大的电流。当栅极施加反向偏置时，沟道宽度变窄，导电能力下降。\n$$ a)~~~JFET的导通偏置 $$ 为了说明上述过程，在一个 n 沟道器件上加上一个一般的工作电压，如图4-3a所示。$V_{DD}$ 提供了一个正的漏源电压，使电子由源极向漏极流动。对 N 沟道 JFET 而言，栅源结的反向偏置由负的栅极电压实现。如图4-3所示，$V_{GG}$ 设置了栅极与源极之间的反向偏置电压。注意，FET 中没有任何正向偏置的 pn 结; 这也是 FET 和 BJT 的主要区别之一。\n$$ b)~~V_{GG}增大将使沟道（白色区域之间)变窄，从而使沟道电阻增大，I_D 减小 $$\n$$ c)~~V_{GG} 减小将使沟道（白色区域之间)变宽，从而使沟道电阻减小，I_D 增大 $$\n$$ 图4-3~~V_{GG}对沟道宽度、电阻和漏极电流的影响(V_{GG}=V_{GS}) $$\n通过改变栅极电压，可以控制沟道宽度和沟道电阻，从而控制漏极电流 $I_D$，这个概念在图 4-3b 和 c 中说明。其中，白色区域表示的是由反向偏置产生的耗尽区。在沟道的漏极一端，该区域更宽，因为栅极和漏极之间的反向偏置电压比栅极和源极之间的反向偏置电压更大。\n4.2.2 JFET符号 $$ a)n沟道 b) p沟道 $$\n$$ 图4-4~~JFET电路符号 $$ n 沟道和 p 沟道 JFET 的电路符号如图 4-4 所示。可以看到漏极上的箭头方向，对 n 沟道而言是“指向里”，对 p 沟道而肓是“指向外”。\n4.2.3漏极特性曲线 FET 的漏极特性曲线是漏极电流 $I_D$ 对漏源电压 $V_{DS}$ 之间的关系曲线，和 BJT 的集电极电流 $I_C$ 对集电极发射极间电压 $V_{CE}$ 曲线相对应。但是 BJT 特性曲线和 FET 特性曲线之间有很多重要差别。由于 FET 是一个电压控制器件，因此 FET 特性曲线上的第三个变量($V_{GS}$)的单位是电压，而 BJT 中是电流($I_B$)。本节介绍 n 沟道器件的漏极特性。p 沟道器件工作原理相同，但是极性相反。通常来说，n 沟道 JFET 比对应的 p 沟道 JFET 具有更好的指标，因此前者更为流行。 $$ a)在V_{GS}=0V，V_{DS} (V_{DD})变化的情况下JFET的工作~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ b)漏极特性 $$ $$ 图4-5~~V_{GS}=0V时JFET的漏极特性曲线(其中给出了夹断电压) $$ 考虑 n 沟道 JFET 栅源电压为0($V_{GS} =0V$)的情况。0电压通过短接栅极和源极来实现，在图4-5a中，将栅极和源极都接地。随着 $V_{DD}$(此情况下也就是 $V_{DS}$)从 0V 开始增大，$I_D$ 也会相应增大，如图4-5b中 A 点和 B 点之间的曲线所示。在该区域中，沟道电阻基本是常数，因为耗尽区不大，不会产生较大的影响。该区域称为可变电阻区，因为 $V_{DS}$ 和 $I_D$ 之间的关系遵循欧姆定律。通过栅极电压可以改变电阻值的大小，因此可以将 JFET 作为电压控制的电阻使用。在后面的图 10-11(文氏桥)中给出了一个应用。更多应用可以参考配套实验练习手册中的实验14、15和27。\n在图 4-5b 中的 B 点处，曲线变为水平，$I_D$ 开始基本保持不变。随着 $V_{DS}$ 从 B 点增大到 C 点，栅极到漏极之间的反向偏置电压($V_{GD}$)使得耗尽区变大到足以抵消 $V_{DS}$ 增大的影响，因此使 $I_D$ 基本不变。这一区域称为恒流区。\n4.2.4夹断电压 当 $V_{GS} =0V$ 时，$I_D$变为几乎恒定(图4-5b中曲线上的 B 点)时，对应的 $V_{DS}$ 的值称为夹断电压，$V_P$. 注意，对于 n 沟道 JFET 而言，夹断电压为正值。对于给定的 JFET，$V_P$ 为确定的值。可以看出，当 $V_{DS}$ 超过夹断电压并继续增大时，对应的漏极电流几乎为常数。该漏极电流值为 $I_{DSS}$(栅极短路时漏极到源极电流)，通常会在 JFET 的数据手册中给出。$I_{DSS}$ 是给定的 JFET 能够产生的最大漏极电流，与外部电路无关，并始终在 $V_{GS}=0V$ 的条件下确定。\n继续分析图4-5b，在 C 点会发生击穿，此时对于 $V_{DS}$ 的任何进一步增加，$I_D$ 开始快速增大。因为击穿可能会造成器件不可逆的损坏，所以 JFET 通常工作在击穿以下区域，并通常在恒流区内(图4-5b中的 B 点和 C 点之间)工作。因此恒流区也被称为工作区。\n4.2.5 $V_{GS}$控制 I_D $$ a)JFET偏置在 V_{GS}=-1V~~~~~~~~~~~~~~~~~~~~~~~~ b)漏极特性曲线族 $$ 在栅极与源极之间连接上一个偏置电压 $V_{GG}$，如图 4-6a 所示。通过调整 $V_{GG}$，使 $V_{GS}$ 往负值增大，可以得到如图 4-6b 所示的一族漏极特性曲线。注意，随着 $V_{GS}$ 变为更大的负值，$I_D$减小，因为沟道变窄。也可以看到对于每一组 $V_{GS}$ ，JFET 在小于 $V_P$ 的 $V_{DS}$ 值下达到夹断状态(恒流开始的位置)。由此可见，$V_{GS}$可以控制漏极电流的大小。\n4.2.6截止电压 使得 $I_D$ 的值接近于 0 的 $V_{GS}$ 称为截止电压，记为 $V_{GS(off)}$, JFET 必须工作在$V_{GS}=0V$ 和 $V_{GS(off)}$ 之间.随着栅源电压在此范围内变化， $I_D$ 最大可达到 $I_{DSS}$ ，最小达到接近于零.\n如前所述，对 n 沟道 JFET 而言，$V_{GS}$ 越往负值变大，恒流区中的 $I_D$ 值就越小。当 $V_{GS}$ 是一个足够大的负值时， $I_D$ 减小到 0。这一截止效应的产生是由于耗尽区不断变宽，最终完全关闭沟道，如图 4-7 所示。\n$$ 图4-7~~~截止的 ~JFET $$\n4.2.7夹断和截止的比较 夹断电压在漏极特性中测量得到。对 n 沟道器件而言，夹断电压为正，是当 $V_{GS}=0V$ 时漏极电流变为恒定时的 $V_{DS}$。截止电压也可以在漏极特性中测量得到，是使得漏极电流变为零时的栅源电压，为负值。\n$V_{GS(off)}$ 和 $V_P$ 始终大小相等，但符号相反。数据手册通常会给出 $V_{GS(off)}$ 或 $V_P$ 的值，但不会同时给出。但是，一旦知道其中一个，就能得到另一个。例如，如果 $V_{GS(off)}=-5V$，则$V_P=+5V$。\n4.2.8 JFET 跨导曲线 描述电路的一种有用方式是给出输出和输人之间的关系，如1.4节中对放大器所做的一样。这一特性称为传输曲线。\n因为 JFET 由输人端(栅极)的负电压控制，并且输出是漏极电流，所以传输曲线是 $I_D$ 关于 $V_{GS}$ 的函数，其中 $I_D$ 对应 y 轴， $V_{GS}$ 对应 x 轴。当输出单位(mA)除以输人单位(V)时，结果是电导单位(mS)。可以将输入端传输到输出端的电压看成电沉，囚此在电导前面加上前缀“跨”形成跨导这个词语。跨导曲线是 FET 的输出特性( $I_D$ 对 $V_{GS}$ )曲线。在数据手册中一般以 $g_m$ 或者 $y_{fs}$ 来给出跨导。\n$$ a）跨导曲线 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~b）漏极曲线 $$\n$$ 图4-9~~MPF102 n沟道JFET的典型特性曲线 $$\nn 沟道 JFET 的典型跨导曲线如图 4-9a 所示。一般来讲，所有类型的 FET 都有相同形状的跨导曲线。其中，曲线是 MPF102的典型曲线，这是一种通用的 n 沟道 JFET。\n跨导特性与图 4-9b 所示的漏极特性直接相关。注意，这两条曲线都有相同的纵坐标 $I_D$。跨导是一个交流参数，其值可在曲线的任何点上通过漏极电流的变化除以栅源电压的变化得到。 $$ g_m=\\frac{△I_D}{△V_{GS}} $$ 此式可写成交流形式为: $$ g_m=\\frac{I_d}{V_{gs}}~~~(4-1) $$ 跨导特性曲线并不是一条直线，这表明输出电流和输入电压间的关系是非线性的。这非常重要: FET 具有非线性的跨导曲线。这意味着 FET 可能会造成输入信号的失真。失真并不总是负面的，例如，在射频混频器中，JFET 因为失真特性反而较 BJT 有优势。然而，也有一些 JFET(例如 2N4339)通过几何设计使得失真最小，以便用于音频处理。此外，设计者也能通过保持较小的信号幅度(小于约 100mV)来减小失真。还有其他设计方法(如系统例子4-2中所使用的偏置方法)也用来减小失真。\n4.2.9 JFET 输入电阻和电容 已经知道，pn 结在反向偏置时具有很高的电阻, 而 JFET 工作时栅源结反向偏置，因此栅极的输入电阻很大。这是 JFET 与 BJT 相比的一个主要优势，因为后者的发射结正向偏置。\nJFET 的数据手册通常会通过给出特定栅源电压下的栅极反向电流 $I_{GSS}$ 来指明输入电阻。输入电阻可由下面的公式计算，其中竖线表示绝对值。 $$ R_{IN}=|\\frac{V_{GS}}{I_{GSS}}|~~~~(4-2) $$ 例如，2N5457 的数据手册给出在 25℃，$V_{GS}=-15V$ 时，$I_{GSS}$ 最大值为 -1nA。用上述值可以计算得到输入电阻为 $$ R_{IN}=|\\frac{V_{GS}}{I_{GSS}}|=\\frac{15V}{1nA}=15G\\Omega $$ 从结果可以看出，该 JFET 的输入电阻非常高。但是，随着温度升高，$R_{IN}$ 会明显下降(如例子4-3所示)。\n输入端反向偏置的 pn 结的高电阻与反向偏置的二极管相关，但这也意味着 JFET 通常会有比 BJT 更大的输人电容值。已经知道反向偏置的 pn 结相当于一个电容，其电容值取决于反偏电压的大小(见2.8节)。JFET 的输入电容 $C_{iss}$ 比 BJT 的要高，因为其 pn 结反向偏置。例如，在 $V_{GS}=0V$ 时 2N5457 的 $C_{iss}$ 最大为 7pF。\n","date":"2023-07-14T17:37:26+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-2jfet%E7%89%B9%E6%80%A7/","title":"4.2 JFET特性"},{"content":"目标 描述场效应管(FET)的基本分类 描述结型场效应管(JFET)的结构和工作原理 描述JFET的三种偏置方法以及它们的工作原理 解释金属-氧化物半导体场效应管(MOSFET)的工作原理 讨论和分析MOSFET偏置电路 描述FET线性放大器的工作原理 讨论MOSFET模拟和数字开关电路 本章介绍场效应管(FET)，一种与双极结型晶体管(BJT)工作原理完全不一样的晶体管。虽然FET的发明要比 BJT 早数十年，但直到20世纪60年代，FET 才实现了商业生产。在某些应用中，FET 优于 BJT。在其他领域，一般混合采用两种晶体管，以获得性能最优的电路。FET主要分为两类，一类称为结型场效应管(JFET)，另一类称为金属-氧化物半导体FET(MOSFET)。尽管 MOSFET 是实际中更为常用的器件，但是 JFET 的结构更加简单，和 MOSFET 也有很多相同的基本特性，因此本书还是首先讨论 JFET 的相关内容。\n在本章中，JFET 和 MOSFET 在不同的小系统中给出。每个小系统都说明了利用这些晶体管独有特性的例子。此外，每个系统例子说明了场效应管的不同应用，包括线性放大器和开关电路。本章最后介绍一个利用 MOSFET 开关电路的太阳能跟踪系统。\n4.1FET的结构 已经知道双极结型晶体管(BJT)是一种电流控制器件，即基极电流控制集电极电流。场效应管(FET)是电压控制器件，其中栅极电压来控制流经器件的电流。BJT 和 FET 均可作为放大器使用，也都可用于开关电路。\n学完本节后，你应该掌握以下内容:\n描述场效应管(FET)的基本分类 讨论 FET 和 BJT 的主要差别 4.1.1 FET系列 场效应管(FET)是以与 BJT 的原理工作完全不同的一类半导体。在 FET 中，在称为源极(Source)和漏极(Drain)的两个电极之间由一条窄导电沟道相连。该沟道要么由 n 型材料，要么由 p 型材料制成。正如名字中的“场效应”指出的那样，沟道的导通由一个电场控制，该电场由施加在第三个电极即栅极(Gate)上的电压形成。在结型场效应管(或JFET)中，栅极和沟道之间形成了一个 pn 结。另一种场效应管称为金属-氧化物半导体场效应管(MOSFET)，它利用绝缘的栅极来控制沟道的导通(绝缘栅和 MOSFET 指同一种器件)。绝缘层是一层很薄(\u0026lt;lμm)的玻璃(通常是 $SiO_2$)。图4-1是 FET 系列的一个概览，展示了目前各种种类的场效应管。本章将讨论这些所有种类的场效应管。 $$ 图4-1~~~~场效应管的分类 $$ 事实上，FET 的有关构想要远远早于 BJT。早在1925年，J.E. Lilienfeld就申请了 FET 的专利(在1930年生效)，但直到20世纪60年代，FET 才得到商业化应用。今天，MOSFET用在大部分的数字集成电路中，因为 MOSFET 与 BJT 相比有几个巨大优势，特别是在制造大规模集成电路的时候。MOSFET 之所以成为数字电路中采用的主要晶体管，主要有以下原因。它们可以制造在比 BJT 更小的面积上，并且，它们非常容易制造在集成电路上。此外，它们还可以得到不含电阻和二极管的更简单电路。所有微处理器和计算机内存都采用 FET 技术。4.7节会简要介绍FET如何在集成电路中进行使用。\n与BJT相比，FET 会有更多的系列。不同种类的 FET 间的区别之一主要是它们的直流特性。例如，JFET 的偏置就和增强型MOSFET 不同。因此，本章分别讨论每种类型的直流偏置特性。幸好，偏置电路非常容易理解。在介绍偏置电路之前，将首先讨论FET系列中不同种类晶体管的特性。\n所有 FET 的共同特征是具有非常高的输入电阻和低电噪。此外，JFET 和 MOSFET 对交流信号的响应方式也相同，并且有相似的交流等效电路。JFET 具有高输人电阻是因为输入 pn 结一直工作在反向偏置状态，而 MOSFET 的高输人电阻来源于绝缘栅。尽管所有 FET 都具有高输人电阻，但并不具有 BJT 一样的高增益。BJT 的线性也优于 FET。在某些应用场合，采用 FET 更好;在其他一些应用场合，采用 BJT 更好。许多设计使用两种类型的晶体管，往往同时采用 FET 和 BJT。因此，你需要同时理解这两种晶体管。\n","date":"2023-07-14T17:37:12+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/4-1fet%E7%9A%84%E7%BB%93%E6%9E%84/","title":"4.1 FET的结构"},{"content":"之前的章节讨论了晶体管作为线性放大器的应用，其另一个主要应用是在数字系统中作为开关。最初数字电路的大规模应用是在电话系统中。现在，计算机成为使用集成电路(IC)的开关电路的最重要应用领域。当需要提供比从 IC 上能够获得的更高的电流或者需要在不同的电压下工作时，会使用分立晶体管开关电路。\n学完本节后，你应该掌握以下内容:\n解释怎样将晶体管用作开关 计算晶体管开关的饱和电流 解释一个具有迟滞的晶体管开关电路如何改变状态 $$ a)截止\u0026mdash;-打开的开关 $$ $$ b)饱和——闭合的开关 $$ $$ 图3-45~~~~晶体管的理想开关特性 $$ 图3-45说明了晶体管用作开关的基本工作原理。开关是具有打开或关闭两种状态的设备。在图3-45a中，晶体管处于截止状态，因为发射结没有正向偏置。在该状态下，集电极和发射极之间理想情况下为开路，可以用一个打开的开关来等效。在3-45b中，晶体管处于饱和状态，因为发射结正向偏置，并且基极电流大到足以使集电极电流达到其饱和值。在该状态下，集电极和发射极之间理想情况下为短路，可以等效为闭合的开关。实际上，当处于饱和状态时，晶体管上一般会有一个几十分之一伏大小的压降。\n3.7.1截止状态 如前所述，当发射结没有正向偏置时，晶体管处于截止状态。忽略泄漏电流，总电流为零，$V_{CE}$等于 $V_{CC}$. $$ V_{CE(cutoff)}=V_{CC} $$\n3.7.2饱和状态 当发射结正向偏置且有足够的基极电流来产生最大集电极电流时，晶体管处于饱和状态。因为 $V_{CE}$ 在饱和状态下非常小，所以整个电源电压都作用在集电极电阻上。集电极电流近似为 $$ I_{C(sat)}\\approx \\frac{V_{CC}}{R_C} $$ 能够产生饱和的最小基极电流为 $$ I_{B(min)}\\approx \\frac{I_{C(sat)}}{\\beta_{DC}} $$ $I_B$ 应该远大于 $I_{B(min)}$ 才能使晶体管较好地保持在饱和状态，而且满足不同晶体管的不同 $\\beta$ 值。\n3.7.3单晶体管开关电路的改进 $$ 图3-47~~~具有陡门限的两晶体管开关电路 $$ 图3-45所示的基本开关电路通过门限电压控制其工作状态从开到关或从关到开变化。遗憾的是，该门限并不是一个绝对点﹐因为晶体管能够在截止和饱和之间的状态工作,这种状态在开关电路中是不希望出现的。加入第二个晶体管可以显著改善开关动作，提供一个更陡的门限电压。该电路如图 3-47 所示，其中用发光二极管(LED)作为输出显示，这样就可以观察开关行为了。该电路工作状况如下。当 $V_{IN}$ 很小时，因为电路并不能提供足够的基极电流，所以 $Q_1$ 截止。 $Q_2$ 处于饱和状态，因为它能够通过 $R_2$ 获得足够的基极电流，并且LED会发光。随着 $Q_1$ 基极电压增大， $Q_1$ 开始导通。当 $Q_1$ 接近饱和时， $Q_2$ 基极电压突然下降，导致它迅速从饱和状态切换到截止状态。 $Q_2$ 的输出电压降低，LED灭掉。\n$$ 图3-48~~~迟滞导致电路在C点和E点发生变换，在其他各点不发生变换 $$ 基本切换电路的另一个改进是增加迟滞。对开关电路而言,迟滞意味着有两个门限电压值,这取决于输出电压是高还是低。图3-48说明了这种情况。当输入电压增大时，它必须跨过上门限值才能使开关发生切换动作。它不会在 A 点或 B 点发生切换，因为下门限不起作用。当信号在 C 点跨过上门限时，输出发生切换，门限也瞬间变为小的阈值。输出并没有在 D 点切换回来，而是必须跨过 E 点的下门限才能返回最初的状态。再一次，因为门限值切换到上门限值，所以在 F 点并不会发生开关动作。开关电路中迟滞的主要优点在于其抗噪能力。从本例中可以看出，尽管输入噪声很强，但是输出仅改变了两次。\n$$ 图3-49~~~具有迟滞的分立晶体管开关电路 $$ 图3-49给出了具有迟滞的晶体管电路图。随着电位计往一个方向调整，输出会切换一次，即使电位计具有噪声。当输出切换时，共发射极电阻 $R_E$ 使门限电压发生改变。这由两个晶体管不同的饱和电流所引起。当输出处于截止和饱和状态时，会有不同的门限值。\n","date":"2023-07-14T17:36:19+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-7%E5%BC%80%E5%85%B3%E5%9E%8B%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/","title":"3.7 开关型双极型晶体管"},{"content":"第三种基本的放大器组态为共基极(CB)放大器。CB 放大器能够提供高电压增益，但输入电阻较小。由于这个原因，其应用并不像其他两种那样广泛，但会在某些高频应用和称为差分放大器的电路中使用，该差分放大器将在第6章中讨论。\n学完本节后，你应该掌握以下内容:\n理解和分析 CB 放大器的工作原理 画出 CB 放大器的交流等效电路 计算 CB 放大器的电压增益、输入电阻和输出电阻 $$ a）典型的CB放大器 $$ $$ b)交流等效电路 $$ $$ 图3-42 ~~~~CB 放大器及其交流等效电路 $$ 图3-42a为分压式偏置的典型共基极(CB)放大器。由于存在 $C_3$，所以基极为信号地(交流地)，输入信号加在发射极。输出通过 $C_2$ 从集电极耦合到负载电阻。图3-42b给出了其交流等效电路。电容和直流电源用短路代替，这使得偏置电阻在等效电路中也被短路。该电路与共发射极电路的基本差别在于信号如何加入放大器中。\n3.6.1电压增益 如同 CE 与 CC 放大器，CB 放大器的电压增益也为 $V_{out}/V_{in}$。对于 CB 放大器而言，$V_{out}$ 为集电极交流电压 $V_c$，$V_{in}$ 为发射极交流电压 $V_e$。记住这点，就可以得到电压增益为: $$ V_v=\\frac{V_c}{V_e}=\\frac{I_c(R_C||R_L)}{I_e(r\u0026rsquo;_e||R_E)} $$ 集电极交流电流和发射极交流电流几乎相同，因此二者可以互相抵消。因为 $R_E\u0026raquo;r\u0026rsquo;_e$，所以可以将 $r\u0026rsquo;_e||R_E$ 近似为 $r\u0026rsquo;_e$。此外，$R_C||R_L$ 表示集电极交流电阻 $R_c$。因此，电压增益仍然是电阻之比。\n$$ A_v =\\frac{R_C||R_L}{r\u0026rsquo;_e||R_E} $$ 或者为 $$ A_v\\approx \\frac{R_c}{r\u0026rsquo;_e} $$ 该式说明电压增益近似等于集电极交流电阻和发射极内部交流电阻的比值。在本例中，发射极电阻仅由 $r\u0026rsquo;_e$ 组成。更普通的情况是在发射极电路中增加扩量程电阻，下面将会介绍。\n存在扩量程电阻的电压增益 图3-42中的基本 CB 放大器的一个问题是它会使较大的信号产生失真，因为输入端只有一个电阻 $r\u0026rsquo;_e$ 少它在一定程度上与信号幅度相关。一个较大的信号会引起 $r\u0026rsquo;e$ 的变化，从而改变增益。图3-43所示为基本放大器的改进,其中给出了针对小信号晶体管的一些典型值。通过增加具有较小值的扩量程电阻 $R{E1}$,并将其与 $r\u0026rsquo;_e$ 串联来进行改进。如同在CE放大器中，额外增加的固定电阻会产生更高的增益稳定性并增大输入电阻，但是以降低增益为代价。对 CB 放大器来说，它也可以显著改善其线性性质，因为扩量程电阻是与信号幅度无关的定值。\n因为扩量程电阻与 $r\u0026rsquo;_e$ 串联，所以其值与 $r\u0026rsquo;e$ 相加得到交流发射极电阻的近似值(忽略并联的 $R{E2}$，因为它的值非常大)。CB 放大器的电压增益仍为交流集电极电阻 $R_c$ 除以交流发射极电阻 $R_e$，但现在包含扩量程电阻。\n$$ A_v\\approx \\frac{R_C||R_L}{r\u0026rsquo;e||R{E1}}\\ A_v\\approx \\frac{R_c}{R_e}~~~~~(3-15) $$ 注意，该增益公式与 CE 放大器的增益公式相同，除了 CB 放大器不会使信号反相，因此增益符号为正。\n3.6.2输入电阻 对于没有扩量程电阻的基本放大器(见图3-42)，从电源端看过去，$R_E$ 与 $r\u0026rsquo;_e$ 并联。但是，因为 $r\u0026rsquo;_e$ 通常要比 $R_E$ 小，所以在求输入电阻时一般可以忽略 $R_E$ 值。因此，在没有扩量程电阻时，CB 的总输人电阻近似为 $r\u0026rsquo;_e$,。这是 CB 放大器的主要缺点。虽然该输入电阻与 CE 和 CC 放大器相比很小，但在某些高频应用中，这也可以成为其优势。\n如同在 CE 放大器中，扩量程电阻增大了输入电阻。当存在扩量程电阻时，输入电阻近似为 $r\u0026rsquo;e+R_E$。该近似中忽略了电阻 $R{E2}$ 的作用，因为对于输入信号而言，其处于一个值较大的并联通路上。因此有: $$ R_{in(tot)}\\approx r\u0026rsquo;e + R{E1}~~~~~(3-16) $$\n3.6.3 输出电阻 CB 放大器的输出电路与 CE 放大器的相同，因此，其输出电阻也一样(见3.4节的讨论)。从输出耦合电容往回看，CB 和 CE 放大器的输出电阻都为集电极电阻 $R_C$。 $$ R_{out}=R_C $$ 3.2节介绍的偏置方法也可以用于 CB 放大器。发射极偏置需要较少的元件但需要双电源。当 CB 放大器采用发射极偏置时，基极可以直接接地而不需要通过电容，而且也没有偏置电阻。\n","date":"2023-07-14T17:36:07+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-6%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.6 共基极放大器"},{"content":"共集电极(CC)放大器通常也称为射极跟随器，是三种基本放大器组态中的第二种。输入加在基极，而输出端为发射极。CC放大器提供电流增益，电压增益近似等于1。由于其输入电阻较高，因此常常用作缓冲器或驱动器。\n学完本节后，你应该掌握以下内容:\n理解和分析CC放大器的工作原理 画出CC放大器的交流等效电路 解释为什么CC放大器的电压增益近似等于1 计算CC放大器的电流增益、输入电阻和输出电阻 解释为什么达林顿管有非常高的 $\\beta$ 值 $$ a）典型的CC放大器或射极跟随器 $$ $$ b)交流等效电路 $$ $$ 图3-37~~~ CC放大器及其交流等效电路 $$ 图3-37a给出一个分压式偏置的共集电极(CC)电路。集电极直接接在直流电源上，它是一个交流地。注意，输入加在基极，输出从发射极取出。输出信号与输入信号相位相同。从输入耦合电容往基极看，交流等效电路包含偏置电阻和发射极电路中的电阻，如图3-37b所示。\n3.5.1电压增益 将并联发射极和负载电阻合并为一个等效电阻($R_E||R_L$)可以简化图3-37b中的交流电路，如图3-38所示。该电路图用来分析CC极放大器的电压增益。 $$ 图3-38 ~~~ CC放大器的交流输入等效电路 $$ 如同所有线性放大器一样，CC 放大器的电压增益为 $A_v=V_{out}/V_{in}$。分析该增益时，偏置电阻并没有包含在其中，因为它们不会直接影响输入信号(但是它们会对电源产生负载效应)。注意，图3-38中输入电压作用在 r\u0026rsquo;$_e$ 和 $R_E||R_L$ 的串联电路上，而输出电压只作用在 $R_E||R_L$ 两端。只要 r\u0026rsquo;$_e$ 与 $R_E||R_L$ 相比非常小，就可以忽略 r\u0026rsquo;$_e$ 两端很小的电压降。这意味着输入电压和输出电压几乎相同。因此有: $$ A_v\\approx1~~~(3-12) $$ 因为 r\u0026rsquo;$_e$ 两端有一个小的压降，所以实际增益要稍小于1。在实际电路中，这点差别并不重要。如果你用示波器查看一个 CC 放大器的输入和输出端，可以看到几乎一样的信号。因为发射极输出电压跟随输入电压变化，所以 CC 放大器通常也称为射极跟随器。共集电极放大器不会进行信号反相。\n你可能想知道，如果 CC 放大器具有单位电压增益，那么它的价值何在?答案在于它有电流增益。当需要驱动低阻抗负载(如扬声器)时，就要用到 CC 放大器。为了求得电流增益，首先需要分析输入和输出交流电阻。\n3.5.2输入电阻 射极跟随器的特点是有很高的输入电阻，这使其成为非常有用的电路。由于输人电阻很高，当一个电路驱动另一个电路的时候，射极跟随器可以用作缓冲器来减小负载效应。从基极看进去，输人电阻的推导与 CE 放大器的推导相同。从电源看过去，CC 放大器与具有分压式偏置的 CE 放大器有相同的并联通路，如图3-38的等效电路所示。但是，在本例中，发射极电路没有旁路电容。总的输人电阻公式与 CE 相似但有一个不同的发射极交流电阻( $R_E||R_L$ )。 $$ R_{in(tot)}=R_1||R_2[\\beta(r\u0026rsquo;_e+R_E||R_L)]~~~~(3-13) $$\n3.5.3 输出电阻 $$ 图3-39~~~CC放大器的交流等效输出电路 $$ 图3-39中给出了从输出耦合电容往回看过去的 CC 放大器交流等效输出电路。$R_{base}$ 代表基极电路中的电源和偏置电阻。从发射极电路看，其值非常小(其值要除以 $\\beta_{ac}$ )。在实际电路中，可以忽略它们; 从发射极角度来看，基极近似于交流地。最后只留下 r\u0026rsquo;$_e$ 与 $R_E$ 并联。由于 $R_E$ 远大于 r\u0026rsquo;$_e$，故 r\u0026rsquo;$_e$ 也可以忽略掉。对于基本分析而言，CC 放大器的输出电阻非常简单——即为 r\u0026rsquo;$_e$!\n3.5.4电流增益 射极跟随器的信号电流增益为 $Ⅰ_{load}/I_s$,其中，$Ⅰ_{load}$ 为负载电阻中的交流电流，$I_s$ 为来自电源的交流信号电流。$I_s$ 由欧姆定律计算得到，为 $V_{in}/R_{in(tot)}$。因为电压增益近似为 1，所以负载上的电压即输入电压. 于是, 负载电流为 $V_{in}/R_L$。计算电流比例就得到电流增益: $$ A_i=\\frac{Ⅰ_{load}}{I_s}=\\frac{V_{in}/R_L}{V_{in}/R_{in(tot)}} \\\\ A_i=\\frac{R_{in(tot)}}{R_L}~~~~(3-14) $$ 这是非常有用的结果，可见对于有负载的 CC 放大器而言,电流增益 $A_i$ 即为总输人电阻与负载电阻之比。如同之前学习的电压增益公式，电流增益也可以写作电阻的比值。\n3.5.5达林顿管 使用 CC 放大器的一个原因是它能够提供很高的输入电阻。CC 放大器的输入电阻受到偏置电阻大小和晶体管 $\\beta_{ac}$ 值的限制。如果 $\\beta_{ac}$ 可以更高，则更大值的偏置电阻仍然可以提供必需的基极电流，并且晶体管的输入电阻也将更高。\n$$ 图3-41~~~达林顿管 $$ 一种增大输人电阻的方法是使用达林顿管，如图3-41所示。达林顿管由两个晶体管级联而成，它们的集电极端连接在一起，第一个晶体管的发射极驱动第二个晶体管的基极。这种组态实现了 $\\beta_{ac}$ 的成倍增加。实际上，达林顿管是一个 “超级 $\\beta$” 晶体管，它看起来就像单个晶体管，但其 $\\beta$ 值等于两个晶体管的 $\\beta$ 值相乘。 $$ \\beta_{ac}=\\beta_{ac1}\\beta_{ac2} $$ 达林顿管的主要优势是其电路可以获得很高的输入电阻和很高的电流增益。达林顿管可以用在任何需要很高β值的电路中。与其他晶体管类似，达林顿晶体管可以以单个封装形式得到。例如，2N6426 是一个具有 $\\beta$ 最小值为 30 000 的小信号达林顿晶体管。\n","date":"2023-07-14T17:35:56+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-5%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.5 共集电极放大器"},{"content":"共发射极(CE)是BJT放大器的一种组态，其中发射极是输入信号和输出信号的公共端。本节将介绍特定的CE放大器，并用它来说明一些交流参数。\n学完本节后，你应该掌握以下内容:\n理解和分析共发射极放大器的工作原理 画出 CE 放大器的交流等效电路 计算 CE 放大器的电压增益、输人电阻和输出电阻 讨论交流负载线和直流负载线的区别 画出 CE 放大器的交流负载线，并求 Q 点 $$ a)电路图 $$ 共发射极(CE)放大器是 BJT 放大器中使用最广泛的类型，它的发射极作为输人和输出信号的参考端。图3-30a给出了一个 CE 放大器，它能够在负载电阻上产生一个放大和反相的输出信号。输人信号 $V_{in}$ 通过电容 $C_1$ 耦合到基极，并导致基极电流在其直流偏置值.上下波动。该基极电流的波动相应地产生了集电极电流的波动。由于晶体管的电流增益，集电极电流的变化量要远大于基极电流的变化量。这就产生了在集电极电压上一个更大的变化量，并且与基极信号电压反相。集电极电压的这个变化量又被电容耦合到负载上，产生输出电压 $V_{out}$。\n$$ b)直流负载线 $$ $$ 图3-30 基本的共发射极放大器 $$ 现在来仔细研究图3-30a中的放大器，并检查它的直流和交流参数。直流参数已经在例3-5(图3-20)中算出，这里简要回顾一下方法。注意，初始的 470$\\Omega$ 发射极电阻现在包含两个串联电阻 $R_{E1}$ 和 $R_{E2}$，其和为 470$\\Omega$。这对直流电流和电压没有影响，但由于旁路电容 $C_2$ 的存在，发射极电路的交流电阻值会不同。\n这里存在分压式偏置，因此首先利用分压原理计算直流基极电压。由于发射结二极管压降，发射极电压为基极电压减去 0.7V。接下来，对发射极电阻利用欧姆定律计算出发射极电流。计算得到发射极电流为3.34mA，近似等于集电极电流; 因此，$R_C$ 两端的电压降也可以通过欧姆定律计算得到。从例3-5得到的结果可以知道 $V_C$ 为8 .98V，$V_{CE}$为 7.41V。我们知道 $I_C$ 和 $V_{CE}$ 确定了电路的 Q 点。由于这些 $I_C$ 值和 $V_{CE}$ 值是 Q 点处的值，因此它们有专门的标记: 分别为 $I_{CQ}$ 和 $V_{CEQ}$。\n刚刚复习过的参数图能够帮你直观了解这些直流参数。可以通过计算电路的饱和电流和集电极-发射极截止电压来确定负载线。我们知道饱和电流是集电极-发射极电压近似为零时的电流。因此有: $$ I_{C(sat)}=\\frac{V_{CC}}{R_C+R_{E1}+R_{E2}}=\\frac{18V}{2.7k\\Omega+200\\Omega+270\\Omega}=5.68mA $$ 在截止点处没有电流，因此整个电源电压 $V_{CC}$ 就是集电极到发射极两端的电压。利用饱和点和截止点可以画出直流负载线，如图3-30b所示。其中给出了所有可能的工作点，但没有交流信号。Q 点位于前面计算得到的负载线上。\n3.4.1交流等效电路 $$ 图3-31 ~~~ 图3-30a电路的交流等效电路 $$ 由于各种原因，交流信号电路与直流源电路大不相同。如果在图3-30a所示电路图中应用叠加原理，并且将电容视为短路，那么你可以从交流信号的角度重新画出 CE 放大器电路图，如图3-31所示。电源用交流地替换(用灰色给出)。电容用短路代替，由于 $C_2$ 的旁路作用，因此可以将 $R_{E2}$ 删除。\n交流等效电路也给出了发射结二极管中的内部电阻(使用2.4节所描述的补偿电阻模型)。该内部电阻记为 r\u0026rsquo;$_e$ ,在增益及放大器的输人阻抗中发挥作用，因为它通常包含在交流等效电路中。因为它是一个交流电阻，所以有时也称为动态发射极电阻。该交流电阻值与直流发射极电流有关: $$ r\u0026rsquo;_e=\\frac{25mV}{I_E}~~~(3-9) $$ 该公式推导见附录。\n3.4.2 电压增益 CE 放大器的电压增益 $A_v$。为输出信号电压与输入信号电压之比 $V_{out}/V_{in}$。输出电压 $V_{out}$ 在集电极端测量得到，输人电压 $V_{in}$ 在基极端测量得到。由于发射结正向偏置，因此发射极的信号电压近似等于基极端信号电压，即 $V_b=V_e$，则电压增益为: $$ A_v=-\\frac{V_c}{V_e}=-\\frac{I_cR_c}{I_eR_e} $$ 由于 $I_c≈I_e$,因此电压增益化简为交流集电极电阻与交流发射极电阻之比: $$ A_v≈-\\frac{R_c}{R_e}~~~(3-10) $$ 增益公式中的负号表示反相，指的是输出信号与输人信号相位相反。注意，该增益写作两个交流电阻的比值，在其他放大器组态中也会见到类似的情况。\n该增益公式是快速确定共发射极放大器电压增益有效而简单的方法。检测故障的时候，你需要知道期望的信号是什么样，记住，计算增益时，集电极和发射极电阻都是交流总电阻。下面总结一下这些概念。\n发射极交流电路 在发射极电路中， 需要包含内部发射结二极管电阻 r\u0026rsquo;$_e$ 和没有被电容旁路的固定电阻。在交流发射极电路中，内部电阻 r\u0026rsquo;$e$ 与未被旁路的发射极电阻串联。顺便提及，在图3-30a中这个未被旁路的电阻是 $R{E1}$，该电阻在确定增益和保持增益稳定性方面具有重要作用。稍后会看到，它同时提高了放大器的输人电阻。因为它趋向于扩大 r\u0026rsquo;$_e$ 的不确定值，所以有时候也称它为扩量程电阻。 集电极交流电路 从集电极的角度来看，集电极电阻和负载电阻是并联的。因此，集电极的交流电阻 $R_c$ 为 $R_C || R_L$。用一个例子来说明这个问题。 3.4.3 输入电阻 放大器的输人电阻 $R_{in(tot)}$ 在1.4节和图1-19中已经介绍过了。当存在电容效应或电感效应时该电阻也称作输人阻抗。它是一一个交流参数，其作用类似于一个与电源的内阻串联的负载。只要输人电阻远大于电源电阻，大部分电压就将呈现在输人端，并且负载效应微乎其微。如果输人电阻与电源的电阻相比很小，那么电源电压会主要作用于其自身的串联电阻，只留下极少的电压被放大器进行放大。\nCE 放大器的一个问题是其输人电阻受 $\\beta_{ac}$ 值影响。就像你看到的那样，该参数的变化范围非常大，因此在不知道 $\\beta_{ac}$ 值的情况下，无法准确计算出给定放大器的输人电阻。尽管如此，还是可以通过在发射极电路中增加扩量程电阻来增大总的输人电阻以及最小化 $\\beta_{ac}$ 的影响。这样就可以获得输人电阻的一.个合理估计值，进而确定给定的放大器是否符合任务要求。\n$$ 图3-32~~~~ 图3-30a中CE放大器的交流 等效输人电路 $$ 图3-30a 中 CE 放大器的输人电路重画在图3-32中，该图略去了输出电路。由于集电结反向偏置，因此 $R_C$ 不是输人电路的一部分。对交流输人信号而言，它与地之间有三条并联通路。从电源端看进去，三条通路由 $R_1、R_2$ 和经过晶体管基极-发射极电路的通路组成。正是这三条并联支路构成电路的输人电阻。将这个电阻定义为 $R_{in(tot)}$，因为它表示了包括偏置电阻在内的总输人电阻值。但是，基极-发射极支路由于晶体管电流增益的作用而与 $\\beta_{ac}$ 相关。由于电流增益的原因，等效电阻 $R_{E1}$ 和 ${r\u0026rsquo;e}$ 在基极电路中比在发射极电路中大。发射极电路中的电阻必须乘以 $\\beta{ac}$ 才能得到其在基极电路中的等效电阻值。因此，总输人电阻为:\n$$ R_{in(tot)} = R_1||R_2||[\\beta_{ac}(r_e + R_{E1})]~~~~(3-11)式子替换成r\u0026rsquo;_e $$\n3.4.4 输出电阻 回忆1.4节的放大器模型，该模型包含一个驱动串联电阻的戴维南电压源或者一个驱动并联电阻的诺顿电流源。在这两种模型中，电阻都- -样。它是放大器的等效输出电阻。\n$$ 图3-33 CE 放大器等效交流输出电路 $$ 为了计算任意 CE 放大器的输出电阻，从图3-33所示的输出耦合电容往回看过去。晶体管相当于一个电流源与集电极电阻并联。这与图1-11和图1-19b中的等效诺顿电路是一样的。\n已经知道理想电流源的内部电阻为无穷大。只要记住这点，你就很容易看到 CE 放大器的输出电阻就是集电极电阻 $R_C$。\n3.4.5 交流负载线 对于大多数故障检测工作，能够快速估计电路的电压值和电流值非常有用。尽管技术人员在日常工作中很少使用负载线，但它是理解晶体管工作原理的一个非常有用的工具，同时也能帮助你了解电路的极限值(比如限幅电平)。\n如3.1节讨论过的，可以画出由串联集电极电阻 $R_C$ 和电压源 $V_{CC}$ 组成的基本晶体管电路的直流负载线。如图3-12a所示，该串联组合构成一个戴维南电路，它在图3-12b中用与 y 轴在饱和点交叉的直流负载线来表示。注意，图3-12b中的负载线与作为负载的晶体管无关。\n对交流而言，由于存在电容和发射极内电阻 $r$\u0026rsquo;$_e$，因此戴维南电阻要更加复杂。在高频电路中，电感也可能发挥作用。即使 $r$\u0026rsquo;$_e$ 是晶体管内部电阻，也要将其看作戴维南电阻的一部分。耦合电容和旁路电容也会存在于大多数实际的交流电路中。对交流信号而言，电容一般被当成短路，这意味着集电极-发射极电路的交流电阻\n$R_{ac}$ 会减小。例3-12解释了这个概念。\n图3-34中同时给出了电容耦合放大器的直流和交流负载线。对两条负载线而言，Q 点是相同的，因为当交流信号减小到零的时候，必然会在 Q 点工作。可以看到交流饱和电流要比直流饱和电流大(由于交流电阻较小)。此外，交流集电极-发射极截止电压比直流集电极-发射极截止电压要小。对交流信号而言，交流负载线给出了任何可能的工作点(集电极电流对集电极-发射极电压)。\n在交流负载线上可以计算出交流饱和点和交流截止点。交流负载线与 y 轴的交点为 $I_{c(sat)}$。可以通过直流Q点($I_{CQ}$)加上包含集电极一发射极电路的交流电阻 $R_{ac}$ 的一项，计算得到该点，如图3-34所示。交流饱和公式如下: $$ I_{c(sat)}=I_{CQ}+\\frac{V_{CEQ}}{R_{ac}} $$ 交流负载线与 $x$ 轴交点为 $V_{ce(cutoff)}$。也可以通过直流 Q 点 ($V_{CEQ}$) 加上包含交流电阻 $R_{ac}$ 的一项得到。交流截止公式如下: $$ V_{ce(cutoff)}=V_{CEQ}+I_{CQ}R_{ac} $$\n$$ 图3-36叠加在典型晶体管特性曲线上的交流负载线 $$ 了解放大器工作原理的一个有趣方法就是在交流负载线上叠加晶体管的一系列特性曲线。图3-36中给出了一个典型晶体管的这些曲线，并可用于图3-30a中的 CE 放大器。从基极电流的峰值与 $I_C$ 轴的交点映射出的两条线以及从交流负载线映射到 $V_{CE}$ 轴的两条线给出了集电极电流和集电极-发射极电压峰峰值的大小，如图3-36所示。对于本例中的电阻，如果输人信号使基极电流在 13~18μA 的范围内变化，那么集电极输出电流将在 2.9~3.9mA 的范围内变化。此外，对相同的信号而言， $V_{CE}$ 的变化范围为 6.3~8.1V。交流负载线也清晰地给出了当信号超过放大器的线性范围时，电流和电压的变化范围。\n","date":"2023-07-14T17:35:43+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-4%E5%85%B1%E5%8F%91%E5%B0%84%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"3.4 共发射极放大器"},{"content":"模拟电子的主干是线性放大器，一种能够从较小信号的副本产生较大信号的电路。上一节介绍了如何利用偏置为晶体管的工作提供必要的直流条件。本节将介绍影响交流信号的因素。\n学完本节后，你应该掌握以下内容:\n讨论晶体管参数并利用这些参数对晶体管电路进行分析 比较直流量和交流量的标注 讨论厂商数据手册中给出的BJT主要特性 解释耦合电容和旁路电容的作用 解释放大器如何产生电压增益 3.3.1直流和交流量 在本章第一部分中，利用直流量来建立晶体管的工作状态。这些直流电压和电流量用标准的斜体大写字母加上正体大写字母下标来表示，如$V_E、I_E、I_C$和$V_{CE}$。小写斜体下标用来表示交流量方均根值、峰值、峰峰电压和电流，如$V_e、I_e、I_c$和$V_{ce}$。瞬态量用斜体小写字母以及斜体小写下标标注，如$v_e、 i_e、i_c$和$v_{ce}$。\n除了电流和电压以外，从交流角度和直流角度来比较，电阻往往具有不同的值(参考1.1节中直流电阻值与交流电阻值的对比)。小写斜体下标用来标识交流电阻值。例如 $R_C$ 代表直流集电极电阻，而 $R_c$ 表示交流集电极电阻。在讨论放大器时可以看到进行这种区分的必要性。内部电阻是晶体管等效电路的一部分，并经常写成小写斜体字母(有时还加一个撇)和下标。例如， $r\u0026rsquo;e$代表内部交流发射极电阻，而 $R{in(tot)}$ 代表放大电路作为信号源负载呈现的总交流电阻值。\n对直流和交流电路不同的一个参数是 $\\beta$。电路中的直流 $\\beta(\\beta_{DC})$ 如前定义为集电极电流 $I_C$ 和基极电流 $I_B$ 的比值。交流 $\\beta(\\beta_{ac})$ 定义为集电极电流的小变化量除以相应的基极电流变化量。用 ac 表示这一变化量，同时它也是集电极电流 $Ⅰ_c$ 和基极电流 $Ⅰ_b$ 的比值(注意，用小写斜体下标)。在厂商的数据手册中 $\\beta_{DC}$ 通常写作 $h_{fe}$。公式表示为: $$ \\beta_{ac}=\\frac{I_c}{I_b}~~~(3-8) $$\n对于给定的晶体管，$\\beta_{ac}$ 和 $\\beta_{DC}$ 的值通常差别很小，并且这种差别是由于特性曲线上微小的非线性而引起的。对大多数设计而言，这些差别并不重要，但是在阅读数据手册时需要理解。\n3.3.3 交流和直流等效电路 在3.2节中，你已经解决了设置晶体管正常工作所必需的直流偏置条件。分析或检测任何晶体管放大器故障的第一.步是求直流工作状态。在确定直流电压正确后，下一步就是检查交流信号。交流等效电路与直流电路有很大差别。例如，电容能够阻碍直流通过，因此，它在直流电路中相当于开路;但对于大多数交流信号而言相当于短路。出于这个原因，需要区别对待直流和交流等效电路。\n回忆直流/交流电路课程，运用叠加原理可求得线性电路中在单个电压或电流源单独作用下任何地方的电压和电流，可以通过将其他所有电源置 0 来达到这个目标。为了计算交流参数，可以用短路来替换直流电源将它设为 0，然后计算交流参数，就如同只有交流源单独作用。用短路替换电源是指 $V_{CC}$ 实际上对于交流信号而言相当于地电势，这称为交流地。该接地点概念指的是交流信号地而不是直流地，这是个全新的概念。只要记住交流地是交流信号的公共参考点。\n3.3.4 耦合电容和旁路电容 图3-29所示为一个基本的 BJT 放大器。该电路与图3-19中的电路的差别在于加人了一个交流信号源、三个电容和一个负载电阻。另外，发射极电阻一分为二。\n交流信号通过电容( $C_1$ 和 $C_3$ )进出放大器，这些电容称为耦合电容。如前所述，电容对交流信号而言相当于短路，而对直流信号来说相当于开路。这意味着耦合电容能够通过交流信号，同时阻碍直流电压。输人耦合电容 $C_1$ 将交流信号从信号源输人到基极，同时将信号源与直流偏置电压进行隔离。输出耦合电容 $C_3$ 将信号输出到负载，同时将负载与电源电压进行隔离。注意，这些耦合电容串联连接在信号通路上。\n电容 $C_2$ 则不同，它与其中的一个发射极电阻并联。这使得交流信号从发射极电阻的旁路通过，因此称为旁路电容。旁路电容的作用是增大放大器增益，其原因稍后会讲述。因为旁路电容为交流短路，所以电容的两端都为交流接地。无论电容的哪一端接地，另一端对交流信号而言也为接地端。检测故障时一定要记住这一条，你不应该在旁路电容的任意端查找交流信号。如果你能找到，那么该电容可能是开路的。\n3.3.5 放大 $$ 图3-29基本的晶体管放大器 $$ 图3-29中的信号源 $V_s$,引起基极电流的变化，相应地，在 Q 点附近发射极和集电极电流产生了更大的变化，并且与基极电流相位相同。但是，当集电极电流增大时，集电极电压减小，反之亦然。因此，集电极-发射极电压在 Q 点值上下按正弦变化，相位与基极电压相位差180°。晶体管基极信号和集电极信号始终反相。因为基极电流上一个很小的变化能够在集电极电压上产生较大的变化，所以产生放大作用。\n","date":"2023-07-14T17:35:32+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-3%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E4%BA%A4%E6%B5%81%E5%88%86%E6%9E%90/","title":"3.3 数据手册中的参数及交流分析"},{"content":"本节将给出BJT的偏置方法。偏置是为了使晶体管正确工作而加的合适的直流电压。这可以通过一些基本电路来实现。偏置电路的选择很大程度上取决于应用。本节将介绍4种偏置方法，以及它们的优缺点。\n学完本节后，你应该掌握以下内容:\n解释4种BJT偏置电路的工作原理 描述基极偏置电路 描述集电极反馈偏置电路 描述分压式偏置电路 描述发射极偏置电路 对于线性放大器，信号必定在正负两个方向上摆动，而晶体管工作电流只能在一个方向上摆动。为了使晶体管放大交流信号，该交流信号必须叠加在设置工作点的直流电平上。偏置电路将直流电平设置为该工作点，这样就允许交流信号在正负两个方向上变化，而不会使晶体管进人饱和与截止状态。\n3.2.1基极偏置 $$ a )npn偏置电路 $$ $$ b)负电源供电的pnp偏置电路 $$ $$ c）正电源供电的pnp偏置电路 $$ $$ 图3-14基极偏置电路 $$ 最简单的偏置电路是基极偏置。对于 npn 晶体管，如图3-14a所示，在基极和电压源之间连接一个电阻($R_B$)。注意，这与图3-9a中所介绍的用来生成特性曲线的电路本质上相同。唯一的区别是基极和集电极电源被合并成单个电源(称为 $V_{CC}$)。尽管这种偏置方法很简单，但对于线性放大器而言，这不是一种好方法，下面讨论原因。\npnp晶体管可以使用负电源来实现偏置，如图3-14b所示﹔或者如图3-14c所示，在发射极上加上一个正电源来实现偏置。这两种偏置方法都通过发射结为基极电流提供回路。反过来，该基极电流产生大小为基极电流βpc倍的集电极电流(假定线性工作)。因此，在线性工作条件下，集电极电流为: $$ I_C=\\beta_{DC}I_B $$ 流过基极电阻 $R_B$ 的电流为基极电流 $I_B$。根据欧姆定律，替换 $I_B$。并得到 $$ I_C=\\beta_{DC}(\\frac{V_{R_B}}{R_B})\\\nI_C=\\beta_{DC}(\\frac{V_{CC}-V_{BE}}{R_B})~~~~~(3-3) $$ 只要晶体管不处于饱和状态，在给定基极偏置下，该式就给出了集电极电流。由于该式在没有发射极电阻的情况下推导得到，因此只能应用于此种偏置组态。\n如前所述，晶体管有不同的电流增益。相同类型的典型晶体管的 $\\beta_{DC}$ 值可以有3倍的差距。此外，电流增益还受到温度影响，随着温度升高，基极-发射极电压减小， $\\beta_{DC}$ 的值增大。因此，在基极偏置的相似电路中，集电极电流可能相差很大。不能期望依赖于特定 $\\beta_{DC}$ 的电路工作在恒定状态。出于这个原因，基极偏置很少用在线性电路中。\n因为只使用单一电阻来进行偏置，故基极偏置在开关应用中是很好的选择，此时晶体管始终工作在饱和或者截止状态。对开关放大器，式(3-3)并不成立。\n3.2.2集电极反馈偏置 $$ 图3-16集电极反馈偏置 $$ 对于 npn 型晶体管的另一种偏置组态为图3-16所示的集电极反馈偏置电路。(pnp 型晶体管工作原理完全相同，除了负电源电压供电以外。)基极电阻 $R_B$ 连接在集电极，而不是像在之前讨论的基极偏置电路中那样连接在 $V_{CC}$。比起基极偏置情况，该基极电阻的值更小，因为集电极电压比一般工作情况下的 $V_{CC}$ 要小。\n集电极反馈用到了电子学中很重要的一个概念——负反馈来获得稳定性。负反馈将部分输出返回到输入来抵消可能出现的变化。负反馈连接提供了相对稳定的 Q 点。\n下面来看一下负反馈是如何起作用的。在图3-16中，集电极电压为发射结提供偏置。负反馈产生补偿效果来保持 Q 点稳定。假设 $\\beta_{DC}$ 由于温度增加而增加，这导致 $I_C$ 增大，反过来，$R_C$ 上的电压降就加大。随着 $R_C$ 两端的电压降增大，$V_C$ 减少，这反过来也意味着它将提供更少的偏置电流。这种补偿行为正是负反馈产生的作用。关于负反馈的其他应用接下来会一一介绍。\n集电极反馈偏置中的集电极电流通过应用基尔霍夫电压定律(KVL)推导得到。写出基极电路的回路方程，可以推导出集电极电流公式为: $$ I_C=\\frac{V_{CC}-V_{BE}}{R_C+R_B/\\beta_{DC}}~~~~(3-4) $$ 对 npn 型和 pnp 型晶体管，该式都是成立的(需要注意符号)。接下来的例子中会应用式(3-4)来说明如何通过反馈补偿不同的 $\\beta_{DC}$ 值产生的影响。\n3.2.3分压式偏置 前面已经看到，基极偏置的主要缺点在于它对 $\\beta_{DC}$ 值的依赖。集电极反馈偏置比基极偏置提供了较高的稳定性，但分压式偏置可以提供更高的稳定性。分压式偏置是使用最广泛的偏置方式，因为它只需要一个供电电压，而且提供的偏置本质上不受 $\\beta_{DC}$ 的影响。事实上，观察分压式偏置的方程可以发现公式中既没有 $\\beta_{DC}$ 也没有其他任何晶体管参数。本质上，好的分压器设计与所使用的晶体管无关。 $$ a) 空载 $$ $$ 图3-18分压器 $$ 分压器原理是基本直流/交流电路课程中最有用的原理之一，利用它可以计算电路中任意串联电阻两端的电压。图3-18a描述了一个基本的分压器。求出输出电阻与总电阻的比值，再乘以输人电压，就可以计算出输出电压。 $$ V_{OUT} = (\\frac{R_2}{R_1+R_2})V_{IN} $$ 根据分压器原理，计算比值时，分子为输出电阻(本例中为 $R_Z$)，分母为总电阻值。 $$ b)带负载 $$ $$ 图3-18分压器 $$ 如图3-18b所示，当分压器输出端接负载电阻时，由于负载效应则输出电压会减小。只要负载电阻值比分压电阻值大很多，负载效应就可以忽略不计。\n$$ 图3-19分压式偏置 $$ 分压式偏置如图3-19所示。在该电路图中，$R_1$ 、$R_2$两个电阻构成分压器，使基极电压对任何要求极小电流的负载几乎保持不变。该电压使发射结正向偏置,产生一个极小的基极电流。在分压式偏置下，晶体管相当于分压器上的一个高阻负载。这使得基极电压比无负载时的值要略小一些。在实际的分压式偏置电路中，这种效应通常很小，所以负载效应可以忽略。在任何情况下，通过选择合适的 $R_1$ 和 $R_2$。可以使负载效应达到最小。根据经验，当使用的晶体管具有不同的 $\\beta_{DC}$ 参数值时，这些电阻中的电流至少应该十倍于基极电流才能避免基极电压的变化。这称为刚性偏置，因为基极电压与基极电流相对无关。\n计算分压式偏置电路参数的步骤是直接利用分压器原理和欧姆定律。基于没有负载效应的假设，可以运用之前提到的分压器原理来计算基极电压。对图3-19应用分压器原理可得: $$ V_B=(\\frac{R_2}{R_1+R_2})V_{CC}~~~~~~~(3-5) $$\n发射极电压为基极电压减去二极管压降。(对 pnp 型晶体管，为基极电压加上二极管压降.)\n$$ V_E = V_B-V_{BE}\\ V_E=V_B-0.7V~~~(3-6) $$\n已知发射极电压，则根据欧姆定律可求得发射极电流为: $$ I_E=\\frac{V_E}{R_E} $$ 集电极电流近似等于发射极电流: $$ I_C\\approx I_E $$ 此时可以求得集电极电压。集电极电压为 $V_{CC}$ 减去集电极电阻两端的压降，该压降可以通过欧姆定律求得。写出该式为:\n$$ V_C=V_{CC}-I_CR_C~~~~~(3-7) $$\n从集电极电压 $V_C$ 中减去发射极电压 $V_E$ 得到集电极-发射极电压 $V_{CE}$.\n$$ V_{CE}=V_C-V_E $$\n$$ 3-21pnp晶体管的分压式偏置 $$\n图3-21给出了 pnp 型晶体管的两种分压式偏置组态。在基极偏压时，无论是正负电源电压都可用来偏置。当使用如图3-21a所示的负电压供电时，电压加到集电极。如图3-21b所示，当正电源电压供电时，电压加到发射极。晶体管经常上下颠倒绘制以使电源电压位于上方，这意味着发射极电阻也位于上方。npn 型晶体管的公式也可用于 pnp 型，但要注意正负号。\n3.2.4发射极偏置 发射极偏置是非常稳定的偏置形式，它使用正负电源和单个偏置电阻，在通常的电路配置中，该偏置电阻会使基极电压接近地电势。这种偏置用于大多数集成电路放大器。 $$ 图3-23发射极偏置电路 $$ npn 型和 pnp 型发射极偏置电路如图3-23所示。如同其他偏置电路一样，npn 型和 pnp 型电路的最主要差别是电源电压的极性相反。\n对稳定的偏置而言，所选基极电阻上的压降只有几十分之一伏。对 npn 型晶体管而言，由于 $R_B$ 两端的压降很小，而正向偏置的发射结压降为 0.7V，因此发射极电压大约为 -1V。对 pnp 型而言，发射极的电压大约为 ＋1V。检测故障时，快速查看发射极电压可以看出晶体管是否导通以及偏置电压是否正确。\n根据欧姆定律可以计算出发射极电流。由于 $I_C\\approx I_E$，因此可以计算集电极电压，并根据下式求得集电极电压: $$ V_C=V_{CC}-I_CR_C $$\n","date":"2023-07-14T17:35:19+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-2bjt%E5%81%8F%E7%BD%AE%E7%94%B5%E8%B7%AF/","title":"3.2 BJT偏置电路"},{"content":" 双极结型晶体管(BJT)和场效应管(FET)是两种基本类型的晶体管。本章将介绍第一种类型——双极结型晶体管。本章首先讨论直流工作原理以及偏置电路，然后将会介绍各种偏置电路如何工作以及基本类型的分立放大器如何在线性和开关应用中进行工作，也将学习如何阅读厂商的数据手册。\n双极结型晶体管(BJT)的基本结构决定了它的工作特性。本节将介绍半导体材料如何形成BJT，以及标准晶体管符号，也将讲述通过对基本晶体管电路应用负载线来设置合适的直流电流和电压。\n学完本节后，你应该掌握以下内容:\n描述BT的基本构造和工作原理 区分 npn 和 pnp晶体管 定义 BJT 电流以及解释它们之间的关系 解释 BJT 的特性曲线 解释如何构造晶体管电路的直流负载线 定义截止和饱和 BJT包括 三个掺杂 半导体区域: 发射区、基区和集电区。(这三个区域被两个 pn 结分隔开。图3-1所示为两种不同类型的双极型晶体管。第一种类型由被一个薄的 $p$ 区分隔开的两个 $n$ 区组成( $npn$ )，第二种类型由被一个薄的 $n$ 区分隔开的两个 $p$ 区组成( $pnp$ )。这两种类型都广泛使用，但是，因为 $npn$ 型更加普遍，所以接下来将多以这种类型为例进行讨论。 $$ a)基本的外延平面结构 $$ $$ b)npn $$ $$ c)pnp $$ $$ 图3-1双极结型晶体管结构 $$ 连接基区和发射区的pn结称为发射结，连接基区和集电区的pn结称为集电结，如图3-1b所示。这些 $pn$ 结类似于第 ⒉章讨论的二极管结，因此也经常称为发射结二极管和集电结二极管。从每个区都引出一个电极，分别将从发射区、基区和集电区引出的电极标为E、B和C。尽管发射区和集电区由同种类型的材料制成，但它们的掺杂浓度和其他特性不尽相同。\n图3-2给出了 npn 和 pnp 两种 BJT 的电路符号(可以看到npn晶体管上的箭头并不指向里)。术语 双极 指在晶体管结构中空穴和电子都是载流子。\n$$ 图3-2BJT的标准符号 $$\n3.1.1晶体管工作原理 $$ 图3-3BJT的正向-反向偏置 $$ 为了使晶体管正常工作，两个 pn 结必须由外部提供直流偏压来设置合适的工作状态。图3-3给出了 npn 型和 pnp 型两种晶体管的合适偏置。在两种情况下，发射结(BE)为正向偏置而集电结(BC)为反向偏置，这称为正向-反向偏置。通常 npn 型和 pnp 型晶体管都使用正向-反向偏置，但偏置电压的极性和电流方向在两种类型中是相反的。 $$ 图3-4~~BJT工作原理，其中给出了电子流 $$ 为了说明晶体管如何工作，首先来了解一下当晶体管为正向-反向偏置时，在 npn 晶体管内部发生了什么( pnp 晶体管具有相同的情况，只要将极性进行反置)。基极到发射极的正向偏置使 BE 耗尽区变窄，而基极到集电极的反向偏置使 BC 耗尽区变宽，如图3-4所示。重掺杂的 n 型发射区充满了自由电子,这些电子能够很容易地越过正向偏置的BE结而扩散进入 p 型基区,就像正向偏置二极管中的情况一样。\n基区掺杂浓度较低，并且非常窄，以至于其中的空穴数量非常有限。因此通过 BE 结流过来的自由电子只有很少一部分会与基区中的空穴复合。这些数量相对较少的被复合的电子作为价电子流出基极，形成一个非常小的基极电流，如图3-4所示。\n从发射区流入基区的大多数电子没有被复合，而是继续扩散到 BC 耗尽区。一旦进入该区域，它们就会在该区域中正离子和负离子形成的电场作用下越过反向偏置的 BC 结。实际上，也可以认为这些电子在集电极电源电压的吸引下越过反偏的 BC 结。此时电子越过集电区、流过集电极、进入外部直流电源的正端，因此形成了集电极电流，如图3-4所示。集电极电流的大小取决于基极电流的大小，而与集电极直流电压无关。 重点是: 一个小的基极电流可以控制一个大的集电极电流。因为控制元素是基极电流，并且它能够控制一个较大的集电极电流，所以 BJT 本质上是一个电流放大器。利用小控制元素来控制大电流的概念类似于1.1节中所提到的 deForest 控制栅。\n3.1.2晶体管电流 基尔霍夫电流定律(KCL)指出进入结的总电流必须等于流出该结的总电流。将该定律应用到 npn 和 pnp 晶体管可以看到发射极电流($I_E$)是集电极电流($I_C$)和基极电流($I_B$)之和，如下所示: $$ I_E= I_C+I_B~~~~~~~~(3-1) $$ 与 $I_E$ 或 $I_C$ 相比，基极电流 $I_B$ 非常小，因此可以近似得到$I_E \\approx I_C$，在分析晶体管电路时，这是一个非常有用的假设。图3-5a和 b分别给出了 npn 和 pnp 小信号晶体管的例子，其中电表上给出了表示的电流。可以看到在 npn 和 pnp晶体管中，安培表和电源电压的极性相反。大写字母下标表示直流值。\n3.1.3 直流$\\beta(\\beta_{DC})$ 当晶体管在一定的限制条件下工作时，集电极电流与基极电流成比例。晶体管的电流增益直流 $\\beta$ 为直流集电极电流与直流基极电流之比。\n$$ 图3-5小信号晶体管中的电流 $$ $$ \\beta_{DC} = \\frac{I_C}{I_B}~~~~(3-2) $$ 直流 $\\beta(\\beta_{DC})$ 是称为电流增益的比例常数，在晶体管数据手册中通常表示为$h_{FE}$。只要晶体管工作在线性区域，它就有效。在这种情况下，集电极电流等于 $\\beta_{DC}$ 乘以基极电流。在图3-5的例子中，$\\beta_{DC}$=100。\n$\\beta_{DC}$ 的值变化范围很大，取决于晶体管的类型。一般来讲，其数值可以从20(功率管)到200(小信号管)。甚至两个相同类型的晶体管的电流增益也会有很大的差别。尽管对于晶体管用作放大器来讲，其电流增益是必需的，但是好的设计方案并不依赖于特定的 $\\beta_{DC}$ 值来进行工作。\n3.1.4晶体管电压 图3-6中给出的晶体管的三个直流偏置电压为发射极电压($V_E$)、集电极电压($V_C$)和基极电压($V_B$)。这些单下标电压表示以地为参考点的电压。集电极电源电压 $V_{CC}$ 用两个重复的下标字母表示。因为发射极接地，所以集电极电压等于直流电源电压 $V_{CC}$ 减去 $R_C$ 两端的电压。 $$ V_C = V_{CC}-I_CR_C $$ 基尔霍夫电压定律(KVL)指出一个闭环回路的电压之和为0。上面的式子就是该定律的一个应用。\n如前所述，当晶体管处于一般工作状态时，发射结二极管为正向偏置。正向偏置的发射结二极管压降 $V_{BE}$ 近似等于0.7V。这意味着基极电压比发射极电压大一个二极管压降，表示为: $$ V_B = V_E+V_{BE}=V_E+0.7V $$ 在图3-6所示的电路中，发射极是参考端，因此$V_E$=0V，$V_B$=0.7V。 $$ 图3-6偏置电压 $$\n3.1.5BJT的特性曲线 $$ 图3-8基极-发射极特性 $$ 基极-发射极特性 发射结的 $I-V$ 特性曲线如图3-8所示。可以看到，它与一般的二极管的I-V特性曲线相同。因此可以用第⒉章中给出的三种二极管模型中的任何一个来对发射结建立模型。在大多数情况下，该模型足够精确。这意味着,如果要对一个BJT电路进行检修，可以通过查看发射结(正向偏置)两端的压降是否为 0.7V 来确定晶体管是否导通。如果电压为0,则晶体管不导通;如果远大于 0.7V，则很有可能该晶体管的发射结开路。\n$$ a)电路 $$ $$ b)给定I_B、I_C与V_{CE}的关系 $$ $$ c)给定几个I_B值(I_{B1}\u0026lt;I_{B2}\u0026lt;I_{B3}等)，I_C与V_{CE}的曲线族 $$ $$ 图3-9集电极特性曲线 $$ 集电极特性 已经知道集电极电流与基极电流成比例($I_C=\\beta_{DC}I_B$)。如果没有基极电流，则集电极电流为0。为了画出集电极特性,必须选择―个基极电流并保持固定不变。图3-9a所示的电路可以用来产生一组集电极 $I-V$ 曲线来表示在给定基极电流的情况下 $I_C$ 如何随 $V_{CE}$ 变化而变化。这些曲线称为集电极特性曲线。\n在电路图中可以看到直流电源电压 $V_{BB}$ 和 $V_{CC}$ 都是可调整的。如果将 $V_{BB}$ 设置为产生一个特定的$I_B$值，$V_{CC}$ 设为0，那么 $I_C=0$，$V_{CE}=0$。此时，随着 $V_{CC}$ 逐渐增大，$V_{CE}$ 将增大，$I_C$ 也将增大，如图3-9b中 A 点和 B 点之间的曲线所示。\n当 $V_{CE}$ 达到 0.7V 时，集电结变为反偏，$I_C$ 达到其最大值 $I_C=\\beta_{DC}I_B$。理想情况下，随着 $V_{CE}$ 继续增大，$I_C$ 基本保持固定不变。这如图3-9b中 B 点右边曲线所示。实际上，随着 $V_{CE}$ 增大 $I_C$ 会稍微增大，这主要因为集电结耗尽区宽度会变宽，从而导致基区中复合的空穴更少。$I_C$ 上升的陡峭程度由一个称为正向厄尔利电压(因J.M.Early而得名)的参数决定。\n将 $I_B$ 设置为其他固定值，就可以产生 $I_C$ 与 $V_{CE}$ 之间的其他曲线，如图3-9c所示。这些曲线组成了特定晶体管的集电极曲线族，使得晶体管三个变量之间的相互作用关系变得可视化。保持其中一个变量($I_B$)固定，就可以看到其他两个变量( $I_C$ 对 $V_{CE}$ )之间的关系。\n3.1.6截止和饱和 当 $I_B=0$ 时，晶体管处于截止状态，此时集电极电流几乎为0，除了一个非常小的集电极泄漏电流 $I_{CEQ}$，不过该泄漏电流通常可以忽略。在截止状态，发射结和集电结都反向偏置。当对处于截止状态的晶体管进行故障检测时，可以假定集电极电流为0﹔因此，集电极电阻上没有电压降。集电极和发射极之间的电压几乎等于电源电压。\n现在考虑相反情况。当图3-9中的发射结变为正向偏置并且基极电流增大时，则集电极电流也增大，$R_C$ 两端的电压降增大，因此 $V_{CE}$ 减少。根据基尔霍夫电压定律，如果 $R_C$ 两端的电压增大，则晶体管两端的压降势必减少。理想情况下，当基极电流足够高时，电压 $V_{CC}$ 全部加在 $R_C$ 两端，而集电极和发射极之间没有电压。该工作状态称为饱和状态。当电源电压 $V_{CC}$ 是集电极电路的总电阻 $R_C$ 两端的电压时产生饱和状态。这种组态下饱和电流为: $$ I_{C(sat)}=\\frac{V_{CC}}{R_C} $$ 一旦基极电流足够高以至于产生饱和状态，进一步增大基极电流并不会影响集电极电流，式子 $I_C=\\beta_{DC}I_B$ 也不再成立。当 $V_{CE}$ 达到饱和值 $V_{CE(sat)}$ 时，集电结变为正向偏置。理想情况下， $V_{CE(sat)}$ 为0。\n进行晶体管电路故障检测时，对截止或饱和状态进行快速检查可以提供有用的信息。必须牢记，当晶体管处于截止状态时，集电极和发射极之间的电压几乎就是整个电源电压。饱和晶体管在集电极和发射极之间实际上存在一个非常小的电压降(一般为 0.1V)。\n3.1.7直流负载线 $$ a)右侧框所示的集电极电路是一个戴维南电路。左侧框中显示的晶体管电路为负载 $$ $$ b)~~a)中戴维南电路的直流负载线 $$ 从1.3节已经知道戴维南电路可以画成一个电压源与一个电阻的串联。考虑图3-12a所示的电路，集电极电压源 $V_{CC}$ 和集电极电阻 $R_C$ 组成一个戴维南电源，晶体管为负载。该电源能够提供的最小和最大电流分别为 0 和 $V_{CC}/R_C$。当然，这就是前面所定义的截止值和饱和值。注意，饱和点和截止点仅取决于戴维南电路，晶体管对此没有影响。截止点和饱和点之间所画的一条线段定义了该电路的直流负载线，如图3-12b所示。该线段给出了该电路所有可能的直流工作点。 $$ c）叠加在直流负载线上的集电极特性曲线 $$ $$ 图3-12直流负载线 $$ 任何类型负载的 $I-V$ 曲线都可以作为直流负载线加到相同的图形中来得到电路工作的图形化表示，如1.3节所示。图3-12c给出了一条直流负载线，它叠加在一系列理想集电极特性曲线上。只要保持直流工作状态，任何 $I_C$ 值以及相应的 $V_{CE}$ 值都将位于这条直线上。\n$$ a)特性曲线 $$ $$ b）直流测试电路 $$ 现在介绍如何运用直流负载线和晶体管特性曲线来说明晶体管的工作属性。假定有一个晶体管，它具有如图3-13a所示的特性曲线，并将它安装在图3-13b所示的直流测试电路中。通过画出直流负载线，可以用图解法求得电流和电压。首先，在负载线上确定截止点。当晶体管截止时，本质上没有集电极电流，因此集电极与发射极之间的电压和电流为: $$ V_{CE(cutoff)}=V_{CC}=12V,~~I_{C(cutoff)}=0mA $$ 然后，确定负载线上的饱和点。当晶体饱和时，$V_{CE}$ 近似为0。因此，$R_C$两端的压降为$V_{CC}$，对集电极电阻应用欧姆定律可求得集电极电流的饱和值 $I_{C(sat)}$ 为: $$ I_{C(sat)}=\\frac{V_{CC}}{R_C}=\\frac{12V}{2.0k\\Omega}=6.0mA $$ 该值为 $I_C$ 的最大值。在没有改变 $V_{CC}$ 或 $R_C$ 时，该值不可能变得更大。\n$$ c)负载线以及特性曲线 $$ 接下来，在特性曲线的同一个图上画出截止点和饱和点，并在两者之间画出一条线段，即负载线。这表示该电路所有可能的工作点。图3-13c在同一幅图上给出了负载线以及该晶体管的特性曲线。\n3.1.8Q点 在求得实际集电极电流之前，需要建立基极电流 $I_B$。参考原始电路，显然基极电源 $V_{BB}$ 是基极电阻 $R_B$ 和正向偏置的发射结串联组合两端的电压。这意味着基极电阻两端的电压为: $$ V_{R_B} = V_{BB}-V_{BE}=12V-0.7V=11.3V $$ 应用欧姆定律可以求得基极电流 $$ I_B = \\frac{V_{R_B}}{R_B}=\\frac{11.3V}{1.0M\\Omega}=11.3μA $$\n基极电流与负载线的交叉点为电路的静态点或 Q 点。通过在 10μA 和 15μA 基极电流线之间插值可以在图3-13上求得 Q 点。Q 点的坐标就是 $I_C$ 和 $V_{CE}$ 值，如图3-13d所示。从图3-13上读出这些值，可以求得 $I_C$ 值近似为2.6mA，$V_{CE}$ 近似为7.0V.\n图3-13d中的图形完全说明了该放大器电路的直流工作状态。进行故障检测时不需要画出负载线，而是要学会对电路应用基本数学知识来得到给定电路的工作情况。但是，负载线为描述晶体管的直流工作提供了一种非常有用的图形描述。\n$$ d）定位Q点 $$\n","date":"2023-07-14T17:35:07+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/3-1bjt%E7%9A%84%E7%BB%93%E6%9E%84/","title":"3.1 BJT的结构"},{"content":"前面关于二极管的讨论主要集中在利用二极管单向导电性的应用上。有些二极管是为其他一些应用而设计的。本节将学习许多特殊用途的二极管，如齐纳二极管、变容二极管、光敏二极管和发光二极管。\n学完本节后,你应该掌握以下内容:\n阐述四种特殊用途二极管的特性 描述齐纳二极管的特性曲线 说明齐纳二极管在一个基本的稳压器中是如何起作用的 解释变容二极管是如何成为可变电容器的 讨论发光二极管(LED)和光敏二极管的基本原理 2.8.1齐纳二极管 图2-44给出了齐纳二极管的图示符号。齐纳二极管是一个硅的 $pn$ 结器件，与整流二极管不同的地方在于它的反向击穿区的设计。市场上常见的齐纳二极管的反向击穿电压在1.8～200V之间。在制造时是通过精细地控制掺杂浓度来设置其击穿电压的。从2.4节讨论的二极管特性曲线可知，当二极管反向击穿时，即使电流在急剧变化，但电压仍几乎保持常量。图2-45再次显示了二极管的伏安特性曲线。\n齐纳二极管最重要的应用是用作参考电压和小电流应用时的稳压器。作为稳压器时，齐纳二极管存在着局限:它没有集成电路稳压器(在2.6节中讨论)那么高的波动抑制能力，并且也不能应付大负载电流的变化。通过把齐纳二极管和晶体管或运算放大器相结合，就能构造出性能更好的稳压器。\n图2-46给出了齐纳二极管反向特性曲线部分。注意，随着反向电压($V_R$)的增加，反向电流($I_R$)始终保持非常小，直到曲线到达拐点处。在这一点,开始出现击穿效应;随着反向电流的快速增大，内部的齐纳交流电阻开始减小。通常这个电阻在参数表中表示为阻抗$Z_Z$。在拐点的底部，齐纳击穿电压($V_Z$)基本保持不变，尽管齐纳击穿电压会随着$I_Z$的增大而稍微增大。特性曲线的恒定电压区表明齐纳二极管的稳压能力。\n要使齐纳二极管工作在稳压状态，必须不能低于其反向电流$I_{ZK}$。从图2-46中的曲线可以看到，当反向电流减小到低于拐点处时，电压将急剧减小，稳压功能也就失去了。同样，也存在最大电流$I_{ZM}$，超过这个电流值二极管可能会损坏。因而，基本情况上，当通过齐纳二极管中的反向电流在$I_{ZK} $~$ I_{ZM}$范围内变化时,其端电压几乎保持恒定。数据手册中的额定齐纳电压$V_{ZT}$是指反向电流处于$I_{ZT}$(称为齐纳测试电流)时所对应的电压值。\n齐纳等效电路 图2-47a给出了齐纳二极管反向击穿时的理想近似。它被简化成了一个电池，其电压值就是额定齐纳电压。图2-47b表示齐纳二极管的实际等效电路，其中包含齐纳阻抗($Z_Z$)。因为实际的电压曲线并不是理想垂直的，所以齐纳电流的变化($△I_Z$)会引起齐纳电压有微小的变化($△V_Z$)，如图2-47c所示。\n$$ a)理想模型 $$ $$ b)实际模型 $$ $$ c)特性曲线 $$ $$ 图2-47齐纳二极管等效电路和Z_Z的图示化特性曲线 $$ 根据欧姆定理，$△V_Z$ 和 $△I_Z$ 的比等于齐纳阻抗，公式如下: $$ Z_Z = \\frac{△V_Z}{△I_Z}~~~~~~(式子2-5) $$ 通常，$Z_Z$ 指定为在齐纳测试电流 $I_Z$ 处的值。大多数情况下，在齐纳电流值的整个线性范围内，可以假定 $Z_Z$ 是个常量。\n齐纳稳压器 如前所述，齐纳二极管在一些简单的应用中可以作为稳压器。图2-48图示了一个齐纳二极管是如何把变化的直流输人电压稳定在一个恒定值上的。前面学过，这个过程称为线路调整率(见2.6节)。 $$ a）在输入电压增大时,输出电压几乎保持恒定(I_{ZK} \u0026lt; I_Z \u0026lt; I_{ZM}) $$ $$ b)在输入电压减小时，输出电压几乎保持恒定(I_{ZK} \u0026lt; I_Z \u0026lt; I_{ZM}) $$ $$ 2-48 输入电压改变时的齐纳稳压 $$\n当输入电压变化时(在满足条件的范围内)，齐纳二极管的输出端电压几乎保持恒定。然而，随着 $V_{IN}$ 变化，$I_Z$ 将相应地变化。因此在满足$V_{IN}\u0026gt;V_Z$的条件下，齐纳二极管能起稳压作用的前提就是输人电压变化引起的二极管电流Iz须在最小和最大电流值($I_{ZK}$和$I_{ZM}$)之间。$R$是串联限流电阻。数字万用表(DMM)上的显示条会显示出相应的值和变化趋势。除了数字读数外，许多数字万用表还有模拟显示。\n2.8.2变容二极管 因为结电容会随着反向偏置电压的大小而发生变化，变容二极管故又称为可变电容二极管。变容器是专门为利用可变电容特性而设计的。可以通过改变反向电压来改变电容。这些器件主要用于通信系统中的电子调谐电路。 变容器本质上是一个反向偏置的pn结，它利用耗尽层固有的电容特性。由于反向偏置时所产生的耗尽层不导电，因此它充当了电容器中的电介质。而 $p$ 区和 $n$ 区是导电的，充当了电容器的极板，如图2-51所示。 $$ 图2-51反向偏置时变容二极管用作变容器 $$ 回想一下，电容是由极板面积( A )、介电常数( $\\epsilon$ )和电解质厚度( $d$ )决定的，公式如下: $$ C=\\frac{A\\epsilon}{d} $$ 当反向偏置电压增大时，耗尽层变宽，等效于增加了电解质的厚度，所以减小了电容。当反向偏置电压减小，耗尽层变窄，所以增大了电容。图2-52a和 b 反映了这种作用。通常的电容-电压曲线如图2-52c所示。\n$$ a）反向偏置越大，电容越小 $$ $$ b)反向偏置越小，电容越大 $$ $$ c）二极管电容与反向电压关系图 $$ $$ 图2-52变容二极管的容量随反向偏置电压变化 $$ 变容二极管的电容参数可以通过耗尽层中掺杂的方法、二极管构造的大小和形状进行控制。变容器电容的范围通常从几皮法到几百皮法。\n图2-53a给出了变容二极管的通用符号，图2-53b是其简化的等效电路。内部反向串联电阻记为$r_s$,可变电容标记为 $C_V$。\n2.8.3发光二极管 顾名思义，发光二极管(LED)就是一个光发射器;LED可用作指示器(例如在逻辑探头中)，用于显示，例如许多数字时钟中常见的七段显示器,也用作光纤通信系统中的源。红外发光二极管是LED中的一种，用于光耦合应用(如将病人身上的心电图传感器与测量仪器隔离)和一些远程控制应用中。 $$ 图2-55LED的电致发光 $$ LED的基本工作原理是这样的:当器件正向偏置时，$n$区电子穿过$pn$结并和$p$区的空穴复合。这些自由电子处于导带并且比价带中的空穴处于更高的能级。当复合发生时,复合电子以光和热的方式释放出能量。这样的半导体材料如果表层有较大一块露出在外，就能允许光子以可见光的形式释放。图2-55图示了这个称为电致发光的过程。\nLED中的半导体材料是砷化家(GaAs)、砷化家磷化物(GaAsP)和磷化家(GaP)。并没有使用硅和锗，因为它们是会发热的材料，发光性能会很差。GaAsLED能释放红外(IR)辐射，它是不可见的。GaAsP要么释放红色要么释放黄色的可见光，而GaP能释放红色或绿色的可见光，释放蓝色光的发光二极管也是有的。LED的图示符号如图2-56所示。 $$ 图2-56LED的图示符号 $$ 如图2-57a所示，当正向电流( $I_F$ )足够大时LED发光。转换成光的输出功率直接与正向电流大小成正比，如图2-57b所示。典型的LED特性如图2-57c和d所示。 $$ a)正向偏置操作 $$ $$ b)光输出与正向电流的关系 $$ $$ 图2-57LED的使用 $$\n","date":"2023-07-14T15:06:29+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-8%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E4%BA%8C%E6%9E%81%E7%AE%A1/","title":"2.8 特殊用途二极管"},{"content":"有时用称为限幅器或削波器的二极管电路来对信号电压高于或低于某值的部分进行限幅。另一种称为钳位器的二极管电路常用来将直流电平还原成电信号。\n学完本节后，你应该掌握以下内容:\n分析二极管限幅器和钳位器的工作原理 解释二极管限幅器是如何工作的，对给定电路决定其限幅电平 解释二极管钳位电路是如何工作的 举出二极管限幅和钳位电路的应用例子 2.7.1二极管限幅器 $$ a)正半周期的限幅;二极管在正半周期导通 $$ $$ b)负半周期的限幅;二极管在负半周期导通 $$ $$ 图2-30二极管限幅电路(削波电路) $$ 图2-30a给出了称作限幅器(也称作削波器)的二极管电路，它用来限制或削掉输人信号的正部分。当信号变为正的时候，二极管正向偏置。因为阴极接地(OV)，所以阳极不能超过 0.7V(假设是硅二极管)。因此，当输入电压超过该值时，$A$ 点的值就被钳位在 +0.7V。\n当输入低于 0.7V 时，二级管反向偏置，可以看作开路。输出电压的波形与输入电压的负半部分一样，但是幅值由 $R_1$ 和 $R_L$ 构成的分压器决定，如下: $$ V_{out} = (\\frac{R_L}{R_1+R_L})V_{in} $$ 如果 $R_1$ 远小于 $R_L$ ，则 $V_{out}$ $\\approx$ $V_{in}$。\n把二极管反转，如图2-30b所示，则输入的负半部分被钳位在接近 0 电位。当输人为负时二极管正向偏置，A点处的电压恒定在 -0.7V，即二极管的压降。当输人大于 -0.7V时，二极管不再正向偏置; $R_L$ 的端电压与输入成正比。\n$$ 图2-31对输入计算机的信号进行限幅 $$ 限幅器的应用 图2-31给出了一个限幅器的应用。假设你想使用电源线将计算机操作与交流线路同步。如图2-31所示，一个半波整流器连接到变压器的 6.3V 输出端，整流器的峰值信号大约为 9V，对计算机输入来说太大了。计算机和其他逻辑电路在设计时均不能超过规定电压的最大值(典型值＋5.0V)，这样不会有严重损坏计算机的风险。图2-31所示的限幅器防止输入到计算机的信号超过 4.7V。\n限幅电平的调节 为了调节对信号电压进行限幅的电平大小，可以将一个偏置电压与二极管串联，如图2-34所示。在二极管变为正向偏置和导通前，A点电压应等于 $V_{BIAS}+0.7V$。一旦二极管开始导通，A点电压就限幅在 $V_{BIAS}+0.7V$，于是所有高于这个值的输人电压都将被限幅，如图2-34所示。 $$ 图2-34带正偏置的正限幅器 $$ $$ 图2-35有可变正向偏置的正限幅器 $$ 如果偏置电压增大或减小，则限幅电平会相应地进行变化，如图2-35所示。如果偏置电压的极性反向，如图2-36所示，高于 $-V_{BB}+0.7V$ 的电压被限幅，输出波形如图2-35所示。只有当A点电压小于 $-V_{BB}+0.7V$ 时，二极管才反向偏置。 $$ 图2-36带负偏置的正限幅器，注意，波形的正侧被限幅在 -V_{BIAS}＋0.7V 以上 $$ 如果需要剪去低于某个指定负值的电平，那么二极管和偏置电压应该像 图2-37 那样连接。在这种情况下，A点电压必须要低于 $-V_{BB}-0.7V$，使得二极管正向偏置并开始限幅工作，如图2-37所示。 $$ 图2-37带负偏置的负限幅器 $$\n2.7.2二极管钳位器 $$ a)二极管导通并向电容 C 充电 $$ $$ b)电容 C 充电后，它相当于电源 $$ $$ c）电容器电压加到交流输入电压上 $$ $$ 图2-40正钳位，二极管允许电容器快速充电，电容只能通过 R_L 放电 $$ 二极管钳位器在交流信号上加了一个直流电平。钳位器有时也称作直流分量还原器。图2-40是一个二极管钳位器，它在输出波形插入了一个正直流电平。为了理解这种电路的工作原理，先考虑输人电压的负半周期。当输入开始为负时，二极管正向偏置，允许电容器充电到接近输人峰值($V_{p(in)}-0.7V$)，如 图2-40a 所示。一旦越过了负峰值，二极管变成反向偏置，这是因为电容器通过充电将阴极维持在$V_{p(in)}$.\n钳位的实际效果是电容电量大约维持在输入峰值减去二极管压降。电容电压本质上相当于一个与输入信号串联的电源，如图2-40b所示。电容器的直流电压通过叠加的方式加到交流输入电压上，如图2-40c所示。\n$$ 图2-41 负钳位 $$\n","date":"2023-07-14T15:06:10+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-7%E4%BA%8C%E6%9E%81%E7%AE%A1%E9%99%90%E5%B9%85%E7%94%B5%E8%B7%AF%E5%92%8C%E9%92%B3%E4%BD%8D%E7%94%B5%E8%B7%AF/","title":"2.7 二极管限幅电路和钳位电路"},{"content":"电源滤波器大大地减小了整流器输出电压的波动，形成了幅度接近恒定的直流电压。滤波的原因是电子电路需要恒定的直流电压源和直流电流源来提供电功率与偏置，使得电路能正常工作。通常使用大电容器来进行滤波，为了改善滤波效果，电容(输入滤波器)后紧跟着稳压器。如今由于集成电路(IC)的发展，有了便宜而有效的稳压器。本节介绍集成稳压器，更详细的内容将会在第11章中介绍。\n学完本节后，你应该掌握以下内容:\n描述整流滤波器和集成稳压器的工作原理 给出IC稳压器的例子，并知道它们是如何连接到整流器的输出端 对一个给定纹波抑制和输人纹波的 IC 稳压器，能计算其输出的纹波 对一个给定的有负载或无负载的电压，计算其负载变动范围 对给定的输人电压变化所引起的输出电压的变化，计算其线性调整率 在大多数电源供电的应用中，标准的 60Hz 交流线性电压源都应转换成幅度接近恒定，值的直流电压。半波整流器的 60Hz 脉动直流输出或全波桥式整流器的 120Hz 脉动输出应该经过滤波来减小较大的电压变化。滤波可以通过一一个电容器、一个电感器或者它们的组合来完成。迄今为止，电容输人滤波器是最便宜并且广泛应用的类型。\n2.6.1电容输入滤波器 图2-24给出了一个带有电容输人滤波器的半波整流器。我们将用半波整流器来阐述滤波的原理，然后推广到全波整流器。 $$ a)当电源刚开启时，电容开始充电(二极管正向偏置) $$ b) 在正周期的峰值电压过后，电容通过R_L开始放电，此时二极管处于反向偏置。放电过程占据的时间段在输入电压中用灰色实线标出\nc) 电容又开始充电，达到了输入电压的峰值，此时二极管又处于正向偏置状态。充电过程持续时间段在输入电压中用灰色实线标出。注意，在第二个充电周期电容电压在超过它原来的电压前，二极管一直反向偏置\n$$ 图2-24具有电容输人滤波器的半波整流器工作原理 $$\n在输入正向的前四分之一周期，二极管正向偏置，在二极管到达输人峰值后开始下降前的这段时间，允许电容进行充电，如图2-24a所示。当输入下降到低于其峰值时，如图2-24b所示，电容继续充电，二极管开始反向偏置。在这个周期的剩下部分到下一个周期的开始，电容只能通过负载电阻以一定的速率放电，放电速度取决 $RC$ 时间常数。时间常数越大，电容放电速率就越小。\n在下一个周期到达峰值前，如图2-24c所示，当输入电压超过电容器电压大约一个二极管管压降时，二极管又重新正向偏置。\n纹波电压 正如你看到的一样，电容在一个周期的开始快速地充电，在正峰值以后通过 $R_L$ 慢慢地放电(当二极管反向偏置时)。由于充电和放电会引起电容电压的变化，这种变化会形成纹波电压。纹波电压越小，滤波效果越好。\n对给定的输人频率，全波整流器的输出频率是半波整流器输出频率的两倍。所以，对全波整流器进行滤波更容易，因为两个峰值之间的间隔时间更短。当进行滤波时，对于相同的负载电阻和滤波电容器，全波整流电压的纹波要小于半波整流电压。因为两个全波脉冲间的间隔越短，电容放电越少，所以电压纹波也越小，如图2-25所示。 $$ 图2-25当电路的滤波电容器和正弦波输人相同时，半波和全波整流器输出的纹波电压的比较 $$\n$$ 图2-26电容输人滤波器中的浪涌电流沿着灰色的路径流动 $$ 电容输入滤波器的浪涌电流 当电源刚开始接通时，滤波电容器是未充电的。当开关合上的瞬间，电压像短路一样直接加到整流器和未充电的电容器上。图2-26a中用桥式电路来阐述这种情况。初始浪涌电流(有时称作浪涌电流)通过正向偏置的二极管产生。最坏的情况发生在二二次电压达到峰值时开关闭合，会产生最大的浪涌电流。\n浪涌电流很可能损坏二极管，因此通常会连接一个浪涌限制电阻器$R_{surge}$, 如图2-26b所示。为了避免在电阻器上产生很大的压降，电阻器的值必须要小。同样，二极管必须具有正向额定电流从而使它能够承受瞬间的浪涌电流。\n2.6.2 IC稳压器 当滤波器可以将电源的纹波降低到很小时，最有效的滤波器是将电容输人滤波器和 IC稳压器组合起来运用。通常，IC(集成电路)是在一个小的硅芯片，上构建的功能完整的电路。IC稳压器是一块连接到整流器输出端的IC，即使输入、负载电流或温度发生变化，它也能始终保持输出电压(或电流)的恒定。电容滤波器使得稳压器的输人纹波降低到了一个合适的值。一个大电容和一个IC稳压器的组合价格不贵，但能有助于产生一个很好的小电源。\n最流行的IC稳压器具有三个端一输人端、 输出端和参考端(或调节端)。电容器首先对稳压器的输人进行滤波，使纹波减小到 $\u0026lt;$ 10%,然后稳压器可以将纹波减少到可以忽略的水平。此外，大多数稳压器具有内部参考电压、短路保护和热切断电路。它们可以用在各种正、负极性输出的电压中，并且可以用最少的外部元件设计成可变输出。典型地，IC稳压器可以提供具有很强纹波抑制能力的1至数安培电流的输出。超过5A负载电流的IC稳压器也可用。\n$$ 图2-27三端稳压器 $$ 为了稳定输出电压而设计的三端稳压器只需要连接外部电容器就可以完成对电源的稳压调整，如图2-27所示。滤波是通过在输人电压和地之间的大容量电容器来完成的。有时，为了防止振荡，当滤波电容器与IC稳压器并不是很靠近的时候，再并联-一个较小的输人电容器，这个电容器需要靠近IC稳压器。最后，为了改善暂态响应，将一个输出电容器(典型值为0.1 ~ lμF)并联在其输出端。\n$$ 图2-28 基本的十5.0V电源 $$ 固定三端稳压器的例子有 78XX 和 79XX 系列稳压器，这些系列具有各种输出电压并且能够提供达到1A的负载电流(散热充分)。型号的最后两个数字表示输出电压，因此，7812具有 +12V 的输出。相同稳压器的负输出电压版本记为79XX系列，因此 7912 具有 -12V 的输出。这些稳压电路的输出电压在正常值的 1.5%~4% 之间，不管输人电压或输出负载如何变化，它们能保持几乎接近恒定的电压输出。图2-28是一个通过7805稳压器输出恒定 +5V 的基本电源。78XX和79XX系列稳压器的数据手册参见www. onsemi. com。\n作为一个例子，用 7812 稳压器来减小纹波。注意，数据手册中的纹波抑制参数是$RR$。7812 的典型纹波抑制参数是 60dB(分贝请参阅1.4节)，这就意味着输出纹波比输人纹波要小 60dB，这是一个非常大的降低，在下一个例题中将会详细阐述。\n$$ 图2-29具有可变输出(1.25～6.5V)的基本电源 $$ 另一种类型的三端稳压电路是一种可调的稳压电路，图2-29给出了具有可调输出的电源电路，输出可以通过可变电阻 $R_2$ 控制。注意， $R_2$ 的取值可以在 0~1.0 $kΩ$ 之间变化。LM317 稳压器在输出和调节端之间保持1.25V的恒定电压，这使得在 $R_1$ 中产生-一个恒定电流，电流大小为1.25V/240 $Ω$=52mA。如果我们忽略调节端的微小电流，则流过 $R_2$ 的电流和流过 $R_1$ 的电流相等，在 $R_2$ 和 $R_1$ 所产生的输出可以从下式获得， $$ V_{out} = 1.25V(\\frac{R_1+R_2}{R_1}) $$ 注意，电源的输出电压等于稳压器的 1.25V 乘以电阻的比率。在图2-29中，当 $R_2$ 的值设置为最小(零)电阻时，输出是 1.25V。当 $R_2$ 的值设置为最大电阻时，输出近似为6.5V。\n2.6.3百分比调整率 用表示成百分比的度量数值来描述稳压器的性能好坏。百分比调整率可以用输人(线路)调整率负载调整率来表示。线路调整率规定为给定的输人电压变化引起多少输出电压变化。它通常定义为输出电压变化和相应输入电压变化的百分比。 $$ 线路调整率=(△V_{OUT}/△V_{IN})\\times100%\\(2-3) $$ 负载调整率 规定为负载电流在一定范围内变化时，输出电压的变化有多大。负载电流变化范围通常从最小电流(空载，NL)到最大电流(满载，FL)。它通常表示成百分比，一般可以用下面的公式可以计算: $$ 负载调整率=(\\frac{V_{NL}-V_{FL}}{V_{FL}})\\times100%\\(2-4) $$ 式中，$V_{NL}$是空载时输出电压，$V_{FL}$ 是满载(最大负载)时输出电压。线性调整率 和 负载调整率 将在11.1节进一步讨论。\n前面的讨论主要集中在广泛使用的三端稳压器上。三端稳压器可以用于各种特殊的应用或需求，如电流源或自动关机、电流限定等。对其他的一些应用(大电流、高效率、高电压)，可用集成电路和分立式晶体管构成更复杂的稳压电路。第11章将更详细地讨论这些应用。\n","date":"2023-07-14T15:05:51+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-6%E6%95%B4%E6%B5%81%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%92%8Cic%E7%A8%B3%E5%8E%8B%E5%99%A8/","title":"2.6 整流滤波器和IC稳压器"},{"content":"由于二极管在一个方向上允许电流通过，而在另一个方向上阻止电流通过，因此二极管通常用在电路(整流器)中，把交流电压转换成直流电压。由交流电压源变成直流电压源中都需要整流器，从最简单的电子系统到最复杂的电子系统，电源是它们基本的部分。本节将学习三种基本的整流器——半波整流器、中间抽头全波整流器、全波桥式整流器。\n2.5.1半波整流器 整流器是一个可以把交流转换成脉动直流的电子电路。图2-15阐述了半波整流过程。如图2-15a所示，在一个半波整流器中，一个交流源与一个二极管和一个负载电阻串联。 $$ a)半波整流器 $$ 当正弦波输入电压为正时，二极管是正向偏置的，流过的电流送到负载电阻上，如图2-15b所示。输出电压等于峰值电压减去管压降。 $$ b)当输入电压处于正半周期时，二极管导通 $$ $$ V_{p(out)}=V_{p(in)}-0.7V (式子2-1) $$ $$ c)当输入电压处于负半周期时，二极管截止;所以，输出电压为0 $$ 电流在负载两端产生电压,这个电压与输入电压的正半周期具有相同的形状。当输入电压进入负半周期时变为负值,二极管反向偏置。因为电路中没有电流,所以负载电阻两端的电压为0，如图2-15c所示。最终结果是仅在交流输入电压的正半周期，负载电阻的电压是输入电压减去二极管管压降，使输出成为一个脉动直流电压，如图2-15d所示。注意,在负半周期，二极管需要承受住电源的负峰值电压而不被击穿。\n$$ d)三个输入周期的半波输出电压 $$\n$$ 图2-15半波整流 器的工作原理，二极管是理想二极管 $$ 在二极管电路中，当所加电压的峰值远远大于势垒电势时,通常可忽略二极管的管压降。这相当于使用二极管的理想模型。\n2.5.2全波整流器 全波整流器和半波整流器的区别就是: 全波整流器在整个输入周期允许单向电流流过负载，而半波整流器只在半个周期内允许电流流过负载。全波整流后的结果是一个按照输入电压半个周期的节拍重复输出的直流电压，如图2-18所示。 $$ 图2-18全波整流器 $$\n中间抽头全波整流器 中间抽头(CT)全波整流器使用两个二极管连接到一个中间抽头变压器的二次侧，如图2-19所示。输人信号通过变压器耦合到二次侧，整个二次电压的一半出现在中间抽头和每个二次绕组端之间。 $$ 图2-19中 间抽头(CT)全波整流器 $$ 对输人电压的正半周期，二次电压的极性如图2-20a所示。在这种情况下，上面的二极管$D_1$ 正向偏置，下面的二极管 $D_2$ 反向偏置。电流流过的路径是经过 $D_1$ 和负载电阻，在图2-20a中用灰色线标出。 $$ a)在正半周期，D_1正向偏置，D_22反向偏置 $$ 对输入电压的负半周期，次级电压的极性如图2-20b所示。在这种情况下，二极管 $D_1$ 反向偏置，二极管 $D_2$ 正向偏置。电流流过的路径是经过 $D_2$ 和负载电阻，在图2-20b中用灰色线标出。 $$ b)在负半周期，D_2正向偏置，D_1反向偏置 $$ $$ 图2-20二次侧中的导通路径用灰色标出 $$\n因为在输人周期的正半周部分和负半周部分，流过负载的电流具有相同的方向，所以在负载两端产生的输出电压是全波整流直流电压。\n匝数比对全波输出电压的影响 如果变压器的匝数比是1,整流输出电压的峰值等于一次输人电压峰值的一半减去二极管压降。这是因为在二次绕组端的一半处输出的电压是输人电压的一半。 为了使峰值输出电压等于峰值输入电压(减去势垒电势)，应该使用匝数比为2(1 : 2)的升压变压器。在这种情况下，因为整个二次电压是一-次电压的2倍，所以二次电压在一半处输出的电压等于输人电压。 $$ V_{out} = \\frac{V_{sec}}{2}-0.7V $$ 峰值反向电压(PIV) 全波整流器中的每个二极管都交替地处于正向偏置和反向偏置状态。每个二极管需要承受的最大反向电压是整个二次电压的峰值( $V_{sec}$ )。中间抽头全波整流器中每个二极管的峰值反向电压是 $$ PIV=V_{p(out)} $$\n2.5.3桥式整流器 桥式整流器使用4个二极管，如图2-23所示，这种排列方式不再需要中间抽头变压器，是电源中最普遍的结构方式。4个二极管安放在一-起，之间用导线连接成桥式结构。桥式整流器是全波整流器的一种,它每次把正弦波的-半传送到输出负载上。\n$$ a)输入的正半周期，D_1和D_2正向偏置并导通。D_3和D_4反向偏置 $$\n$$ b)输入的负半周期，D_3和D_4正向偏置并导通。D_1和D_2反向偏置 $$ $$ 图2-23全波整流器的工作原理，二次侧的导通路径用灰色标出 $$ 桥式整流器是这样工作的: 当输人处于正半周期时，如图2-23a所示，二极管 $D_1$ 和 $D_2$ 正向偏置并且导通，电流的流经路径用灰色的线标出。$R_L$ 两端产生电压，电压波形和输人的正半周期相同。这时，二极管 $D_3$ 和 $D_4$ 反向偏置。当输人处于负半周期时，如图2-23b所示，二极管 $D_3$ 和 $D_4$ 正向偏置并导通，电流的流经路径在图2-23b中用灰色的线标出。$R_L$ 两端又产生电压，电压的方向和正半周期时的相同。在负半周期，二极管 $D_1$ 和 $D_2$ 反向偏置。全波整流器的输出电压是 $R_L$ 的端电压。\n桥式输出电压 忽略二极管压降， 整个二次电压 $V_{sec}$，都落在了负载电阻上，因而， $$ V_{out} = V_{sec} $$ 如图2-23所示，不管在正半周期还是负半周期，两个二极管始终和负载电阻相串联。如果考虑二极管的管压降，输出电压(假设是硅二极管)是 $$ V_{out} = V_{sec}-1.4V (式子2-2) $$\n峰值反向电压 当$D_1$ 和 $D_2$ 正向偏置时，反向电压加在 $D_3$ 和 $D_4$ 之上。 $D_1$ 和 $D_2$ 相当于短路(理想情况下)，峰值反向电压等于二次峰值电压。 $$ PIV = V_{p(out)} $$\n","date":"2023-07-14T15:05:29+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-5%E6%95%B4%E6%B5%81%E5%99%A8/","title":"2.5 整流器"},{"content":"2.4.1二级管管符号 通用二极管的标准电路符号： 二极管的两极是 A 和 K ，A 是阳极，K 是阴极。箭头符号总是指向阴极。\n$$ a)二极管符号 $$\n$$ b)正向偏置 $$ $$ c)反向偏置 $$\n$$ 图2-8二极管电路符号和偏置电路。 V_{BB} 是偏置电池电压，V_B是势垒电压。电阻将正向电流限制在一个安全值 $$ 图2-8a给出了通用二极管的标准电路符号。如图2-8a所示，二极管的两极是A和K,A是阳极，K是阴极。箭头符号总是指向阴极。\n图2-8b给出了正向偏置二极管通过一个电流限制电阻连接到电源时的情况。二极管的阳极相对于阴极电位是正的，使得二极管导通，如电流表指示的那样。记住，当二极管正向偏置时，势垒电压 $V_B$ 一直存在于阳极和阴极之间，如图2-8b所示。电阻两端的电压$V_R$等于 $V_{BB}$ 减去$V_B$\n二极管的反向偏置如图2-8c所示。二极管的阳极相对于阴极电位是负的，二极管不导通，如电流表所指示那样。偏置电压$V_{BB}$全部加在二极管上。因为没有电压降在电阻上，所以电路中没有电流。注意，偏置电压$V_{BB}$与势垒电压$V_B$不相等。\n图2-9给出了一些典型的二极管封装。字母A表示阳极;K表示阴极。\n2.4.2二极管特性曲线 $$ 图2-10是二极管的伏安特性曲线 $$ $$ 正向偏置的 V-I 特性曲线 $$ $$ 反向偏置的 V-I 特性曲线 $$ 图2-10是二极管的伏安特性曲线。图2-10的右上部分表示二极管正向偏置时的情况。如图2-10所示，当正向偏置电压($V_F$)低于势垒电势时，没有正向电流($I_F$)。当正向偏置电压接近势垒电势的值时(通常硅是0.7V,锗是0.3V)，流过二极管的电流开始增大。一旦正向偏置电压大于势垒电势，正向电流随着偏置电压增大而急剧增大，必须靠限流电阻来限制电流。正向偏置二极管的端电压几乎等于势垒电势的值，但是会随着正向电流的增大而略微增大。对正向偏置的二二极管，通常将势垒电势就作为二极管的管压降。\n图2-10的左下部分表示二极管反向偏置时的情况。当反向偏置电压小于击穿电压时，随着反向偏置电压朝着左边增大，电流的值接近于零。当二极管被反向击穿时，二极管中会有较大的反向电流产生，如果不对这个反向电流进行限制，二极管将会被损坏。日通常，大多数整流二极管的击穿电压都大于50V，普通二极管的大多数应用都不会运行在反向击穿区域内。\n在示波器上显示二极管的伏安特性曲线 按照图 2-11所示的电路连接方法，可以在示波器上显示二极管的正向特性曲线。信号是峰峰值为5V的三角波信号，用来产生一系列过零电压。这使得二极管在正向偏置和反向偏置之间交替。通道1探测二极管上的管压降，通道2显示与电流成正比的信号。示波器处于 X-Y 模式。信号发生器的公共端绝对不能与示波器共地。通道2需要反转来显示正确方向的信号。 2.4.3用欧姆计或万用表测试二极管 2.4.4二极管的模型 理想模型:\n模拟二极管原理最简单的方法就是把二极管看成一个开关。理想情况下，当二极管正向偏置时，相当于开关闭合﹔当二极管反向偏置时，相当于开关断开，特性曲线如图2-12所示。注意，在理想情况下，正向管压降和反向电流始终零。当然，`这是二极管的理想模型，忽略了势垒电势、内部阻抗和其他的一些影响``,然而，在大多数情况下，这种模型已足够精确，尤其是当偏置电压是势垒电势的十倍或者更高倍时。\n偏移模型:\n精度更高一点的模型是偏移模型。偏移模型考虑了二极管的势垒电势。在这个模型中，正向偏置的二极管等效于一个闭合的开关串联一个小“电池”，这个电池的电压值等于势垒电势 $V_B$ 的值(硅是0.7V)，如图2-13a所示。等效电池的正极向着电源的阳极。记住，势垒电势并不是一个电压源，不能用电压表去测量﹔当二极管正向偏置时，等效电池仅仅具有偏移电源的效果，因为二极管的正向偏置电压 $V_{BB}$ 只有克服了势垒电势的作用才能使二极管导电。和理想模型一样，二极管反向偏置时等效于一-个断开的开关，如图2-13b所示，因为势垒电势并不影响反向偏置的情况。偏移模型的特性曲线如图2-13c所示。在本书中，如不特别说明，都使用偏移模型进行分析。\n偏移-电阻模型:\n图2-14a给出了正向偏置二极管的等效电路，它由势垒电势和一-个较小的正向电阻构成。正向电阻实际上是一个交流电阻(见1.1节)。正向电阻的值是变化的(取决于在哪点测试)，但是在这个模型中用直线来近似表示。 偏移-电阻模型图2-14a给出了正向偏置二极管的等效电路，它由势垒电势和一-个较小的正向电阻构成.正向电阻实际上是一个交流电阻(见1.1节)。正向电阻的值是变化的(取决于在哪点测试)，但是在这个模型中用直线来近似表示.\n在偏移-电阻模型中，反向偏置情况用一个非常大的并联电阻来表示，结果就是产生的反向电流非常小。图2-14b表示很大的反向电阻作用在反向偏置模型中，特性曲线如图2-14c所示。还有其他的一些较小的影响(如结电容)并没有包括在此模型中，对于这些影响，在计算机建模时通常会考虑。\n","date":"2023-07-14T15:05:04+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-4%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%89%B9%E6%80%A7/","title":"2.4 二极管特性"},{"content":"一个pn结就构成一只半导体二极管。平衡时pn结中没有电流。半导体二极管的主要用处是它能够根据偏置使得电流只朝着一个方向流动。pn结有两种偏置条件——正向偏置和反向偏置。这两种偏置都需要在pn结上外接合适方向的直流电压。\n2.3.1 正向偏置 在电子学中，术语偏置是指给半导体器件外加固定直流电压的工作条件。正向偏置是允许电流流过pn结的条件。 图2-6给出了半导体二极管正向偏置时直流电源的极性。电源的负极连接到n区（阴极端），电源的正极连接到p区（阳极端）。当半导体二极管正向偏置时，二极管的阳极电位比其阴极电位高。\n正向偏置时是这样工作的：当一个直流电源正向偏置二极管时，由于静电排斥，电源负极推动n区的导带电子向结处运动。同样地，电源正极推动力p区的空穴向结处运动。当外部偏置电压足够可以克服势垒电压时，电子就会有足够的能量进入耗尽区，并穿过pn结进入p区。进入p区的电子会和p区的空穴复合。当电子离开n区时，更多的电子流从电源负极进入n区。因此，通过导带电子（多数载流子）向结的定向移动产生流向n区的电流。当导带电子进入p区并和p区的空穴复合后，这些导带电子就成为价电子。然后，这些价电子向着正阳极连接方向不断地从一个空穴跳到另一个空六。这些价电子的定向移动本质上形成空穴朝着相反方向的定向移动。因此，通过空穴（多数载流子）朝着结方向的定向运动在p区产生电流。\n2.3.2 反向偏置 反向偏置是阻止电流流过pn结的偏置条件。图2-7a给出了反向偏置一个半导体二极管所需的直流电源极性。注意，电源负极连接p区，电源正极连接n区。当半导体二极管反向偏置时，二极管的阳极电位比其阴极电位低。 反向偏置时是这样工作的：由于相反的电荷相互吸引，电源负极吸引p区的空穴离开pn结，同时电源正极吸引电子离开pn结。由于电子和空穴离开pn结，耗尽区的宽度变得越来越大；在n区产生越来越多的正离子，在p区产生越来越多的负离子。直到势垒电压等于外部偏置电压时，耗尽层的宽度不再增加，当二极管反向偏置时，耗尽区实际上相当于位于正离子层和负离子层之间的绝缘体。\n峰值反向电压(PIV) 当一个二极管反向偏置时，它必须承受住加在两端之上的最大反向电压，否则二极管会被击穿，二极管的这个最大额定电压称为峰值反向电压(PIV)，所需要的PIV值取决于应用场合；在大多数使用普通二极管的情况下，PIV应该高于反向偏置电压.\n反向击穿 当外部反向偏置电压增大到足够大时，会发生雪击穿。雪崩击穿是这样产生的：假设少数导带电子从外部电源获得足够大的能量，从而加速它向二极管正极快速运动。在它的运动过程中，它碰撞一个原子并给予这个原子足够的能量使得一个价电子进人导带。这时，就有两个导带电子。每个导带电子又去碰撞原子，使得又有两个价电子被撞入导带。这时，就有4个导带电子。接着，这4个导带电子又撞击4个价电子使它们进入导带。导带电子这种快速的倍增称为雪崩效应，雪崩效应使得反向电流急剧增大。\n因为大多数二极管电路并不是为工作在反向击穿条件下而设计的，所以这些二极管工作在反向击穿条件下时可能会损坏。反向击穿也可以不损坏二极管，但是必须限制流过二极管 的电流大小，防止温度过高而损害二极管。有一种类型的二极管，即稳压二极管，就是专门 为工作在反向击穿而设计的，稳压二极管同样需要进行限流（稳压管在2.8节中讨论）。\n","date":"2023-07-14T15:04:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-3%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%81%8F%E7%BD%AE/","title":"2.3 半导体二极管的偏置"},{"content":"本征半导体硅(纯度99.999999999%)和锗的导电性能不好，通过加入杂质可以改善其导电性能。\n在纯净的硅中加入5价杂质，形成n(negative)型半导体。\n在纯净的硅中加入3价杂质，形成p(positive)型半导体。\n将两种材料合在一起，则在它们交界处就会形成pn结。\n2.2.1 掺杂 掺杂可以增加载流子(电子和空穴)的数量，低电阻率和导电性能。\n加入5价电子元素材料，形成n型半导体。在n型半导体材料中，自由电子称为多数载流子；空穴为少数载流子\n加入3价电子元素材料，形成p型半导体。在p型半导体材料中，空穴称为多数载流子；自由电子为少数载流子\n2.2.2 pn结 在一块本征硅上参杂，使得硅的一半形成n型半导体，另一半形成p型半导体，则在交界处会形成pn结。在n区有很多自由电子（多数载流子）和少量由热激发产生的空穴（少数载流子）。在p区有很多空穴（多数载流子）和少量由热激发产生的自由电子（少数载流子）。pn结形成了基本的二极管，它是所有固态半导体器件的工作基础。二极管是一种只允许电流朝一个方向流动的器件。\n耗尽区当pn结形成之后，在结附近的一些导带电子漂移到区并且和区的空穴复合，如图2-5a所示。每个电子穿过结并且和空穴复合后，在n区靠近结处会留下带一个净正电荷的五价原子。同样，当电子和p区的一个空穴复合，一个3价原子会带一个净负电荷。因此，结的n区会有正离子，区会有负离子。正负离子出现在结的相对一侧，在耗尽区处产生势垒电压（V）。势垒电压的大小受温度影响。在室温下，一般硅大约为0.7V，锗为0.3V。因为二极管很少使用，所以在实际应用中势电压为0.7V，本书内容也假设势电压为0.7V。\n为了扩散到p区，n区的导带电子必须克服所有正离子的吸力和负离子的力。在离子层形成后，结两边的区域中自由电子和空穴的数量会急剧减少，这个区域称为耗尽区，如图2-5b所示。电荷穿过交界处的任何运动都需要克服势垒电压。\n","date":"2023-07-14T15:03:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-2pn%E7%BB%93/","title":"2.2 pn结"},{"content":"2.1.1 原子的电子层和轨道： 每个原子的电子不是混乱的堆杂在一起的，而是分层的，每层有其合适的电子数运动，离原子核越近能量越低，活跃度越低。 The Maximum Number of Electrons in Each Shell 每个壳层中的最大电子数 $$ N_e = 2n^2 $$\n2.1.2 价电子、传导电子、离子 离原子核越远越活跃，越近舒服越强。最外层的电子称为价电子,能量最强，束缚最小。\n传导电子：价电子又被称为自由电子，获得足够的能量可以脱离原子核的束缚电子。\n离子：自由电子附身于中性原子上，此原子被称为负离子。\n2.1.3 金属键 原子的原子核和内层电子占据固定的晶格位置。外层价电子受到晶体原子束缚非常小并且可以自由移动，这些带有负电的大量电子和正离子一起形成金属键。 价带：价电子的离散能级模糊成一个带，这个带被测称为价带。\n导带：价带的下一个能级(通常被占用)也被模糊成一个能带，被称为导带。\n2.1.4 共价键 在钻石中相邻碳原子组成4个键，效果是每个原子周边的8个价电子形成一个化学稳定状态。共用价电子产生很强的共价键。使原子紧密的结合在一起。\n共用电子是不可移动的。所以价带和导带之间存在很大的能带间隔。\n2.1.5 电子电流和空穴电流 $$ 图2-3本征硅中由热激发产生的电子电流 $$\n当价带电子获得足够的能量时会进入导带，会在价带留下一个空穴。这些空穴和和进入的导带的电子行成电子-空穴对。\n导带电子失去能量并且跌落到价带的空穴时，这种现象称为复合。 电子电流：在半导体材料中，自由电子的移动是电流的一种。\n空穴电流：在晶体结构中从一个位置移动到另一个位置，，这个电流称为空穴电流。\n","date":"2023-07-14T15:01:04+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/2-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84/","title":"2.1 半导体原子结构"},{"content":"信号在之前，大多数都需要放大。放大器简单地增加了信号的幅度(电压、电流)。\n1.4.1 线性放大器 线性放大器对输入信号进行幅度上的放大。\n理想放大器指对信号的放大不产生噪声和失真，随着时间变化而变化，并且对输入的精确再现。\n主要用于放大电压和功率。\n电压放大器：$V_{out}$(t)正比于$V_{in}$(t),其比值为电压增益，公式： $$ A_v = \\frac{V_{out}}{V_{in}} $$\n$A_{v}$=电压增益；$V_{out}$=输出信号电压；$V_{in}$=输入信号电压\n理想的放大器的传输曲线应该是一条固定斜率无限延伸的直线，但实际没有这样的器件，在$V_{in}$达到一定的时会达到饱和(斜率不变)，最后$V_{in}$怎么变大$V_{out}$都不会变，在达到$V_{out}$ = $V_{max}$ 时曲线会平行于$X$轴。在达到$V_{out}$ = $V_{max}$之前，饱和之后存在一段非线性曲线。\n1.4.2 非线性放大器 放大曲线也可能不是直线，而是曲线。\n有两类放大器：波形整形和开关。\n波形整形放大器：用于改变波形的形状。\n开关放大器：从其他波形产生一个矩形输出。\n功率增益$V_p$,信号的输出·比上输入功率。用电压或电流的有效值来求功率。公式： $$ A_p = \\frac{P_{out}}{P_{in}} $$ $A_p$=功率增益，$P_{out}$=输出功率， $P_{in}$=输入功率 $$ A_p = \\frac{I_{out}V_{out}}{I_{in}V_{in}} $$\n$$ A_p = (\\frac{V^2_{out}/R_L}{V^2_{in}/R_{in}}) $$\n1.4.3 放大器模型 放大器是负载用来放大信号幅度的器件。可以认为放大器是源和负载之间的一个接口。\n1.4.4 级联 多个放大器可以结合成一个更大放大能力的放大器的。\n1.4.5 对数 对数就是幂，方程： $$ y = b^x $$ y值取决于底为b的幂指数，而幂x则是y的对数值。\n有两个常用的对数底：10和e\nlog以底为10的对数\nln以底为e的对数\n以10为底的对数用来描述分贝，对于以10位底，有： $$ y = 10^x $$ 得 $$ x = log_{10}y $$ 把10省掉，简写成$log$。\n当乘与或除以很大或很小数值时，对数很有用。两个指数相乘，可写成他们的幂相加： $$ 10^x×10^y = 10^{x+y} $$ 等于 $$ log^{xy} = log^x+log^y $$ 此概念用于解决级联放大器的放大或衰减。\n1.4.6 分贝功率比 功率比的数值比较大。工程师用分贝比来描述大的增益或衰减。分贝(dB)被定义为功率增益对数的10倍： $$ dB = 10log(\\frac{P_2}{P_1}) $$ 式中，P1、P2是两个相互比较的功率。\n用分贝来表示功率增益$A_p$,公式:\n$$ A\u0026rsquo;p = 10log(\\frac{P{out}}{P_{in}})$ $$\n式中， $A\u0026rsquo;$ =分贝值表示功率比，$P_{out}$ = 负载端的功率, $P_{in}$ = 提供给放大器的功率。\n500W和1W的比值是500 : 1，分贝值27dB。100mW : 0.2mW比值27dB,比值小于1存在功率衰耗或衰减。功率增加，分贝值是整数；对于功率衰减，分贝值是负值。\n功率比2 : 1很重要，用来表示仪器、放大器、滤波器等的频率截止频率，代入公式：\n$$ dB = 10log(\\frac{P_2}{P_1}) = 10log(\\frac{2}{1}) = 3.01dB $$\n约3dB。\n3dB表示功率是两倍，6dB表示功率是原功率的$2^2$倍(功率比是4 : 1), 9dB表示功率比是$2^3$倍。如果比值一样，而$P_2$比$P_1$小，那么对数值除了符号外是一样的，式子：\n$$ dB = 10log(\\frac{P_2}{P_1}) = 10log(\\frac{1}{2}) = -3.01dB $$\n负数表示$P_2$比$P_1$小。\n另一个有用的比值是10 : 1,因为以10为底的对数是1,10dB表示功率比是10 : 1.\n比如信号衰减了23dB，它可以有两个10dB的衰减器和一个3dB的衰减器表示。两个衰减器衰减了100倍，3dB衰减器衰减了2倍，因此总衰减了1 : 200;\n如果多级级联的增益或衰减是常见的，比如总电压是各级增益绝对值的乘积：\n$$ A_{v(tot)} = A_{v1}×A_{v2}×···A_{vn} $$\n分贝值的代数相加等于绝对值增益的乘积：\n$$ A\u0026rsquo;{v(tot)} = A\u0026rsquo;{v1} + A\u0026rsquo;{v2}+···A\u0026rsquo;{vn} $$\ndBm是指在某个假定的负载阻抗上消耗 1mW 的功率作为参考功率时测得的功率。对于射频系统，负载阻值为 50Ω；对于音频系统，一般为600Ω，其定义为： $$ dBm = 10log(\\frac{P_2}{1mW}) $$ dBm通常用来表示信号发生器的输出功率，或用来简化通信系统中功率的计算。\n1.4.7 分贝电压比 $P = V^2/R$,分贝功率可写成： $$ dB = 10log(\\frac{V^2_2/R_2}{V^2_1/R_1}) $$ $R_1$、$R_2$ = $P_1$、$P_2$对应的电阻；$V_1$、$V_2$ = 电阻$R_1$、$R_2$上的电压\n如果电阻相等，$R_1$、$R_2$可以约掉： $$ dB = 10log(\\frac{V^2_2}{V^2_1}) $$\n对数： $$ logx^2 = 2logx $$ 分贝电压比: $$ dB = 20log(\\frac{V_2}{V_1}) $$ 放大器电压增益用分贝表示: $$ A_v = 20log(\\frac{V_{out}}{V_{in}}) $$\n","date":"2023-07-14T14:58:40+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-4%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"1.4 放大器"},{"content":"戴维南定理：可以用一个电压源串联一个电阻代替一个复杂的线性电路，这个电路可以看成一个二端口。\n诺顿定理：可以用一个电流源并联一个电阻代替一个二端口线性电路。\n1.3.1 独立源 理想的独立电压源产生的$\\color{#376956}{电压}$与$\\color{#871F78}{负载电流}$无关。\n理想的独立电流源产生的$\\color{#871F78}{电流}$与$\\color{#376956}{负载电压}$无关。\n理想的独立信号源的值是固定的，与电路中的所有其他参数都无关。虽然无法实现个真正理想的信号源，但是在某些情况下(例如稳压电源)，它可以很接近理想情况。实际中的信号源可以看成一个理想的源与一个电阻(对交流源而言也可以是其他的无源器件)的组合。\n1.3.2 戴维南定理 它的适用前提是线性元件。\n1.3.3 诺顿定理 诺顿电流的幅度等于负载短路后流经端口的电流。\n1.3.4 负载线 戴维南的电流-电压特性曲线是负载线。\n短路和开路的特性曲线\n在一个线性曲线，接在输出端口的任何负载都满足此特性曲线，\n1.3.5 传感器 传感器是一种将物理量(例如位置、压力或温度)从一种形式转换成另一种形式。\n","date":"2023-07-14T14:58:21+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-3%E4%BF%A1%E5%8F%B7%E6%BA%90/","title":"1.3 信号源"},{"content":"是指任何携带信息的物理量，力、热、声、光、电等。\n1.2.1 模拟信号和数字信号 信号分为：离散信号和连续信号。离散信号可以只有几个值，连续信号可以无限细分下去。 离散和连续指信号的幅度，也可以指时间。\n采样和量化：\n​\t采样：将模拟波形在时间域上进行切分，每个切片大小大致等于原来波形的值，会丢失一些信息。\n​\t量化：给每个时间片分配一个数字，量化后的数字可以交给计算机或其它素质电路处理 1.2.2 周期信号 重复的波形称为周期性的，此周期信号有变化。\n周期(period, $T$)表示一个周期信号完成一个循环所需要的时间。周期(cycle)是指在波形呈现出另一个完全相同的图案之前波形的完整序列值。可以是在逐次循环的波形上任意两个相应点来测出周期。\n向量：既有大小又有方向的量。\n频率和周期：\n频率：每1s内完成的完整周期的个数，单位Hz\n周期：一个循环所经历的时间，单位s，所以周期的倒数就是频率，频率的倒数是周期\n$$ T = \\frac{1}{f} $$\n和 $$ f = \\frac{1}{T} $$ 正弦曲线的瞬时值： $$ v(t) = V_Psin(wt + ⌀) $$ $V_p$\n正弦曲线的平均值： $$ V_{avg} = \\frac{2V_P}{π} $$ 化简得： $$ V_{avg} = 0.637V_P $$ 电流平均值： $$ I_{avg} = 0.637I_p $$ 正弦曲线的有效值： $$ P = IV $$ 计算与直流电压电流产生相同的热效应时的交流电压、电流，通过积分可以求出等效的热量，称为方均根电压(rms)或者电流。\n方均根电压和峰值电压的关系： $$ V_{rms} = 0.707V_p $$ 方均根电流与有效电流的关系是： $$ I_{rms} = 0.707I_p $$\n1.2.3 时域信号 信号随时间变化而变化\nX轴为时间单位\nY轴为电压、电流、电阻或其他信号\n1.2.4 频域信号 信号随频率变化而变化\nX轴为频率\nY轴为幅度(通常为对数)的信号。\n频谱图：幅度随频率变化而变化的图\n谐波：一个非正弦周期波形由一个基频和几个谐频组成。\n基频是这个非正弦周期波形的重复频率。 谐频是更高频率的正弦波，其频率是基频的数倍，都是整数倍。 奇次谐波的频率是波形基频的奇数倍。比如一个1KHz的方波，包含基频1Khz,奇次谐波3kHz 偶次谐波的频率是基波的偶数倍。一个非正弦波是基波和多次谐波的组合，有些仅有奇次谐波，有写仅有偶次谐波，也有皆有。 一般来说，只有基波和奇次谐波对波形的形状影响比较重要。\n傅里叶级数：用三角级数表示周期信号，这个三角级数称为傅里叶级数，可以通过它求出符合波形的每个正弦波的幅度值。\n","date":"2023-07-14T14:57:45+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-2%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/","title":"1.2 模拟信号"},{"content":"出版者的话 译者序 前言 第1章 基本模拟概念 ##### 1.1 模拟电子学 ##### 1.2 模拟信号 ##### 1.3 信号源 ##### 1.4 放大器 ##### 1.5 故障检测\n第2章 二极管及其应用 ##### 2.1 半导体原子结构 ##### 2.2 pn结 ##### 2.3 半导体二极管的偏置 ##### 2.4 二极管特性 ##### 2.5 整流器 ##### 2.6 整流滤波器和IC稳压器 ##### 2.7 二极管限幅电路和钳位电路 ##### 2.8 特殊用途二极管 ##### 2.9 二极管数据手册 ##### 2.10 故障检测\n第3章 BJT ##### 3.1 BJT的结构 ##### 3.2 BJT偏置电路 ##### 3.3 数据手册中的参数及交流分析 ##### 3.4 共发射极放大器 ##### 3.5 共集电极放大器 ##### 3.6 共基极放大器 ##### 3.7 开关型双极型晶体管 ##### 3.8 晶体管封装及端口 ##### 3.9 故障检测\n第4章 FET ##### 4.1 FET的结构 ##### 4.2 JFET特性 ##### 4.3 JFET偏置 ##### 4.4 MOSFET特性 ##### 4.5 MOSFET偏置 ##### 4.6 FET线性放大器 ##### 4.7 MOSFET开关电路 ##### 4.8 系统\n第5章 多级放大器、RF放大器和功率放大器 ##### 5.1 电容耦合放大器 ##### 5.2 RF放大器 ##### 5.3 变压器耦合放大器 ##### 5.4 直接耦合放大器 ##### 5.5 A类功率放大器 ##### 5.6 B类功率放大器 ##### 5.7 C类和D类功率放大器 ##### 5.8 IC功率放大器\n第6章 运算放大器 ##### 6.1 运算放大器介绍 ##### 6.2 差分放大器 ##### 6.3 运放数据手册中的参数 ##### 6.4 负反馈 ##### 6.5 负反馈运放组态 ##### 6.6 运放阻抗和噪声 ##### 6.7 故障检测\n第7章 运算放大器响应 ##### 7.1 基本概念 ##### 7.2 运算放大器开环响应 ##### 7.3 运算放大器闭环响应 ##### 7.4 正反馈和稳定性 ##### 7.5 运算放大器的补偿\n第8章 基本运算放大器电路 ##### 8.1 比较器 ##### 8.2 求和放大器 ##### 8.3 积分器和微分器 ##### 8.4 转换器和其他运算放大器电路 ##### 8.5 故障检测\n第9章 有源滤波器 ##### 9.1 基本滤波器响应 ##### 9.2 滤波器的响应特性 ##### 9.3 有源低通滤波器 ##### 9.4 有源高通滤波器 ##### 9.5 有源带通滤波器 ##### 9.6 有源带阻滤波器 ##### 9.7 测量滤波器响应\n第10章 振荡器和定时器 ##### 10.1 振荡器 ##### 10.2 反馈振荡器原理 ##### 10.3 具有RC反馈电路的正弦波振荡器 ##### 10.4 具有LC反馈电路的振荡器 ##### 10.5 弛豫振荡器原理 ##### 10.6 555定时器作为振荡器 ##### 10.7 555定时器作为单稳态触发器\n第11章 稳压器 ##### 11.1 稳压 ##### 11.2 基本串联稳压器 ##### 11.3 基本并联稳压器 ##### 11.4 基本开关稳压器 ##### 11.5 IC稳压器 ##### 11.6 IC稳压器的应用\n第12章 特殊用途放大器 ##### 12.1 仪表放大器 ##### 12.2 隔离放大器 ##### 12.3 OTA ##### 12.4 对数和反对数放大器\n第13章 通信电路 ##### 13.1 基本接收机 ##### 13.2 线性乘法器 ##### 13.3 幅度调制 ##### 13.4 混频器 ##### 13.5 AM解调 ##### 13.6 IF和音频放大器 ##### 13.7 频率调制 ##### 13.8 PLL ##### 13.9 光纤\n第14章 数据转换 ##### 14.1 模拟开关 ##### 14.2 采样保持放大器 ##### 14.3 模拟和数字接口 ##### 14.4 D/A转换 ##### 14.5 A/D转换的基本概念 ##### 14.6 A/D转换方法 ##### 14.7 V/F和F/V转换器 ##### 14.8 故障检测\n第15章 测量和控制 ##### 15.1 RMS-DC转换器 ##### 15.2 角度测量 ##### 15.3 温度测量 ##### 15.4 应变测量、压力测量和运动测量 ##### 15.5 功率控制\n附录 部分公式的推导 奇数编号习题的答案 术语表 ","date":"2023-07-12T20:53:37Z","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","title":"模拟电子技术基础"},{"content":"1.1 模拟电子学 模拟信号: 我们测量到的自然现象的特性(比如,压力，流速和温度)都来源于模拟信号\n信号可分为有 二进制数字 表示的数字信号和有 连续变化量 表示的模拟信号\n模拟电子学包括所有其他(非数字)信号，它包括信号处理功能，比如放大,微分和集成等。\n1.1.1 线型方程 线型方程式:\n$$ y = mx + b $$\n式中，y是因变量，x自变量，m是斜率，b是y轴上的截距。 欧姆定理：\n$$ I = \\frac{V}{R} $$\n电流(I)是因变量，自变量是电压(V),斜率是电阻的倒数(1/R), 也就是电导(G).欧姆定律可变化为：\n$$ I = GV $$\n特性曲线是能够反应一个器件两个变化特性之间关系的图\n线性分量：在欧姆定理给定的形式中电流的增加正比于所施加电压的变化\n1.1.2 交流电阻 在模拟电子学中，很多器件的特性曲线中电流和电压不成正比。这些器件是非线性器件，但由于这些器件采用了连续的输入信号，它依然在模拟电子学的研究范围内。\n交流电阻：将电压的一个微小变化量除以相应的电流变化量(即∆U/∆I)的比值定义为模拟器件的交流电阻(r)，又被称为动态小信号电阻或体电阻。 $$ r_{ac} = \\frac{∆U}{∆I} $$ 1.1.3 传统的电流与电子流动 电流是电荷的流动速率。\n电流的流向：从电源正极流出，负极流入。\n电子的流向：从负极流出，正极流入。\n","date":"2023-07-12T22:05:41+08:00","permalink":"https://okokfun.github.io/post/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/1-1%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E5%AD%A6/","title":"1.1 模拟电子学"},{"content":" 第1章 基本概念 1.1 数字量与模拟量 1.2 二进制数、逻辑电平和数字波形 1.3 固定功能的集成电路 关键词 判断题 自测题 习题 答案\n第2章 数字系统、运算和编码 2.1 十进制数 2.2 二进制数 2.3 十进制数到二进制数的转换 2.4 二进制算术 2.5 二进制数的反码和补码 2.6 带符号数 2.7 带符号数的算术运算 2.8 十六进制数 2.9 八进制数 2.10 二—十进制编码(BCD) 2.11 数字编码 2.12 错误检测码 关键词 判断题 自测题 习题 答案\n第3章 逻辑门 3.1 反相器 3.2 与门 3.3 或门 3.4 与非门 3.5 或非门 3.6 异或门和同或门 3.7 固定功能逻辑 关键词 判断题 自测题 习题 答案\n第4章 布尔代数和逻辑化简 4.1 布尔运算和表达式 4.2 布尔代数的定律和法则 4.3 狄摩根定理 4.4 逻辑电路的布尔分析 4.5 使用布尔代数进行化简 4.6 布尔表达式的标准形式 4.7 布尔表达式和真值表 4.8 卡诺图 4.9 卡诺图乘积项之和的最小化 4.10 5变量的卡诺图 数字系统应用 关键词 判断题 自测题 习题 答案\n第5章 组合逻辑分析 5.1 基本组合逻辑电路 5.2 组合逻辑电路的实现 5.3 与非门和或非门的通用特性 5.4 使用与非门和或非门的组合逻辑 5.5 具有脉冲波形输入的逻辑电路运算 数字系统应用 关键词 判断题 自测题 习题 答案\n第6章 组合逻辑电路函数 6.1 基本加法器 6.2 并行二进制加法器 6.3 异步进位与超前进位加法器 6.4 比较器 6.5 译码器 6.6 编码器 6.7 代码转换器 6.8 多路复用器(数据选择器) 6.9 多路分配器 6.10 奇偶发生器/校验器 数字系统应用 关键词 判断题 自测题 习题 答案\n第7章 锁存器、 触发器和定时器 7.1 锁存器 7.2 边沿触发器 7.3 触发器运算特性 7.4 触发器应用 7.5 *稳态触发器 7.6 非稳态多谐振荡器 数字系统应用 关键词 判断题 自测题 习题 答案\n第8章 计数器 8.1 异步计数器运算 8.2 同步计数器运算 8.3 加/减同步计数器 8.4 同步计数器的设计 8.5 *联计数器 8.6 计数器译码 8.7 计数器应用 8.8 关联标注的逻辑符号 数字系统应用 关键词 判断题 自测题 习题 答案\n第9章 移位寄存器 9.1 基本移位寄存器的功能 9.2 串行输入/串行输出移位寄存器 9.3 串行输入/并行输出移位寄存器 9.4 并行输入/串行输出移位寄存器 9.5 并行输入/并行输出移位寄存器 9.6 双向移位寄存器 9.7 移位寄存器计数器 9.8 移位寄存器应用 9.9 关联标注的逻辑符号 数字系统应用 总结 关键词 判断题 自测题 习题 答案\n第10章 内存和外存 10.1 半导体存储器基础 10.2 随机存储器(RAM) 10.3 只读存储器(ROM) 10.4 可编程ROM(PROM和EPROM) 10.5 闪存 10.6 存储器扩展 10.7 特殊类型的存储器 10.8 磁和光存储 数字系统应用 关键词 判断题 自测题 习题 答案\n第11章 数字信号处理 11.1 模拟信号转换为数字信号 11.2 模—数转换方法 11.3 数—模转换方法 11.4 数字信号处理基础 关键词 判断题 自测题 习题 答案\n第12章 集成电路技术 12.1 基本操作特性和参数 12.2 CMOS电路 12.3 TTL电路 12.4 TTL在实际使用中的注意事项 12.5 CMOS和TTL性能的比较 12.6 发射极耦合逻辑(ECL)电路 12.7 PMOS、 NMOS和E2CMOS 关键词 判断题 自测题 习题 答案 附录A 卡诺图或与项(POS)的小化 附录B Q—M方法(奎恩—麦克拉斯基化简法) 附录C 数字电路NI Multisim仿真——仿真、 样机、 测试电路理论、 设计与画图 奇数编号题*\n","date":"2023-07-12T21:20:25+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/","title":"数字电子技术"},{"content":" 文件下载链接 https://github.com/txt1994/keil_plugs 本人收集的Keil插件，当然也可用于其他软件\n1.AStyle 下载链接:\nhttps://sourceforge.net/projects/astyle/files 1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令： -n !E --style=google -s4 对多个文件格式化，但需要在同一个文件夹，命令：\n-n \u0026#34;$E*.c\u0026#34; \u0026#34;$E*.h\u0026#34; --style=google -p -s4 -S -f -xW -w -xw -R 2.FileComments 2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令： !E 3.DateTime 3.1 DateTime可以识别当前日期和时间，用的不多，命令： 当前日期：\n!E ~E ^E 当前时间：\n!E ~E ^E T 4.FunctionComment 4.1 FunctionComment可以提供函数快速添加注释，命令： !E ~E 把这些插件添加到keil中，打开keil，依次点击Tools-\u0026gt;Customize Tools Menu,此时页面是这样的： 把上述的插件添加进去，Command是插件路径，Arguments是使用插件时的参数，可以根据需要自行定制\n添加插件的快捷键：点击keil页面的小扳手，找到Shortcut Keys,把下拉框拉到刚才添加的插件处，右边是添加快键键的地方，添加后可以使用了\n","date":"2023-07-11T13:55:45Z","permalink":"https://okokfun.github.io/post/keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/","title":"适用于Keil的插件合集"},{"content":"第三部分 新的标准库组件 本部分介绍了 C++17 的新库组件。\n15 std::optional\u0026lt;\u0026gt; 在编程中，我们经常遇到可能返回/传递/使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布尔成员/标志，表明一个值是否存在。 std::optional\u0026lt;\u0026gt; 以类型安全的方式提供此类对象。\n可选对象仅具有包含对象的内部存储器以及布尔标志。因此，大小通常比包含的对象大一个字节。对于某些包含的类型，甚至可能根本没有大小开销，前提是可以将附加信息放置在包含的对象中。没有分配堆内存。对象使用与包含类型相同的对齐方式。\n但是，可选对象不仅仅是将布尔标志的功能添加到值成员的结构。例如，如果没有值，则不会为包含的类型调用构造函数（因此，您可以为对象提供没有的默认状态）。\n与 std::variant\u0026lt;\u0026gt; 和 std::any 一样，结果对象具有值语义。也就是说，复制被实现为深度复制，创建一个独立的对象，带有标志和包含的值（如果有的话）在它自己的内存中。复制没有包含值的 std::optional\u0026lt;\u0026gt; 很便宜；复制带有包含值的 std::optional\u0026lt;\u0026gt; 与复制包含的类型/值一样便宜/昂贵。支持移动语义。\n15.1 使用 std::optional\u0026lt;\u0026gt; std::optional\u0026lt;\u0026gt;模型是一个任意类型的可忽略的实例。这个实例可能是一个成员，一个参数，或者一个返回值。你也可以说，std::optional\u0026lt;\u0026gt;是一个容纳零或一个元素的容器。\n15.1.1 可选的返回值 以下程序演示了 std::optional\u0026lt;\u0026gt; 用作返回值的能力： lib/optional.cpp\n#include \u0026lt;optional\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; // 如果可能，将字符串转换为 int: std::optional\u0026lt;int\u0026gt; asInt(const std::string\u0026amp; s) { try { return std::stoi(s); } catch (...) { return std::nullopt; } } int main() { for (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 如果可能，尝试将 s 转换为 int 并打印结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int\\n\u0026#34;; } } } 在程序中 asInt() 是将传递的字符串转换为整数的函数。 但是，这可能不会成功。 出于这个原因，使用了 std::optional\u0026lt;\u0026gt; 以便我们可以返回\u0026quot;no int\u0026quot;并避免为其定义一个特殊的 int 值或向调用者抛出异常。 因此，我们要么返回调用 stoi() 的结果，它用一个 int 初始化返回值，要么我们返回 std::nullopt，表明我们没有一个 int 值。 我们可以实现如下相同的行为：\nstd::optional\u0026lt;int\u0026gt; asInt(const std::string\u0026amp; s) { std::optional\u0026lt;int\u0026gt; ret; // 最初没有值 try { ret = std::stoi(s); } catch (...) { } return ret; } 在 main() 中，我们为不同的字符串调用此函数。\nfor (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 将 s 转换为 int 并尽可能使用结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); ... } 对于我们评估的每个返回的 std::optional oi，我们是否有一个值（通过将对象评估为布尔表达式）并通过“取消引用”可选对象来访问该值：\nif (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 请注意，对于字符串“0x33”，asInt() 产生 0，因为 stoi() 不会将字符串解析为十六进制值。 有其他方法可以实现对返回值的处理，例如：\nstd::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi.has_value()) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; oi.value() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 在这里，has_value() 用于检查是否返回了一个值，并使用 value() 访问它。 value() 比 operator * 更安全：如果不存在值，它会抛出异常。 运算符 * 仅应在您确定可选项包含值时使用； 否则你的程序将有未定义的行为。 请注意，我们可以通过使用新类型 std::string_view 来改进 asInt()。\n15.1.2 可选参数和数据成员 另一个使用 std::optional\u0026lt;\u0026gt; 的例子是参数的可选传递 and/or 数据成员的可选设置：\nlib/optionalmember.cpp\n#include \u0026lt;string\u0026gt; #include \u0026lt;optional\u0026gt; #include \u0026lt;iostream\u0026gt; class Name { private: std::string first; std::optional\u0026lt;std::string\u0026gt; middle; std::string last; public: Name (std::string f, std::optional\u0026lt;std::string\u0026gt; m, std::string l) : first{std::move(f)}, middle{std::move(m)}, last{std::move(l)} {} friend std::ostream\u0026amp; operator \u0026lt;\u0026lt; (std::ostream\u0026amp; strm, const Name\u0026amp; n) { strm \u0026lt;\u0026lt; n.first \u0026lt;\u0026lt; \u0026#39; \u0026#39;; if (n.middle) { strm \u0026lt;\u0026lt; *n.middle \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return strm \u0026lt;\u0026lt; n.last; } }; int main() { Name n{\u0026#34;Jim\u0026#34;, std::nullopt, \u0026#34;Knopf\u0026#34;}; std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Name m{\u0026#34;Donald\u0026#34;, \u0026#34;Ervin\u0026#34;, \u0026#34;Knuth\u0026#34;}; std::cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 类名表示由名字、可选的中间名和姓氏组成的名称。 成员 middle 被相应地定义，并且构造函数允许在没有中间名时传递 std::nullopt 。 这是与中间名是空字符串不同的状态。\n请注意，与通常具有值语义的类型一样，定义初始化相应成员的构造函数的最佳方法是按值获取参数并将参数移动到成员：\n还要注意 std::optional\u0026lt;\u0026gt; 改变了对成员中间值的访问。 使用 middle 作为布尔表达式会产生是否存在中间名，必须使用 *middle 来访问当前值（如果有）。\n访问该值的另一个选项是使用成员函数 value_or()，它可以在不存在值的情况下指定一个备用值。 例如，在类 Name 中，我们还可以实现：\nstd::cout \u0026lt;\u0026lt; middle.value_or(\u0026#34;\u0026#34;); // 打印中间名或什么都没有 15.2 std::optional\u0026lt;\u0026gt; 类型和操作 本节详细介绍 std::optional\u0026lt;\u0026gt; 的类型和操作。\n15.2.1 std::optional\u0026lt;\u0026gt; 类型 在头文件 中，C++ 标准库定义类 std::optional\u0026lt;\u0026gt; 如下：\nnamespace std { template\u0026lt;typename T\u0026gt; class optional; } 此外，还定义了以下类型和对象：\nstd::nullopt_t 类型的 nullopt 作为没有值的可选对象的“值”。 异常类std::bad_optional_access，它派生自std::exception，用于没有值的值访问。 可选对象还使用 中定义的对象 std::in_place（std::in_place_t 类型）来初始化具有多个参数的可选对象的值（见下文）。\n15.2.2 std::optional\u0026lt;\u0026gt; 操作 表 std::optional Operations 列出了为 std::optional\u0026lt;\u0026gt; 提供的所有操作。\n建造 特殊构造函数可以将参数直接传递给包含的类型。\n您可以创建一个没有值的可选对象。 在这种情况下，您必须指定包含的 类型：\nstd::optional\u0026lt;int\u0026gt; o1; std::optional\u0026lt;int\u0026gt; o2(std::nullopt); 这不会调用包含类型的任何构造函数.\n您可以传递一个值来初始化包含的类型。 由于推导指南，您不必指定包含的类型，然后：\nstd::optional o3{42}; // 推导出optional\u0026lt;int\u0026gt; std::optional\u0026lt;std::string\u0026gt; o4{\u0026#34;hello\u0026#34;}; std::optional o5{\u0026#34;hello\u0026#34;}; // 推导出 optional\u0026lt;const char*\u0026gt; 操作 作用 constructors 创建一个可选对象（可能为包含的调用构造函数类型） make_optional\u0026lt;\u0026gt;() 创建一个可选对象（传递值来初始化它） destructor 销毁一个可选对象 = 分配一个新值 emplace() 为包含的类型分配一个新值 reset() 销毁任何值（使对象为空） has_value() 返回对象是否有值 conversion to bool 返回对象是否有值 * 值访问（如果没有值，则为未定义行为） -\u0026gt; 访问值的成员（如果没有值，则行为未定义） value() 值访问（如果没有值则例外） value_or() 值访问（如果没有值，则为后备参数） swap() 在两个对象之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较可选对象 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 要使用多个参数初始化可选对象，您必须创建对象或添加 std::in_place 作为第一个参数（无法推断包含的类型）：\nstd::optional o6{std::complex{3.0, 4.0}}; std::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o7{std::in_place, 3.0, 4.0}; 请注意，后一种形式避免了创建临时对象。 通过使用这种形式，你甚至可以传递一个初始化列表和额外的参数：\n// 使用 lambda 作为排序标准初始化集合: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::optional\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt; o8{std::in_place, {4, 8, -7, -2, 0, 5}, sc }; 您可以复制可选对象（包括类型转换）。\nstd::optional o5{\u0026#34;hello\u0026#34;}; // 推导出 optional\u0026lt;const char*\u0026gt; std::optional\u0026lt;std::string\u0026gt; o9{o5}; // OK 请注意，还有一个便利函数 make_optional\u0026lt;\u0026gt;()，它允许使用单个或多个参数进行初始化（不需要 in_place 参数）。 像往常一样 make\u0026hellip; 函数它会衰减：\nauto o10 = std::make_optional(3.0); // optional\u0026lt;double\u0026gt; auto o11 = std::make_optional(\u0026#34;hello\u0026#34;); // optional\u0026lt;const char*\u0026gt; auto o12 = std::make_optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;(3.0, 4.0); 但是，请注意，没有构造函数获取值并根据其值来决定是使用值初始化可选项还是 nullopt。 为此，必须使用运算符 ?:。 例如：\nstd::multimap\u0026lt;std::string, std::string\u0026gt; englishToGerman; ... auto pos = englishToGerman.find(\u0026#34;wisdom\u0026#34;); auto o13 = pos != englishToGerman.end() ? std::optional{pos-\u0026gt;second} : std::nullopt; 在这里，由于 std::optional{pos-\u0026gt;second} 的类模板参数推导，o13 被初始化为 std::optionalstd::string。 对于 std::nullopt 类模板参数推导不起作用，但 operator ?: 在推导表达式的结果类型时也将其转换为这种类型。\n访问值 要检查可选对象是否具有值，您可以在布尔表达式中使用它或调用 has_value()：\nstd::optional o{42}; if (o) ... // true if (!o) ... // false if (o.has_value()) ... // true 然后，为了访问该值，提供了一种指针语法。 也就是说，使用 operator* 您可以直接访问它的值，而 operator-\u0026gt; 可以访问该值的成员：\nstd::optional o{std::pair{42, \u0026#34;hello\u0026#34;}}; auto p = *o; // 将 p 初始化为 pair\u0026lt;int,string\u0026gt; std::cout \u0026lt;\u0026lt; o-\u0026gt;first; // prints 42 请注意，这些运算符要求可选项包含一个值。 在没有值的情况下使用它们是未定义的行为：\nstd::optional\u0026lt;std::string\u0026gt; o{\u0026#34;hello\u0026#34;}; std::cout \u0026lt;\u0026lt; *o; // OK: prints ”hello” o = std::nullopt; std::cout \u0026lt;\u0026lt; *o; // 未定义的行为 请注意，实际上第二个输出仍然会编译并执行一些输出，例如再次打印“hello”，因为可选对象的值的底层内存没有被修改。\n但是，您不能也不应该依赖它。 如果您不知道可选对象是否有值，则必须调用以下代码：\nif (o) std::cout \u0026lt;\u0026lt; *o; // OK (可能什么也不输出) 或者，您可以使用 value()，如果没有包含值，则会引发 std::bad_optional_access 异常：\nstd::cout \u0026lt;\u0026lt; o.value(); // OK (如果没有值则抛出) std::bad_optional_access 直接派生自 std::exception。\n最后，您可以请求该值并传递一个备用值，如果可选对象没有值，则使用该值：\nstd::cout \u0026lt;\u0026lt; o.value_or(\u0026#34;fallback\u0026#34;); // OK (如果没有值则输出fallback) 后备参数作为右值引用传递，因此如果不使用后备，它不会花费任何成本，并且如果使用它，它支持移动语义。 请注意，operator* 和 value() 都通过引用返回包含的对象。 因此，在直接调用这些操作以获取临时返回值时，您必须小心。 例如：\nstd::optional\u0026lt;std::string\u0026gt; getString(); ...; auto a = getString().value(); // OK: 包含对象的副本 auto b = *getString(); // ERROR: 如果 std::nullopt 的行为未定义 const auto\u0026amp; r1 = getString().value(); // ERROR: 引用已删除的包含对象 auto\u0026amp;\u0026amp; r2 = getString().value(); // ERROR: 引用已删除的包含对象 一个示例可能是基于范围的 for 循环的以下用法：\nstd::optional\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getVector(); ...; for (int i : getVector().value()) { // ERROR: 迭代已删除的vector std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 请注意，迭代返回的 int 向量是可行的。 所以，不要盲目地将函数 foo() 的返回类型替换为相应的可选类型，而是调用 foo().value() 。\n对比 您可以使用通常的比较运算符。 操作数可以是可选对象， 包含类型和 std::nullopt。\n如果两个操作数都是具有值的对象，则使用包含类型的相应运算符。 如果两个操作数都是没有值的对象，则它们被认为是相等的（== 产生 true 并且 所有其他比较结果为假）。 如果只有一个操作数是具有值的对象，则认为没有值的操作数小于另一个操作数。 例如：\nstd::optional\u0026lt;int\u0026gt; o0; std::optional\u0026lt;int\u0026gt; o1{42}; /* o0 == std::nullopt // yields true o0 == 42 // yields false o0 \u0026lt; 42 // yields true o0 \u0026gt; 42 // yields false o1 == 42 // yields true o0 \u0026lt; o1 // yields true */ 这意味着对于 unsigned int 的可选对象，有一个小于 0 的值，对于 bool 的可选对象，有一个小于 0 的值：\nstd::optional\u0026lt;unsigned\u0026gt; uo; uo \u0026lt; 0 // yields true std::optional\u0026lt;bool\u0026gt; bo; bo \u0026lt; false // yields true 同样，支持底层类型的隐式类型转换：\nstd::optional\u0026lt;int\u0026gt; o1{42}; std::optional\u0026lt;double\u0026gt; o2{42.0}; /* o2 == 42 // yields true o1 == o2 // yields true */ 请注意，可选的布尔值或原始指针值可能会导致一些意外。\n更改值 赋值和 emplace() 操作对应于初始化存在：\nstd::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o; // 没有值 std::optional ox{77}; // optional\u0026lt;int\u0026gt; with value 77 o = 42; // 值变为 complex(42.0, 0.0) o = {9.9, 4.4}; // 值变为 complex(9.9, 4.4) o = ox; // OK, 因为 int 转换为 complex\u0026lt;double\u0026gt; o = std::nullopt; // o 不再具有值 o.emplace(5.5, 7.7); // 值变为 complex(5.5, 7.7) 分配 std::nullopt 会删除该值，如果之前有值，则调用包含类型的析构函数。 您可以通过调用 reset() 来获得相同的效果：\no.reset(); // o 不再具有值 或分配空花括号：\no = {}; // o 不再具有值 最后，我们还可以使用 operator* 来修改值，因为它通过引用产生值。 但是，请注意，这需要有一个值要修改：\nstd::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; o; *o = 42; // 未定义的行为 ...; if (o) { *o = 88; // OK: 值变为 complex(88.0, 0.0) *o = {1.2, 3.4}; // OK: 值变为 complex(1.2, 3.4) } 移动语义 std::optional\u0026lt;\u0026gt; 也支持移动语义。 如果将对象作为一个整体移动，则将复制状态并移动包含的对象（如果有）。 结果，移出的对象仍然具有相同的状态，但任何值都未指定。\n​\t但是您也可以将值移入或移出包含的对象。 例如：\nstd::optional\u0026lt;std::string\u0026gt; os; std::string s = \u0026#34;a very very very long string\u0026#34;; os = std::move(s); // OK, 移动 std::string s2 = *os; // OK 拷贝 std::string s3 = std::move(*os); // OK, 移动 请注意，在最后一次调用之后 os 仍然有一个字符串值，但对于已移动的对象，该值通常是未指定的。 因此，只要您不对它的值做任何假设，您就可以使用它。 您甚至可以在那里分配一个新的字符串值。\n散列 可选对象的哈希值是包含的非常量类型（如果有）的哈希值。\n15.3 特殊情况 特定的可选值类型可能会导致特殊或意外行为。\n15.3.1 可选的布尔值或原始指针值 请注意，使用比较运算符与使用可选对象作为布尔值具有不同的语义。 如果包含的类型是 bool 或指针类型，这可能会变得令人困惑：例如：\nstd::optional\u0026lt;bool\u0026gt; ob{false}; // 有值，为假 if (!ob) ... // 产生错误 if (ob == false) ... // yields true std::optional\u0026lt;int*\u0026gt; op{nullptr}; if (!op) ... // yields false if (op == nullptr) ... // yields true 15.3.2 Optional 的 Optional 原则上，您还可以定义可选值的可选：\nstd::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos1; std::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos2 = \u0026#34;hello\u0026#34;; std::optional\u0026lt;std::optional\u0026lt;std::string\u0026gt;\u0026gt; oos3{std::in_place, std::in_place, \u0026#34;hello\u0026#34;}; std::optional\u0026lt;std::optional\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;\u0026gt; ooc{std::in_place, std::in_place, 4.2, 5.3}; 即使使用隐式转换，您也可以分配新值：\noos1 = \u0026#34;hello\u0026#34;; // OK: 分配新值 ooc.emplace(std::in_place, 7.2, 8.3); 由于没有值的两个层次，可选的可选使得在外部或内部具有“无值”，这可以具有不同的语义含义：\n*oos1 = std::nullopt; // 内部可选没有值 oos1 = std::nullopt; // 外部可选没有值 但是您必须特别注意处理可选值：\nif (!oos1) std::cout \u0026lt;\u0026lt; \u0026#34;no value\\n\u0026#34;; if (oos1 \u0026amp;\u0026amp; !*oos1) std::cout \u0026lt;\u0026lt; \u0026#34;no inner value\\n\u0026#34;; if (oos1 \u0026amp;\u0026amp; *oos1) std::cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; **oos1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 但是，因为这在语义上更像是一个具有两个不同状态的值，表示没有值，所以具有两个布尔或单态替代方案的 std::variant\u0026lt;\u0026gt; 可能更合适。\n15.4 后记 可选对象于 2005 年由 Fernando Cacciola 在 https://wg21.link/n1878 中首次提出，将 Boost.Optional 作为参考实现。 正如 Fernando Cacciola 和 Andrzej Krzemienski 在 https://wg21.link/n3793 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。\n正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。\nTony van Eerd 使用 https://wg21.link/n3765 和 https://wg21.link/p0307r2 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::variant\u0026lt;\u0026gt; 和 std::any 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。\n16 std::variant\u0026lt;\u0026gt; 借助 std::variant\u0026lt;\u0026gt;，C++ 标准库提供了一个新的联合类，其中包括支持多态性和处理非同质集合的新方法。 也就是说，它允许我们处理不同数据类型的元素，而无需公共基类和指针（原始或智能）。\n16.1 std::variant\u0026lt;\u0026gt; 的时机 从 C 中采用，C++ 提供对联合的支持，联合是能够保存可能类型列表之一的对象。但是，此语言功能存在一些缺点：\n对象不知道它们当前持有哪种类型的值。 出于这个原因，您不能拥有非平凡的成员，例如 std::string （无需特别努力）。 你不能从工会派生。 使用 std::variant\u0026lt;\u0026gt;，C++ 标准库提供了一个封闭的可区分联合（这意味着有一个指定的可能类型列表，您可以指定您的意思），其中 当前值的类型总是已知的， 可以有任何指定类型的成员，并且 你可以从中得到。 事实上，一个 std::variant\u0026lt;\u0026gt; 保存着各种选择的值，这些选择通常有不同的类型。但是两个替代也可以具有相同的类型，如果具有不同语义含义的替代具有相同的类型，这很有用（例如，持有两个字符串，它们代表不同的数据库列，以便您仍然知道该值代表哪些列） . 变体只是具有用于基础类型的最大大小的内部存储器以及一些固定的开销来管理使用哪个替代方案。 没有分配堆内存。\n一般来说，变量不能为空，除非您使用特定的替代信号来表示空虚。 但是，在极少数情况下（例如由于在分配不同的新值期间出现异常） type) 变体可以进入一个没有任何价值的状态。\n与 std::optional\u0026lt;\u0026gt; 和 std::any 一样，结果对象具有值语义。 通过在自己的内存中创建一个具有当前替代项的当前值的独立对象来进行深度复制。 因此，复制 std::variant\u0026lt;\u0026gt; 与复制当前替代的 type/value 一样便宜/昂贵。 支持移动语义。\n16.2 使用 std::variant\u0026lt;\u0026gt; 以下示例演示了 std::variant\u0026lt;\u0026gt; 的核心功能：\nlib/variant.cpp #include \u0026lt;variant\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::variant\u0026lt;int, std::string\u0026gt; var{\u0026#34;hi\u0026#34;}; // 用字符串替代初始化 std::cout \u0026lt;\u0026lt; var.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 var = 42; // 现在持有 int 替代品 std::cout \u0026lt;\u0026lt; var.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 0 ...; try { int i = std::get\u0026lt;0\u0026gt;(var); // 按索引访问 std::string s = std::get\u0026lt;std::string\u0026gt;(var); // 按类型访问（在这种情况下抛出异常） ...; } catch (const std::bad_variant_access\u0026amp; e) { // 如果使用了错误的type/index std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ...; } } 成员函数 index() 可用于找出当前设置了哪个备选方案（第一个备选方案的索引为 0）。\n初始化和赋值总是使用最佳匹配来找出新的替代方案。 如果类型不完全适合，可能会出现意外。\n请注意，不允许使用空变体、具有引用成员的变体、具有 C 样式数组成员的变体以及具有不完整类型（例如 void）的变体。\n没有空状态。 这意味着对于每个构造对象，必须调用至少一个构造函数。 默认构造函数使用默认构造函数初始化第一个类型：\nstd::variant\u0026lt;std::string, int\u0026gt; var; // =\u0026gt; var.index() == 0, value == ”” 如果没有为第一种类型定义默认构造函数，则调用变体的默认构造函数是编译时错误：\nstruct NoDefConstr { NoDefConstr(int i) { std::cout \u0026lt;\u0026lt; \u0026#34;NoDefConstr::NoDefConstr(int) called\\n\u0026#34;; } }; std::variant\u0026lt;NoDefConstr, int\u0026gt; v1; // ERROR: 不能默认构造第一类型 辅助类型 std::monostate 提供了处理这种情况的能力，也提供了模拟空状态的能力。\nstd::monostate 为了支持第一种类型没有默认构造函数的变体，提供了一个特殊的辅助类型：std::monostate。 std::monostate 类型的对象始终具有相同的状态。 因此，它们总是比较相等。 他们自己的目的是表示一个替代类型，以便该变体没有任何其他类型的值。\n也就是说，struct std::monostate 可以作为第一个替代类型，以使变体类型默认可构造。 例如：\nstd::variant\u0026lt;std::monostate, NoDefConstr\u0026gt; v2; // OK std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 0 在某种程度上，您可以将状态解释为表示空虚。 有多种方法可以检查单态，这也演示了其他一些操作，您可以调用变体：\nif (v2.index() == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (!v2.index()) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::holds_alternative\u0026lt;std::monostate\u0026gt;(v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::get_if\u0026lt;0\u0026gt;(\u0026amp;v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } if (std::get_if\u0026lt;std::monostate\u0026gt;(\u0026amp;v2)) { std::cout \u0026lt;\u0026lt; \u0026#34;has monostate\\n\u0026#34;; } get_if\u0026lt;\u0026gt;() 使用指向变体的指针，如果当前备选方案是 T，则返回指向当前备选方案的指针。否则返回 nullptr。 这与 get() 不同，get() 采用对变体的引用，如果提供的类型正确，则按值返回当前替代项，否则抛出。\n像往常一样，您可以分配另一个替代的值，甚至分配单态，再次表示空虚：\nv2 = 42; std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // index: 1 v2 = std::monostate{}; std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // index: 0 从变体派生 您可以从 std::variant 派生。 例如，您可以定义从 std::variant\u0026lt;\u0026gt; 派生的聚合，如下所示：\nclass Derived : public std::variant\u0026lt;int, std::string\u0026gt; { }; Derived d = {{\u0026#34;hello\u0026#34;}}; std::cout \u0026lt;\u0026lt; d.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 1 std::cout \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(d) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: hello d.emplace\u0026lt;0\u0026gt;(77); // 初始化 int，销毁字符串 std::cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(d) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 77 16.3 std::variant\u0026lt;\u0026gt; 类型和操作 本节详细介绍 std::variant\u0026lt;\u0026gt; 的类型和操作。\n16.3.1 std::variant\u0026lt;\u0026gt; 类型 在头文件 中，C++ 标准库定义类 std::variant\u0026lt;\u0026gt; 如下：\nnamespace std { template\u0026lt;typename Types...\u0026gt; class variant; } 也就是说，std::variant\u0026lt;\u0026gt; 是一个可变参数类模板（C++11 引入的一个特性，允许处理任意数量的类型）。 此外，还定义了以下类型和对象：\n类型 std::variant_size\n类型 std::variant_alternative\n值 std::variant_npos\n类型 std::monostate\n异常类 std::bad_variant_access，派生自 std::exception。\n变体还使用在 utility\u0026gt; 中定义的两个对象 std::in_place_type（std::in_place_type_t 类型）和 std::in_place_index（std::in_place_index_t 类型）。\n16.3.2 std::variant\u0026lt;\u0026gt; 操作 表 std::variant Operations 列出了为 std::variant\u0026lt;\u0026gt; 提供的所有操作.\n构造 默认情况下，变体的默认构造函数调用第一个替代的默认构造函数：\nstd::variant\u0026lt;int, int, std::string\u0026gt; v1; // 将第一个 int 设置为 0，index()==0 另一种方法是值初始化，这意味着对于基本类型，它是 0、false 或 nullptr。 如果为初始化传递了一个值，则使用最佳匹配类型：\nstd::variant\u0026lt;long, int\u0026gt; v2{42}; std::cout \u0026lt;\u0026lt; v2.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 但是，如果两种类型匹配得一样好，则调用是模棱两可的：\nstd::variant\u0026lt;long, long\u0026gt; v3{42}; // ERROR: 模糊的 std::variant\u0026lt;int, float\u0026gt; v4{42.3}; // ERROR: 模糊的 std::variant\u0026lt;int, double\u0026gt; v5{42.3}; // OK std::variant\u0026lt;int, long double\u0026gt; v6{42.3}; // ERROR: 模糊的 std::variant\u0026lt;std::string, std::string_view\u0026gt; v7{\u0026#34;hello\u0026#34;}; // ERROR: 模糊的 std::variant\u0026lt;std::string, std::string_view, const char*\u0026gt; v8{\u0026#34;hello\u0026#34;}; // OK std::cout \u0026lt;\u0026lt; v8.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 2 操作 作用 constructors 创建一个变体对象（可能调用底层类型的构造函数） destructor 销毁一个变体对象 = 分配一个新值 emplace() 为具有类型 T 的替代项分配一个新值 emplace() 为索引 Idx 的替代项分配一个新值 valueless_by_exception() 返回变量是否由于异常而没有值 index() 返回当前替代的索引 swap() 在两个对象之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较不同的对象 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 holds_alternative() 返回是否有类型 T 的值 get() 返回类型为 T 或 throws 的替代项的值 get() 返回具有索引 Idx 或 throws 的替代项的值 get_if() 返回指向 T 或 nullptr 类型的替代值的指针 get_if() 返回指向具有索引 Idx 或 nullptr 的替代项的值的指针 visit() 对当前备选方案执行操作 要为初始化传递多个值，您必须使用 in_place_type 或 in_place_index 标签：\nstd::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v9{3.0, 4.0}; // ERROR std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v10{{3.0, 4.0}}; // ERROR std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v11{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 3.0, 4.0}; std::variant\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt; v12{std::in_place_index\u0026lt;0\u0026gt;, 3.0, 4.0}; 您还可以在初始化期间使用 in_place_index 标记来解决歧义或否决优先级：\nstd::variant\u0026lt;int, int\u0026gt; v13{std::in_place_index\u0026lt;1\u0026gt;, 77}; // 初始化第二个 int std::variant\u0026lt;int, long\u0026gt; v14{std::in_place_index\u0026lt;1\u0026gt;, 77}; // 初始化长，而不是 int std::cout \u0026lt;\u0026lt; v14.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 1 你甚至可以传递一个初始化列表，后跟其他参数：\n// initialize variant with a set with lambda as sorting criterion: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::variant\u0026lt;std::vector\u0026lt;int\u0026gt;, std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt; v15{std::in_place_index\u0026lt;1\u0026gt;, {4, 8, -7, -2, 0, 5}, sc }; 你不能对 std::variant\u0026lt;\u0026gt; 使用类模板参数推导。 并且没有 make_variant\u0026lt;\u0026gt;() 便利函数（与 std::optional\u0026lt;\u0026gt; 和 std::any 不同）。 两者都没有意义，因为变体的整个目标是处理多种选择。\n访问值 访问该值的常用方法是调用 get\u0026lt;\u0026gt;() 以获得相应的替代方法。 您可以传递它的索引，或者，如果一个类型不被多次使用，它的类型。 例如：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 auto a = std::get\u0026lt;double\u0026gt;(var); // compile-time 错误：没有双精度 auto b = std::get\u0026lt;4\u0026gt;(var); // compile-time 错误: 没有第四选择 auto c = std::get\u0026lt;int\u0026gt;(var); // compile-time 错误: int 两次 try { auto s = std::get\u0026lt;std::string\u0026gt;(var); // 抛出异常（当前设置的第一个 int） auto i = std::get\u0026lt;0\u0026gt;(var); // OK, i==0 auto j = std::get\u0026lt;1\u0026gt;(var); // 抛出异常（当前设置的其他 int） } catch (const std::bad_variant_access\u0026amp; e) { // 在无效访问的情况下 std::cout \u0026lt;\u0026lt; \u0026#34;Exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 还有一个 API 可以通过选项检查它是否存在来访问该值：\nif (auto ip = std::get_if\u0026lt;1\u0026gt;(\u0026amp;var); ip) { std::cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;alternative with index 1 not set\\n\u0026#34;; } 您必须将指向变体的指针传递给 get_if\u0026lt;\u0026gt;()，它要么返回指向当前值的指针，要么返回 nullptr。 请注意，如果使用 with 初始化，则可以检查刚刚初始化的值。 访问不同选项值的另一种方法是变体访问者。\n更改值 赋值和 emplace() 操作对应于初始化存在：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 var = \u0026#34;hello\u0026#34;; // 设置字符串，index()==2 var.emplace\u0026lt;1\u0026gt;(42); // 设置第二个 int，index()==1 您还可以使用 get\u0026lt;\u0026gt;() 或 get_if\u0026lt;\u0026gt;() 为当前替代项分配一个新值：\nstd::variant\u0026lt;int, int, std::string\u0026gt; var; // 将第一个 int 设置为 0，index()==0 std::get\u0026lt;0\u0026gt;(var) = 77; // OK,因为第一个 int 已经设置 std::get\u0026lt;1\u0026gt;(var) = 99; // 抛出异常（当前设置的其他 int） if (auto p = std::get_if\u0026lt;1\u0026gt;(\u0026amp;var); p) { // 如果第二个 int 设置 *p = 42; // 修改它 } 修改不同选项值的另一种方法是变体访问者\n比较 对于相同类型的两个变体（即具有相同顺序的相同替代项），您可以使用通常的比较运算符。 运营商按照以下规则行事：\n具有较早替代值的变体小于具有较晚替代值的变体。 如果两个变体具有相同的备选方案，则评估备选方案类型的相应运算符。 注意 std::monostate 类型的所有对象总是相等的。 特殊状态 valueless_by_exception() 为 true 的两个变体是相等的。 否则，任何 valueless_by_exception() 为 true 的变体都小于任何其他变体。 例如：\nstd::variant\u0026lt;std::monostate, int, std::string\u0026gt; v1, v2{\u0026#34;hello\u0026#34;}, v3{42}; std::variant\u0026lt;std::monostate, std::string, int\u0026gt; v4; /* v1 == v4 // COMPILE-TIME ERROR v1 == v2 // yields false v1 \u0026lt; v2 // yields true v1 \u0026lt; v3 // yields true v2 \u0026lt; v3 // yields false v1 = \u0026#34;hello\u0026#34;; v1 == v2 // yields true v2 = 41; v2 \u0026lt; v3 // yields true */ 移动语义 std::variant\u0026lt;\u0026gt; 也支持移动语义。 如果您将对象作为一个整体移动，则将复制状态并移动当前替代项的值。 结果，移出的对象仍然具有相同的选择，但任何值都变得未指定。 您还可以将值移入或移出包含的对象。\n散列 当且仅当每个成员类型都可以提供哈希值时，才启用变体对象的哈希值。 请注意，哈希值不是当前备选方案的哈希值。\n16.3.3 访客 他们必须明确地为每种可能的类型提供函数调用运算符。 然后，使用相应的重载来处理当前的替代方案。\n使用函数对象作为访问者 例子：\nlib/variantvisit.cpp #include \u0026lt;variant\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; struct MyVisitor { void operator() (int i) const { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator() (std::string s) const { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator() (long double d) const { std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { std::variant\u0026lt;int, std::string, double\u0026gt; var(42); std::visit(MyVisitor(), var); // 为 int 调用 operator() var = \u0026#34;hello\u0026#34;; std::visit(MyVisitor(), var); // 为string调用 operator() var = 42.7; std::visit(MyVisitor(), var); // 为long double调用 operator() } 如果 operator() 不支持所有可能的类型或调用不明确，则 visit() 调用是编译时错误。 此处的示例运行良好，因为 long double 比 int 更适合 double 值。 您还可以使用访问者来修改当前替代的值（但不能分配新的替代）。 例如：\nstruct Twice { void operator()(double\u0026amp; d) const { d *= 2; } void operator()(int\u0026amp; i) const { i *= 2; } void operator()(std::string\u0026amp; s) const { s = s + s; } }; std::visit(Twice(), var); // calls operator() for matching type 因为只有类型很重要，所以对于具有相同类型的替代方案，您不能有不同的行为。 请注意，函数调用运算符应标记为 const，因为它们是无状态的（它们不会改变行为，只会改变传递的值）。\n使用通用 Lambda 作为访问者 使用此功能的最简单方法是使用通用 lambda，它是任意类型的函数对象：\nauto printvariant = [](const auto\u0026amp; val) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; ...; std::visit(printvariant, var); 在这里，通用 lambda 定义了一个闭包类型，其中函数调用运算符作为成员模板：\nclass CompilerSpecifyClosureTypeName { public: template\u0026lt;typename T\u0026gt; auto operator() (const T\u0026amp; val) const { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; 因此，如果生成的函数调用运算符中的语句有效（即调用输出运算符有效），则传递给 std::visit() 的 lambda 调用将编译。 您还可以使用 lambda 来修改当前替代项的值：\n// 将当前替代品的值翻倍: std::visit([](auto\u0026amp; val) { val = val + val; }, var); 或者：\n// 恢复为当前替代的默认值; std::visit([](auto\u0026amp; val) { val = std::remove_reference_t\u0026lt;decltype(val)\u0026gt;{}; }, var); 您甚至可以使用编译时语言功能以不同方式处理不同的替代方案。 例如：\nauto dblvar = [](auto\u0026amp; val) { if constexpr(std::is_convertible_v\u0026lt;decltype(val), std::string\u0026gt;) { val = val + val; } else { val *= 2; } }; ...; std::visit(dblvar, var); 在这里，对于 std::string 替代方案，通用 lambda 的调用实例化其通用函数调用模板以进行计算：\nval = val + val; 而对于其他替代方案，例如 int 或 double，lambda 的调用实例化其通用函数调用模板来计算：\nval *= 2; 使用重载的 Lambda 作为访问者 通过对函数对象和 lambda 使用重载器，您还可以定义一组 lambda，其中最佳匹配用作访问者。 假设重载器是重载定义如下：\ntmpl/overload.hpp // “继承”传递的基类型的所有函数调用运算符: template\u0026lt;typename... Ts\u0026gt; struct overload : Ts... { using Ts::operator()...; }; // 基类型是从传递的参数推导出来的: template\u0026lt;typename... Ts\u0026gt; overload(Ts...) -\u0026gt; overload\u0026lt;Ts...\u0026gt;; 您可以通过为每个替代方案提供 lambdas 来使用重载来访问变体：\nstd::variant\u0026lt;int, std::string\u0026gt; var(42); ...; std::visit(overload{ // 调用当前替代的最佳匹配 lambda [](int i) { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, [](const std::string\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, }, var); 您还可以使用通用 lambda。 始终使用最佳匹配。 例如，要修改变体的当前替代项，您可以使用重载将字符串和其他类型的值“加倍”：\nauto twice = overload{ [](std::string\u0026amp; s) { s += s; }, [](auto\u0026amp; i) { i *= 2; }, }; 有了这个重载，对于字符串替代，当前值被附加，而对于所有其他类型，该值乘以 2，这演示了以下变体的应用：\nstd::variant\u0026lt;int, std::string\u0026gt; var(42); std::visit(twice, var); // value 42 becomes 84 ...; var = \u0026#34;hi\u0026#34;; std::visit(twice, var); // value \u0026#34;hi\u0026#34; becomes \u0026#34;hihi\u0026#34; 16.3.4 例外情况下无值 当修改变体以获取新值并且此修改引发异常时，变体可能会进入一个非常特殊的状态：变体已经失去了旧值，但没有获得新值。 例如：\nstruct S { operator int() { throw \u0026#34;EXCEPTION\u0026#34;; } // 任何到 int 的转换都会抛出 }; std::variant\u0026lt;double,int\u0026gt; var{12.2}; // 初始化为 double var.emplace\u0026lt;1\u0026gt;(S{}); // OOPS: 设置为 int 时抛出 如果发生这种情况，那么：\nvar.valueless_by_exception() 返回真 var.index() 返回 std::variant_npos 这表明该变体根本没有任何价值。 具体保证如下： 如果 emplace() 抛出 valueless_by_exception() 总是设置为 true。 如果 operator=() 抛出并且修改不会改变替代 valueless_by_exception() 并且 index() 保持它们的旧状态。值的状态取决于值类型的异常保证。 如果 operator=() 抛出并且新值将设置不同的替代项，则该变体可能没有值（valueless_by_exception() 可能变为 true）。这取决于何时抛出异常。如果它发生在值的实际修改开始之前的类型转换期间，则变体仍将保留其旧值。 通常，只要您不再使用您尝试修改的变体，这种行为应该没有问题。如果你仍然想使用一个变体，尽管使用它会导致异常，你最好检查它的状态。例如：\nstd::variant\u0026lt;double,int\u0026gt; var{12.2}; // 初始化为 double try { var.emplace\u0026lt;1\u0026gt;(S{}); // OOPS: 设置为 int 时抛出 } catch (...) { if (!var.valueless_by_exception()) { ...; } } 16.4 使用std::variant的多态性和非同质化的集合 具有 std::variant 的多态性和非同质集合\nstd::variant 启用了一种新形式的多态性并处理非同质集合。 它是一种具有一组紧密数据类型的 compile-time 多态性形式。\n也就是说，通过使用 variant\u0026lt;\u0026gt;，您可以定义一个对象是多种可能的类型之一。 然后，该对象具有值语义，您可以将这些对象插入到非同质集合中。 因为每个变体都知道它拥有哪个替代方案，并且由于访问者界面，我们可以在运行时针对不同类型进行编程，调用不同的函数/方法（不需要任何虚函数、引用和指针）。\n16.4.1 使用std::variant的几何对象 例如，假设我们必须对几何对象系统进行编程：\nlib/variantpoly1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;variant\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;coord.hpp\u0026#34; #include \u0026#34;line.hpp\u0026#34; #include \u0026#34;circle.hpp\u0026#34; #include \u0026#34;rectangle.hpp\u0026#34; // 所有几何对象类型的通用类型: using GeoObj = std::variant\u0026lt;Line, Circle, Rectangle\u0026gt;; // 创建和初始化几何对象的集合: std::vector\u0026lt;GeoObj\u0026gt; createFigure() { std::vector\u0026lt;GeoObj\u0026gt; f; f.push_back(Line{Coord{1,2},Coord{3,4}}); f.push_back(Circle{Coord{5,5},2}); f.push_back(Rectangle{Coord{3,3},Coord{6,4}}); return f; } int main() { std::vector\u0026lt;GeoObj\u0026gt; figure = createFigure(); for (const GeoObj\u0026amp; geoobj : figure) { std::visit([] (const auto\u0026amp; obj) { obj.draw(); // draw() 的多态调用 }, geoobj); } } 首先，我们为所有可能的类型定义一个通用数据类型：\nusing GeoObj = std::variant\u0026lt;Line, Circle, Rectangle\u0026gt;; 这三种类型不需要任何特殊关系。 事实上，它们不必有一个通用的基类，没有虚函数，它们的接口甚至可能不同。 例如：\nlib/circle.hpp\n#ifndef CIRCLE_HPP #define CIRCLE_HPP #include \u0026#34;coord.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; class Circle { private: Coord center; int rad; public: Circle (Coord c, int r) : center{c}, rad{r} { } void move(const Coord\u0026amp; c) { center += c; } void draw() const { std::cout \u0026lt;\u0026lt; \u0026#34;circle at \u0026#34; \u0026lt;\u0026lt; center \u0026lt;\u0026lt; \u0026#34; with radius \u0026#34; \u0026lt;\u0026lt; rad \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; #endif 现在我们可以通过创建相应的对象并将它们按值传递到容器中来将这些类型的元素放入一个集合中：\nstd::vector\u0026lt;GeoObj\u0026gt; createFigure() { std::vector\u0026lt;GeoObj\u0026gt; f; f.push_back(Line{Coord{1,2},Coord{3,4}}); f.push_back(Circle{Coord{5,5},2}); f.push_back(Rectangle{Coord{3,3},Coord{6,4}}); return f; } 这段代码在运行时多态下是不可能的，因为那样的话类型必须将 GeoObj 作为一个公共基类，我们需要一个 GeoObj 元素的指针向量，并且由于指针，我们必须使用 new 创建对象，这样 我们必须跟踪何时调用 delete 或使用智能指针（unique_ptr 或 shared_ptr）。 通过使用访问者，我们可以遍历元素并根据元素类型“做正确的事”：\nstd::vector\u0026lt;GeoObj\u0026gt; figure = createFigure(); for (const GeoObj\u0026amp; geoobj : figure) { std::visit([] (const auto\u0026amp; obj) { obj.draw(); // polymorphic call of draw() }, geoobj); } 在这里，visit() 使用通用 lambda 来为每个可能的 GeoObj 类型实例化。 也就是说，在编译 visit() 调用时，lambda 被实例化并编译为三个函数：\n编译 Line 类型的代码：\n[] (const Line\u0026amp; obj) { obj.draw(); // call of Line::draw() } 编译 Circle 类型的代码：\n[] (const Circle\u0026amp; obj) { obj.draw(); // call of Circle::draw() } 编译 Rectangle 类型的代码：\n[] (const Rectangle\u0026amp; obj) { obj.draw(); // call of Rectangle::draw() } 如果这些实例之一没有编译，则 visit() 的调用根本不会编译。 如果全部编译，则为每种元素类型生成调用相应函数的代码。 请注意，生成的代码没有 if-else 链。 该标准保证调用的性能不依赖于备选方案的数量。 也就是说，实际上我们得到了与虚函数表相同的行为（每个 visit() 都有一个本地虚函数表）。 请注意，调用的 draw() 函数不必是虚拟的。\n如果类型接口不同，我们可以使用编译时 if 或访问者重载来处理这种情况（参见下面的第二个示例）。\n16.4.2 其他使用std::variant的非同质集合 作为将非同质集合与 std::variant\u0026lt;\u0026gt; 一起使用的另一个示例，请考虑以下示例：\nlib/variantpoly2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;variant\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;type_traits\u0026gt; int main() { using Var = std::variant\u0026lt;int, double, std::string\u0026gt;; std::vector\u0026lt;Var\u0026gt; values {42, 0.19, \u0026#34;hello world\u0026#34;, 0.815}; for (const Var\u0026amp; val : values) { std::visit([] (const auto\u0026amp; v) { if constexpr(std::is_same_v\u0026lt;decltype(v), const std::string\u0026amp;\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }, val); } } 同样，我们为表示多种可能类型之一的对象定义自己的类型：\nusing Var = std::variant\u0026lt;int, double, std::string\u0026gt;; 我们可以用它们创建一个初始化非同质集合：\nstd::vector\u0026lt;Var\u0026gt; values {42, 0.19, \u0026#34;hello world\u0026#34;, 0.815}; 请注意，我们可以使用不均匀的元素集合来初始化vector，因为它们都转换为变体类型。 只有当我们传递一个 long 时，编译器才会知道是将它转换为 int 还是 double，这样就不会编译。\n当我们迭代时，我们使用访问者为他们调用不同的函数。 然而，因为在这里我们想做不同的事情（如果值是字符串，则在值周围加上引号），我们使用compile-time if：\nfor (const Var\u0026amp; val : values) { std::visit([] (const auto\u0026amp; v) { if constexpr(std::is_same_v\u0026lt;decltype(v), const std::string\u0026amp;\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }, val); } 这样输出就变成了：\n42 0.19 \u0026#34;hello world\u0026#34; 0.815 通过使用访问者重载，我们还可以如下实现：\nfor (const auto\u0026amp; val : values) { std::visit(overload{ [] (auto v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }, [] (const std::string\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; \u0026#34;; } }, val); } 16.4.3 比较变体多态性 让我们总结一下使用 std::variant\u0026lt;\u0026gt; 处理多态性和非同质集合的优缺点。 好处是：\n您不需要常见的基本类型（非侵入式）。 您不必为非同质集合使用指针。 不需要虚拟成员函数。 值语义（无法访问已释放的内存或内存泄漏）。 向量中的元素位于一起（而不是通过堆内存中的指针分布）。 限制和缺点是：\n关闭类型集（您必须在编译时了解所有替代方案）。 元素都具有最大元素类型的大小（如果元素类型大小差异很大，则会出现问题）。 复制元素可能更昂贵。 一般来说，我现在建议默认使用 std::variant\u0026lt;\u0026gt; 来编程多态，因为它通常更快（没有 new 和 delete，没有用于非多态使用的虚函数），更安全（没有指针），并且 通常所有类型在所有代码的编译时都是已知的。 就在您必须处理引用语义（在多个地方使用相同的对象）或传递对象变得昂贵（即使使用移动语义）时，运行时多态性 继承可能仍然是合适的。\n16.5 std::variant\u0026lt;\u0026gt; 的特殊情况 特定变体可能导致特殊或意外行为\n16.5.1 同时拥有bool和std::string的选择 如果 std::variant\u0026lt;\u0026gt; 同时具有 bool 和 std::string 替代项，则分配字符串文字可能会变得令人惊讶，因为字符串文字转换为 bool 比转换为 std::string 更好。 例如：\nstd::variant\u0026lt;bool, std::string\u0026gt; v; v = \u0026#34;hi\u0026#34;; // OOPS: sets the bool alternative std::cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; v.index() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::visit([](const auto\u0026amp; val) { std::cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }, v); 此代码段将具有以下输出：\nindex: 0 value: true 因此，字符串文字被解释为通过布尔值 true 初始化变量（因为指针不为 0，所以为 true）。 这里有几个选项可以“修复”分配：\nv.emplace\u0026lt;1\u0026gt;(\u0026#34;hello\u0026#34;); // 明确分配给第二个备选方案 v.emplace\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;); // 显式分配给字符串替代 v = std::string{\u0026#34;hello\u0026#34;}; // 确保分配了一个字符串 using namespace std::literals; // 确保分配了一个字符串 v = \u0026#34;hello\u0026#34;s; 16.6 后记 变体对象于 2005 年由 Axel Naumann 在 https://wg21.link/n4218 中首次提出，将 Boost.Variant 作为参考实现。 制定了最终接受的措辞 Axel Naumann 在 https://wg21.link/p0088r3 中。\nTony van Eerd 使用 https://wg21.link/p0393r3 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::optional\u0026lt;\u0026gt; 和 std::any 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。 Erich Keane 与 https://wg21.link/p0510r0 制定了禁止引用、不完整类型和数组以及空变体的限制。 在 C++17 发布后，Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 使用 https://wg21.link/p0739r0 修复了一个小缺陷。\n17 std::any 一般来说，C++ 是一种具有类型绑定和类型安全性的语言。值对象被声明为具有特定类型，它定义了哪些操作是可能的以及它们的行为方式。并且值对象不能改变它们的类型。\nstd::any 是一种能够改变其类型的值类型，同时仍具有类型安全性。也就是说，对象可以保存任意类型的值，但它们知道当前保存的值是哪种类型。声明此类型的对象时无需指定可能的类型。\n诀窍是对象既包含包含的值，也包含使用 typeid 的包含值的类型。因为该值可以具有任何大小，所以内存可能会在堆上分配。但是，实现应避免将堆内存用于包含的小值，例如 int。\n也就是说，如果您分配一个字符串，该对象会为该值分配内存并复制该字符串，同时还在内部存储分配的字符串。稍后，可以进行运行时检查以找出当前值具有哪种类型，并将该值用作其类型，any_cast\u0026lt;\u0026gt; 是必要的。\n至于 std::optional\u0026lt;\u0026gt; 和 std::variant\u0026lt;\u0026gt; 结果对象具有值语义。也就是说，通过在自己的内存中创建一个具有当前包含值及其类型的独立对象来进行深度复制。因为可能涉及堆内存，所以复制 std::any 通常很昂贵，您应该更喜欢通过引用传递对象或移动值。部分支持移动语义。\n17.1 使用 std::any 以下示例演示了 std::any 的核心功能：\nstd::any a; // a 为空 std::any b = 4.3; // b 具有 double 类型的值 4.3 a = 42; // a 具有 int 类型的值 42 b = std::string{\u0026#34;hi\u0026#34;}; // b 具有 std::string 类型的值 \u0026#34;hi\u0026#34; if (a.type() == typeid(std::string)) { std::string s = std::any_cast\u0026lt;std::string\u0026gt;(a); useString(s); } else if (a.type() == typeid(int)) { useInt(std::any_cast\u0026lt;int\u0026gt;(a)); } 您可以将 std::any 声明为空或由特定类型的值初始化。 初始值的类型成为包含值的类型。\n通过使用成员函数 type()，您可以根据任何类型的类型 ID 检查包含值的类型。 如果对象为空，则类型 ID 为 typeid(void)。\n要访问包含的值，您必须使用 std::any_cast\u0026lt;\u0026gt; 将其转换为它的类型：\nauto s = std::any_cast\u0026lt;std::string\u0026gt;(a); 如果转换失败，因为对象为空或包含的类型不适合，则抛出 std::bad_any_cast。 因此，在不检查或不知道类型的情况下，您最好实现以下内容：\ntry { auto s = std::any_cast\u0026lt;std::string\u0026gt;(a); ... } catch (std::bad_any_cast\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 注意 std::any_cast\u0026lt;\u0026gt; 创建一个传递类型的对象。 如果您将 std::string 作为模板参数传递给 std::any_cast\u0026lt;\u0026gt;，它会创建一个临时字符串（prvalue），然后用于初始化新对象 s。 如果没有这样的初始化，通常最好转换为引用类型以避免创建临时对象：\nstd::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a); 为了能够修改该值，您需要强制转换为相应的引用类型：\nstd::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(a) = \u0026#34;world\u0026#34;; 您还可以调用 std::any_cast 以获得 std::any 对象的地址。 在这种情况下，如果类型适合，则强制转换返回相应的指针，否则返回 nullptr：\nauto p = std::any_cast\u0026lt;std::string\u0026gt;(\u0026amp;a); if (p) { ... } 要清空现有的 std::any 对象，您可以调用：\na.reset(); // 使其为空 或者：\na = std::any{}; 要不就：\na = {}; 您可以直接检查对象是否为空：\nif (a.has_value()) { ... } 另请注意，值是使用其衰减类型存储的（数组转换为指针，顶级引用和 const 被忽略）。 对于字符串文字，这意味着值类型是 const char*。\n要检查 type() 并使用 std::any_cast\u0026lt;\u0026gt; 您必须完全使用这种类型：\nstd::any a = \u0026#34;hello\u0026#34;; // type() is const char* if (a.type() == typeid(const char*)) { // true ... } if (a.type() == typeid(std::string)) { // false ... } std::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;const char*\u0026gt;(v[1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK std::cout \u0026lt;\u0026lt; std::any_cast\u0026lt;std::string\u0026gt;(v[1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // EXCEPTION 这些或多或少都是所有操作。 没有定义比较运算符（因此，您不能比较或排序对象），没有定义散列函数，也没有定义 value() 成员函数。 并且因为类型只在运行时才知道，所以不能使用通用 lambda 来处理独立于其类型的当前值。 您总是需要运行时函数 std::any_cast\u0026lt;\u0026gt; 才能处理当前值，这意味着在处理值时需要一些特定于类型的代码来重新进入 C++ 类型系统。\n但是，可以将 std::any 对象放入容器中。 例如：\nstd::vector\u0026lt;std::any\u0026gt; v; v.push_back(42); std::string s = \u0026#34;hello\u0026#34;; v.push_back(s); for (const auto\u0026amp; a : v) { if (a.type() == typeid(std::string)) { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if (a.type() == typeid(int)) { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::any_cast\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 17.2 std::any 类型和操作 本节详细介绍 std::any 的类型和操作。\n17.2.1 Any 类型 在头文件 中，C++ 标准库定义类 std::any 如下：\nnamespace std { class any; } 也就是说， std::any 根本不是类模板。 此外，还定义了以下类型和对象：\n异常类std::bad_any_cast，派生自std::bad_cast，派生自std::exception，如果类型转换失败。 任何对象也使用 中定义的对象 std::in_place_type（类型为 std::in_place_type_t）。\n17.2.2 Any 操作 表 std::any 操作列出了为 std::any 提供的所有操作。\nOperation 作用 constructors 创建一个任意对象（可能调用底层类型的构造函数） make_any() 创建一个任意对象（传递值来初始化它） destructor 销毁任何对象 = 分配一个新值 emplace() 分配一个类型为 T 的新值 reset() 销毁任何值（使对象为空） has_value() 返回对象是否有值 type() 将当前类型作为 std::type_info 对象返回 any_cast() 使用当前值作为类型 T 的值（其他类型除外） swap() 在两个对象之间交换值 构造 默认情况下， std::any 初始化为空。\nstd::any a1; // a1 为空 如果一个值被传递给初始化，它的衰减类型被用作包含值的类型：\nstd::any a2 = 42; // a2 包含 int 类型的值 std::any a3 = \u0026#34;hello\u0026#34;; // a2 包含 const char* 类型的值 要保存与初始值类型不同的类型，您必须使用 in_place_type 标签：\nstd::any a4{std::in_place_type\u0026lt;long\u0026gt;, 42}; std::any a5{std::in_place_type\u0026lt;std::string\u0026gt;, \u0026#34;hello\u0026#34;}; 甚至传递给 in_place_type 的类型也会衰减。 以下声明包含一个 const char*：\nstd::any a5b{std::in_place_type\u0026lt;const char[6]\u0026gt;, \u0026#34;hello\u0026#34;}; 要通过多个参数初始化可选对象，您必须创建对象或添加 std::in_place_type 作为第一个参数（无法推断包含的类型）：\nstd::any a6{std::complex{3.0, 4.0}}; std::any a7{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 3.0, 4.0}; 你甚至可以传递一个初始化列表，后跟其他参数：\n// initialize a std::any with a set with lambda as sorting criterion: auto sc = [] (int x, int y) { return std::abs(x) \u0026lt; std::abs(y); }; std::any a8{std::in_place_type\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt;, {4, 8, -7, -2, 0, 5}, sc}; 请注意，还有一个便利函数 make_any\u0026lt;\u0026gt;()，可用于单个或多个参数（不需要 in_place_type 参数）。 您始终必须明确指定初始化类型（如果仅传递一个参数，则不会推导出）：\nauto a10 = std::make_any\u0026lt;float\u0026gt;(3.0); auto a11 = std::make_any\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;); auto a13 = std::make_any\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;(3.0, 4.0); auto a14 = std::make_any\u0026lt;std::set\u0026lt;int,decltype(sc)\u0026gt;\u0026gt;({4, 8, -7, -2, 0, 5}, sc); 更改值 存在相应的赋值和 emplace() 操作。 例如：\nstd::any a; a = 42; // a 包含 int 类型的值 a = \u0026#34;hello\u0026#34;; // a 包含 const char* 类型的值 a.emplace{std::in_place_type\u0026lt;std::string\u0026gt;, \u0026#34;hello\u0026#34;}; // a 包含 std::string 类型的值 a.emplace{std::in_place_type\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;, 4.4, 5.5}; // a 包含 std::complex\u0026lt;double\u0026gt; 类型的值 访问值 要访问包含的值，您必须使用 std::any_cast\u0026lt;\u0026gt; 将其转换为它的类型。 要将值转换为字符串，您有几个选项：\nstd::any_cast\u0026lt;std::string\u0026gt;(a) // 生成值的副本 std::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(a); // 通过引用写入值 std::any_cast\u0026lt;const std::string\u0026amp;\u0026gt;(a); // 引用读访问 在这里，如果转换失败，则抛出 std::bad_any_cast 异常。 如果删除了顶级引用的传递类型具有相同的类型 ID，则该类型适合。 如果转换失败，您可以传递一个地址来获取 nullptr，因为当前类型不适合：\nstd::any_cast\u0026lt;std::string\u0026gt;(\u0026amp;a) // 通过指针写访问 std::any_cast\u0026lt;const std::string\u0026gt;(\u0026amp;a); // 通过指针读取访问 请注意，此处转换为引用会导致运行时错误：\nstd::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(\u0026amp;a); // RUN-TIME ERROR 移动语义 std::any 还支持移动语义。 但是，请注意，仅具有复制语义的类型才支持移动语义。 也就是说，不支持将仅移动类型作为包含值类型。\n处理移动语义的最佳方式可能并不明显。 所以，这里是你应该怎么做：\nstd::string s(\u0026#34;hello, world!\u0026#34;); std::any a; a = std::move(s); // move s into a s = std::move(std::any_cast\u0026lt;string\u0026amp;\u0026gt;(a)); // 将 a 中的分配字符串移动到 s 像往常一样，对于移出对象，在最后一次调用之后，a 的包含值是未指定的。 因此，只要不假设包含的字符串值具有哪个值，就可以将 a 用作字符串。 以下语句的输出可能是空字符串，而不是“NIL”：\nstd::cout \u0026lt;\u0026lt; (a.has_value() ? std::any_cast\u0026lt;std::string\u0026gt;(a) : std::string(\u0026#34;NIL\u0026#34;)); 注意：\ns = std::any_cast\u0026lt;string\u0026gt;(std::move(a)); 也可以，但需要额外的动作。\n直接转换为右值引用不会编译：\ns = std::any_cast\u0026lt;std::string\u0026amp;\u0026amp;\u0026gt;(a); // compile-time error 请注意，而不是调用\na = std::move(s); // 将 s 移动到 a 以下可能并不总是有效（尽管它是 C++ 标准中的一个示例）：\nstd::any_cast\u0026lt;string\u0026amp;\u0026gt;(a) = std::move(s); // OOPS: a 必须持有一个字符串 这仅在 a 已经包含 std::string 类型的值时才有效。 如果不是，则在我们移动分配新值之前，演员表会抛出一个 std::bad_any_cast 异常。\n17.3 后记 2006 年，Kevlin Henney 和 Beman Dawes 在 https://wg21.link/n1939 中首次提出任何对象，将 Boost.Any 作为参考实现。 正如 Beman Dawes、Kevlin Henney 和 Daniel Krugler 在 https://wg21.link/n3804 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。\n正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。\nVicente J. Botet Escriba 将 API 与 std::variant\u0026lt;\u0026gt; 和 std::optional\u0026lt;\u0026gt; 与 https://wg21.link/p0032r3 进行了协调。 Jonathan Wakely 使用 https://wg21.link/p0504r0 修复了 in_place 标记类型的行为。\n18 std::byte 程序将数据保存在内存中。 对于 std::byte，C++17 为它引入了一种类型，它确实代表了内存元素字节的“自然”类型。 与 char 或 int 等类型的主要区别在于，这种类型不能（容易）（ab）用作整数值或字符类型。 对于数字计算或字符序列不是目标的情况，这会带来更多的类型安全性。\n唯一支持的“计算”操作是按位运算符。\n18.1 使用 std::byte 以下示例演示了 std::byte 的核心功能：\n#include \u0026lt;cstddef\u0026gt; // for std::byte std::byte b1{0x3F}; std::byte b2{0b1111’0000}; std::byte b3[4] {b1, b2, std::byte{1}}; // 4 bytes (last is 0) if (b1 == b3[0]) { b1 \u0026lt;\u0026lt;= 1; } std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // outputs: 126 在这里，我们定义了两个具有两个不同初始值的字节。 b2 使用自 C++14 以来可用的两个功能进行初始化：\n前缀 0b 可以定义二进制文字。 数字分隔符 \u0026rsquo; 允许使数字文字在源代码中更具可读性（它可以放在数字文字的任意两位之间）。 请注意，列表初始化（使用花括号）是您可以直接初始化 std::byte 对象的单个值的唯一方法。 所有其他形式不编译：\nstd::byte b1{42}; // ok（对于自 C++17 以来具有固定基础类型的所有枚举） std::byte b2(42); // ERROR std::byte b3 = 42; // ERROR std::byte b4 = {42}; // ERROR 这是 std::byte 被实现为枚举类型这一事实的直接结果，使用可以用整数值初始化作用域枚举的新方式。 也没有隐式转换，因此您必须使用显式转换的整数文字来初始化字节数组：\nstd::byte b5[] {1}; // ERROR std::byte b6[] {std::byte{1}}; // OK 在没有任何初始化的情况下，堆栈上的对象的 std::byte 的值是未定义的：\nstd::byte b; // 未定义的值 像往常一样（除了原子），您可以通过列表初始化强制将所有位设置为零的初始化：\nstd::byte b{}; // 与b{0}一样 std::to_integer\u0026lt;\u0026gt;() 提供将字节对象用作整数值（包括 bool 和 char）的能力。 如果没有转换，输出运算符将无法编译。 请注意，因为它是一个模板，您甚至需要使用 std:: 完全限定的转换\nstd::cout \u0026lt;\u0026lt; b1; // ERROR std::cout \u0026lt;\u0026lt; to_integer\u0026lt;int\u0026gt;(b1); // ERROR (ADL 在这里不起作用) std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b1); // OK 这样的转换对于使用 std::byte 作为布尔值也是必要的。 例如：\nif (b2) ... // ERROR if (b2 != std::byte{0}) ... // OK if (to_integer\u0026lt;bool\u0026gt;(b2)) ... // ERROR (ADL 在这里不起作用) if (std::to_integer\u0026lt;bool\u0026gt;(b2)) ... // OK 因为 std::byte 被定义为枚举类型，底层类型为 unsigned char，所以 std::byte 的大小始终为 1：\nstd::cout \u0026lt;\u0026lt; sizeof(b); // always 1 位数取决于 unsigned char 类型的位数，您可以通过标准数字限制找到：\nstd::cout \u0026lt;\u0026lt; std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits; // std::byte 的位数 大多数时候是 8，但有些平台并非如此。\n18.2 std::byte 类型和操作 本节详细介绍 std::byte 的类型和操作。\n18.2.1 std::byte 类型 在头文件 中，C++ 标准库定义类型 std::byte 如下：\nnamespace std { enum class byte : unsigned char { }; } 也就是说，std::byte 只不过是一个范围枚举类型，其中定义了一些补充的按位运算符：\nnamespace std { ... template\u0026lt;typename IntType\u0026gt; constexpr byte operator\u0026lt;\u0026lt; (byte b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte\u0026amp; operator\u0026lt;\u0026lt;= (byte\u0026amp; b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte operator\u0026gt;\u0026gt; (byte b, IntType shift) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr byte\u0026amp; operator\u0026gt;\u0026gt;= (byte\u0026amp; b, IntType shift) noexcept; constexpr byte\u0026amp; operator|= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator| (byte l, byte r) noexcept; constexpr byte\u0026amp; operator\u0026amp;= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator\u0026amp; (byte l, byte r) noexcept; constexpr byte\u0026amp; operator^= (byte\u0026amp; l, byte r) noexcept; constexpr byte operator^ (byte l, byte r) noexcept; constexpr byte operator~ (byte b) noexcept; template\u0026lt;typename IntType\u0026gt; constexpr IntType to_integer (byte b) noexcept; } 18.2.2 std::byte 操作 表 std::byte 操作列出了为 std::byte 提供的所有操作。\nOperation 作用 constructors 创建一个字节对象（使用默认构造函数未定义的值） destructor 销毁一个字节对象（什么都不做） = 分配一个新值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 比较字节对象 `\u0026laquo;, \u0026raquo;, , \u0026amp;, ^, ~` `\u0026laquo;=, \u0026raquo;=, =, \u0026amp;=, ^=` to_integer() 将字节对象转换为整型 T sizeof() Yields 1 转换为整型 通过使用 to_integer\u0026lt;\u0026gt;()，您可以将 std::byte 转换为任何基本的整数类型（bool、字符类型或整数类型）。 例如，这是将 std::byte 与数值进行比较或在条件中使用它所必需的：\nif (b2) ... // ERROR if (b2 != std::byte{0}) ... // OK if (to_integer\u0026lt;bool\u0026gt;(b2)) ... // ERROR (ADL 在这里不起作用) if (std::to_integer\u0026lt;bool\u0026gt;(b2)) ... // OK 另一个使用示例是 std::byte I/O to_integer\u0026lt;\u0026gt;() 使用从 unsigned char 到目标类型的静态转换规则。 例如：\nstd::byte ff{0xFF}; std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;unsigned int\u0026gt;(ff); // 255 std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(ff); // also 255 (没有负值) std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(std::to_integer\u0026lt;signed char\u0026gt;(ff)); // -1 带有 std::byte 的 I/O 没有为 std::byte 定义输入和输出运算符，因此您必须将它们转换为整数值：\nstd::byte b; ... std::cout \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b); // 将值打印为十进制值 std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::to_integer\u0026lt;int\u0026gt;(b); // 将值打印为十六进制值 通过使用 std::bitset\u0026lt;\u0026gt;，您还可以将值输出为二进制值（位序列）：\n#include \u0026lt;bitset\u0026gt; #include \u0026lt;limits\u0026gt; using ByteBitset = std::bitset\u0026lt;std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits\u0026gt;; std::cout \u0026lt;\u0026lt; ByteBitset{std::to_integer\u0026lt;unsigned char\u0026gt;(b1)}; using 声明定义了一个 bitset 类型，其位数与 std::byte 一样，然后我们创建并输出这样一个用字节的整数类型初始化的对象。 您还可以使用它将 std::byte 的二进制表示形式写入字符串：\nstd::string s = ByteBitset{std::to_integer\u0026lt;unsigned char\u0026gt;(b1)}.to_string(); 输入方式类似：只需将值读取为整数、字符串或位集值并进行转换。 例如，您可以编写一个输入运算符，从二进制表示中读取一个字节，如下所示：\nstd::istream\u0026amp; operator\u0026gt;\u0026gt; (std::istream\u0026amp; strm, std::byte\u0026amp; b) { // 读入 bitset: std::bitset\u0026lt;std::numeric_limits\u0026lt;unsigned char\u0026gt;::digits\u0026gt; bs; strm \u0026gt;\u0026gt; bs; // 没有失败，转换为 std::byte: if (! std::cin.fail()) { b = static_cast\u0026lt;std::byte\u0026gt;(bs.to_ulong()); // OK } return strm; } 请注意，我们必须使用 static_cast\u0026lt;\u0026gt;() 将 bitset 转换为 unsigned long 转换为 std::byte。 列表初始化不起作用，因为转换范围缩小：\nb = std::byte{bs.to_ulong()}; // ERROR: 缩小 而且我们没有其他的初始化方式.\n18.3 后记 std::byte 最初由 Neil MacIntosh 提出，传入 https://wg21.link/p0298r0。 最终接受的措辞由 Neil MacIntosh 在 https://wg21.link/p0298r3 中制定。\n19 String Views 在 C++17 中，C++ 标准库采用了一个特殊的字符串类，它允许我们处理像字符串这样的字符序列，而无需为它们分配内存：std::string_view。 也就是说，std::string_view 对象引用外部字符序列而不拥有它们。 也就是说，对象可以被认为是对字符序列的引用。\n使用这样的字符串视图既便宜又快速（按值传递 string_view 总是很便宜）。 然而，它也有潜在的危险，因为与原始指针类似，程序员需要确保在使用 string_view 时引用的字符序列仍然有效）。\n19.1 与 std::string 的区别 与 std::string 相比，std::string_view 对象具有以下属性：\n底层字符序列是只读的。 没有允许修改字符的操作。 您只能分配新值、交换值以及删除开头或结尾的字符。\n不保证字符序列以空值结尾。 因此，字符串视图不是以空结尾的字节流 (NTBS)。\n该值可以是 nullptr，例如在使用默认构造函数初始化字符串视图后由 data() 返回。\n没有分配器支持。 由于可能的 nullptr 值和可能缺少的 null 终止符，您应该始终在通过 operator[] 或 data() 访问字符之前使用 size() （除非您知道得更好）。\n19.2 使用 String Views 字符串视图有两个主要应用：\n您可能已经使用字符序列或字符串分配或映射数据，并希望在不分配更多内存的情况下使用这些数据。典型的例子是使用内存映射文件或处理大文本中的子字符串。\n您想提高接收字符串的函数/操作的性能，只是直接以只读方式处理它们，不需要尾随的空终止符。 这种情况的一种特殊形式可能是将字符串文字处理为具有类似于字符串的 API 的对象：\nstatic constexpr std::string_view hello{\u0026#34;hello world\u0026#34;}; 第一个示例通常意味着通常只传递字符串视图，而编程逻辑必须确保底层字符序列保持有效（即，映射的文件内容未被取消映射）。在任何时候，您都可以使用字符串视图来初始化或将它们的值分配给 std::string。\n但请注意，使用字符串视图就像“更好的字符串”一样。这可能会导致更差的性能和严重的运行时错误。因此，请仔细阅读以下小节。\n19.3 使用与字符串相似的字符串视图 第一个示例，使用像只读字符串一样的 string_view，是一个打印带有作为字符串视图传递的前缀的元素集合的函数：\n#include \u0026lt;string_view\u0026gt; template\u0026lt;typename T\u0026gt; void printElems(const T\u0026amp; coll, std::string_view prefix = std::string_view{}) { for (const auto\u0026amp; elem : coll) { if (prefix.data()) { // 检查 nullptr std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 在这里，仅通过声明函数将采用 std::string_view，与采用 std::string 的函数相比，我们可以节省分配堆内存的调用。 详细信息取决于是否传递了短字符串以及是否使用了短字符串优化 (SSO)。 例如，如果我们将函数声明如下：\ntemplate\u0026lt;typename T\u0026gt; void printElems(const T\u0026amp; coll, const std::string\u0026amp; prefix = std::string{}); 我们传递一个字符串文字，调用会创建一个临时字符串，它将分配内存，除非字符串很短并且使用了短字符串优化。 通过使用字符串视图，不需要分配，因为字符串视图只引用字符串文字。\n但是，请注意，在使用字符串视图的任何未知值之前，必须根据 nullptr 检查 data()。\n另一个示例，使用像只读字符串一样的 string_view，是 std::optional\u0026lt;\u0026gt; 的 asInt() 示例的改进版本，它是为字符串参数声明的：\nlib/asint.cpp #include \u0026lt;optional\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;charconv\u0026gt; // 对于 from_chars() #include \u0026lt;iostream\u0026gt; // 如果可能，将字符串转换为 int: std::optional\u0026lt;int\u0026gt; asInt(std::string_view sv) { int val; // 将字符序列读入 int: auto [ptr, ec] = std::from_chars(sv.data(), sv.data()+sv.size(), val); // 如果我们有错误代码，则不返回任何值: if (ec != std::errc{}) { return std::nullopt; } return val; } int main() { for (auto s : {\u0026#34;42\u0026#34;, \u0026#34; 077\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;0x33\u0026#34;} ) { // 如果可能，尝试将 s 转换为 int 并打印结果: std::optional\u0026lt;int\u0026gt; oi = asInt(s); if (oi) { std::cout \u0026lt;\u0026lt; \u0026#34;convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int: \u0026#34; \u0026lt;\u0026lt; *oi \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t convert \u0026#39;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\u0026#39; to int\\n\u0026#34;; } } } 现在， asInt() 按值获取字符串视图。但是，这会产生重大影响。首先，使用 std::stoi() 创建整数不再有意义，因为 stoi() 接受一个字符串，而从字符串视图创建一个字符串是一项相对昂贵的操作。\n相反，我们将字符串视图的字符范围传递给新的标准库函数 std::from_chars()。它需要一对原始字符指针来转换字符的开头和结尾。请注意，这意味着我们可以跳过对空字符串视图的任何特殊处理，其中 data() 为 nullptr 且 size() 为 0，因为从 nullptr 到 nullptr+0 的范围是有效的空范围（对于添加的任何指针类型0 受支持且无效）。\nstd_from_chars() 返回一个 std::from_chars_result，它是一个具有两个成员的结构，一个指向未处理的第一个字符的指针 ptr 和一个 std::errc ec，其中 std::errc 表示没有错误。因此，在使用返回值的 ec 成员（使用结构化绑定）初始化 ec 后，如果转换失败，则以下检查返回 nullopt：\nif (ec != std::errc{}) { return std::nullopt; } 在对子字符串进行排序时，使用字符串视图还可以显着提高性能。\n19.3.1 被认为是有害的字符串视图 通常，诸如智能指针之类的“智能对象”被认为比相应的语言功能更安全（或至少不更危险）。 因此，给人的印象可能是字符串视图（一种字符串引用）更安全，或者至少与使用字符串引用一样安全。 但不幸的是，事实并非如此。 字符串视图实际上比字符串引用或智能指针更危险。 它们的行为更像原始字符指针。\n不要将字符串分配给字符串视图 考虑我们声明一个返回新字符串的函数：\nstd::string retString(); 使用返回值通常很安全：\n将其分配给使用 auto 声明的字符串或对象是安全的（但可以移动，这通常是可以的，但没有最佳性能）：\nauto std::string s1 = retString(); // safe 如果可能的话，将返回值分配给字符串引用是非常安全的，只要我们在本地使用该对象，因为引用会将返回值的生命周期延长到其生命周期的末尾：\nstd::string\u0026amp; s2 = retString(); // 编译时错误（缺少常量） const std::string\u0026amp; s3 = retString(); // s3 延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK auto\u0026amp;\u0026amp; s4 = retString(); // s4 延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; 4 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 对于字符串视图，没有给出这种安全性。 它既不复制也不延长返回值的生命周期：\nstd::string_view sv = retString(); // sv 不会延长返回字符串的生命周期 std::cout \u0026lt;\u0026lt; sv \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 运行时错误：返回的字符串被破坏 在这里，返回的字符串在第一条语句的末尾被破坏，因此从字符串视图 sv 中引用它是一个致命的运行时错误，导致未定义的行为。 问题与调用时相同：\nconst char* p = retString().c_str(); 或者：\nauto p = retString().c_str(); 出于这个原因，您还应该非常小心地返回一个字符串视图：\n// 非常危险: std::string_view substring(const std::string\u0026amp;, std::size_t idx = 0); // 因为: auto sub = substring(\u0026#34;very nice\u0026#34;, 5); // 将视图返回到传递的临时字符串 // 但调用后临时字符串被破坏 std::cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 运行时错误：tmp 字符串已被破坏 不要将字符串视图返回给字符串 尤其是让字符串成员的 getter 返回字符串视图是一种非常危险的设计。 因此，您不应执行以下操作：\nclass Person { std::string name; public: Person (std::string n) : name{std::move(n)} { } std::string_view getName() const { // don’t do this return name; } }; 因为，同样，以下结果将成为致命的运行时错误，导致未定义的行为：\nPerson createPerson(); auto n = createPerson().getName(); // OOPS：删除临时字符串 std::cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 致命的运行时错误 如果 getName() 按值或按引用返回字符串，这又是一个问题。\n函数模板应该使用返回类型 auto 请注意，很容易意外地将返回的字符串分配给字符串视图。 例如，考虑两个单独看起来非常有用的函数的定义：\n// 为返回字符串的字符串视图定义 +: std::string operator+ (std::string_view sv1, std::string_view sv2) { return std::string(sv1) + std::string(sv2); } // 泛型串联: template\u0026lt;typename T\u0026gt; T concat (const T\u0026amp; x, const T\u0026amp; y) { return x + y; } 但是，再次将它们一起使用可能很容易导致致命的运行时错误：\nstd::string_view hi = \u0026#34;hi\u0026#34;; auto xy = concat(hi, hi); // xy 是 std::string_view std::cout \u0026lt;\u0026lt; xy \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 致命的运行时错误：引用的字符串被破坏 这样的代码很容易被意外编写。 这里真正的问题是 concat() 的返回类型。 如果声明它的返回类型由编译器推断，上面的示例将 xy 初始化为 std::string：\n// 改进的通用连接: template\u0026lt;typename T\u0026gt; auto concat (const T\u0026amp; x, const T\u0026amp; y) { return x + y; } 此外，在调用链中使用字符串视图会适得其反，因为在调用链中或在其末尾需要字符串。 例如，如果您使用以下构造函数定义类 Person：\nclass Person { std::string name; public: Person (std::string_view n) : name{n} { } ... }; 传递您仍然需要的字符串文字或字符串很好：\nPerson p1{\u0026#34;Jim\u0026#34;}; // 没有性能开销 std::string s = \u0026#34;Joe\u0026#34;; Person p2{s}; // 没有性能开销 但是在字符串中移动变得不必要的昂贵，因为传递的字符串首先被隐式转换为字符串视图，然后用于创建一个新的字符串再次分配内存：\nPerson p3{std::move(s)}; // 性能开销：移动损坏 不要在这里处理 std::string_view 。 按值取参数并将其移动到成员仍然是最好的解决方案。 因此，构造函数和 getter 应该如下所示：\nclass Person { std::string name; public: Person (std::string n) : name{std::move(n)} { } std::string getName() const { return name; } }; 字符串视图的安全使用总结 总而言之，请谨慎使用 std::string_view，这意味着您还应该更改 您编程的一般风格：\n不要在 API 中使用将参数传递给字符串的字符串视图。 – 不要从字符串视图参数初始化字符串成员。 – 字符串视图链的末尾没有字符串。 不要返回字符串视图。 – 除非它只是一个转发的输入参数，或者您通过例如相应地命名函数来发出危险信号。 出于这个原因，函数模板永远不应该返回传递的泛型参数的类型 T。 – 改为返回 auto。 永远不要使用返回值来初始化字符串视图。 出于这个原因，不要将返回泛型类型的函数模板的返回值分配给 auto。 – 这意味着，AAA（几乎总是自动）模式被字符串视图打破。 如果这些规则太复杂或难以遵循，请不要使用 std::string_view （除非您知道自己在做什么）。 19.4 String View 类型和操作 本节详细介绍字符串视图的类型和操作。\n19.4.1 具体字符串视图类型 在头文件 \u0026lt;string_view\u0026gt; 中，C++ 标准库提供了一些类 basic_string_view\u0026lt;\u0026gt; 的特化：\n类 std::string_view 是该模板的预定义特化，用于 char 类型的字符： namespace std { using string_view = basic_string_view\u0026lt;char\u0026gt;; } 对于使用更广泛字符集（例如 Unicode 或某些亚洲字符集）的字符串，预定义了其他三种类型： namespace std { using u16string_view = basic_string_view\u0026lt;char16_t\u0026gt;; using u32string_view = basic_string_view\u0026lt;char32_t\u0026gt;; using wstring_view = basic_string_view\u0026lt;wchar_t\u0026gt;; } 在以下部分中，这些类型的字符串视图之间没有区别。用法和问题是相同的，因为所有字符串视图类都具有相同的接口。因此，“字符串视图”表示任何字符串视图类型：string_view、u16string_view、u32string_view 和 wstring_view。本书中的示例通常使用 string_view 类型，因为欧洲和英美环境是软件开发的常见环境。\n19.4.2 字符串视图操作 表字符串视图操作列出了为字符串视图提供的所有操作。 除了 remove_prefix() 和 remove_suffix() 之外，还为 std::strings 提供了字符串视图的所有操作。 但是，保证可能略有不同，因为对于字符串视图， data() 返回的值可能是 nullptr 并且缺少保证以空终止符结束序列。\n操作 作用 constructors 创建或复制字符串视图 destructor 销毁字符串视图 = 分配一个新值 swap() 在两个字符串视图之间交换值 ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, compare() 比较字符串视图 empty() 返回字符串视图是否为空 size(), length() 返回字符数 max_size() 返回最大可能的字符数 [], at() 访问一个字符 front(), back() 访问第一个或最后一个字符 \u0026laquo; 将值写入流 copy() 将内容复制或写入字符数组 data() 将值作为 nullptr 或常量字符返回，数组（注意：没有终止空字符） find functions 搜索某个子字符串或字符 begin(), end() 提供正常的迭代器支持 cbegin(), cend() 提供常量迭代器支持 rbegin(), rend() 提供反向迭代器支持 crbegin(), crend() 提供常量反向迭代器支持 substr() 返回某个子字符串 remove_prefix() 删除前导字符 remove_suffix() 删除尾随字符 hash\u0026lt;\u0026gt; 计算哈希值的函数对象类型 构造 您可以使用默认构造函数创建字符串视图，作为副本，从原始字符数组（以 null 终止或具有指定长度），从 std::string 或作为带有后缀 sv 的文字。 但是，请注意以下几点：\n使用默认构造函数创建的字符串视图将 nullptr 作为 data()。 因此，没有有效的 operator[] 调用。\nstd::string_view sv; auto p = sv.data(); // 产生 nullptr std::cout \u0026lt;\u0026lt; sv[0]; // ERROR: 没有有效字符 当通过空终止字节流初始化字符串视图时，结果大小是不带 \u0026lsquo;\\0\u0026rsquo; 的字符数，并且使用终止空字符的索引是无效的：\nstd::string_view sv{\u0026#34;hello\u0026#34;}; std::cout \u0026lt;\u0026lt; sv; // OK std::cout \u0026lt;\u0026lt; sv.size(); // 5 std::cout \u0026lt;\u0026lt; sv.at(5); // 抛出 std::out_of_range 异常 std::cout \u0026lt;\u0026lt; sv[5]; // 未定义的行为，但在这里它通常有效 std::cout \u0026lt;\u0026lt; sv.data(); // 未定义的行为，但在这里它通常有效 最后两个调用是形式上未定义的行为。 因此，它们不能保证工作，尽管在这种情况下您可以假设在最后一个字符之后有空终止符。 您可以通过传递包括空终止符在内的字符数来初始化具有空终止符作为其值的一部分的字符串视图：\nstd::string_view sv{\u0026#34;hello\u0026#34;, 6}; // NOTE: 6 to include ’\\0’ std::cout \u0026lt;\u0026lt; sv.size(); // 6 std::cout \u0026lt;\u0026lt; sv.at(5); // OK, 打印 ’\\0’的值 std::cout \u0026lt;\u0026lt; sv[5]; // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::cout \u0026lt;\u0026lt; sv.data(); // OK 要从 std::string 创建字符串视图，std::string 类中提供了隐式转换运算符。 同样，在最后一个字符之后有空终止符，通常保证字符串，不保证字符串视图存在：\nstd::string s = \u0026#34;hello\u0026#34;; std::cout \u0026lt;\u0026lt; s.size(); // 5 std::cout \u0026lt;\u0026lt; s.at(5); // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::cout \u0026lt;\u0026lt; s[5]; // OK, 打印 \u0026#39;\\0\u0026#39; 的值 std::string_view sv{s}; std::cout \u0026lt;\u0026lt; sv.size(); // 5 std::cout \u0026lt;\u0026lt; sv.at(5); // 抛出 std::out_of_range 异常 std::cout \u0026lt;\u0026lt; sv[5]; // 未定义的行为，但在这里它通常有效 std::cout \u0026lt;\u0026lt; sv.data(); // 未定义的行为，但在这里它通常有效 由于为后缀 sv 定义了文字运算符，因此您还可以创建一个字符串视图，如下所示：\nusing namespace std::literals; auto s = \u0026#34;hello\u0026#34;sv; 这里的关键点是，通常你不应该期望空终止字符并且在访问字符之前总是使用 size() （除非你知道关于值的具体事情）。\n作为一种解决方法，您可以将 \u0026lsquo;\\0\u0026rsquo; 作为字符串视图的一部分，但您不应该使用字符串视图作为空终止字符串，而空终止符不是它的一部分，即使空终止符就在后面。\n散列 C++ 标准库保证字符串和字符串视图的哈希值是相等的。\n修改字符串视图 只提供了几个操作来修改字符串视图：\n您可以分配一个新值或交换两个字符串视图的值：\nstd::string_view sv1 = \u0026#34;hey\u0026#34;; std::string_view sv2 = \u0026#34;world\u0026#34;; sv1.swap(sv2); sv2 = sv1; 您可以跳过前导或尾随字符（即，将开头移动到第一个字符后面的字符或将结尾移动到最后一个字符之前的字符）。\nstd::string_view sv = \u0026#34;I like my kindergarten\u0026#34;; sv.remove_prefix(2); sv.remove_suffix(8); std::cout \u0026lt;\u0026lt; sv; // prints: like my kind ​ 请注意，不支持 operator+。 因此：\nstd::string_view sv1 = \u0026#34;hello\u0026#34;; std::string_view sv2 = \u0026#34;world\u0026#34;; auto s1 = sv1 + sv2; // ERROR 其中一个操作数必须是字符串：\nauto s2 = std::string(sv1) + sv2; // OK 请注意，没有隐式转换为字符串，因为这是一项昂贵的操作，因为它可能会分配内存。 因此，只能进行显式转换。\n19.4.3 其他类型的字符串视图支持 原则上，可以传递字符串的每个地方也传递字符串视图是有意义的，期望接收者何时需要将该值以空值终止（例如，通过将值传递给字符串的 C 函数）。\n​\t但是，到目前为止，我们只添加了对最重要的地方的支持：\n字符串可以在有用的地方使用或与字符串视图结合使用。 您可以从中创建一个字符串（构造函数是显式的）、分配、追加、插入、替换、比较或通过传递字符串视图来查找子字符串。 还有从字符串到字符串视图的隐式转换。 你可以将一个字符串视图传递给std::quoted，它可以打印出其带引号的值。比如说: using namespace std::literals; auto s = R\u0026#34;\u0026#34;(some\\value) \u0026#34;sv; // 原始字符串视图 std::cout \u0026lt;\u0026lt; std::quoted(s); // 输出。\u0026#34;some\\value\u0026#34; 你可以用字符串视图初始化、扩展或比较文件系统路径。 但是，例如，在C++标准库的regex组件中还没有对字符串视图的支持。标准库中，还没有对字符串视图的支持。\n19.5 使用 String Views in API’s 字符串视图很便宜，每个std::string都可以作为一个字符串视图使用。所以，似乎std::string_view是处理字符串参数的更好的类型。嗯，细节很重要\u0026hellip; 首先，使用std::string_view只有在使用该参数的函数具有以下条件时才有意义 以下的限制条件时，使用std::string_view才有意义。\n它不期望在结尾处有一个空的终结符。例如，当把参数作为一个单一的const char*传递给C函数时，情况就不是这样了。\n它尊重所传递参数的生命周期。通常这意味着接收函数只使用传递的值，直到它结束。\n调用函数不应该处理底层字符的所有者（比如删除它，改变它的值，或者释放它的内存）。\n它可以将nullptr作为值来处理。 请注意，如果你同时为std::string和std::string_view的函数重载，可能会出现歧义错误。std::string_view。\nvoid foo(const std::string\u0026amp;); void foo(std::string_view); foo(\u0026#34;hello\u0026#34;); // ERROR: 模糊的 19.5.1 使用用于初始化字符串的字符串视图 看起来字符串视图的一个简单而有用的应用是在初始化字符串时将其声明为参数类型 当初始化一个字符串时。但是要注意!\n考虑用 \u0026ldquo;老办法 \u0026ldquo;来初始化一个字符串成员。\nclass Person { std::string name; public: Person (const std::string\u0026amp; n) : name(n) { } ... }; 这个构造函数有其缺点。用一个字符串字头初始化一个人，会产生一个不必要的拷贝，这可能会导致对堆内存的不必要的请求。比如说:\nPerson p(\u0026#34;Aprettylong NonSSO Name\u0026#34;); 首先调用 std::string 构造函数来创建临时参数 n，因为请求了 std::string 类型的引用。 如果字符串很长或没有启用短字符串优化，这意味着为字符串值分配堆内存。 即使使用移动语义，临时字符串也会被复制以初始化成员名称，这意味着再次分配内存。 您只能通过添加更多构造函数重载或引入模板构造函数来避免这种开销，这可能会导致其他问题。 相反，如果我们使用字符串视图，性能会更好：\nclass Person { std::string name; public: Person (std::string_view n) : name(n) { } ... }; 现在，一个临时的字符串视图n被创建，它根本不分配内存，因为字符串视图只引用了字符串字面的字符。只有name的初始化为成员name分配了一次内存。\n然而，有一个问题：如果你传递一个临时字符串或用std::move()标记的字符串，该字符串被转换为字符串视图的类型（这很便宜），然后字符串视图被用来为新字符串分配内存（这很昂贵）。换句话说。使用字符串视图会禁用移动语义，除非你为它提供一个额外的重载。\n对于如何初始化带有字符串成员的对象，仍然有明确的建议。以 字符串的值和移动。\nclass Person { std::string name; public: Person (std::string n) : name(std::move(n)) { } ... }; 无论如何，我们必须创建一个字符串。因此，尽快创建它可以使我们在传递参数的那一刻就能从所有可能的优化中受益。当我们拥有它时，我们只需移动，这是一个廉价的操作。\n如果我们通过一个返回临时字符串的辅助函数来初始化这个字符串:\nstd::string newName() { ...; return std::string{...}; } Person p{newName()}; 强制性的复制消除将推迟新字符串的物化，直到该值被传递给构造函数。在那里我们有一个名为n的字符串，这样我们就有了一个有位置的对象（一个glvalue）。 然后这个对象的值被移动到初始化成员名。 这个例子再次证明了。\n字符串视图并不是一个更好的取用字符串的接口。 事实上，字符串视图只应该在调用链中使用，在那里它们永远不必作为字符串使用 19.5.2 使用字符串视图而不是字符串 还有其他通过字符串视图替换字符串的可能。但还是要小心。 例如，用下面的代码代替:\n// 将时间点（带前缀）转换为字符串: std::string toString (const std::string\u0026amp; prefix, const std::chrono::system_clock::time_point\u0026amp; tp) { // 转换为日历时间: auto rawtime = std::chrono::system_clock::to_time_t(tp); std::string ts = std::ctime(\u0026amp;rawtime); // 注意：不是线程安全的 ts.resize(ts.size()-1); // 跳过尾随换行符 return prefix + ts; } 您可以实现以下内容：\nstd::string toString (std::string_view prefix, const std::chrono::system_clock::time_point\u0026amp; tp) { auto rawtime = std::chrono::system_clock::to_time_t(tp); std::string_view ts = std::ctime(\u0026amp;rawtime); // 注意：不是线程安全的 ts.remove_suffix(1); // 跳过尾随换行符 return std::string(prefix) + ts; // 不幸的是还没有运算符 + } 除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。 但只是因为 ctime() 返回的 C 字符串在一段时间内有效（直到下一次调用 ctime() 或 asctime() 才有效）。 请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。 相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。\n19.6 后记 除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。但只是因为ctime()返回的C字符串有一段时间有效（一直有效到下一个有引用语义的字符串类是由Jeffrey Yasskin在https://wg21.link/n3334提出的（使用名称string_ref ). 该课程被 Jeffrey Yasskin 在 https://wg21.link/n3921 中提出的图书馆基础知识 TS 中采用。 正如 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的，该类与 C++17 的其他组件一起采用。 Marshall Clow 在 https://wg21.link/p0254r2 和 https://wg21.link/p0403r1 以及 Nicolai Josuttis 在 https://wg21.link/p0392r0 中添加了一些用于更好集成的修改。 Daniel Krugler 的其他修复在 https://wg21.link/lwg2946 中（这可能是针对 C++17 的缺陷）。调用 ctime() 或 asctime())。请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。\n20 文件系统库 在C++17中，Boost.filesystem库最终被采纳为C++标准库。通过这样做，该库根据新的语言特性进行了调整，与库的其他部分更加一致，进行了清理，并对一些缺失的部分进行了扩展（比如计算文件系统路径之间相对路径的操作）。\n20.1 基本例子 让我们从一些基本的例子开始。\n20.1.1 打印一个通过文件系统路径的属性 以下程序允许我们使用传递的字符串作为文件系统路径来根据文件类型打印补丁的某些方面：\nfilesystem/checkpath1.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） if (is_regular_file(p)) { // 路径 p 是常规文件吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } else if (is_directory(p)) { // 路径 p 是目录吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } else if (exists(p)) { // 路径 p 真的存在吗？ std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a special file\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;path \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; does not exist\\n\u0026#34;; } } 我们首先将任何传递的命令行参数转换为文件系统路径：\nstd::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） 然后，我们执行以下检查：\n如果路径代表一个现有的常规文件，我们打印它的大小：\nif (is_regular_file(p)) { // 路径 p 是普通文件吗? std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } 调用这个程序如下：\ncheckpath checkpath.cpp 将输出如下内容：\n\u0026#34;checkpath.cpp\u0026#34; exists with 907 bytes 请注意，路径的输出运算符会自动写入引用的路径名（在双引号内，反斜杠被另一个反斜杠转义，这是 Windows 路径的一个问题）。\n如果文件系统路径作为目录存在，我们遍历目录中的文件并打印路径：\nif (is_directory(p)) { // 路径 p 是目录吗? std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator(p)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 这里我们使用了 directory_iterator，它提供了 begin() 和 end()，我们可以使用基于范围的 for 循环遍历 directory_entry 元素。 在这种情况下，我们使用 directory_entry 成员函数 path()，它产生条目的文件系统路径。 调用这个程序如下：\ncheckpath . 将输出如下内容：\n\u0026#34;.\u0026#34; is a directory containing: \u0026#34;./checkpath.cpp\u0026#34; \u0026#34;./checkpath.exe\u0026#34; ... 最后，我们检查传递的文件系统路径是否存在：\nif (!exists(p)) { // 路径 p 真的存在吗? ... } Windows下的路径处理 在 Windows 下，默认情况下路径被引用的事实是一个问题，因为通常的目录分隔符反斜杠总是被转义并写入两次。 因此，在 Windows 下调用该程序如下：\ncheckpath C:\\ 将输出如下内容：\n\u0026#34;C:\\\\\u0026#34; is a directory containing: ... \u0026#34;C:\\\\Users\u0026#34; \u0026#34;C:\\\\Windows\u0026#34; 写入引用的路径可确保写入的文件名可以读入程序，以便您取回原始文件名。 但是，对于标准输出，这通常是不可接受的。\n出于这个原因，在 Windows 下运行良好的可移植版本应该避免使用成员函数 string() 将引用的路径写入标准输出：\nfilesystem/checkpath2.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path p{argv[1]}; // p 表示文件系统路径（可能不存在） if (is_regular_file(p)) { // 路径 p 是普通文件吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; } else if (is_directory(p)) { // 路径 p 是目录吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } else if (exists(p)) { // 路径 p 真的存在吗? std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a special file\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;path \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; does not exist\\n\u0026#34;; } } 现在，在 Windows 下调用这个程序如下：\ncheckpath C:\\ 将输出如下内容：\n\u0026#34;C:\\\u0026#34; is a directory containing: ... \u0026#34;C:\\Users\u0026#34; \u0026#34;C:\\Windows\u0026#34; 提供了其他转换以使用通用字符串格式或将字符串转换为本机编码。\n20.1.2 切换文件系统类型 我们仍然可以对之前的程序进行一些修改和改进，如下所示：\nfilesystem/checkpath3.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } namespace fs = std::filesystem; switch (fs::path p{argv[1]}; status(p).type()) { case fs::file_type::not_found: std::cout \u0026lt;\u0026lt; \u0026#34;path \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; does not exist\\n\u0026#34;; break; case fs::file_type::regular: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; exists with \u0026#34; \u0026lt;\u0026lt; file_size(p) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; break; case fs::file_type::directory: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a directory containing:\\n\u0026#34;; for (auto\u0026amp; e : std::filesystem::directory_iterator{p}) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } break; default: std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a special file\\n\u0026#34;; break; } } 命名空间 fs 首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：\nnamespace fs = std::filesystem; 使用这个命名空间，我们初始化，例如，switch 语句中的路径 p：\nfs::path p{argv[1]}; switch 语句是带有初始化的新 switch 的应用，我们在其中初始化路径并为其类型提供不同的情况：\nswitch (fs::path p{argv[1]}; status(p).type()) { ... } 表达式 status(p).type() 创建一个 file_status，type() 为此创建一个 file_type。 这样我们就可以直接处理不同的类型，而不是像 is_regular_file()、is_directory() 等一连串的调用。 提供类型是在多个步骤中有意提供的，这样如果我们对状态信息不感兴趣，我们就不必支付操作系统调用的代价。\n另请注意，特定于实现的 file_type 可能存在。 例如，Windows 提供了特殊的文件类型连接。 但是使用它不是便携式的。\n20.1.3 创建不同类型的文件 在仅对文件系统进行读取访问之后，现在让我们给出第一个修改它的示例。 以下程序在子目录 tmp 中创建不同类型的文件：\nfilesystem/createfiles.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;filesystem\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main () { namespace fs = std::filesystem; try { // 创建目录 tmp/test/（如果它们还不存在）: fs::path testDir{\u0026#34;tmp/test\u0026#34;}; create_directories(testDir); // 创建数据文件 tmp/test/data.txt: auto testFile = testDir / \u0026#34;data.txt\u0026#34;; std::ofstream dataFile{testFile}; if (!dataFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, can\u0026#39;t open \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testFile.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; std::exit(EXIT_FAILURE); // 退出程序失败 } dataFile \u0026lt;\u0026lt; \u0026#34;The answer is 42\\n\u0026#34;; // 创建从 tmp/slink/ 到 tmp/test/ 的符号链接: create_directory_symlink(\u0026#34;test\u0026#34;, testDir.parent_path() / \u0026#34;slink\u0026#34;); // 递归列出所有文件（也遵循符号链接） std::cout \u0026lt;\u0026lt; fs::current_path().string() \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; auto iterOpts{fs::directory_options::follow_directory_symlink}; for (const auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } catch (fs::filesystem_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34; path1: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path1().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } 让我们一步一步地完成这个程序。\n命名空间 fs 首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：\nnamespace fs = std::filesystem; 例如，我们使用这个命名空间初始化临时文件的基本子目录的路径：\nfs::path testDir{\u0026#34;tmp/test\u0026#34;}; 创建目录 然后我们尝试创建子目录：\ncreate_directories(testDir); 通过使用 create_directories() 我们创建整个传递路径的所有缺失目录（还有 create_directory() 仅在现有目录内创建目录）。\n如果目录已经存在，则执行此调用不是错误。 但是，任何其他问题都是错误并引发相应的异常。\n如果 testDir 已经存在，create_directories() 返回 false。 因此，您也可以调用：\nif (!create_directories(testDir)) { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testDir.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; already exists\\n\u0026#34;; } 但是，请注意，如果 testDir 存在但不是目录，这也不是错误。 因此，返回 true 并不意味着在调用之后有一个具有请求名称的目录。 我们可以检查一下，但在这种情况下，这是间接涉及的，因为下一次在目录中创建文件的调用将失败。 但是，错误消息可能会令人困惑。 为了获得更好的错误消息，您可能需要检查之后是否真的存在目录。\n创建常规文件 然后我们创建一个包含一些内容的新文件 /tmp/test/data.txt：\nauto testFile = testDir / \u0026#34;data.txt\u0026#34;; std::ofstream dataFile(testFile); if (!dataFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, can\u0026#39;t open \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; testFile.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; std::exit(EXIT_FAILURE); // 退出程序失败 } dataFile \u0026lt;\u0026lt; \u0026#34;The answer is 42\\n\u0026#34;; 这里我们使用运算符 / 来扩展路径，然后我们将其作为参数传递给文件流的构造函数。 如您所见，常规文件的创建仍然只能使用现有的 I/O 流库来完成。 但是，为构造函数提供了一个新的重载，以便能够直接传递文件系统路径。 请注意，您仍应始终检查创建/打开文件是否成功。 很多事情都可能在这里出错（见下文）。\n创建符号链接 下一条语句尝试创建一个引用目录 tmp/test 的符号链接 tmp/slink：\ncreate_directory_symlink(\u0026#34;test\u0026#34;, testDir.parent_path() / \u0026#34;slink\u0026#34;); 请注意，第一个参数定义了创建链接视图的路径。 因此，您必须通过“test”而不是“tmp/test”才能有效地从 tmp/slink 链接到 tmp/test。 如果你调用：\nstd::filesystem::create_directory_symlink(\u0026#34;tmp/test\u0026#34;, \u0026#34;tmp/slink\u0026#34;); 您将有效地创建 tmp/slink 作为指向 tmp/tmp/test 的符号链接。\n请注意，通常调用 create_symlink() 而不是 create_directory_symlink() 也可以，但是某些操作系统对目录的符号链接有特殊处理，或者当它们知道文件是目录时执行得更好，因此如果您应该使用 create_directory_symlink() 知道符号链接是指一个目录。\n目录递归 最后，我们递归地列出当前目录：\nauto iterOpts = fs::directory_options::follow_directory_symlink; for (auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 因为我们使用递归目录迭代器并传递选项以跟随符号链接，follow_directory_symlink，我们应该在基于 POSIX 的系统上获得如下输出：\n# /home/nico: ... tmp tmp/slink tmp/slink/data.txt tmp/test tmp/test/data.txt ... 在 Windows 系统上的输出如下所示：\n# C:/Users/nico: ... tmp tmp\\slink tmp\\slink\\data.txt tmp\\test tmp\\test\\data.txt ... 请注意，我们在打印所有目录条目的路径时使用 lexically_normal()。 如果我们跳过它，目录条目的路径将包含一个带有初始化迭代器的目录的前缀。 因此，只打印循环内的路径：\nauto iterOpts = fs::directory_options::follow_directory_symlink; for (auto\u0026amp; e : fs::recursive_directory_iterator(\u0026#34;.\u0026#34;, iterOpts)) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 将在基于 POSIX 的系统下输出：\n# all files: ... \u0026#34;./testdir\u0026#34; \u0026#34;./testdir/data.txt\u0026#34; \u0026#34;./tmp\u0026#34; \u0026#34;./tmp/test\u0026#34; \u0026#34;./tmp/test/data.txt\u0026#34; 在 Windows 上，输出将是：\n# all files: ... \u0026#34;.\\\\testdir\u0026#34; \u0026#34;.\\\\testdir\\\\data.txt\u0026#34; \u0026#34;.\\\\tmp\u0026#34; \u0026#34;.\\\\tmp\\\\test\u0026#34; \u0026#34;.\\\\tmp\\\\test\\\\data.txt\u0026#34; 因此，通过调用 lexically_normal() 我们产生了规范化的路径，它确实删除了当前目录的前导点。 如前所述，通过调用 string() 我们避免了每个路径都被引用，这对于基于 POSIX 的系统来说是可以的（只是将名称放在双引号中），但在 Windows 系统上看起来非常令人惊讶（因为每个反斜杠 被另一个反斜杠转义）。\n错误处理 文件系统是麻烦的根源。 由于使用了错误的字符、没有必要的权限或其他进程可能会在您处理文件系统时修改文件系统，您可能无法执行操作。 因此，根据平台和权限，该程序可能会出现一些问题。\n对于那些没有被返回值覆盖的情况（这里是目录已经存在的情况），我们捕获相应的异常并打印一般消息和其中的第一个路径：\ntry { ... } catch (fs::filesystem_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34; path1: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.path1().string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } 例如，如果我们无法创建目录，则可能会打印出如下消息：\nEXCEPTION: filesystem error: cannot create directory: [tmp/test] path1: \u0026#34;tmp/test\u0026#34; 或者，如果我们无法创建符号链接，例如因为它已经存在，您会收到类似以下消息：\nEXCEPTION: create_directory_symlink: Can’t create a file when it already exists: \u0026#34;tmp\\test\\data.txt\u0026#34;, \u0026#34;testdir\u0026#34; path1: \u0026#34;tmp\\test\\data.txt\u0026#34; 如前所述，当目录已经作为常规文件存在时，在目录中创建新文件的尝试将失败。因此，不要忘记检查打开文件的状态。默认情况下，用于读取和写入常规文件的 I/O Stream 库不会将错误作为异常处理。\n无论如何请注意，多用户/多进程操作系统中的情况随时可能发生变化。因此，您创建的目录甚至可能在您创建后被删除、重命名或替换为常规文件。因此，根本不可能通过找出当前情况来确保未来请求的有效性。出于这个原因，它通常是尝试做你想做的事情（即创建目录、打开文件）并处理异常和错误或验证检查预期行为的最佳方法。\n但是，有时尝试对文件系统做一些事情可能会奏效，但不是您想的那样。例如，如果您想在特定目录中创建文件并且已经存在指向另一个目录的符号链接，则该文件会在意外位置创建或覆盖。这可能没问题（用户可能有充分的理由在预期目录的位置创建符号链接）。但是，如果您想检测这种情况，则必须在创建文件之前检查文件是否存在（这比您最初想象的要复杂一些）。\n但同样：不能保证文件系统检查的结果在您处理它们时仍然有效。\n20.1.4 使用并行算法处理文件系统的问题 有关使用并行算法累积目录树中所有常规文件大小的另一个示例，请参见 dirsize.cpp。\n20.2 原则和术语 在讨论文件系统库的细节之前，我们必须介绍一些设计原则和术语。 这是必要的，因为该标准涵盖了不同的操作系统并将它们映射到一个通用 API。\n20.2.1 一般可移植性声明 C++ 标准不仅标准化了所有可能的操作系统对其文件系统的共同点。 在许多情况下，它遵循 POSIX 标准，而 C++ 标准要求尽可能地遵循 POSIX。 只要它是合理的，行为应该仍然存在，但有一些限制。 如果不可能有合理的行为，则实现应报告错误。 此类错误的可能示例是：\n字符用于不支持的文件名 创建了不受支持的文件系统元素（例如，符号链接） 特定文件系统的差异仍然可能很重要： 区分大小写： “hello.txt”和“Hello.txt”和“hello.TXT”可能指同一个（Windows）或三个不同的文件（基于POSIX）。 绝对路径与相对路径： 在某些系统上，“/bin”是绝对路径（基于 POSIX），而在其他系统上则不是（Windows）。 20.2.2 命名空间 文件系统库在 std 中有自己的子命名空间文件系统。 为其引入快捷方式 fs 是一个非常常见的约定：\nnamespace fs = std::filesystem; 例如，这允许使用 fs::current_path() 而不是 std::filesystem::current_path()。 本章的进一步代码示例通常会使用 fs 作为相应的快捷方式。 请注意，不限定文件系统调用有时会导致意外行为。\n20.2.3 路径 文件系统库的关键元素是路径。它是一个名称，表示文件系统中文件的（潜在）位置。它由一个可选的根名称、一个可选的根目录和一系列由目录分隔符分隔的文件名组成。路径可以是相对的（因此文件位置取决于当前工作目录）或绝对的。 不同的格式是可能的：\n通用格式，可移植\n一种原生格式，特定于底层文件系统 在基于 POSIX 的操作系统上，通用格式和本机格式之间没有区别。 在 Windows 上，通用格式 /tmp/test.txt 是除 \\tmp\\test.txt 之外的有效原生格式，它也受支持（因此，/tmp/test.txt 和 \\tmp\\test.txt 是相同的路径）。在 OpenVMS 上，相应的原生格式可能是 [tmp]test.txt。 存在特殊文件名：\n“.”代表当前目录\n\u0026ldquo;..\u0026rdquo; 代表父目录 通用路径格式如下：\n[rootname] [rootdir] [relativepath] 在哪里：\n可选的根名称是特定于实现的（例如，在 POSIX 系统上可以是 //host，在 Windows 系统上可以是 C:） 可选的根目录是目录分隔符 相对路径是由目录分隔符分隔的一系列文件名 根据定义，目录分隔符由一个或多个“/”或特定于实现的首选目录分隔符组成。\n可移植通用路径的示例是：\n//host1/bin/hello.txt . tmp/ /a/b//../c 请注意，最后一个路径与 /a/c 指向相同的位置，并且在 POSIX 系统上是绝对的，但在 Windows 系统上是相对的（因为缺少驱动器/分区）。\n另一方面，诸如 C:/bin 之类的路径在 Windows 系统上是绝对路径（“C”驱动器/分区上的根目录“bin”），但在 POSIX 上是相对路径（目录中的子目录“bin”） “C：”）。\n在 Windows 系统上，反斜杠是实现特定的目录分隔符，因此上面的路径也可以通过使用反斜杠作为首选目录分隔符来编写：\n\\\\host1\\bin\\hello.txt . tmp\\ \\a\\b\\..\\c 文件系统库提供了在本地格式和通用格式之间转换路径的功能。 路径可能是空的。 这意味着没有定义路径。 这不一定与“.”相同。 它的含义取决于上下文。\n20.2.4 规范化 路径可能已经或可以被规范化。 在规范化路径中：\n文件名仅由一个首选目录分隔符分隔。 文件名“.”除非整个路径只是“.”，否则不使用。 （代表当前目录）。 文件名不包含“..”文件名（我们不会先向下然后再向上），除非它们位于相对路径的开头。 如果尾部的文件名是一个名称不是\u0026rdquo;\u0026hellip; \u0026ldquo;或\u0026rdquo;\u0026hellip; \u0026ldquo;的目录，路径才以目录分隔符结束。 请注意，规范化仍然意味着以目录分隔符结尾的文件名与不以分隔符结尾的文件名不同。原因是在某些操作系统上，当知道路径是目录时，行为会有所不同（例如，带有尾随分隔符的符号链接可能会被解析）。\n路径规范化的表效果列出了一些在 POSIX 和 Windows 系统上进行规范化的示例。再次注意，在 POSIX 系统上，C:bar 和 C: are 只是文件名，并没有像在 Windows 上那样指定分区的特殊含义。\n路径 POSIX 标准化 windows 标准化 foo/.///bar/../ foo/ foo\\ //host/../foo.txt //host/foo.txt \\host\\foo.txt ./f/../.f/ .f/ .f\\ C:bar/../ . C: C:/bar/.. C:/ C:\\ C:\\bar.. C:\\bar.. C:\\ /./../data.txt /data.txt \\data.txt ././ . . 请注意，在基于POSIX的系统上进行规范化处理时，路径C:\\bar...保持不变。原因是在那里反斜杠不是目录分隔符，所以整个路径只是一个文件名，其中有一个冒号、两个反斜杠和两个点作为其名称的一部分。 文件系统为词法规范化（不考虑文件系统）和依赖文件系统的规范化都提供了功能。\n20.2.5 成员函数与独立的函数 文件系统库提供了几个函数，它们既可以是成员函数也可以是独立函数。一般的做法是：\n成员函数很便宜。原因是它们是纯词法操作，不考虑实际的文件系统，所以不需要调用操作系统。\n例如：\nmypath.is_absolute() // 检查路径是绝对的还是相对的 独立的函数是昂贵的，因为它们通常考虑到实际的文件系统，所以不需要调用操作系统。\n例子：\nequivalent(path1, path2); // 如果两个路径都指向同一个文件，则为true 有时，文件系统库甚至提供了相同的功能，既在词法上操作，又考虑到了实际的文件系统。\nstd::filesystem::path fromP, toP; ... toP.lexically_relative(fromP); // 产生从 fromP 到 toP 的词法路径 relative(toP, fromP); // 产生从 fromP 到 toP 的实际路径 由于参数依赖性查找（ADL），在调用独立的文件系统函数和一个参数具有文件系统的特定类型时，你通常不需要指定完整的命名空间std::filesystem。只有在使用其他类型的隐式转换时，你才需要限定 调用。比如说:\ncreate_directory(std::filesystem::path{\u0026#34;tmpdir\u0026#34;}); // OK remove(std::filesystem::path{\u0026#34;tmpdir\u0026#34;}); // OK std::filesystem::create_directory(\u0026#34;tmpdir\u0026#34;); // OK std::filesystem::remove(\u0026#34;tmpdir\u0026#34;); // OK create_directory(\u0026#34;tmpdir\u0026#34;); // ERROR remove(\u0026#34;tmpdir\u0026#34;); // OOPS: 调用 C 函数 remove() 请注意，最后一个调用通常会编译，但会找到C函数remove()，它也会删除一个指定的文件，但在Windows下不会删除空目录。\n20.2.6 错误处理 正如第二个例子所讨论的，文件系统是一个错误的来源。你必须考虑到必要的文件可能不存在，文件操作不被允许，或者操作违反了资源限制。此外，当程序运行时，其他进程可能会创建、修改或删除文件，因此，即使提前检查也不能保证没有错误。\n问题是，原则上你无法确保下一个文件系统操作会成功。任何检查的结果在你处理它时可能不再有效。因此，通常最好的方法是执行一个或多个文件系统操作，并处理由此产生的异常或错误。\n还要注意的是，当用普通文件进行读写时，I/O流库默认不会抛出错误。它将任何操作转换为无操作。因此，我们建议至少检查一下文件是否能成功打开。\n因为处理异常并不总是合适的（比如当你想直接对一个失败的文件系统调用做出反应时），文件系统库在处理以下问题时使用了混合方法 文件系统时，采用混合方法:\n默认情况下，文件系统错误被作为异常处理。 但是，如果你有或者想要，你可以在本地处理特定的错误。 这是通过文件系统操作实现的，通常每个操作都有两个重载。 默认情况下（没有额外的错误处理参数），操作在出错时抛出一个filesystem_error异常。 通过传递一个额外的输出参数，你可以在出错时得到一个错误代码。 请注意，在后一种情况下，你可能仍然有特殊的返回值，标志着一个特定的错误没有被作为异常处理。 使用 filesystem_error 异常 例如，你可以尝试创建一个目录，如下所示:\nif (!create_directory(p)) { // 错误异常（除非路径存在） std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; already exists\\n\u0026#34;; // 路径存在 } 这里，没有传递错误代码参数，所以错误通常会引发一个异常。但是请注意，路径已经存在的特殊情况（是否是一个目录并不重要），将通过返回false来处理。因此，一个异常是由于其他问题引起的，比如缺少创建目录的权限，无效的路径p，或者违反文件系统资源（比如超过路径长度 限制）。 像这样的代码应该直接或间接地包含在一个try-catch子句中，它可以处理std::filesystem::filesystem_error类型的异常:\ntry { ...; if (!create_directory(p)) { // 错误异常（除非路径存在） std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; already exists\\n\u0026#34;; // 路径存在 } ...; } catch (const std::filesystem::filesystem_error\u0026amp; e) { // 源自 std::exception std::cout \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; path: \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 正如你所看到的，文件系统异常提供了通常的标准异常API，通过what()产生一个特定于实现的错误信息。然而，它还提供了path1()，如果涉及到一个路径，甚至是 path2()，如果涉及到第二个路径。\n使用 error_code 参数 使用error_code参数 另一种调用函数创建目录的方法如下。\nstd::error_code ec; create_directory(p, ec); // 出错时设置错误代码 if (ec) { // 如果设置了错误代码(由于错误) std::cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 之后，我们还可以针对特定的错误代码进行检查。\nif (ec == std::errc::read_only_file_system) { // if specific error code set std::cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is read-only/n\u0026#34;; } 注意，在这种情况下，我们仍然可以检查create_directory()的返回值。\nstd::error_code ec; if (!create_directory(p, ec)) { // 出错时设置错误代码 std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t create directory \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // any error occurred std::cout \u0026lt;\u0026lt; \u0026#34;ERROR:\u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 然而，并不是所有的文件系统操作都提供这种能力（因为它们在正常情况下返回一些值正常情况下）。 在C++11中引入了error_code类型，包括一个可移植错误条件的列表，如 如std::errc::read_only_filesystem。在POSIX系统中，这些映射为errno值\n20.2.7 文件类型 不同的操作系统支持不同的文件类型。标准文件系统库考虑到了这一点。原则上，有一个枚举类型file_type，它被标准化为有以下值:\nnamespace std::filesystem { enum class file_type { regular, directory, symlink, block, character, fifo, socket, ...; none, not_found, unknown, }; } 表file_type Values列出了这些值的含义。 平台可能会提供额外的文件类型值，但这是不可移植的。例如:\nWindows提供了文件类型值junction，它用于NTFS文件系统的NTFS结点（也称为软链接）。它们被用作位于同一台计算机的不同本地卷上的目录的链接。在同一台计算机上的不同卷上的目录的链接。\n值 意义 regular 常规文件 directory 目录文件 symlink 符号连接 character 字符专用文件 block 块特殊文件 fifo FIFO或管道文件 socket 套接字文件 \u0026hellip; 额外的执行定义的文件类型 none 文件类型未知（尚） unknown 文件存在但无法确定类型 not_found 表示未找到该文件的伪类型 除了常规文件和目录之外，最常见的其他类型是符号链接，它是一种指向另一个文件系统位置的文件的类型。在那个位置可能有一个文件，也可能没有。请注意，某些操作系统和/或文件系统（例如 FAT 文件系统）根本不支持符号链接。某些操作系统仅对常规文件支持它们。请注意，在 Windows 上，您需要特殊权限才能创建符号链接，例如，您可以使用 mklink 命令执行此操作。 字符特殊文件、块特殊文件、FIFO 和套接字来自 UNIX 文件系统。目前，所有四种类型都不能与 Visual C++ 一起使用。 如您所见，对于文件不存在或其文件类型未知或无法检测的情况，存在特殊值。在本章的其余部分中，我使用两个通用类别来表示几种文件类型：\n其他文件：具有除常规文件、目录和符号链接之外的任何文件类型的文件。库函数 is_other() 匹配该术语。 特殊文件：具有以下任何文件类型的文件：字符特殊文件、块特殊文件、FIFO 和套接字。 特殊文件类型加上实现定义的文件类型共同构成了其他文件类型。 20.3 路径操作 为了处理文件系统，有很多操作可以调用。处理文件系统的一个关键类型是std::filesystem::path，它可以作为一个文件的绝对或相对路径，这个文件可能存在，也可能不存在（尚未存在）。\n你可以创建路径，检查它们，修改它们，以及比较它们。因为这些操作通常不考虑文件系统（关心现有文件、符号链接等），所以它们的调用很便宜。因此，它们通常是成员函数（如果它们不是构造函数或 操作符）。\n20.3.1 创建路径 表Path Creation列出了创建新路径对象的方法。\n调用 作用 path(string) 从一个字符串创建路径 path(beg,end) 从一个范围创建路径 u8path(u8string) 从一个UTF-8字符串中创建路径 current_path() 产生当前工作目录的路径 temp_directory_path() 产生临时文件的路径 注意，current_path()和temp_directory_path()都是比较昂贵的操作，因为它们是基于操作系统的调用。通过传递一个参数，current_path()也可以用来修改当前工作目录。 通过u8path()，你可以使用所有UTF-8字符创建可移植的路径。比如说:\nstd::filesystem::path{u8path(u8\u0026#34;K\\u00F6ln\u0026#34;); // ”Koln” (Cologne native) ¨ ... // 从返回的UTF-8字符串中创建目录: std::string utf8String = readUTF8String(...); create_directory(std::filesystem::u8path(utf8String)); 20.3.2 路径检查 表Path Inspection列出了你可以调用的检查路径p的函数。注意，这些操作不考虑文件系统，因此是路径的成员函数。 每个路径都是绝对或相对的。如果它没有根目录，它就是相对的（根名称是可能的；例如，C:hello.txt在Windows下是一个相对路径）。 has_\u0026hellip;()函数检查没有has_的相应函数是否产生一个空路径。 请注意以下几点。\n如果根元素或目录分隔符是路径的一部分，总是有一个父路径。如果路径只由根元素组成（即相对路径是空的），parent_path()得到的是相同的路径。也就是说，例如，\u0026rdquo;/\u0026ldquo;的父路径是\u0026rdquo;/\u0026quot;。只有像 \u0026ldquo;hello.txt \u0026ldquo;这样的纯文件名的父路径是空的。 调用 作用 p.empty() 产生路径是否为空 p.is_absolute() 产生一个路径是否是绝对的 p.is_relative() 产生是否是相对路径 p.has_filename() 产生路径是否既不是目录也不是根名的问题 p.has_stem() 与has_filename()相同（因为任何文件名都有一个干）。 p.has_extension() 产生路径是否有扩展名 p.has_root_name() yields 路径是否有根名 p.has_root_directory() yields 路径是否有根目录 p.has_root_path() yields 路径是否有根名或根目录 p.has_parent_path() 产生路径是否有一个父路径 p.has_relative_path() 产生路径是否不只由根元素组成 p.filename() 产生文件名（或空路径）。 p.stem() 产生不带扩展名的文件名（或空路径） p.extension() 产生扩展名(或空路径) p.root_name() 产生根名(或空路径) p.root_directory() 产生根目录(或空路径) p.root_path() 产生根元素(或空路径) p.parent_path() 产生父路径(或空路径) p.relative_path() 产生没有根元素的路径(或空路径) p.begin() 路径迭代的开始 p.end() 路径迭代结束 如果一个路径有一个文件名，它也总是有一个茎。 空路径是一个相对路径（对于除is_empty()和is_relative()之外的所有其他操作，产生false或空路径）。 这些操作的结果可能取决于操作系统。例如，路径C:/hello.txt 在Unix系统上 是相对的 没有根元素（既没有根名称也没有根目录），因为C:是一个文件名。 有父路径C: 具有相对路径C:/hello.txt 在Windows系统上 是绝对的 有根名称C：和根目录/ 没有父路径 有相对路径 hello.txt 路径迭代 你可以对一个路径进行迭代，产生路径中的元素：根名（如果有），根目录（如果有），以及所有的文件名。如果路径以目录分隔符结束，最后一个元素是一个空文件名。 迭代器是一个双向的迭代器，这样你就可以使用\u0026mdash;-。迭代器引用的值又是路径类型的。然而，两个迭代器在同一路径上迭代时，即使它们引用了相同的元素，也可能不会引用相同的路径对象。 比如说：\nvoid printPath(const std::filesystem::path\u0026amp; p) { std::cout \u0026lt;\u0026lt; \u0026#34;path elements of \u0026#34; \u0026lt;\u0026lt; p.string \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; for (auto pos = p.begin(); pos != p.end(); ++pos) { std::filesystem::path elem = *pos; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; elem; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 如果这个函数被调用如下:\nprintPath(\u0026#34;../sub/file.txt\u0026#34;); printPath(\u0026#34;/usr/tmp/test/dir/\u0026#34;); printPath(\u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;); 在基于POSIX的系统上的输出将是:\npath elements of \u0026#34;../sub/file.txt\u0026#34;: \u0026#34;..\u0026#34; \u0026#34;sub\u0026#34; \u0026#34;file.txt\u0026#34; path elements of \u0026#34;/usr/tmp/test/dir/\u0026#34;: \u0026#34;/\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; path elements of \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;: \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34; 注意，最后一个路径只是一个文件名，因为在基于POSIX的系统下，C:既不是有效的根名，反斜杠也不是有效的目录分隔符。 在Windows系统上的输出将是：\npath elements of \u0026#34;../sub/file.txt\u0026#34;: \u0026#34;..\u0026#34; \u0026#34;sub\u0026#34; \u0026#34;file.txt\u0026#34; path elements of \u0026#34;/usr/tmp/test/dir/\u0026#34;: \u0026#34;/\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; path elements of \u0026#34;C:\\\\usr\\\\tmp\\\\test\\\\dir\\\\\u0026#34;: \u0026#34;C:\u0026#34; \u0026#34;\\\\\u0026#34; \u0026#34;usr\u0026#34; \u0026#34;tmp\u0026#34; \u0026#34;test\u0026#34; \u0026#34;dir\u0026#34; \u0026#34;\u0026#34; 要检查一个路径p是否以目录分隔符结束，你可以实现:\nif (!p.empty() \u0026amp;\u0026amp; (--p.end())-\u0026gt;empty()) { std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; has a trailing separator\\n\u0026#34;; } 20.3.3 路径I/O和转换 表中路径I/O和转换列出了读取或写入以及产生转换后的路径的操作。 这些功能没有考虑到实际的文件系统。如果你必须处理符号链接重要的路径，你可能想使用与文件系统相关的路径转换。\n调用 作用 strm \u0026laquo; p 把路径的值写成引号字符串 strm \u0026raquo; p 将路径的值读成带引号的字符串 p.string() 得到的路径是std::string p.wstring() 得到的路径是std::wstring p.u8string() 产生路径的UTF-8字符串，类型为std::u8string p.u16string() 产生路径的UTF-16字符串，类型为std::u16string p.u32string() 产生路径的UTF-32字符串，类型为std::u32string p.string\u0026lt;\u0026hellip;\u0026gt;() 得到的路径是std::basic_string\u0026lt;\u0026hellip;\u0026gt;。 p.lexically_normal() 产生 p 作为标准化路径 p.lexically_relative(p2) 产生从p2到p的路径（如果没有则为空路）。 p.lexically_proximate(p2) 产生从 p2 到 p 的路径（如果没有，则为 p） lexically_\u0026hellip;()函数返回一个新的路径，而其他转换函数产生一个相应的字符串类型。这些函数都没有修改它们所调用的路径。 例如，下面的代码:\nstd::filesystem::path p{\u0026#34;/dir/./sub//sub1/../sub2\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;path: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;string(): \u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;wstring(): \u0026#34; \u0026lt;\u0026lt; p.wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 对前三行有相同的输出:\npath: \u0026#34;/dir/./sub//sub1/../sub2\u0026#34; string(): /dir/./sub//sub1/../sub2 wstring(): /dir/./sub//sub1/../sub2 但最后一行的输出取决于目录分隔符。在基于POSIX的系统中，它是:\nlexically_normal(): \u0026#34;/dir/sub/sub2\u0026#34; 而在Windows上，它是:\nlexically_normal(): \u0026#34;\\\\dir\\\\sub\\\\sub2\u0026#34; 路径I/O 首先，请注意，I/O操作符是以带引号的字符串形式写入和读取路径。你必须把它们转换为字符串，以便在写它们时不加引号:\nstd::filesystem::path file{\u0026#34;test.txt\u0026#34;} std::cout \u0026lt;\u0026lt; file \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // writes: \u0026#34;test.txt\u0026#34; std::cout \u0026lt;\u0026lt; file.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // writes: test.txt 在Windows上，这有更糟糕的效果。下面的代码:\nstd::filesystem::path tmp{\u0026#34;C:\\\\Windows\\\\Temp\u0026#34;}; std::cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; tmp.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\u0026#34;\u0026#39; \u0026lt;\u0026lt; tmp.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; 有以下输出:\n\u0026#34;C:\\\\Windows\\\\Temp\u0026#34; C:\\Windows\\Temp \u0026#34;C:\\Windows\\Temp\u0026#34; 注意，读取文件名支持两种形式（带前导 \u0026ldquo;的引号和不带引号）。因此，所有打印出来的形式将被正确地读回，使用标准输入操作符的路径:\nstd::filesystem::path tmp; std::cin \u0026gt;\u0026gt; tmp; // 正确读取带引号和不带引号的路径 正常化 当你处理可移植代码时，malization可能有更多令人惊讶的结果。比如说：\ntd::filesystem::path p2{\u0026#34;//dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p2.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 在Windows系统上有以下可能的预期输出:\np2: \u0026#34;//host\\\\dir/sub\\\\/./\\\\\u0026#34; lexically_normal(): \u0026#34;\\\\\\\\host\\\\dir\\\\sub\\\\\u0026#34; 然而，在基于POSIX的系统上，输出变成了:\np2: \u0026#34;//host\\\\dir/sub\\\\/./\\\\\u0026#34; lexically_normal(): \u0026#34;/host\\\\dir/sub\\\\/\\\\\u0026#34; 原因是在基于POSIX的系统中，反斜杠不是目录分隔符，也不是根名的有效字符，所以我们有一个绝对路径，有三个文件名host\\dir、sub\\和\\。在基于POSIX的系统中，没有办法检测到反斜杠是一个可能的目录分隔符（在这种情况下，generic_string()和make_preferred()都没有帮助）。 因此，对于可移植代码来说，在处理路径时，你应该始终使用通用路径格式。 尽管如此，在迭代当前目录时，使用lexically_normal()函数去掉前面的点也是一个好办法。\n相对路径 lexically_relative()和lexically_proximate()都可以被调用来计算相对于 路径之间的相对路径。唯一的区别是在没有路径的情况下的行为，只有在一个路径是相对的，另一个是绝对的或者根名称不同的情况下才会发生。在这种情况下。\np.lexically_relative(p2)如果没有从p2到p的相对路径，则产生空路径。\np.lexically_proximate(p2)如果没有从p2到p的相对路径，则产生p。 由于这两个操作都是词法操作，实际的文件系统（可能有符号链接）和current_path()都没有被考虑在内。如果两个路径相等，则相对路径为\u0026rdquo;.\u0026quot;。 例子:\nfs::path{\u0026#34;/a/d\u0026#34;}.lexically_relative(\u0026#34;/a/b/c\u0026#34;) // \u0026#34;../../d\u0026#34; fs::path{\u0026#34;/a/b/c\u0026#34;}.lexically_relative(\u0026#34;/a/d\u0026#34;) // \u0026#34;../b/c\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b/\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/b\\\\\u0026#34;) // \u0026#34;.\u0026#34; fs::path{\u0026#34;/a/b\u0026#34;}.lexically_relative(\u0026#34;/a/d/../c\u0026#34;) // \u0026#34;../b fs::path{\u0026#34;a/d/../b\u0026#34;}.lexically_relative(\u0026#34;a/c\u0026#34;) // \u0026#34;../d/../b\u0026#34; fs::path{\u0026#34;a//d/..//b\u0026#34;}.lexically_relative(\u0026#34;a/c\u0026#34;) // \u0026#34;../d/../b\u0026#34; 在Windows系统上，我们有:\nfs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_relative(\u0026#34;c:/c/d\u0026#34;) ; // \u0026#34;\u0026#34; fs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_relative(\u0026#34;D:/c/d\u0026#34;) ; // \u0026#34;\u0026#34; fs::path{\u0026#34;C:/a/b\u0026#34;}.lexically_proximate(\u0026#34;D:/c/d\u0026#34;) ; // \u0026#34;C:/a/b\u0026#34; 转换为字符串 使用u8string()，你可以将路径作为UTF-8字符串使用，这也是当今存储数据的常用格式。存储数据的常用格式。比如说;\n// 将路径存储为UTF-8字符串: std::vector\u0026lt;std::string\u0026gt; utf8paths; // std::u8string with C++20 for (const auto\u0026amp; entry : fs::directory_iterator(p)) { utf8paths.push_back(entry.path().u8string()); } 请注意，u8string()的返回值可能会在C++20中从std::string变为std::u8string（新的UTF-8字符串类型，与char8_t一起在https://wg21.link/p0482，用于UTF-8字符）。 成员模板string\u0026lt;\u0026gt;()可以用来转换为一个特殊的字符串类型，例如一个不区分大小写的字符串类型:\nstruct ignoreCaseTraits : public std::char_traits\u0026lt;char\u0026gt; { // 不敏感地比较两个字符的情况: static bool eq(const char\u0026amp; c1, const char\u0026amp; c2) { return std::toupper(c1) == std::toupper(c2); } static bool lt(const char\u0026amp; c1, const char\u0026amp; c2) { return std::toupper(c1) \u0026lt; std::toupper(c2); } // 比较s1和s2的多达n个字符: static int compare(const char* s1, const char* s2, std::size_t n); // 检索字符c在s中的位置: static const char* find(const char* s, std::size_t n, const char\u0026amp; c); }; // 为这类字符串定义一个特殊的类型: using icstring = std::basic_string\u0026lt;char, ignoreCaseTraits\u0026gt;; std::filesystem::path p{\u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; icstring s2 = p.string\u0026lt;char,ignoreCaseTraits\u0026gt;(); 还需要注意的是，你不应该使用同样提供的函数c_str()，因为它可以转换为本地字符串格式，可能是一个wchar_t，这样你就必须使用，例如 std::wcout而不是std::cout来将其写入流中。\n20.3.4 本地格式和通用格式之间的转换 在本地和通用格式之间的转换表列出了在通用路径格式和实际平台的特定实现格式之间的转换操作。\n这些函数在基于POSIX的系统中应该没有影响，因为本地路径格式和通用路径格式之间没有区别。在其他平台上调用这些函数可能会有影响：\ngeneric\u0026hellip;() path 函数产生转换为具有通用格式的相应字符串格式的路径，\n调用 作用 p.generic_string() 得到的路径是一个通用的std::string p.generic_wstring() 得到的路径是一个通用的std::wstring p.generic_u8string() 得到的路径是一个通用的std::u8string p.generic_u16string() 得到的路径是一个通用的std::u16string p.generic_u32string() 得到的路径是一个通用的std::u32string p.generic_string\u0026lt;\u0026hellip;\u0026gt;() 得到的路径是一个通用的std::basic_string\u0026lt;\u0026hellip;\u0026gt; p.native() 产生本地格式的路径，类型为path::string_type conversionToNativeString 隐式转换为本地字符串类型 p.c_str() 产生作为本地字符串格式的字符序列的路径 p.make_preferred() 用本地格式替换p中的目录分隔符，并得到修改后的p native()产生转换为本地字符串编码的路径，它由std::filesystem::path::string_type类型定义。在Windows下，这个类型是std::wstring类型，所以你必须使用std::wcout而不是std::cout来直接将其写入标准输出流。新的重载允许我们将本地字符串传递给文件流的新重载。 c_str()做了同样的事情，但产生的结果是一个空尾的字符序列。注意，使用这个函数也是不可移植的，因为在Windows上用std::cout打印序列并不能产生正确的输出。你必须在那里使用std::wcout。 make_preferred()用本地目录分隔符替换了除根名之外的任何目录分隔符。注意，这是唯一一个修改它所调用的路径的函数。因此，严格来说属于下一节修改路径的函数，但由于它处理的是本地格式的转换，所以也在这里列出。 例如，在Windows下，下面的代码。\nstd::filesystem::path p{\u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34;}; std::cout \u0026lt;\u0026lt; \u0026#34;p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;string(): \u0026#34; \u0026lt;\u0026lt; p.string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;wstring(): \u0026#34; \u0026lt;\u0026lt; p.wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;lexically_normal(): \u0026#34; \u0026lt;\u0026lt; p.lexically_normal() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;generic_string(): \u0026#34; \u0026lt;\u0026lt; p.generic_string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::wcout \u0026lt;\u0026lt; \u0026#34;generic_wstring(): \u0026#34; \u0026lt;\u0026lt; p.generic_wstring() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 因为它是Windows，而且本地字符串类型是wstring。: std::wcout \u0026lt;\u0026lt; \u0026#34;native(): \u0026#34; \u0026lt;\u0026lt; p.native() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Windows! std::wcout \u0026lt;\u0026lt; \u0026#34;c_str(): \u0026#34; \u0026lt;\u0026lt; p.c_str() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;make_preferred(): \u0026#34; \u0026lt;\u0026lt; p.make_preferred() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 有以下输出:\np: \u0026#34;/dir\\\\subdir/subsubdir\\\\/./\\\\\u0026#34; string(): /dir\\subdir/subsubdir\\/./\\ wstring(): /dir\\subdir/subsubdir\\/./\\ lexically_normal(): \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\u0026#34; generic_string(): /dir/subdir/subsubdir//.// generic_wstring(): /dir/subdir/subsubdir//.// native(): /dir\\subdir/subsubdir\\/./\\ c_str(): /dir\\subdir/subsubdir\\/./\\ make_preferred(): \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\\\\.\\\\\\\\\u0026#34; p: \u0026#34;\\\\dir\\\\subdir\\\\subsubdir\\\\\\\\.\\\\\\\\\u0026#34; 再次注意:\n本地字符串类型是不可移植的。在Windows上它是一个wstring，在基于POSIX的系统上它是一个字符串，所以你必须使用cout而不是wcout来打印native()和c_str()的结果。使用wcout只对wstring()和generic_wstring()的返回值具有可移植性。generic_wstring()的返回值。 只有make_preferred()的调用会修改它所调用的路径。所有其他的调用使p 不受影响。 20.3.5 路径修改 表Path Modifications列出了允许我们直接修改路径的操作。 +=和concat()只是在路径上添加新的字符，而/、/=和append()则是在路径上添加一个子 路径，并用当前目录的分隔符分隔:\nstd::filesystem::path p{\u0026#34;myfile\u0026#34;}; p += \u0026#34;.git\u0026#34;; // p: myfile.git p /= \u0026#34;.git\u0026#34;; // p: myfile.git/.git p.concat(\u0026#34;1\u0026#34;); // p: myfile.git/git1 p.append(\u0026#34;1\u0026#34;); // p: myfile.git/git1/1 std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; p / p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 在基于POSIX的系统上，输出是:\n\u0026#34;myfile.git/.git1/1\u0026#34; \u0026#34;myfile.git/.git1/1/myfile.git/.git1/1\u0026#34; 在Windows系统上，输出为:\n\u0026#34;myfile.git\\\\.git1\\\\1\u0026#34; \u0026#34;myfile.git\\\\.git1\\\\1\\\\myfile.git\\\\.git1\\\\1\u0026#34; 注意，追加一个绝对子路径意味着替换现有的路径。例如，在:\nnamespace fs = std::filesystem; auto p1 = fs::path(\u0026#34;/usr\u0026#34;) / \u0026#34;tmp\u0026#34;; // path is /usr/tmp or /usr\\tmp auto p2 = fs::path(\u0026#34;/usr/\u0026#34;) / \u0026#34;tmp\u0026#34;; // path is /usr/tmp auto p3 = fs::path(\u0026#34;/usr\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is /tmp 调用 作用 p = p2 指定一个新的路径 p = sv 指定一个字符串（视图）作为新的路径 p.assign(p2) 指定一个新的路径 p.assign(sv) 将一个字符串(视图)作为一个新的路径。 p.assign(beg, end) 将范围内的元素从开始到结束分配给路径 p1 / p2 将p2作为p1的子路径连接起来，产生路径。 p /= sub 将子路径作为子路径附加到路径p上 p.append(sub) 将子路径作为子路径附加到路径p上 p.append(beg, end) 将范围内从开始到结束的元素作为子路径附加到路径p p += str 将str的字符附加到路径p中 p.concat(sub) 将str的字符附加到路径p中 p.concat(beg, end) 将范围内从beg到end的元素追加到路径p中。 p.remove_filename() 从路径中删除尾部的文件名 p.replace_filename(repl) 替换尾部的文件名（如果有的话） p.replace_extension() 删除任何尾部的文件名扩展名 p.replace_extension(repl) 替换尾部文件名的扩展名（如果有）。 p.clear() 使路径为空 p.swap(p2) 交换两个路径的值 swap(p1, p2) 交换两个路径的值 p.make_preferred() 用本地格式替换p中的目录分隔符，并产生修改后的p auto p4 = fs::path(\u0026#34;/usr/\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is /tmp 我们有4个路径，分别指向两个不同的文件。\np1和p2相等，指向文件/usr/tmp（注意，在Windows下它们相等，p1是/usr/tmp）。\np3和p4是相等的，指的是文件/tmp，因为附加了一个绝对路径。 对于根元素来说，是否分配了一个新元素也很重要。例如，在Windows下\n我们有:\nauto p1 = fs::path(\u0026#34;usr\u0026#34;) / \u0026#34;C:/tmp\u0026#34;; // path is C:/tmp auto p2 = fs::path(\u0026#34;usr\u0026#34;) / \u0026#34;C:\u0026#34;; // path is C: auto p3 = fs::path(\u0026#34;C:\u0026#34;) / \u0026#34;\u0026#34;; // path is C: auto p4 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;/tmp\u0026#34;; // path is C:/tmp auto p5 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;C:tmp\u0026#34;; // path is C:usr\\tmp auto p6 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;c:tmp\u0026#34;; // path is c:tmp auto p7 = fs::path(\u0026#34;C:usr\u0026#34;) / \u0026#34;D:tmp\u0026#34;; // path is D:tmp 函数make_preferred()将路径中的目录分隔符转换为本地格式。 比如说:\nstd::filesystem::path p{\u0026#34;//server/dir//subdir///file.txt\u0026#34;}; p.make_preferred(); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 写在基于POSIX的平台上:\n\u0026#34;//server/dir/subdir/file.txt\u0026#34; 在Windows上，输出结果如下:\n\u0026#34;\\\\\\\\server\\\\dir\\\\\\\\subdir\\\\\\\\\\\\file.txt\u0026#34; 请注意，前导根名不会被修改，因为它必须由两个斜线或反斜线组成。 还要注意的是，在基于POSIX的系统上，这个函数不能将反斜线转换为斜线，因为反斜线不被认为是目录分隔符。 replace_extension() 替换、添加或删除一个扩展名。\n如果文件有一个扩展名，它被替换\n如果文件没有扩展名，将添加新的扩展名。\n如果你跳过新的扩展名或者新的扩展名是空的，任何现有的扩展名都会被删除。 你是否在替换处放置一个前导点并不重要。该函数确保 例如：\nfs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // file.tmp fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;.tmp\u0026#34;) // file.tmp fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension(\u0026#34;\u0026#34;) // file fs::path{\u0026#34;file.txt\u0026#34;}.replace_extension() // file fs::path{\u0026#34;dir\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // dir.tmp fs::path{\u0026#34;.git\u0026#34;}.replace_extension(\u0026#34;tmp\u0026#34;) // .git.tmp 注意，作为 \u0026ldquo;纯扩展名 \u0026ldquo;的文件名（如.git）不算是扩展名。\n20.3.6 路径比较 表路径比较列出了你可以用来比较两个不同路径的操作。 请注意，大多数比较不考虑文件系统，这意味着它们只进行词法操作，这很便宜，但可能会导致令人惊讶的返回值。\n使用==、!=和compare()，下列路径都是不同的。\ntmp1/f ./tmp1/f tmp1/./f tmp1/tmp11/../f 调用 作用 p1 == p2 产生两个路径是否相等 p1 != p2 得出两条路径是否不相等 p1 \u0026lt; p2 产生一个路径是否小于另一个路径的结果 p1 \u0026lt;= p2 产生一条路径是否小于或等于另一条路径 p1 \u0026gt;= p2 产生一条路径是否大于或等于另一条路径 p1 \u0026gt; p2 产生一条路径是否大于另一条路径 p.compare(p2) 得出p2是否小于、等于或大于p的结论 p.compare(sv) 产生p2是否小于、等于或大于字符串(view)的结果，sv转换为路径 equivalent(p1, p2) 考虑到文件系统的昂贵的路径比较 只检测指定目录分隔符的不同格式。因此，下列路径都是相同的（只要反斜线是有效的目录分隔符）。\ntmp1/f /tmp1//f /tmp1\\f tmp1/\\/f 只有当你为每个路径调用lexically_normal()时，上面所有的路径才是相等的（只要反斜杠是有效的目录分隔符）。比如说:\nstd::filesystem::path p1{\u0026#34;tmp1/f\u0026#34;}; std::filesystem::path p2{\u0026#34;./tmp1/f\u0026#34;}; p1 == p2 // true p1.compare(p2) // not 0 p1.lexically_normal() == p2.lexically_normal() // true p1.lexically_normal().compare(p2.lexically_normal()) // 0 如果你想把文件系统考虑进去，以便正确处理符号链接，你可以使用equivalent()。然而，请注意，这个函数要求两个路径都代表现有的文件。因此，一个尽可能准确地比较路径的通用方法（但没有最好的性能） 是这样的:\nbool pathsAreEqual(const std::filesystem::path\u0026amp; p1, const std::filesystem::path\u0026amp; p2) { return exists(p1) \u0026amp;\u0026amp; exists(p2) ? equivalent(p1, p2) : p1.lexically_normal() == p2.lexically_normal(); } 20.3.7 其他路径操作 表中其他路径操作列出了尚未列出的其余路径操作。\n调用 作用 p.hash_value() 产生一个路径的哈希值 注意，只有相等的路径才有相同的哈希值。也就是说，以下的路径产生不同的 哈希值：\ntmp1/f ./tmp1/f tmp1/./f tmp1/tmp11/../f 出于这个原因，你可能想在将路径放入哈希表之前将其规范化。\n20.4 文件系统操作 本节涵盖了考虑到当前文件系统的更昂贵的文件系统操作。 因为这些操作通常要考虑到文件系统（照顾现有文件、符号链接等），所以它们比纯路径操作要昂贵。 因此，它们通常是独立的函数。\n20.4.1 文件属性 有几个属性你可以得到关于一个给定路径后面的文件。首先，表 \u0026ldquo;文件类型的操作 \u0026ldquo;列出了你可以调用的函数，以检查由路径p指定的文件是否存在以及它的整体类型（如果有的话）。注意，这些操作确实考虑到了文件系统，因此是独立的函数。 文件系统类型的函数与相应的file_type值相匹配。然而，请注意，这些函数（除了is_symlink()）遵循符号链接。也就是说，对于一个目录的符号链接，is_symlink()和is_directory()都会产生true。 还要注意的是，根据其他文件类型的定义，对于所有检查特殊文件（没有普通文件、没有目录、没有符号链接）的is_other()也会产生真值。 对于特定实现的文件类型，没有特定的便利函数，因此对它们来说 只有is_other()为真（如果我们有一个符号链接到这样的文件，则is_symlink()为真）。你可以 使用文件状态API来检查这些特定的类型。 为了不跟踪符号链接，使用symlink_status()并为返回的 file_status，正如接下来讨论的exists()。 调用 作用 exists(p) 产生是否有文件可以打开的结果 is_symlink(p) 产生文件p是否存在并且是一个符号链接 is_regular_file(p) 产生文件p是否存在并且是一个普通文件 is_directory(p) 产生文件p是否存在并且是一个目录 is_other(p) 产生文件是否存在 p 并且既不是常规也不是目录也不是符号链接 is_block_file(p) 产生文件p是否存在并且是一个块状的特殊文件 is_character_file(p) 产生文件p是否存在并且是一个特殊字符的文件 is_fifo(p) 产生文件 p 是否存在，并且是 FIFO 或管道文件 is_socket(p) 产生文件p是否存在并且是一个套接字文件 检查文件是否存在 exists()回答的问题是，是否有一个有效的文件可以打开。因此，正如刚才讨论的，它遵循符号链接。所以，如果有一个符号链接到一个不存在的文件，它就会产生错误。 因此，像这样的代码不会像预期的那样工作：\n// 如果还没有做，就创建一个符号链接到文件: if (!exists(p)) { // OOPS：检查p所指的文件是否不存在 std::filesystem::create_symlink(file, p); } 如果p已经作为一个不存在的文件的符号链接存在，它将尝试在已经存在符号链接的位置创建符号链接，并引发一个相应的异常。\n因为多用户/多进程文件系统中的情况可能随时发生变化，通常最好的办法是尝试执行一个操作，并在操作失败时处理错误。因此，我们可以简单地调用操作并处理相应的异常或处理作为附加参数传递的错误代码。\n然而，有时你需要检查一个文件是否存在（在执行文件系统操作之前）。例如，如果你想在一个特定的位置创建一个文件，而那里已经有一个符号链接，那么这个文件就会在一个可能意想不到的位置被创建或被覆盖。在这种情况下，你 在这种情况下，你应该检查文件是否存在，方法如下:\nif (!exists(symlink_status(p))) { // OK: 检查p是否还不存在（作为符号链接）。 ... } 这里我们使用symlink_status()，它产生的是不跟随符号链接的状态，来检查 检查在p的位置是否存在任何文件。\n其他文件属性 文件属性的表操作列出了几个独立的函数来检查额外的文件属性。\n调用 作用 is_empty(p) 产生文件是否为空 file_size(p) 产生文件的大小 hard_link_count(p) 产生硬链接的数量 last_write_time(p) 产生最后一次写到一个文件的时间点 请注意，一个路径是否为空和一个路径所指定的文件是否为是空的：\np.empty() // 如果路径p是空的，则为真（廉价操作）。 is_empty(p) // 如果路径p上的文件是空的，则为真(文件系统操作) file_size(p)返回文件p的大小，如果它作为常规文件存在的话（就像POSIX函数stat()的成员st_size一样）。对于所有其他的文件，其结果是执行定义的，不可移植。 hard_link_count(p) 返回一个文件在文件系统中存在的次数。通常这个数字是1，但在某些文件系统中，同一个文件可以存在于文件系统的不同位置（即有不同的路径）。这与符号链接不同，在符号链接中，一个文件指的是另一个文件。在这里，我们有一个具有不同路径的文件，可以直接访问它。只有当最后一个硬链接被删除时，文件本身才会被删除。文件本身也会被删除。\n处理最后一次修改 last_write_time(p)返回文件最后一次修改或写入的时间点。返回类型是标准Chrono库中用于时间点的特殊time_point类型:\nnamespace std::filesystem { using file_time_type = chrono::time_point\u0026lt;trivialClock\u0026gt;; } 时钟类型trivialClock是一个特定实现的时钟类型，反映了文件时间值的分辨率和范围。例如，你可以按以下方式使用它:\nvoid printFileTime(const std::filesystem::path\u0026amp; p) { auto filetime = last_write_time(p); auto diff = std::filesystem::file_time_type:🕰:now() - filetime; std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::seconds\u0026gt;(diff).count() \u0026lt;\u0026lt; \u0026#34; Seconds old.\\n\u0026#34;; } 这可能会输出:\n\u0026#34;fileattr.cpp\u0026#34; is 4 Seconds old. 而不是\nstd::filesystem::file_time_type:🕰:now() 在这个例子中，你也可以这样写:\ndecltype(filetime):🕰:now() 请注意，文件系统时间点使用的时钟并不保证是标准的system_clock。由于这个原因，目前还没有标准化的支持将文件系统的时间点转换为time_t类型，以便在字符串或输出中使用它作为绝对时间。下面的函数 \u0026ldquo;大致 \u0026ldquo;地将任何时钟的时间点转换为time_t对象:\ntemplate\u0026lt;typename TimePoint\u0026gt; std::time_t toTimeT(TimePoint tp) { using system_clock = std::chrono::system_clock; return system_clock::to_time_t(system_clock::now() + (tp - decltype(tp):🕰:now())); } 诀窍是计算出文件系统时间点相对于现在的持续时间，然后把这个差值加到系统时钟的当前时间上。这个函数并不精确，因为两个时钟可能有不同的分辨率，而且我们在稍微不同的时间调用now()两次。然而，在一般情况下 一般来说，这样做效果很好。 例如，对于一个路径p，我们可以调用:\nauto ftime = last_write_time(p); std::time_t t = toTimeT(ftime); // 转换为日历时间（包括跳过尾部换行）。: std::string ts = ctime(\u0026amp;t); ts.resize(ts.size()-1); std::cout \u0026lt;\u0026lt; \u0026#34;last access of \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; ts \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 其中可能会打印:\nlast access of \u0026#34;fileattr.exe\u0026#34;: Sun Jun 24 10:41:12 2018 为了以我们想要的方式格式化一个字符串，我们可以调用:\nstd::time_t t = toTimeT(ftime); char mbstr[100]; if (std::strftime(mbstr, sizeof(mbstr), \u0026#34;last access: %B %d, %Y at %H:%M\\n\u0026#34;, std::localtime(\u0026amp;t))) { std::cout \u0026lt;\u0026lt; mbstr; } 这可能会输出:\nlast access: June 24, 2018 at 10:41 将任何文件系统的时间点转换为字符串的一个有用的辅助工具是:\nfilesystem/ftimeAsString.hpp #include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;filesystem\u0026gt; std::string asString(const std::filesystem::file_time_type\u0026amp; ft) { using system_clock = std::chrono::system_clock; auto t = system_clock::to_time_t(system_clock::now() + (ft - std::filesystem::file_time_type:🕰:now())); // 转换为日历时间（包括跳过尾部的新行）。 std::string ts = ctime(\u0026amp;t); ts.resize(ts.size()-1); return ts; } 注意，ctime()和strftime()不是线程安全的，不能同时调用。 请参阅修改现有文件，了解修改最后一次写入权限的相应API。\n20.4.2 文件状态 为了避免文件系统的访问，有一个特殊的类型file_status，可以用来保持和修改缓存的文件类型和权限。 缓存的文件类型和权限。这个状态可以在询问特定路径的文件状态时被设置。\n当询问特定路径的文件状态时，如表 \u0026ldquo;文件状态的操作 \u0026ldquo;中所列。\n当在一个目录上迭代时\n调用 作用 status(p) 产生文件p的file_status（包括符号链接) symlink_status(p) 读取p的文件状态（不遵循符号链接） 不同的是，如果路径p在符号链接中解析，status()跟随链接并打印那里的文件属性（状态可能是没有文件），而symlink_status(p)打印的是符号链接本身的状态。 表file_status Operations列出了对file_status对象fs的可能调用。\n调用 作用 exists(fs) 产生一个文件是否存在。 is_regular_file(fs) 产生文件是否存在并且是一个常规文件 is_directory(fs) 产生文件是否存在并且是一个目录。 is_symlink(fs) 产生文件是否存在并且是一个符号链接。 is_other(fs) 产生文件是否存在，并且既不是普通文件也不是目录也不是象征性链接 is_character_file(fs) 产生文件是否存在并且是一个特殊字符的文件。 is_block_file(fs) 产生文件是否存在并且是一个块状特殊文件。 is_fifo(fs) 产生文件是否存在并且是FIFO或管道文件 is_socket(fs) 产生文件是否存在并且是一个套接字。 fs.type() 产生文件的文件类型。 fs.permissions() 产生文件的权限。 状态操作的一个好处是，你可以为同一个文件保存多个操作系统的调用。同一个文件。例如，不使用\nif (!is_directory(path)) { if (is_character_file(path) || is_block_file(path)) { ... } ... } 你最好执行:\nauto pathStatus{status(path)}; if (!is_directory(pathStatus)) { if (is_character_file(pathStatus) || is_block_file(pathStatus)) { ... } ... } 另一个关键的好处是，通过使用symlink_status()，你可以在不遵循任何符号链接的情况下检查路径的状态。例如，这有助于检查某个特定路径上是否存在任何文件。 因为这些文件状态不使用操作系统，所以不提供返回错误代码的重载。提供。\n路径参数的exists()和is_\u0026hellip;()函数是调用和检查文件状态的type()的捷径。比如说:\nis_regular_file(mypath) 快捷方式:\nis_regular_file(status(mypath)) 捷径，它是\nstatus(mypath).type() == file_type::regular 20.4.3 权限 处理文件权限的模式是从UNIX/POSIX世界中采用的。有一些位来表示对文件所有者、同一组的成员或所有其他人的阅读、写入和/或执行/搜索访问。此外，还有 \u0026ldquo;执行时设置用户ID\u0026rdquo;、\u0026ldquo;执行时设置组ID \u0026ldquo;和粘性位（或其他与系统有关的含义）的特殊位。 表Permission Bits列出了在命名空间std::filesystem中定义的bitmask范围枚举类型perms的值，它代表一个或多个权限位。\n枚举 八进制 POSIX 意义 none 0 未设置权限 owner_read 0400 S_IRUSR 对所有者的阅读权限 owner_write 0200 S_IWUSR 对所有者的写入权限 owner_exec 0100 S_IXUSR 所有者的执行/搜索权限 owner_all 0700 S_IRWXU 所有者的所有权限 group_read 040 S_IRGRP 组的读取权限 group_write 020 S_IWGRP 组的写入权限 group_exec 010 S_IXGRP 组的执行/搜索权限 group_all 070 S_IRWXG 群组的所有权限 others_read 04 S_IROTH 所有其他人的读取权限 others_write 02 S_IWOTH 所有其他人的写入权限 others_exec 01 S_IXOTH 所有其他人的执行/搜索权限 others_all 07 S_IRWXO 所有其他人的所有权限 all 0777 所有人的所有权限 set_uid 04000 S_ISUID 在执行时设置用户 ID set_gid 02000 S_ISGID 在执行时设置组 ID sticky_bit 01000 S_ISVTX 依赖于操作系统 mask 07000 所有可能位掩码 unkonwn 0xFFFF 权限未知 你可以询问当前的权限，结果是检查返回的perms对象的位。 为了组合标志，你必须使用位操作符。比如说：\n// 如果可写: if ((fileStatus.permissions() \u0026amp; (fs::perms::owner_write | fs::perms::group_write | fs::perms::others_write)) != fs::perms::none) { ... } 初始化比特掩码的一个更短的方法（但可能不太容易读懂）是直接使用相应的八进制值和放松枚举的初始化:\n// 如果可写: if ((fileStatus.permissions() \u0026amp; fs::perms{0222}) != fs::perms::none) { ... } 注意，在将结果与特定的值进行比较之前，你必须将\u0026amp;表达式放在括号里。还要注意的是，你不能跳过比较，因为对于比特掩码范围的枚举类型，没有隐含的转换为bool。 再比如，要把一个文件的权限转换为UNIX ls -l命令中的字符串，你可以使用下面的辅助函数:\nfilesystem/permAsString.hpp\n#include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;filesystem\u0026gt; std::string asString(const std::filesystem::perms\u0026amp; pm) { using perms = std::filesystem::perms; std::string s; s.resize(9); s[0] = (pm \u0026amp; perms::owner_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[1] = (pm \u0026amp; perms::owner_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[2] = (pm \u0026amp; perms::owner_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; s[3] = (pm \u0026amp; perms::group_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[4] = (pm \u0026amp; perms::group_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[5] = (pm \u0026amp; perms::group_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; s[6] = (pm \u0026amp; perms::others_read) != perms::none ? \u0026#39;r\u0026#39; : \u0026#39;-\u0026#39;; s[7] = (pm \u0026amp; perms::others_write) != perms::none ? \u0026#39;w\u0026#39; : \u0026#39;-\u0026#39;; s[8] = (pm \u0026amp; perms::others_exec) != perms::none ? \u0026#39;x\u0026#39; : \u0026#39;-\u0026#39;; return s; } 这允许你打印一个文件的权限，作为标准ostream命令的一部分:\nstd::cout \u0026lt;\u0026lt; \u0026#34;permissions: \u0026#34; \u0026lt;\u0026lt; asString(status(mypath).permissions()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 对于一个拥有所有者所有权限和所有其他人的读/执行权限的文件，可能的输出结果是:\npermissions: rwxr-xr-x 然而，请注意，Windows的ACL（访问控制列表）方法并不真正适合这个方案。由于这个原因，在使用Visual C++时，可写文件总是设置了所有的读、写和执行位（即使它们不是可执行文件），带有只读标志的文件总是设置了所有的读和可执行位。这也影响了可移植地修改权限的API。\n20.4.4 文件系统的修改 你也可以通过创建和删除文件或修改现有文件来修改文件系统。\n创建和删除文件 创建和删除文件表列出了路径 p 创建和删除文件的操作。\n调用 作用 create_directory(p) 创建一个目录 create_directory(p, attrPath) 创建一个具有attrPath属性的目录。 create_directories(p) 创建一个目录和上面的所有目录，还不存在的目录 create_hard_link(old, new) 创建另一个文件系统的条目，以取代现有的文件old create_symlink(to, new) 创建一个符号链接，从新文件到新文件。 create_directory_symlink(to, new) 创建一个符号链接，从新的目录连接到 copy(from, to) 复制一个任何类型的文件 copy(from, to, options) 复制一个带有选项的任何类型的文件 copy_file(from, to) 复制一个文件（但不是目录或符号链接） copy_file(from, to, options) 拷贝一个带有选项的文件 copy_symlink(from, to) 复制一个符号链接（to指的是from指的地方）。 remove(p) remove(p) 删除一个文件或空目录 remove_all(p) 删除p和其子树中的所有文件（如果有的话）任何）。 没有创建普通文件的功能。这是由I/O流标准库涵盖的。 例如，下面的语句创建一个新的空文件（如果它还不存在）:\nstd::ofstream{\u0026#34;log.txt\u0026#34;}; 创建一个或多个目录的函数会返回是否创建了一个新目录。 因此，查找已经存在的目录不会出错。 但是，在那里找到不是目录的文件也不是错误。 因此，在 create_directory() 或 create_directories() 返回 false 之后，您不知道是否已经存在请求的目录或其他内容。 当然，如果您之后对该文件执行特定于目录的操作并获得异常，您会发现它可能没问题（因为处理这个罕见的问题可能不值得付出努力）。 但是，如果您想要更正错误消息或出于其他原因必须确保确实有一个目录，您必须执行以下操作：\nif (!create_directory(myPath) \u0026amp;\u0026amp; !is_directory(myPath)) { std::cerr \u0026lt;\u0026lt; \u0026#34;OOPS, \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; myPath.string() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is already something else\\n\u0026#34;; ... // 处理这个错误 } copy\u0026hellip;() 函数不适用于特殊文件类型。 默认情况下，它们：\n如果现有文件被覆盖，则报告错误\n不要递归操作\n按照符号链接 这个默认值可以被参数 options 覆盖，它具有位掩码范围的枚举类型 copy_options，定义在命名空间 std::filesystem 中。 表复制选项。 列出可能的值。\n复制选项 作用 none 默认值（值 0） skip_existing 跳过覆盖现有文件 overwrite_existing 覆盖现有文件 update_existing 如果新文件较新，则覆盖现有文件 recursive 递归复制子目录及其内容 copy_symlinks 将符号链接复制为符号链接 skip_symlinks 忽略符号链接 directories_only 仅复制目录 create_hard_links 创建额外的硬链接而不是文件副本 create_symlinks 创建符号链接而不是文件副本（源路径必须是绝对路径，除非目标路径在当前目录中） rename() 可以处理任何类型的文件，包括目录和符号链接。 对于符号链接，链接被重命名，而不是它所指的位置。 请注意， rename() 需要包含文件名的完整新路径才能将其移动到不同的目录：\n// move \u0026#34;tmp/sub/x\u0026#34; to \u0026#34;tmp/x\u0026#34;: std::filesystem::rename(\u0026#34;tmp/sub/x\u0026#34;, \u0026#34;top\u0026#34;); // ERROR std::filesystem::rename(\u0026#34;tmp/sub/x\u0026#34;, \u0026#34;top/x\u0026#34;); // OK last_write_time() 使用处理上次修改中描述的时间点格式。 例如：\n// 创建文件p（更新最后的文件访问）。: last_write_time(p, std::filesystem::file_time_type:🕰:now()); permissions() 使用权限中描述的权限 API 格式。 可选模式是位掩码枚举类型 perm_options，在命名空间 std::filesystem 中定义。 它一方面允许在替换、添加和删除之间进行选择，另一方面允许使用 nofollow 来修改符号链接而不是它们所引用的文件的权限。 例如：\n// 删除组的写访问权限和其他人的任何访问权限: permissions(mypath, std::filesystem::perms::group_write | std::filesystem::perms::others_all, std::filesystem::perm_options::remove); 再次注意，Windows 由于其 ACL 权限概念仅支持两种模式：\n读取、写入和执行/搜索所有 (rwxrwxrwx)\n读取、执行/搜索所有（r-xr-xr-x） 要在这两种模式之间进行可移植的切换，您必须同时启用或禁用所有三个写入标志（一个接一个地删除不起作用）：\n// 启用/禁用写访问的可移植值: auto allWrite = std::filesystem::perms::owner_write | std::filesystem::perms::group_write | std::filesystem::perms::others_write; // 可移植地删除写入权限: permissions(file, allWrite, std::filesystem::perm_options::remove); 初始化allWrite的一个更短的方法（但可能不那么好读）（使用放松的枚举初始化）如下。:\nstd::filesystem::perms allWrite{0222}; resize_file() 可用于减小或扩展常规文件的大小：例如：\n// 使文件为空: resize_file(file, 0); 20.4.5 符号链接和依赖文件系统的路径转换 表中文件系统路径转换列出了处理文件路径的操作，其中考虑到了文件系统。如果你需要处理符号链接，这一点尤其重要。对于不考虑文件系统的廉价路径转换，请参见纯路径转换。 注意，这些调用对文件是否必须存在、是否规范化以及是否遵循符号链接的处理方式不同。表中的文件系统路径转换属性给出了这些函数的要求和执行情况的概述。 下面的函数演示了大多数这些操作的用法和效果（在处理符号链接时）:\nfilesystem/symlink.hpp 调用 作用 read_symlink(symlink) 产生现有符号链接引用的文件 absolute(p) 产生现有的 p 作为绝对路径（不遵循符号链接） canonical(p) 产生现有的 p 作为绝对路径（遵循符号链接） weakly_canonical(p) 产生 p 作为绝对路径（遵循符号链接） relative(p) 产生从当前目录到 p 的相对（或空）路径 relative(p, base) 产生从 base 到 p 的相对（或空）路径 proximate(p) 产生从当前目录到 p 的相对（或绝对）路径 proximate(p, base) 产生从 base 到 p 的相对（或绝对）路径 调用 必须存在 规范化 遵循符号链接 read_symlink() yes yes once absolute() no yes no canonical() yes yes all weakly_canonical() no yes all relative() no yes all proximate() no yes all #include \u0026lt;filesystem\u0026gt; #include \u0026lt;iostream\u0026gt; void testSymLink(std::filesystem::path top) { top = absolute(top); // 在我们更改当前路径时使用绝对路径 create_directory(top); // 确保 top 存在 current_path(top); // 这样我们就可以将目录更改为它 std::cout \u0026lt;\u0026lt; std::filesystem::current_path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 打印top路径 // 定义我们的子目录（不创建它们）: std::filesystem::path px{top / \u0026#34;a/x\u0026#34;}; std::filesystem::path py{top / \u0026#34;a/y\u0026#34;}; std::filesystem::path ps{top / \u0026#34;a/s\u0026#34;}; // 打印一些相对路径（对于不存在的文件）： std::cout \u0026lt;\u0026lt; px.relative_path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 相对路径，从top std::cout \u0026lt;\u0026lt; px.lexically_relative(py) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 py 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, py) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 py 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从curr.path到px : \u0026#34;a/x\u0026#34; std::cout \u0026lt;\u0026lt; px.lexically_relative(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; // 现在创建所有子目录和符号链接: create_directories(px); create_directories(py); if (!is_symlink(ps)) { create_directory_symlink(top, ps); } std::cout \u0026lt;\u0026lt; \u0026#34;ps: \u0026#34; \u0026lt;\u0026lt; ps \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; read_symlink(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 并查看词法和文件系统相关之间的区别: std::cout \u0026lt;\u0026lt; px.lexically_relative(ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;../x\u0026#34; std::cout \u0026lt;\u0026lt; relative(px, ps) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 从 ps 到 px: \u0026#34;a/x\u0026#34; } 注意，我们首先将可能的相对路径转换为绝对路径，因为否则改变当前路径会影响路径变量的位置。 relative_path()和lexically_relative()是廉价的路径成员函数，没有考虑到实际的文件系统。因此，它们忽略了符号链接。独立的函数relative() 将文件系统考虑在内。只要我们还没有文件，它的作用就像lexically_relative()。但在创建符号链接ps（top/a/s）之后，它就会跟随符号链接，并给出不同的结果。 在POSIX系统中，从\u0026rdquo;/tmp \u0026ldquo;调用该函数，参数为 \u0026ldquo;top\u0026rdquo;，其输出结果如下:\n\u0026#34;/tmp/sub\u0026#34; \u0026#34;tmp/sub/a/x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;a/x\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;../x\u0026#34; ps: \u0026#34;/tmp/sub/a/s\u0026#34; -\u0026gt; \u0026#34;/tmp/sub\u0026#34; \u0026#34;../x\u0026#34; \u0026#34;a/x\u0026#34; 在Windows系统中，从 \u0026ldquo;C:/temp \u0026ldquo;调用该函数，参数为 \u0026ldquo;top\u0026rdquo;，输出结果为如下所示:\n\u0026#34;C:\\\\temp\\\\top\u0026#34; \u0026#34;temp\\\\top\\\\a/x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;a\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;..\\\\x\u0026#34; ps: \u0026#34;C:\\\\temp\\\\top\\\\a/s\u0026#34; -\u0026gt; \u0026#34;C:\\\\temp\\\\top\u0026#34; \u0026#34;..\\\\x\u0026#34; \u0026#34;a\\\\x\u0026#34; 请再次注意，你需要管理员权限才能在Windows上创建符号链接。\n20.4.6 其他文件系统操作 表 \u0026ldquo;其他操作 \u0026ldquo;列出了尚未提及的其他文件系统操作。\n调用 作用 equivalent(p1, p2) 得出 p1 和 p2 是否引用同一个文件 space(p) 产生有关路径 p 处可用磁盘空间的信息 current_path(p) 将当前工作目录的路径设置为 p 在关于路径比较的章节中讨论了equivalent()函数。 space()的返回值是以下结构：\nnamespace std::filesystem { struct space_info { uintmax_t capacity; uintmax_t free; uintmax_t available; }; } 因此，使用结构化绑定可以打印 root 的可用磁盘空间，如下所示：\nauto [cap, _, avail] = std::filesystem::space(\u0026#34;/\u0026#34;); std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::precision(2) \u0026lt;\u0026lt; avail/1.0e6 \u0026lt;\u0026lt; \u0026#34; of \u0026#34; \u0026lt;\u0026lt; cap/1.0e6 \u0026lt;\u0026lt; \u0026#34; MB available\\n\\n\u0026#34;; 输出可能是例如：\n43019.82 of 150365.79 MB available 为路径参数调用的 current_path() 会修改整个程序的当前工作目录（因此，它适用于所有线程）。 离开范围时，您可以通过以下方式切换到另一个工作目录并恢复旧目录：\nauto current{std::filesystem::current_path()}; try { std::filesystem::current_path(subdir); ...; } catch (...) { std::filesystem::current_path(current); throw; } std::filesystem::current_path(subdir); 20.5 遍历目录 文件系统库的一个关键应用是遍历目录或文件系统（子）树的所有文件。 最方便的方法是使用基于范围的 for 循环。 您可以遍历目录中的所有文件：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 或递归遍历文件系统（子）树中的所有文件：\nfor (const auto\u0026amp; e : std::filesystem::recursive_directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 传递的参数 dir 可以是路径或任何可隐式转换为路径的内容（尤其是所有形式的字符串）； 请注意， e.path() 产生的文件名包括迭代开始的目录。\n因此，如果我们遍历“.” 文件名 file.txt 变为 ./file.txt 或 .\\file.txt。\n此外，此路径被引用到流中，因此此文件名的输出变为“./file.txt”或“.\\file.txt”。 因此，正如之前在初始示例中所讨论的，以下循环更便于移植：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator(dir)) { std::cout \u0026lt;\u0026lt; e.path().lexically_normal().string() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 要在当前目录上进行迭代，你应该传递\u0026rdquo;. \u0026ldquo;作为当前目录而不是\u0026rdquo;\u0026quot;。传递一个空的路径在Windows上是可行的，但不能移植。\n范围的目录迭代器 你可以将一个迭代器传递给一个基于范围的for循环，这可能看起来令人惊讶，因为你通常需要一个范围。\n诀窍在于，directory_iterator和recursive_directory_iterator都是提供begin()和end()的全局重载的类。\nbegin()产生迭代器本身。 end()产生结束迭代器，你也可以用默认的构造函数来创建它。 出于这个原因，你也可以按以下方式进行迭代。\nstd::filesystem::directory_iterator di{p}; for (auto pos = begin(di); pos != end(di); ++pos) { std::cout \u0026lt;\u0026lt; pos-\u0026gt;path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 或者如下:\nfor (std::filesystem::directory_iterator pos{p}; pos != std::filesystem::directory_iterator{}; ++pos) { std::cout \u0026lt;\u0026lt; pos-\u0026gt;path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 目录迭代器选项 遍历目录时，您可以传递 directory_options 类型的值，这些值列在表 Directory Iterator Options 中。 该类型是位掩码范围的枚举类型，在命名空间 std::filesystem 中定义。\n目录选项 作用 none 默认（值 0） follow_directory_symlink 跟随符号链接（而不是跳过它们） skip_permission_denied 跳过权限被拒绝的目录 默认情况下，不跟踪符号链接，并跳过你不允许迭代的目录。使用 skip_permission_denied 遍历一个被拒绝的目录时，会产生一个异常。 createfiles.cpp显示了follow_directory_symlink的一个应用:\n20.5.1 目录条目 目录迭代器所迭代的元素是std::filesystem::directory_entry类型的。因此，如果一个目录迭代器是有效的，operator*()就会产生该类型。这意味着，基于范围的for循环的正确类型如下。\nfor (const std::filesystem::directory_entry\u0026amp; e : std::filesystem::directory_iterator(p)) { std::cout \u0026lt;\u0026lt; e.path() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 目录条目既包含路径对象，也包含额外的属性，如硬链接计数、文件状态、文件大小、最后写入时间、是否是符号链接，以及如果是的话，它指向哪里。\n注意，这些迭代器是输入迭代器。原因是在一个目录上迭代可能导致不同的结果，因为在任何时候目录条目都可能改变。在并行算法中使用目录迭代器时，必须考虑到这一点。\n表中目录条目操作列出了你可以为一个目录条目e调用的操作，它们或多或少是你可以调用的查询文件属性、获取文件状态检查权限和比较路径的操作。\n调用 作用 e.path() 产生当前条目的文件系统路径 e.exists() 产生文件是否存在 e.is_regular_file() 产生文件是否存在并且是一个普通文件 e.is_directory() 产生文件是否存在并且是一个目录 e.is_symlink() 得出文件是否存在并且是一个符号链接 e.is_other() 产生文件是否存在，并且既不是常规文件也不是目录也不是象征性链接 e.is_block_file() 产生文件是否存在并且是一个块状特殊文件 e.is_character_file() 产生文件是否存在并且是一个特殊字符的文件。 e.is_fifo() 产生文件是否存在，并且是FIFO或管道文件 e.is_socket() 产生文件是否存在并且是一个套接字。 e.file_size() 产生文件的大小。 e.hard_link_count() 产生硬链接的数量 e.last_write_time() 产生最后一次写到文件的时间点 e.status() 产生文件的状态p e.symlink_status() 产生文件的状态（在符号链接之后） p e1 == e2 产生两个入口的路径是否相等 e1 != e2 产生两个入口路径是否不相等 e1 \u0026lt; e2 产生是否一个条目路径小于另一个条目路径的结果 e1 \u0026lt;= e2 产生一个条目路径是否比另一个条目路径小或相等 e1 \u0026gt;= e2 产生一个条目路径是否大于或等于另一个条目路径 e1 \u0026gt; e2 产生一个条目路径是否大于另一个条目路径。 e.assign(p) 用p替换e的路径并更新所有条目属性 e.replace_filename(p) 用p替换e的当前路径的文件名并更新所有条目属性 e.refresh() 更新此条目的所有缓存属性 assign()和replace_filename()调用相应的修改路径操作，但不修改底层文件系统中的文件。\n目录条目缓存 我们鼓励实现者缓存这些额外的文件属性，以避免在使用条目时对文件系统的额外访问。然而，实现并不要求缓存数据，这意味着这些通常很便宜的操作可能会变得更昂贵。 因为所有的值通常都被缓存了，这些调用通常是廉价的，因此是成员函数。\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { auto t = e.last_write_time(); // 通常便宜 ... } 无论是否有缓存，在一个多用户或多进程的操作系统中，所有这些迭代可能产生不再有效的文件数据。文件内容和大小可能会改变，文件可能被删除或替换（因此，甚至文件类型也可能改变），权限可能被修改。 在这种情况下，你可以要求刷新一个目录项所持有的数据:\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { ...; // 数据数据变旧 e.refresh(); // 刷新文件的缓存数据 if (e.exists()) { auto t = e.last_write_time(); ...; } } 另外，你可能总是问当前的情况：\nfor (const auto\u0026amp; e : std::filesystem::directory_iterator{\u0026#34;.\u0026#34;}) { ...; // 数据数据变旧 if (exists(e.path())) { auto t = last_write_time(e.path()); ... } } 20.6 后记 文件系统库在Beman Dawes的领导下作为一个Boost库开发了多年。在2014年，它第一次成为一个正式的测试标准，即文件系统技术规范（见https://wg21.link/n4100）。 随着https://wg21.link/p0218r0，文件系统技术规范被采纳为 由Beman Dawes提出的标准库。对计算相对路径的支持被添加到 由Beman Dawes, Nicolai Josuttis和Jamie Allsop在https://wg21.link/p0219r1。由Beman Dawes在https://wg21.link/p0317r1 中提议增加了几个小的修正。Nicolai Josuttis在https://wg21.link/p0392r0，Jason Liu和Hubert Tong在https: //wg21.link/p0430r2，特别是文件系统小组的成员（Beman Dawes, S. Davis Herring, Nicolai Josuttis, Jason Liu, Billy O\u0026rsquo;Neal, P.J. Plauger, and Jonathan Wakely）在https://wg21.link/p0492r2。\n","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/c++/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/","title":"第三部分-新的标准库组件"},{"content":"第五部分 专业工具 这部分介绍了普通应用程序程序员通常不必知道的新语言和库特性。 它可能涵盖基础库、特定模式或特殊环境中的程序员的工具。\n27 多态的内存资源 (PMR) 自C++98以来，标准库就支持配置类分配其内部（堆）内存的方式的能力。由于这个原因，标准库中几乎所有分配内存的类型都有一个分配器参数。因此，你可以配置容器、字符串和其他类型分配其内部内存的方式，如果它们需要比堆栈上分配的空间更多的话。 分配这种内存的默认方式是从堆中分配。但是有不同的理由来修改这个默认行为：\n你可以使用你自己的方式分配内存，以减少系统调用的数量。 你可以确保分配的内存位于彼此的旁边，以从CPU缓存中获益。 你可以把容器和它们的元素放在可供多进程使用的共享内存中。 你甚至可以重定向这些堆内存调用，以使用早期在堆栈上分配的内存。因此，可以有性能和功能方面的原因。 然而，在C++17之前，使用分配器（右）在很多方面都是既棘手又笨拙的（由于一些缺陷，太过复杂，以及与后向兼容的修改）。 现在，C++17为预定义和用户定义的内存分配方式提供了一个相当容易使用的方法，它可以用于标准类型和用户定义的类型。 基于这个原因，本章将讨论：\n使用标准库提供的标准内存资源 定义自定义内存资源 为自定义类型提供内存资源支持 如果没有Pablo Halpern、Arthur O\u0026rsquo;Dwyer、David Sankel和Jonathan Wakely的大力帮助，本章就不可能完成。一些视频解释了这里提供的功能：\n分配器：Pablo Halpern 的好零件 C++17 的 std::pmr 有代价 David Sankel 分配器是 Arthur O\u0026rsquo;Dwyer 的堆句柄 27.1 使用标准内存资源 本节介绍了标准内存资源以及如何使用它们。\n27.1.1 激励性的例子 让我们首先比较一下没有和有标准内存资源的内存消耗。\n为容器和字符串分配内存 假设在你的程序中，你有一个由一些字符串组成的向量，你用相当长的方式初始化这些字符串字符串：\npmr/pmr0.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 注意，我们使用一个类来跟踪内存分配的数量，该类跟踪所有用以下循环执行的::new调用：\nstd::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } 有很多的分配，因为 vector 内部使用内存来存储元素。此外，字符串元素本身可能会在堆上分配内存以保存其当前值（由于经常实现小字符串优化，这通常只在字符串超过15个字符时发生）。 该程序的输出可能类似于以下内容。\n1018 allocations for 134,730 bytes 这将意味着为每个元素分配一次，加上 vector 内部的18次分配，因为它18次分配（更多）内存来容纳其元素。 这样的行为可能变得很关键，因为内存（重新）分配需要时间，在某些情况下（如嵌入式系统），分配堆内存可能是个问题。 我们可以要求 vector 在前面预留足够的内存，但一般来说，你无法避免重新分配，除非你知道前面要处理的数据量。如果你不知道到底要处理多少数据，你总是要在避免重新分配和不浪费太多内存之间找到一个折中点。而你至少需要1001个分配（一个分配用于保存向量中的元素，一个用于不使用小字符串优化的每个字符串）。\n不为容器分配内存 通过使用多态分配器，我们可以轻松地改善这种情况。首先，我们可以使用std::pmr::vector，让向量在堆栈中分配其内存。 pmr/pmr1.cpp。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); // 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; // 并将其用作vector的初始内存池： std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 首先，我们使用新类型 std::byte 在堆栈上分配我们自己的内存：\n// 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; 除了 std::byte 你也可以只使用 char。 然后，我们用这个内存初始化一个 monotonic_buffer_resource，传递它的地址和它的大小：\nstd::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; 最后，我们使用一个std::pmr::vector，它占用了所有分配的内存资源:\nstd::pmr::vector\u0026lt;std::string\u0026gt; coll{\u0026amp;pool}; 这个声明只是以下的一个快捷方式:\nstd::vector\u0026lt;std::string, std::pmr::polymorphic_allocator\u0026lt;std::string\u0026gt;\u0026gt; coll{\u0026amp;pool}; 也就是说，我们声明向量使用多态分配器，它可以在运行时在不同的内存资源之间切换。monotonic_buffer_resource类派生于memory_resource类，因此可以作为多态分配器的内存资源。因此，通过传递我们的内存资源的地址，我们确保向量使用我们的内存资源作为多态分配器。 如果我们测量这个程序的分配的内存，输出结果可能是。 32000字节的1000次分配 矢量的18次分配不再是在堆上进行的。相反，我们初始化的缓冲区buf被使用。 如果预先分配的200000字节的内存不够用，向量仍然会在堆上分配更多的内存。发生这种情况，是因为monotonic_memory_resource使用了默认的分配器，它用new来分配内存，作为退路。\n完全不分配内存 我们甚至可以通过定义std::pmr::vector的元素类型来避免使用堆内存 的元素类型为std::pmr::string:\npmr/pmr2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { TrackNew::reset(); // 在堆栈中分配一些内存： std::array\u0026lt;std::byte, 200\u0026#39;000\u0026gt; buf; // 并将其作为vector及其字符串的初始内存池。: std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 1000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } 由于以下的矢量定义：\nstd::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; 程序的输出成为:\n0 allocations for 0 bytes 原因是，默认情况下，pmr向量试图将其分配器传播给其元素。当元素不使用多态分配器时，这是不成功的，如std::string类型的情况。然而，通过使用std::pmr::string类型，它是一个使用多态分配器的字符串，传播工作正常。 同样，只有当缓冲区中没有更多的内存时，新的内存才会由堆上的池分配。例如，这种情况可能发生在以下修改中:\nfor (int i=0; i \u0026lt; 50000; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } 当输出可能突然变得:\n8 allocations for 14777448 bytes 重复使用内存池 我们甚至可以重复使用我们的堆栈内存池。比如说:\npmr/pmr3.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; #include \u0026#34;../lang/tracknew.hpp\u0026#34; int main() { // 在堆栈上分配一些内存: std::array\u0026lt;std::byte, 200000\u0026gt; buf; for (int num : {1000, 2000, 500, 2000, 3000, 50000, 1000}) { std::cout \u0026lt;\u0026lt; \u0026#34;-- check with \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; elements:\\n\u0026#34;; TrackNew::reset(); std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; num; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } TrackNew::status(); } } 这里，在分配了堆栈上的200,000字节后，我们再次使用这块内存，为vector及其元素初始化一个新的资源池:\n输出可能变为：\n-- check with 1000 elements: 0 allocations for 0 bytes -- check with 2000 elements: 1 allocations for 300000 bytes -- check with 500 elements: 0 allocations for 0 bytes -- check with 2000 elements: 1 allocations for 300000 bytes -- check with 3000 elements: 2 allocations for 750000 bytes -- check with 50000 elements: 8 allocations for 14777448 bytes -- check with 1000 elements: 0 allocations for 0 bytes 每次200000字节足够的时候，我们不需要额外的分配（在这里，它是最多1000个元素的情况）。这200000字节被使用，当内存池被销毁时，可用于下一次迭代。 每次内存被超过时，内存池会在堆上分配额外的内存，当内存池被销毁时，这些内存会被删除。 这样你就可以很容易地对内存池进行编程，你只需分配一次内存（无论是在堆栈还是在堆上），并在每个新任务（服务请求、事件、要处理的数据文件等）中重复使用它。等等）。 我们将在后面讨论更复杂的内存池的例子。\n27.1.2 标准内存资源 为了支持多态分配器，C++标准库提供了表标准内存资源中列出的内存。\n内存资源 行为 new_delete_resource() 产生一个指向内存资源的指针，调用new和删除 synchronized_pool_resource 类来创建内存资源，碎片少，线程安全。 unsynchronized_pool_resource 创建零散的内存资源的类，不是线程安全的 monotonic_buffer_resource 创建内存资源的类，该类永远不会取消分配，可以选择使用一个传递的缓冲区，不是线程安全的 null_memory_resource() 产生一个指向内存资源的指针，每次分配都会失败 new_delete_resource()和null_memory_resource()是返回全局内存资源指针的函数，它被定义为一个单子。其他三个内存资源是类，你必须创建对象并将这些对象的指针传递给多态分配器。一些使用例子:\nstd::pmr::string s1{\u0026#34;my string\u0026#34;, std::pmr::new_delete_resource()}; std::pmr::synchronized_pool_resource pool1; std::pmr::string s2{\u0026#34;my string\u0026#34;, \u0026amp;pool1}; std::pmr::monotonic_buffer_resource pool2{...}; std::pmr::string s3{\u0026#34;my string\u0026#34;, \u0026amp;pool2}; 一般来说，内存资源是作为指针传递的。由于这个原因，重要的是你要确保这些指针所指的资源对象在最后一次调用去分配之前一直存在（如果你移动对象并且内存资源可以互换，这可能比你预期的要晚）。\n默认的内存资源 多态分配器有一个默认的内存资源，如果没有传递其他的内存资源，就会使用它。表中默认内存资源的操作列出了为其定义的操作。\n内存资源 行为 get_default_resource() 产生一个指向当前默认内存资源的指针 set_default_resource(memresPtr) 设置默认的内存资源（传递一个指针），并且产生一个指向前一个的指针 你可以用std::pmr::get_default_resource()来获取当前的默认资源，你可以通过它来初始化一个多态分配器。你可以用std::pmr::set_default_resource()全局性地设置一个不同的默认内存资源。这个资源在任何范围内都作为默认资源使用，直到下一次调用std::pmr::set_default_resource()。比如说\nstatic std::pmr::synchronized_pool_resource myPool; // 设置myPool为新的默认内存资源。 std::pmr::memory_resource* old = std::pmr::set_default_resource（\u0026amp;myPool）。 ...; // 恢复旧的默认内存资源为默认值。 std::pmr::set_default_resource(old)。 如果你在程序中创建了一个自定义的内存资源，并将其作为默认资源使用，那么在main()中作为静态对象先创建它，这是一个好办法。\nint main() { static std::pmr::synchronized_pool_resource myPool; ... } 或者，提供一个全局函数，将你的资源作为静态对象返回。\nmemory_resource* myResource() { static std::pmr::synchronized_pool_resource myPool; return \u0026amp;myPool; } 返回类型 memory_resource 是所有内存资源的基类。 请注意，以前的默认资源在被替换时可能仍然被使用。除非你知道（并确保）情况并非如此，例如，这意味着没有使用该资源创建静态对象，否则你应该让你的资源尽可能长地存活（同样，最好是在main()的开头创建，以便它最后被销毁）。\n27.1.3 标准内存资源的详细介绍 让我们详细讨论一下不同的标准内存资源。\nnew_delete_resource() new_delete_resource()是默认的内存资源。它是由get_default_resource()返回的。 返回，除非你通过调用set_default_resource()定义了一个不同的默认内存资源。 它处理分配，就像使用默认分配器时的处理方式。\n每次分配都调用new 每一次去分配都调用delete 然而，请注意，具有这种内存资源的多态分配器不能与默认分配器互换，因为它们只是具有不同的类型。由于这个原因\nstd::string s{\u0026#34;my string with some value\u0026#34;}。 std::pmr::string ps{std::move(s), std::pmr::new_delete_resource()}; // copies 将不会移动（将分配给s的内存传递给ps）。相反，s的内存将被复制到ps的新内存中，用new分配。\n(un)synchronized_pool_resource synchronized_pool_resource和unsynchronized_pool_resource是内存资源的类，它们试图将所有内存定位在彼此附近。因此，它们迫使内存的碎片化很少。 不同的是，synchronized_pool_resource是线程安全的（这需要花费更多的性能），而unsynchronized_pool_resource则不是。因此，如果你知道这个池子的内存只由一个线程处理（或者（去）分配是同步的），你应该选择unsynchronized_pool_resource。 这两个类仍然使用底层内存资源来实际执行分配和去分配。它们只是作为一个封装器，确保这些分配能更好地被集群起来。因此:\nstd::pmr::synchronized_pool_resource myPool。 与\nstd::pmr::synchronized_pool_resource myPool{std::pmr::get_default_resource()}。 此外，当池子被销毁时，它们会删除所有的内存。 这些池子的一个主要应用是确保基于节点的容器中的元素位于彼此的旁边。这也可能大大增加了容器的性能，因为这样CPU缓存就会把元素装在一起的缓存行中。其效果是，当你访问一个元素后，访问其他元素就变得非常快，因为它们已经在缓存中了。 然而，你应该衡量一下，因为这取决于内存资源的实现。例如，如果内存资源使用mutex来同步内存访问，性能可能会明显变差。 让我们用一个简单的例子来看看这个效果。下面的程序创建了一个地图，它将积分值映射到字符串。\npmr/pmrsync0.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; int main() { std::map\u0026lt;long, std::string\u0026gt; coll; for (int i=0; i\u0026lt;10; ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } // print element distances: for (const auto\u0026amp; elem : coll) { static long long lastVal = 0; long long val = reinterpret_cast\u0026lt;long long\u0026gt;(\u0026amp;elem); std::cout \u0026lt;\u0026lt; \u0026#34;diff: \u0026#34; \u0026lt;\u0026lt; (val-lastVal) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lastVal = val; } } 这个数据结构是一个平衡的二叉树，每个节点都执行自己的分配来存储一个元素。因此，对每个元素进行分配，这些分配默认当前在堆上分配内存（使用标准默认分配器）。 为了看清效果，程序打印了元素地址之间的距离，同时迭代了 它们之间的距离。例如，一个输出可能看起来如下:\ndiff: 1777277585312 diff: -320 diff: 60816 diff: 1120 diff: -400 diff: 80 diff: -2080 diff: -1120 diff: 2720 diff: -3040 这些元素不是彼此相邻的。我们有60,000字节的距离，10个元素的大小约为24字节。如果在元素的分配之间分配了其他的内存，这种碎片化就会变得更严重。 现在让我们用多态分配器运行这个程序，使用synchronized_pool_resource:\npmr/pmrsync1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory_resource\u0026gt; int main() { std::pmr::synchronized_pool_resource pool; std::pmr::map\u0026lt;long, std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i\u0026lt;10; ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } // 打印元素距离: for (const auto\u0026amp; elem : coll) { static long long lastVal = 0; long long val = reinterpret_cast\u0026lt;long long\u0026gt;(\u0026amp;elem); std::cout \u0026lt;\u0026lt; \u0026#34;diff: \u0026#34; \u0026lt;\u0026lt; (val-lastVal) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lastVal = val; } } 正如你所看到的，我们简单地创建了资源并将其作为参数传递给容器的构造函数:\nstd::pmr::synchronized_pool_resource pool; std::pmr::map\u0026lt;long, std::pmr::string\u0026gt; coll{\u0026amp;pool}; 例如，现在的输出看起来如下:\ndiff: 2548552461600 diff: 128 diff: 128 diff: 105216 diff: 128 diff: 128 diff: 128 diff: 128 diff: 128 diff: 128 正如你所看到的，这些元素现在都位于彼此附近。但是，它们仍然没有位于一个内存块中。当内存池发现第一块内存不足以容纳所有的元素时，它为更多的元素分配更多的内存。因此，我们分配的内存越多，内存块就越大，这样就有更多的元素被放在彼此附近。这个算法的细节是由实现定义的。\n当然，这个输出是特殊的，因为我们按照元素在容器内的排序来创建它们。因此，在实践中，如果你用随机值创建对象，这些元素将不会一个接一个地顺序定位（在不同的内存块中）。然而，它们仍然位于彼此之间，这对于处理这个容器中的元素时的良好性能是很重要的。\n还请注意，我们不看元素值的内存是如何安排的。在这里，通常小字符串的优化导致对元素没有分配内存。但是一旦我们放大了字符串值，池子也会尝试将这些字符串放在一起。请注意，池为不同的分配大小管理不同的内存块。也就是说，在一般情况下，元素之间是相互定位的，相同字符串大小的元素的字符串值是相互靠近的。\nmonotonic_buffer_resource monotonic_buffer_resource类也提供了将所有内存放在大块内存中的能力。然而，它还有另外两种能力。\n你可以传递一个缓冲区来作为内存使用。这一点，特别是可以在堆栈上分配内存。 内存资源永远不会被取消分配，直到整个资源被取消分配。也就是说，它也试图避免碎片化。而且，它的速度超快，因为去分配是一个无操作的过程，你跳过了追踪去分配的内存以便进一步使用。每当有分配内存的请求时，它只是返回下一块空闲的内存，直到所有的内存都用完。 请注意，对象仍然是被销毁的。只有它们的内存没有被释放。如果你删除了对象，这通常会删除它们的内存，但删除并没有影响。 如果你没有删除对象，或者你有足够的内存可以浪费（不重复使用之前被其他对象使用的内存），你应该更喜欢这种资源。 我们已经在第一个激励性的例子中看到了monotonic_buffer_resource的应用，我们把在堆栈中分配的内存传递给了池。\nstd::array\u0026lt;std::byte, 200000\u0026gt; buf。 std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()}。 你也可以使用这个池子让任何内存资源跳过去分配（可以选择传递一个初始大小）。默认情况下，这将适用于默认的内存资源，默认是new_delete_resource()。就是说，用\n//使用默认的内存资源，但只要池子还在，就跳过去分配。 { std::pmr::monotonic_buffer_resource pool。 std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;)。 } coll.clear(); // 销毁但不去分配 } // 取消分配所有分配的内存 带有循环的内部块将不时为向量及其元素分配内存。由于我们使用的是一个池子，分配的内存被组合成块状。例如，这可能导致14次分配。通过首先调用coll.reserve(100)，这通常会变成只有两个分配。 正如所写的那样，只要池子存在，就不做任何取消分配。因此，如果向量的创建和使用是在一个循环中完成的，池子分配的内存会不断增加。 monotonic_buffer_resource也允许我们传递一个初始大小，然后它使用其第一次分配的最小大小（当第一次内存请求发生时进行）。此外，你可以定义它使用哪个内存资源来执行分配。这使得我们可以通过连锁内存资源来提供更复杂的内存资源。 考虑一下下面的例子:\n{ // 分配大块内存（从10k开始），而不去分配: std::pmr::monotonic_buffer_resource keepAllocatedPool{10000}; std::pmr::synchronized_pool_resource pool{\u0026amp;keepAllocatedPool}; for (int j=0; j \u0026lt; 100; ++j) { std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } } // 去分配的数据被送回池中，但没有解除分配。 // 到目前为止，没有任何东西被释放 } // 释放所有分配的内存 通过这段代码，我们首先为我们所有的内存创建一个池，只要它活着就永远不会去分配，初始化时开始分配10000字节（使用默认的内存资源分配）。\nstd::pmr::monotonic_buffer_resource keepAllocatedPool{10000}。 然后我们创建另一个池，使用这个非去分配的池来分配内存块。\nstd::pmr::synchronized_pool_resource pool{\u0026amp;keepAllocatedPool}。 综合的效果是，我们的所有内存都有一个池子，它从10000字节开始分配，如果有必要，可以分配更多的内存，而且几乎没有碎片，可以被所有使用这个池子的pmr对象使用。 当keepAllocatedPool超出范围时，所分配的内存（可能是最初的10000字节加上一些更大的内存块的额外分配）都将被释放。\n这里到底发生了什么，将在后面我们扩展这个例子以追踪这个嵌套池的所有分配时进行演示。\nnull_memory_resource() null_memory_resource()处理分配的方式是每次分配都会抛出一个bad_alloc异常。 最重要的应用是确保使用堆栈上分配的内存的内存池不会突然在堆上分配内存，如果它需要更多的话。 考虑一下下面的例子:\npmr/pmrnull.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; // for std::byte #include \u0026lt;memory_resource\u0026gt; int main() { // 使用堆栈上的内存而不在堆上进行回退: std::array\u0026lt;std::byte, 200000\u0026gt; buf; std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size(), std::pmr::null_memory_resource()}; // 并分配太多内存: std::pmr::unordered_map\u0026lt;long, std::pmr::string\u0026gt; coll {\u0026amp;pool}; try { for (int i=0; i\u0026lt;buf.size(); ++i) { std::string s{\u0026#34;Customer\u0026#34; + std::to_string(i)}; coll.emplace(i, s); } } catch (const std::bad_alloc\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;BAD ALLOC EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; coll.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 我们在堆栈中分配内存，并将其传递给单调的缓冲区作为内存资源:\nstd::array\u0026lt;std::byte, 200000\u0026gt; buf; std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size(), std::pmr::null_memory_resource()}; 通过传递null_memory_resource()作为后备内存资源，我们确保任何分配更多内存的尝试都会抛出一个异常，而不是在堆上分配内存。 其结果是，程序迟早会结束，例如，输出结果如下:\nBAD ALLOC EXCEPTION: bad allocation size: 2048 当堆内存分配不是一种选择时，这有助于获得合理的反馈，而不是碰上你必须避免的行为。\n27.2 定义自定义内存资源 你可以提供你自定义的内存资源。为此，你只需要\n派生自std::pmr::memory_resource 实现私有成员 do_allocate() 来分配内存 do_deallocate()来删除内存 do_is_equal()定义你的类型是否以及何时可以与另一个内存资源对象交换分配的内存 下面是一个完整的例子，它仅仅允许我们跟踪任何 其他的内存资源:\npmr/tracker.hpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory_resource\u0026gt; class Tracker : public std::pmr::memory_resource { private: std::pmr::memory_resource* upstream; // 包装的内存资源 std::string prefix{}; public: // 我们包装传递的或默认的资源: explicit Tracker(std::pmr::memory_resource* us = std::pmr::get_default_resource()) : upstream{us} { } explicit Tracker(std::string p, std::pmr::memory_resource* us = std::pmr::get_default_resource()) : prefix{std::move(p)}, upstream{us} { } private: void* do_allocate(size_t bytes, size_t alignment) override { std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#34;allocate \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; Bytes\\n\u0026#34;; void* ret = upstream-\u0026gt;allocate(bytes, alignment); return ret; } void do_deallocate(void* ptr, size_t bytes, size_t alignment) override { std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; \u0026#34;deallocate \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; Bytes\\n\u0026#34;; upstream-\u0026gt;deallocate(ptr, bytes, alignment); } bool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // 相同的类型和前缀以及相等的上游？ auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix \u0026amp;\u0026amp; upstream-\u0026gt;is_equal(other); } }; 像通常的智能内存资源一样，我们支持传递另一个内存资源（通常称为上游）来包裹它或将其作为后备资源。此外，我们还可以传递一个可选的前缀。在每次分配和去分配时，我们都会用可选的前缀来追踪这个调用。 我们唯一需要实现的其他函数是do_is_equal()，它定义了两个分配器何时可以互换（也就是说，一个多态内存资源对象是否以及何时可以去分配另一个分配的内存）。在这种情况下，我们简单地说，只要前缀相同，任何这种类型的对象都可以取消从任何其他这种类型的对象分配的内存:\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // 相同的类型和前缀以及相等的上游？: auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix \u0026amp;\u0026amp; upstream-\u0026gt;is_equal(other); } 第一个比较的存在只是为了跳过其他更昂贵的与下限的比较。如果我们不使用相同的跟踪器，我们要求另一个内存资源也是具有相同前缀的跟踪器（相同意义上的相同）和可交换的底层内存资源。否则，如果我们使用不同底层内存资源的跟踪器，应用程序会认为从完全不同的内存资源中分配的内存是可以取消的。 让我们使用这个跟踪器来理解之前演示的嵌套池的行为，以分配大块的内存而不去分配:\npmr/tracker.cpp\n#include \u0026#34;tracker.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory_resource\u0026gt; int main() { { // 追踪分配内存块（从10k开始）而不去分配。: Tracker track1{\u0026#34;keeppool:\u0026#34;}; std::pmr::monotonic_buffer_resource keeppool{10000, \u0026amp;track1}; { Tracker track2{\u0026#34; syncpool:\u0026#34;, \u0026amp;keeppool}; std::pmr::synchronized_pool_resource pool{\u0026amp;track2}; for (int j=0; j \u0026lt; 100; ++j) { std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;pool}; coll.reserve(100); for (int i=0; i \u0026lt; 100; ++i) { coll.emplace_back(\u0026#34;just a non-SSO string\u0026#34;); } if (j==2) std::cout \u0026lt;\u0026lt; \u0026#34;--- third iteration done\\n\u0026#34;; } // 去分配的数据被送回池子里，但没有去分配。 // 到目前为止，没有分配到任何东西 std::cout \u0026lt;\u0026lt; \u0026#34;--- leave scope of pool\\n\u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;--- leave scope of keeppool\\n\u0026#34;; } // 删除所有已分配的内存 } 输出可能如下所示：\nsyncpool:allocate 48 Bytes keeppool:allocate 10000 Bytes syncpool:allocate 16440 Bytes keeppool:allocate 16464 Bytes syncpool:allocate 96 Bytes keeppool:allocate 24696 Bytes syncpool:deallocate 48 Bytes syncpool:allocate 312 Bytes syncpool:allocate 568 Bytes syncpool:allocate 1080 Bytes syncpool:allocate 2104 Bytes syncpool:allocate 4152 Bytes syncpool:deallocate 312 Bytes syncpool:deallocate 568 Bytes syncpool:deallocate 1080 Bytes syncpool:deallocate 2104 Bytes syncpool:allocate 8248 Bytes syncpool:deallocate 4152 Bytes --- third iteration done --- leave scope of pool syncpool:deallocate 8248 Bytes syncpool:deallocate 16440 Bytes syncpool:deallocate 96 Bytes --- leave scope of keeppool keeppool:deallocate 24696 Bytes keeppool:deallocate 16464 Bytes keeppool:deallocate 10000 Bytes 输出显示了以下情况。\n随着一个对象的第一次分配，syncpool分配了48个字节，这导致keeppool分配其初始的10,000字节。这10,000字节是在堆上分配的，使用的是keeppool初始化时get_default_resource()的资源。 后来的对象会分配和删除内存，这使得syncpool不时地分配更多的内存块，但也会删除内存块。如果syncpool有效地分配了比keeppool所分配的更多的内存，keeppool再次从堆中分配更多的内存。也就是说，只有keeppool的分配成为（相当昂贵的）系统调用。 通过对第三个迭代结束时的额外追踪，你可以看到所有这些分配都发生在外循环的前三个迭代中。然后，（重新）使用的内存量是稳定的。因此，剩下的97次迭代根本就没有从操作系统中分配任何内存。 即使syncpool已经分配了所有的内存，keeppool也没有分配任何内存。 只有当keeppool被销毁时，分配的六块内存才会真正地被调用::delete（或者当keeppool被初始化时用set_default_resource()定义的任何东西）而被取消分配。 如果我们在这个程序中引入第三个跟踪器，我们也可以跟踪对象从syncpool分配和删除内存的时间:\n// 跟踪每个调用，同步池中的效果，以及单池中的效果: Tracker track1{\u0026#34;keeppool:\u0026#34;}; std::pmr::monotonic_buffer_resource keepAllocatedPool{10000, \u0026amp;track1}; Tracker track2{\u0026#34; syncpool:\u0026#34;, \u0026amp;keepAllocatedPool}; std::pmr::synchronized_pool_resource syncPool{\u0026amp;track2}; Tracker track3{\u0026#34; objects:\u0026#34;, \u0026amp;syncPool}; ... std::pmr::vector\u0026lt;std::pmr::string\u0026gt; coll{\u0026amp;track3}; 27.2.1 内存资源的平等性 让我们谈谈 do_is_equal()，该函数定义两个内存资源何时可互换。 这个功能需要比最初看起来更多的思考。 在我们的跟踪器中，我们定义了分配器是可互换的，如果它们都是 Tracker 类型并且使用相同的前缀：\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // same object?: if (this == \u0026amp;other) return true; // same type and prefix?: auto op = dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other); return op != nullptr \u0026amp;\u0026amp; op-\u0026gt;prefix == prefix; } 这具有以下效果：\nTracker track1{\u0026#34;track1:\u0026#34;}; Tracker track2{\u0026#34;track2:\u0026#34;}; std::pmr::string s1{\u0026#34;more than 15 chars\u0026#34;, \u0026amp;track1}; // 用 track1 分配 std::pmr::string s2{std::move(s1), \u0026amp;track1}; // 移动（相同的跟踪器） std::pmr::string s3{std::move(s2), \u0026amp;track2}; // 拷贝（不同的前缀） std::pmr::string s4{std::move(s3)}; // 移动（复制分配器） std::string s5{std::move(s4)}; // 移动（其他分配器） 也就是说，只有当源码和目的码具有可互换的分配器时，移动才会作为移动执行。对于多态分配类型，当使用移动构造函数时就是这种情况（新对象复制了分配器）。但是如果需要一个不可互换的分配器（如这里的跟踪器有不同的前缀），或者使用不同的分配器类型（如移动到std::string，它使用默认的分配器），内存会被复制。因此，互换性会影响移动的性能。 如果我们让所有Tracker类型的内存资源都可以互换，只检查类型:\nbool do_is_equal(const std::pmr::memory_resource\u0026amp; other) const noexcept override { // 如果所有 Tracker 具有相同的类型，则它们都可以互换: return this == \u0026amp;other || dynamic_cast\u0026lt;const Tracker*\u0026gt;(\u0026amp;other) != nullptr; } 我们会得到以下行为:\nTracker track1{\u0026#34;track1:\u0026#34;}; Tracker track2{\u0026#34;track2:\u0026#34;}; std::pmr::string s1{\u0026#34;more than 15 chars\u0026#34;, \u0026amp;track1}; // 用 track1 分配 std::pmr::string s2{std::move(s1), \u0026amp;track1}; // 移动（相同的跟踪器类型） std::pmr::string s3{std::move(s2), \u0026amp;track2}; // 移动 (same tracker type) std::pmr::string s4{std::move(s3)}; // 移动 (allocator copied) std::string s5{std::move(s4)}; // 拷贝 (other allocator) 如您所见，效果是track1分配的内存通过s3传递给s4，两者都使用track2，因此我们得到：\ntrack1:allocate 32 Bytes track2:deallocate 32 Bytes 如果我们的内存资源不会有不同的状态（即不会有前缀），这将是一个很好的实现，因为这可以提高移动的性能。 所以，使内存资源可互换是值得的，因为较少的移动会转换为拷贝。但你不应该让它们的互换性超过其目的需要。\n27.3 为自定义类型提供内存资源支持 在我们介绍了标准内存资源和用户定义的内存资源之后，还有一个问题。我们怎样才能使我们的自定义类型具有多态分配器意识，从而使它们像pmr::string一样作为pmr容器的一个元素，使用其分配器进行分配。\n27.3.1 PMR类型的定义 支持多态分配器的方法出奇的简单，只要对所有需要堆内存的数据使用pmr成员就可以了。你必须这样做。\n将allocator_type定义为多态分配器的公共成员 为所有构造函数添加重载，使其将分配器作为附加参数（包括复制和移动构造函数）。 让没有分配器参数的初始化构造函数使用allocator_type（如果实现的话，这不适用于复制和移动构造函数）。 下面是第一个例子:\npmr/pmrcustomer.hpp #include \u0026lt;string\u0026gt; #include \u0026lt;memory_resource\u0026gt; // 一个多态分配器感知类型 客户 // - 分配器存储在字符串成员中 class PmrCustomer { private: std::pmr::string name; // 也用于存储分配器 public: using allocator_type = std::pmr::polymorphic_allocator\u0026lt;char\u0026gt;; // 初始化构造函数 constructor(s): PmrCustomer(std::pmr::string n, allocator_type alloc = {}) : name{std::move(n), alloc} { } // 使用分配器复制/移动: PmrCustomer(const PmrCustomer\u0026amp; c, allocator_type alloc) : name{c.name, alloc} { } PmrCustomer(PmrCustomer\u0026amp;\u0026amp; c, allocator_type alloc) : name{std::move(c.name), alloc} { } // setters/getters: void setName(std::pmr::string s) { name = std::move(s); } std::pmr::string getName() const { return name; } std::string getNameAsString() const { return std::string{name}; } }; 首先注意，我们使用一个pmr字符串作为成员。这不仅持有值（这里是名称），还持有当前使用的分配器:\nstd::pmr::string name; // 也用于存储分配器 然后，我们必须指定这个类型支持多态分配器，这可以通过提供一个相应的allocator_type类型的声明来简单完成:\nusing allocator_type = std::pmr::polymorphic_allocator\u0026lt;char\u0026gt;; 传递给polymorphic_allocator的类型并不重要（当它被使用时，分配器会被反弹到必要的类型）。例如，你也可以在那里使用std::byte。4 另外，你也可以使用字符串成员的allocator_type:\nusing allocator_type = decltype(name)::allocator_type; 接下来我们定义通常的构造函数，增加一个可选的分配器参数。\nPmrCustomer(std::pmr::string n, allocator_type alloc = {}) : name{std::move(n), alloc} { } 你可以考虑将这样的构造函数声明为显式的。至少如果你有一个默认的构造函数，你应该这样做以避免从分配器到客户的隐式转换。\nexplicit PmrCustomer(allocator_type alloc = {}) : name{alloc} { } 然后，我们必须提供要求特定分配器的复制和移动操作。这是pmr容器的主要接口，确保其元素使用容器的分配器。\nPmrCustomer(const PmrCustomer\u0026amp; c, allocator_type alloc) : name{c.name, alloc} { } PmrCustomer(PmrCustomer\u0026amp;\u0026amp; c, allocator_type alloc) : name{std::move(c.name), alloc} { } 注意，这两个都不是noexcept，因为如果所需的分配器allocator不能互换，即使是move构造函数也可能要复制一个被传递的客户。 最后，我们实现必要的setters和getters，它们通常是。\nvoid setName(std::pmr::string s) { name = std::move(s); } std::pmr::string getName() const { return name; } 还有一个getter，getNameAsString()，我们提供这个getter来廉价地将名字返回为 std::string。我们将在后面讨论它。目前，你也可以不使用它。\n27.3.2 PMR类型的用法 有了上面 PmrCustomer 的定义，我们就可以在 pmr 容器中使用这个类型了。 例如：\npmr/pmrcustomer1.cpp\n#include \u0026#34;pmrcustomer.hpp\u0026#34; #include \u0026#34;tracker.hpp\u0026#34; #include \u0026lt;vector\u0026gt; int main() { Tracker tracker; std::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); coll.reserve(100); // 用跟踪器分配 PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 coll.push_back(c1); // 使用vector分配器（跟踪器）进行分配 coll.push_back(std::move(c1)); // 副本（分配器不可互换） for (const auto\u0026amp; cust : coll) { std::cout \u0026lt;\u0026lt; cust.getName() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 为了让人们看到所发生的事情，我们使用追踪器来追踪所有的分配和取消分配:\nTracker tracker; std::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); 当我们为100个元素保留内存时，vector使用我们的跟踪器来分配必要的数据:\ncoll.reserve(100); //用跟踪器分配 当我们创建消费者时，不使用跟踪器：\nPmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 然而，当我们把customer的副本推到vector中时，vector会确保元素也都使用其多态分配器。由于这个原因，PmrCustomer的扩展拷贝构造函数被调用，其第二个参数是vector分配器，这样元素就被初始化了 与跟踪器一起初始化。\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 coll.push_back(c1); // 使用vector分配器（跟踪器）进行分配 如果我们把customer 移到vector中，也会发生同样的情况，因为vector的分配器（跟踪器）和客户的分配器（使用默认资源）是不能互换的：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 用 get_default_resource() 分配 ... coll.push_back(std::move(c1)); // 副本（分配器不可互换） 如果我们还使用跟踪器初始化客户，则移动将起作用：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll(\u0026amp;tracker); ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;, \u0026amp;tracker}; // 用跟踪器分配 ... coll.push_back(std::move(c1)); // 移动（相同的分配器） 如果我们根本不使用任何跟踪器，情况也是如此：\nstd::pmr::vector\u0026lt;PmrCustomer\u0026gt; coll; // 使用默认资源分配 ... PmrCustomer c1{\u0026#34;Peter, Paul \u0026amp; Mary\u0026#34;}; // 使用默认资源分配 ... coll.push_back(std::move(c1)); // 移动（相同的分配器） 27.3.3 处理不同的类型 虽然将 PmrCustomer 与 pmr 类型一起使用变得非常好，但我们有一个问题：通常，程序使用 std::string 类型的字符串。 那么我们如何处理同时使用 std::string 和 std::pmr::string 呢？ 首先，不同字符串类型之间存在显式但没有隐式转换：\nstd::string s; std::pmr::string t1{s}; // OK std::pmr::string t2 = s; // ERROR s = t1; // ERROR s = std::string(t1); // OK 支持显式转换，因为任何字符串都会隐式转换为 std::string_view，它可以显式转换为任何字符串类型。 进一步降低成本，但后者需要分配内存（假设小字符串优化不适用）。 在我们的示例中，这意味着：\nstd::string s{\u0026#34;Paul Kalkbrenner\u0026#34;}; PmrCustomer c1 = s; // 错误：没有隐式转换 PmrCustomer c2{s}; // 错误：没有隐式转换 PmrCustomer c3{std::pmr::string{s}}; // OK（隐式将 s 转换为 string_view） 我们可能想提供额外的构造函数，但不提供它们的好处是程序员被迫实现昂贵的转换。 此外，如果您为不同的字符串类型（std::string 和 std::pmr::string）重载，则会产生额外的歧义（例如，采用 string_view 或字符串文字），因此需要更多的重载。 无论如何，getter 只能返回一种类型（因为我们不能只重载不同的返回类型）。 因此，我们只能提供一个 getter，它通常应该返回 API 的“本机”类型（这里是 std::pmr::string）。 这意味着，如果我们返回一个 std::pmr::string 并且需要名称为 std::string，我们再次需要显式转换：\nPmrCustomer c4{\u0026#34;Mr. Paul Kalkbrenner\u0026#34;}; // OK：使用默认资源分配 std::string s1 = c4.getName(); // 错误：没有隐式转换 std::string s2 = std::string{c4.getName()}; // OOPS：两个分配 这不仅不太方便，这也是一个性能问题，因为在最后一条语句中发生了两次分配：\n首先我们为返回值分配内存，然后 那么从 std::pmr::string 类型到 std::string 的转换需要另一个分配。 出于这个原因，提供一个额外的 getNameAsString() 直接创建并返回请求的类型可能是个好主意：\nstd::string s3 = c4.getNameAsString(); // OK：一次分配 27.4 后记 多态分配器首先由 Pablo Halpern 在 https://wg21.link/n3525 中提出。 这 采用 Pablo Halpern 在 https://wg21.link/n3916 中提出的方法成为图书馆基础 TS 的一部分。 该方法与 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的 C++17 的其他组件一起采用。\n28 对齐数据上的new和delete 从C++11开始，你可以指定过度对齐的类型，通过使用alignas指定器，拥有比默认对齐方式更大的对齐方式。比如说:\nstruct alignas(32) MyType32 { int i; char c; std::string s[4]; }; MyType32 val1; // 32 字节对齐 alignas(64) MyType32 val2; // 64 字节对齐 请注意，对齐值必须是 2 的幂，并且指定小于该类型默认对齐的任何值都是错误的。 但是，过度对齐数据的动态/堆分配在 C++11 和 C++14 中未正确处理。 默认情况下，对过度对齐的类型使用 operator new 会忽略请求的对齐方式，因此通常 63 字节对齐的类型可能例如仅 8 字节或 16 字节对齐。 C++17 弥补了这一差距。 新行为的结果是提供了带有对齐参数的新重载，以便能够为过度对齐的数据提供您自己的 operator new 实现。\n28.1 使用新的对齐方式 通过使用过度对齐的类型，例如：\nstruct alignas(32) MyType32 { int i; char c; std::string s[4]; }; 一个新的表达式现在可以保证所请求的堆内存是按要求对齐的（前提是 支持过度对齐）:\nMyType32* p = new MyType32; // 因为 C++17 保证是 32 字节对齐的 ... 在C++17之前，请求不保证是32字节对齐的。 像往常一样，没有任何初始化的值，对象是默认初始化的，这意味着可用的构造器被调用，但基本类型的（子）对象有一个未定义的值。由于这个原因，你最好使用带大括号的列表初始化，以确保（子）对象要么有其默认值或0/false/nullptr：\nMyType32* p = new MyType32{}; // 对齐和初始化 28.1.1 不同的动态/堆栈内存领域 请注意，对对齐内存的请求可能会导致调用从一个不相连的内存分配机制中获取内存。由于这个原因，对对齐内存的请求可能需要一个特定的相应请求来取消对齐数据。有可能内存是用C11函数aligned_alloc()分配的（现在在C++17中也可用）。在这种情况下，用free()去分配还是可以的，这样与用malloc()分配的内存相比就没有什么区别。 然而，对于平台来说，new和delete的其他实现是允许的，这就导致了必须用不同的内部函数去分配默认对齐的和超对齐的数据的要求。例如，在Windows上通常使用_aligned_malloc()，这就要求使用_aligned_free()作为对应。 与C标准相比，C++标准尊重这种情况，因此在概念上假定有两个互不相干的、不可操作的内存区域，一个用于默认对齐的数据，一个用于超对齐的数据。大多数情况下，编译器知道如何正确地处理这个问题：\nstd::string* p1 = new std::string; // 使用默认对齐的内存操作 MyType32* p2 = new MyType32; // 使用过度对齐的内存操作 ... delete p1; // 使用默认对齐的内存操作 delete p2; // 使用过度对齐的内存操作 但有时程序员必须做正确的事情，正如我们将在本章的其余部分中看到的那样。\n28.1.2 用new表达式传递对齐方式 还有一种方法是为特定的新调用请求特定的过度对齐。比如说：\n#include \u0026lt;new\u0026gt; // for align_val_t ... std::string* p = new(std::align_val_t{64}) std::string; // 64 字节对齐 MyType32* p = new(std::align_val_t{64}) MyType32{}; // 64 字节对齐 ... std::align_val_t 类型在标头 中定义如下：\nnamespace std { enum class align_val_t : size_t { }; } 它被规定为现在能够将对齐请求传递给运算符new()的相应实现。请记住，在C++中运算符new()可以用不同的方式实现。\n作为一个全局函数（默认提供了不同的重载，可以由程序员替换）。 作为特定类型的实现，可以由程序员提供，并具有比全局重载更高的 优先级高于全局重载。 然而，这是第一个例子，必须特别注意正确处理不同的动态内存领域，因为当用新的表达式指定对齐方式时，编译器不能使用类型来知道是否以及哪种对齐方式被请求。程序员必须指定调用哪个删除操作。 不幸的是，没有一个删除操作符，你可以传递一个额外的参数，你必须直接调用相应的操作符delete()，这意味着你必须知道多个重载中的哪一个被实现。事实上，在这个例子中，对于一个T类型的对象，可以调用以下函数中的一个 类型的对象，可以调用以下函数之一:\nvoid T::operator delete(void* ptr, std::size_t size, std::align_val_t align); void T::operator delete(void* ptr, std::align_val_t align); void T::operator delete(void* ptr, std::size_t size); void T::operator delete(void* ptr); void ::operator delete(void* ptr, std::size_t size, std::align_val_t align); void ::operator delete(void* ptr, std::align_val_t align); void ::operator delete(void* ptr, std::size_t size); void ::operator delete(void* ptr); 是的，就是这么复杂，我将在后面详细解释。目前，请使用三个选项中的一个。\n不要在新的表达式中直接使用过度对齐。 提供操作者new()和操作者delete()的实现，使用相同的内存区域（这样调用delete总是可以的）。 提供与运算符new()相匹配的运算符delete()的特定类型实现，并直接调用它们，而不是使用delete表达式。 注意，你不能使用类型定义或使用声明来代替:\nusing MyType64 = alignas(64) MyType32; // ERROR typedef alignas(64) MyType32 MyType64; // ERROR ... MyType64* p = new MyType64; // 因此不可能 原因是typedef或using声明只是原始类型的一个新名称/别名，这里所要求的是一个不同的类型，遵循不同的对齐规则。 如果你想调用一个对齐的new，获得nullptr作为返回值，而不是抛出 std::bad_alloc，你可以这样做：\n// 分配一个 64 字节对齐的字符串（如果没有，则为 nullptr）: std::string* p = new(std::align_val_t{64}, std::nothrow) std::string; if (p != nullptr) { ... } 28.2 为对齐的内存实现操作符new() 在C++中，当new和delete被调用时，你可以提供你自己的分配和删除内存的实现。这种机制现在也支持传递一个对齐参数。\n28.2.1 在C++17之前实现对齐分配 在全局范围内，C++提供了操作符new()和操作符delete()的重载，除非定义了特定类型的实现，否则会使用这些操作符。如果存在这些操作符的特定类型的实现，就会使用它们。请注意，有一个特定类型的操作符new()，就不能使用该类型的任何全局操作符new()实现（同样适用于delete、new[]和 delete[]）。\n也就是说，每次为类型 T 调用 new 时，都会调用特定类型的 T::operator new() 或（如果不存在）全局 ::operator new() 的相应调用：\nauto p = new T; // 尝试调用特定类型的运算符 new()（如果有） // 如果没有尝试调用全局 ::operator new() 同样地，每次你为一个类型T调用delete时，都会相应地调用特定类型的T::operator delete()或全局的::operator delete()。如果数组被分配/去分配，相应的特定类型或全局操作符operator new和operator delete被调用。 在C++17之前，要求的对齐方式不会自动传递给这些函数，默认机制分配动态内存时不会考虑对齐方式。一个过度对齐的类型总是需要自己实现operator new()和operator delete()才能在动态内存上正确对齐。更糟糕的是，没有可移植的方法来执行对过度对齐的动态内存的请求。 因此，举例来说，你必须定义如下的东西:\nlang/alignednew11.hpp #include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;string\u0026gt; #if __STDC_VERSION \u0026gt;= 201112L #include \u0026lt;stdlib.h\u0026gt; // for aligned_alloc() #else #include \u0026lt;malloc.h\u0026gt; // for _aligned_malloc() or memalign() #endif struct alignas(32) MyType32 { int i; char c; std::string s[4]; ...; static void* operator new (std::size_t size) { // 为要求的排列方式分配内存: #if __STDC_VERSION \u0026gt;= 201112L // use API of C11: return aligned_alloc(alignof(MyType32), size); #else #ifdef _MSC_VER // use API of Windows: return _aligned_malloc(size, alignof(MyType32)); #else // use API of Linux: return memalign(alignof(MyType32), size); #endif #endif } static void operator delete (void* p) { // 为所要求的对齐方式取消分配内存: #ifdef _MSC_VER // 使用Windows的特殊API: _aligned_free(p); #else // C11/Linux可以使用通用的free()函数。: free(p); #endif } // since C++14: static void operator delete (void* p, std::size_t size) { MyType32::operator delete(p); // 使用非尺寸删除 } ...; // also for arrays (new[] and delete[]) }; 注意，从C++14开始，你可以为删除操作符提供一个大小参数。然而，可能会发生尺寸不可用的情况（例如，当处理不完整的类型时），有些情况下，平台可以选择是否向操作符delete()传递一个尺寸参数。出于这个原因，自C++14以来，你应该总是同时替换操作符delete()的无大小和有大小的重载。让一个人调用另一个人通常是可以的。 有了这个定义，下面的代码表现得很正确：\nlang/alignednew11.cpp #include \u0026#34;alignednew11.hpp\u0026#34; int main() { auto p = new MyType32; ...; delete p; } 如所写，从 C++17 开始，您可以跳过执行操作以分配/取消分配对齐数据的开销。 即使没有为您的类型定义 operator new() 和 operator delete()，该示例也能正常工作：\nlang/alignednew17.cpp #include \u0026lt;string\u0026gt; struct alignas(32) MyType32 { int i; char c; std::string s[4]; ... }; int main() { auto p = new MyType32; // 从C++17开始分配32字节对齐的内存 ...; delete p; } 28.2.2 实现特定类型操作符new() 如果你必须自己实现运算符new()和运算符delete()，现在已经支持超对齐数据。在实践中，特定类型的相应代码 实现的相应代码自C++17以来看起来如下：\nlang/alignednew.hpp #include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;new\u0026gt; // for std::align_val_t #include \u0026lt;cstdlib\u0026gt; // for malloc(), aligned_alloc(), free() #include \u0026lt;string\u0026gt; struct alignas(32) MyType32 { int i; char c; std::string s[4]; ...; static void* operator new (std::size_t size) { // 要求默认对齐的数据: // 调用默认对其数据： std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size); } static void* operator new (std::size_t size, std::align_val_t align) { // 要求过度对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; and alignment \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;std::size_t\u0026gt;(align) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size, align); } static void operator delete (void* p) { // 要求默认对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::delete() without alignment\\n\u0026#34;; ::operator delete(p); } static void operator delete (void* p, std::size_t size) { MyType32::operator delete(p); // 使用非大小删除 } static void operator delete (void* p, std::align_val_t align) { // 要求默认对齐的数据: std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::delete() with alignment\\n\u0026#34;; ::operator delete(p, align); } static void operator delete (void* p, std::size_t size, std::align_val_t align) { MyType32::operator delete(p, align); // 使用非大小删除 } // also for arrays (operator new[] and operator delete[]) ...; }; 原则上，我们只需要额外对齐参数的重载，并调用函数来分配和释放对齐的内存。 最便携的方法是调用为过度对齐（取消）分配提供的全局函数：\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; return ::operator new(size, align); } ...; static void operator delete (void* p, std::align_val_t align) { ...; ::operator delete(p); } 您也可以直接调用 C11 函数进行对齐分配：\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); } ...; static void operator delete (void* p, std::align_val_t align) { ...; std::free(p); } 然而，由于Windows对aligned_alloc()的问题，在实践中，我们需要特殊的处理方式来进行移植，那么:\nstatic void* operator new (std::size_t size, std::align_val_t align) { ...; #ifdef _MSC_VER // 特定于 Windows 的 API: return aligned_malloc(size, static_cast\u0026lt;size_t\u0026gt;(align)); #else // 标准 C++17 API: return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); #endif } static void operator delete (void* p, std::align_val_t align) { ...; #ifdef _MSC_VER // 特定于 Windows 的 API: _aligned_free(p); #else // 标准 C++17 API: std::free(p); #endif } 请注意，所有的分配函数都将对齐参数作为size_t类型，这意味着我们必须使用静态转换来从std::align_val_t类型转换数值。 此外，你可能想用[[nodiscard]]声明运算符new()的重载。属性:\n[[nodiscard]] static void* operator new (std::size_t size) { ...; } [[nodiscard]] static void* operator new (std::size_t size, std::align_val_t align) { ...; } 直接调用运算符new()（不使用new表达式）是很罕见的，但（正如你在这里看到的）是可能的。有了[[nodiscard]]，编译器会检测到，如果调用者忘记使用返回值，这将导致内存泄漏。\noperator new() 什么时候调用？ 正如所介绍的，我们现在可以有两个重载的操作符new()。\n只有size参数的版本，在C++17之前也被支持，一般是为默认对齐的数据请求提供的。 然而，如果没有提供用于大对齐数据的版本，它也可以作为回退。 带有额外对齐参数的版本，自C++17以来得到了特别的支持，一般是为超对齐数据的请求提供的。 使用哪个重载不一定取决于是否使用了alignas。它取决于特定平台对过对齐数据的定义。 编译器会根据一个一般的对齐值从默认对齐切换到超对齐，这个值 你可以在新的预处理程序常量中找到 stdcpp_default_new_alignment。 也就是说，在任何大于这个常数的对齐方式下，调用new会从试图调用\noperator new(std::size_t) 试调用：\noperator new(std::size_t, std::align_val_t) 因此，以下代码的输出可能因平台而异:\nstruct alignas(32) MyType32 { ...; static void* operator new (std::size_t size) { std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size); } static void* operator new (std::size_t size, std::align_val_t align) { std::cout \u0026lt;\u0026lt; \u0026#34;MyType32::new() with size \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; and alignment \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;std::size_t\u0026gt;(align) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return ::operator new(size, align); ::operator delete(p); } ...; }; auto p = new MyType32; 如果默认的对齐方式是32（或者更少，并且代码可以编译），表达式new MyType32将调用运算符new()的第一个重载，只有大小参数，所以输出是这样的 像这样:\nMyType32::new() with size 128 如果默认对齐方式小于32，将调用两个参数的运算符new()的第二个重载，这样输出就变成了这样:\nMyType32::new() with size 128 and alignment 32 如果没有为特定类型的运算符new()提供std::align_val_t重载，没有这个参数的重载将被用作回退。因此，一个只提供C++17之前支持的运算符new()重载的类仍然可以编译并具有相同的行为（注意，对于全局运算符new()来说，情况不是这样的）:\nstruct NonalignedNewOnly { ...; static void* operator new (std::size_t size) { ...; } ...; // 不operato new(std::size_t, std::align_val_t align) }; auto p = new NonalignedNewOnly; // OK：使用了操作符new(size_t)。 反之则不然。如果一个类型只提供了带有对齐方式参数的重载，那么任何使用默认对齐方式的new分配存储的尝试都会失败：\nstruct AlignedNewOnly { ...; // no operator new(std::size_t) static void* operator new (std::size_t size, std::align_val_t align) { return std::aligned_alloc(static_cast\u0026lt;size_t\u0026gt;(align), size); } }; auto p = new AlignedNewOnly; // 错误：没有用于默认对齐的运算符 new() 如果对该类型要求的对齐方式是（小于）默认的对齐方式，这也将是一个错误。\n在新的表达式中请求对齐 如果你在new表达式中传递了一个要求的对齐方式，那么传递的对齐方式参数总是被传递，并且必须被操作符new()所支持。事实上，对齐方式参数的处理与你可以传递给新表达式的任何其他额外参数一样。它们被作为附加参数传递给运算符new()。 因此，一个调用，如:\nstd::string* p = new(std::align_val_t{64}) std::string; // 64 字节对齐 将始终尝试调用：\noperator new(std::size_t, std::align_val_t) 一个仅有大小的重载在这里不会作为fallback。 如果你对一个过度对齐的类型有一个特定的对齐请求，其行为就更加有趣了。例如，如果你调用:\nMyType32* p = new(std::align_val_t{64}) MyType32{}; 并且 MyType32 过度对齐，编译器首先尝试调用:\noperator new(std::size_t, std::align_val_t, std::align_val_t) 32作为第二个参数（type的一般过度对齐），64作为第三个参数（要求的特定对齐）。只作为退步:\noperator new(std::size_t, std::align_val_t) 被调用，并将64作为请求的特定对齐方式。原则上，你可以为这三个参数提供一个重载，以实现对超对齐类型请求特定对齐时的特定行为。 再次注意，如果你需要为超对齐的数据提供特殊的去分配函数，你必须在新表达式中传递对齐方式时调用正确的去分配函数:\nstd::string* p1 = new(std::align_val_t{64}) std::string{}; MyType32* p2 = new(std::align_val_t{64}) MyType32{}; ...; ::operator delete(p2, std::align_val_t{64}); // !!! MyType32::operator delete(p1, std::align_val_t{64}); // !!! 这意味着，本例中的新表达式将调用\noperator new(std::size_t size, std::align_val_t align); 而 delete 表达式将为默认对齐的数据调用以下两个操作之一：\noperator delete(void* ptr, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t align); 以及针对过度对齐数据的以下四种操作之一：\noperator delete(void* ptr, std::align_val_t typealign, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t typealign, std::align_val_t align); operator delete(void* ptr, std::align_val_t align); operator delete(void* ptr, std::size_t size, std::align_val_t align); 28.3 实现全局操作符new() 默认情况下，C++ 平台现在为 operator new() 和 delete() 提供了大量的全局重载（包括相应的数组版本）：\nvoid* ::operator new(std::size_t); void* ::operator new(std::size_t, std::align_val_t); void* ::operator new(std::size_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new(std::size_t, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete(void*) noexcept; void ::operator delete(void*, std::size_t) noexcept; void ::operator delete(void*, std::align_val_t) noexcept; void ::operator delete(void*, std::size_t, std::align_val_t) noexcept; void ::operator delete(void*, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete(void*, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new[](std::size_t); void* ::operator new[](std::size_t, std::align_val_t); void* ::operator new[](std::size_t, const std::nothrow_t\u0026amp;) noexcept; void* ::operator new[](std::size_t, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete[](void*) noexcept; void ::operator delete[](void*, std::size_t) noexcept; void ::operator delete[](void*, std::align_val_t) noexcept; void ::operator delete[](void*, std::size_t, std::align_val_t) noexcept; void ::operator delete[](void*, const std::nothrow_t\u0026amp;) noexcept; void ::operator delete[](void*, std::align_val_t, const std::nothrow_t\u0026amp;) noexcept; 如果你想实现自己的内存管理（例如，为了能够调试动态内存调用），你不必全部覆盖它们。只要实现以下基本函数就足够了，因为默认情况下，所有其他函数（包括所有数组版本）都会调用这些基本函数中的一个:\nvoid* ::operator new(std::size_t); void* ::operator new(std::size_t, std::align_val_t); void ::operator delete(void*) noexcept; void ::operator delete(void*, std::size_t) noexcept; void ::operator delete(void*, std::align_val_t) noexcept; void ::operator delete(void*, std::size_t, std::align_val_t) noexcept; 原则上，操作者delete()的默认大小版本也只是调用非大小版本。然而，这在将来可能会发生变化，因此要求你同时实现这两个功能（如果你不这样做，有些编译器会发出警告）。\n28.3.1 向后的不相容性 请注意，以下程序的行为会随着 C++17 默默地改变：\nlang/alignednewincomp.cpp\n#include \u0026lt;cstddef\u0026gt; // for std::size_t #include \u0026lt;cstdlib\u0026gt; // for std::malloc() #include \u0026lt;cstdio\u0026gt; // for std::printf() void* operator new (std::size_t size) { std::printf(\u0026#34;::new called with size: %zu\\n\u0026#34;, size); return ::std::malloc(size); } int main() { struct alignas(64) S { int i; }; S* p = new S; // 仅在 C++17 之前调用我们的运算符 new } 在 C++14 中，为所有新表达式调用全局 ::operator new(size_t) 重载，以便程序始终具有以下输出：\n::new called with size: 64 从 C++17 开始，这个程序的行为发生了变化，因为现在默认重载了过度对齐的数据\n::operator new(size_t, align_val_t) 在这里调用，没有被替换。 结果，程序将不再输出上面的行。\n请注意，此问题仅适用于全局运算符 new()。 如果为 S 定义了特定于类型的运算符 new()，则该运算符仍用作过度对齐数据的后备，以便此类程序的行为与 C++17 之前一样。 另请注意，此处有意使用 printf() 以避免 std::cout 的输出在我们分配内存时分配内存，这可能会导致严重错误（充其量是核心转储）。\n28.4 跟踪所有::new的调用 下面的程序演示了如何使用 new 运算符 new() 重载结合内联变量和 [[nodiscard]] 来跟踪 ::new 的所有调用，只需包含此头文件：\nlang/tracknew.hpp\n#ifndef TRACKNEW_HPP #define TRACKNEW_HPP #include \u0026lt;new\u0026gt; // for std::align_val_t #include \u0026lt;cstdio\u0026gt; // for printf() #include \u0026lt;cstdlib\u0026gt; // for malloc() and aligned_alloc() #ifdef _MSC_VER #include \u0026lt;malloc.h\u0026gt; // for _aligned_malloc() and _aligned_free() #endif class TrackNew { private: static inline int numMalloc = 0; // num malloc 调用 static inline size_t sumSize = 0; // 到目前为止分配的字节数 static inline bool doTrace = false; // 启用跟踪 static inline bool inNew = false; // 不要在新的重载中跟踪输出 public: static void reset() { //重置新/内存计数器 numMalloc = 0; sumSize = 0; } static void trace(bool b) { // 启用/禁用跟踪 doTrace = b; } // 实施跟踪分配: static void* allocate(std::size_t size, std::size_t align, const char* call) { // 跟踪和跟踪分配: ++numMalloc; sumSize += size; void* p; if (align == 0) { p = std::malloc(size); } else { #ifdef _MSC_VER p = _aligned_malloc(size, align); // Windows API #else p = std::aligned_alloc(align, size); // C++17 API #endif } if (doTrace) { // 不要在这里使用 std::cout 因为它可能会分配内存 // 当我们分配内存时（充其量是核心转储） printf(\u0026#34;#%d %s \u0026#34;, numMalloc, call); printf(\u0026#34;(%zu bytes, \u0026#34;, size); if (align \u0026gt; 0) { printf(\u0026#34;%zu-bytes aligned) \u0026#34;, align); } else { printf(\u0026#34;def-aligned) \u0026#34;); } printf(\u0026#34;=\u0026gt; %p (total: %zu Bytes)\\n\u0026#34;, (void*)p, sumSize); } return p; } static void status() { // 打印当前状态 printf(\u0026#34;%d allocations for %zu bytes\\n\u0026#34;, numMalloc, sumSize); } }; [[nodiscard]] void* operator new (std::size_t size) { return TrackNew::allocate(size, 0, \u0026#34;::new\u0026#34;); } [[nodiscard]] void* operator new (std::size_t size, std::align_val_t align) { return TrackNew::allocate(size, static_cast\u0026lt;size_t\u0026gt;(align), \u0026#34;::new aligned\u0026#34;); } [[nodiscard]] void* operator new[] (std::size_t size) { return TrackNew::allocate(size, 0, \u0026#34;::new[]\u0026#34;); } [[nodiscard]] void* operator new[] (std::size_t size, std::align_val_t align) { return TrackNew::allocate(size, static_cast\u0026lt;size_t\u0026gt;(align), \u0026#34;::new[] aligned\u0026#34;); } // 确保释放匹配: void operator delete (void* p) noexcept { std::free(p); } void operator delete (void* p, std::size_t) noexcept { ::operator delete(p); } void operator delete (void* p, std::align_val_t) noexcept { #ifdef _MSC_VER _aligned_free(p); // Windows API #else std::free(p); // C++17 API #endif } void operator delete (void* p, std::size_t, std::align_val_t align) noexcept { ::operator delete(p, align); } #endif // TRACKNEW_HPP 考虑在以下 CPP 文件中使用此头文件：\nlang/tracknew.cpp\n#include \u0026#34;tracknew.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { TrackNew::reset(); TrackNew::trace(true); std::string s = \u0026#34;string value with 26 chars\u0026#34;; auto p1 = new std::string{\u0026#34;an initial value with even 35 chars\u0026#34;}; auto p2 = new(std::align_val_t{64}) std::string[4]; auto p3 = new std::string[4] { \u0026#34;7 chars\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;or 11 chars\u0026#34;, \u0026#34;a string value with 28 chars\u0026#34; }; TrackNew::status(); ...; delete p1; delete[] p2; delete[] p3; } 输出取决于何时初始化跟踪以及为其他初始化执行了多少分配。 但它应该包含类似于以下几行的内容：\n#1 ::new (27 bytes, def-aligned) =\u0026gt; 0x8002ccc0 (total: 27 Bytes) #2 ::new (24 bytes, def-aligned) =\u0026gt; 0x8004cd28 (total: 51 Bytes) #3 ::new (36 bytes, def-aligned) =\u0026gt; 0x8004cd48 (total: 87 Bytes) #4 ::new[] aligned (100 bytes, 64-bytes aligned) =\u0026gt; 0x8004cd80 (total: 187 Bytes) #5 ::new[] (100 bytes, def-aligned) =\u0026gt; 0x8004cde8 (total: 287 Bytes) #6 ::new (29 bytes, def-aligned) =\u0026gt; 0x8004ce50 (total: 316 Bytes) 6 allocations for 316 bytes 第一个输出是，例如，为s的值初始化内存。注意，根据std::string类的分配策略，这个值可能更大。 接下来写的两行是由第二个请求引起的:\nauto p1 = new std::string{\u0026#34;an initial value with even 35 chars\u0026#34;}; 它为核心字符串对象分配了24个字节，加上36个字节的字符串初始值（同样，这些值可能会有所不同）。 第三次调用要求一个64字节的4个字符串的数组。 最后一个调用再次执行两个分配：一个用于数组，一个用于最后一个字符串的初始值。是的，只为最后一个字符串，因为库的实现通常使用小/短字符串优化（SSO），它将通常不超过15个字符的字符串存储在数据成员中，而不是完全分配堆内存。其他实现可能在这里进行5次分配。\n28.5 后记 堆/动态内存分配的对齐由 Clark Nelson 在 https://wg21.link/n3396 中首次提出。 最终接受的措辞由 Clark Nelson 在 https://wg21.link/p0035r4 中制定。\n29 其他专业库的改动 对于专家来说，C++标准库还有一些进一步的改进，例如基础库的程序员，本章将介绍这些改进。\n29.1 字符序列和数字值之间的低级转换 自 C 以来，将整数值转换为字符序列（反之亦然）一直是一个问题。虽然 C 提供了 sprintf() 和 sscanf()，但 C++ 首先引入了字符串流，但是这需要大量资源。使用 C++11 引入了方便的函数，例如 std::to_string 和 std::stoi() ，它们只接受 std::string 参数。 C++17 引入了具有以下能力的新基本字符串转换函数（引用自最初的提议）：\n没有格式字符串的运行时解析 接口本身不需要动态内存分配 不考虑语言环境 不需要通过函数指针进行间接寻址 防止缓冲区溢出 解析字符串时，错误可与有效数字区分开来 解析字符串时，空格或装饰不会被忽略 除了浮点数之外，此功能还将提供往返保证，即转换为字符序列并转换回原始值的值。\n这些函数在头文件 中提供。\n29.1.1 使用实例 提供了两个重载函数：\nstd::from_chars() 将给定的字符序列转换为数值。 std::to_chars() 将数值转换为给定的字符序列。 from_chars() std::from_chars() 将给定的字符序列转换为数值。 例如：\n#include \u0026lt;charconv\u0026gt; const char* str = \u0026#34;12 monkeys\u0026#34;; int value; std::from_chars_result res = std::from_chars(str, str+10, value); 在成功解析后，值包含解析后的值（本例中为12）。结果值是以下结构:\nstruct from_chars_result { const char* ptr; std::errc ec; }; 在调用之后，ptr指的是第一个没有被解析为数字的一部分的字符（或者传递的第二个参数，如果所有的字符都被传递了），ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。因此，你可以这样检查结果如下:\nif (res.ec != std::errc{}) { ... // error handling } 注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:\nif (res.ec) { // 错误：没有隐式转换为布尔值 或者：\nif (!res.ec) { // 错误：没有操作员！ 定义 但是，通过使用结构化绑定并且如果使用初始化，您可以编写：\nif (auto [ptr, ec] = std::from_chars(str, str+10, value); ec != std::errc{}) { ... // error handling } 另一个例子是解析传递的字符串视图:\nto_chars() std::to_chars() 将数值转换为给定的字符序列。 例如：\n#include \u0026lt;charconv\u0026gt; int value = 42; char str[10]; std::to_chars_result res = std::to_chars(str, str+9, value); *res.ptr = \u0026#39;\\0\u0026#39;; // 确保后面有一个尾随空字符 转换成功后，str包含了代表传递值的字符序列（本例中为42），没有尾部空字符。 结果值是以下结构:\nstruct to_chars_result { char* ptr; std::errc ec; }; 在调用之后，ptr指的是最后一个写入的字符之后的字符，ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。 因此，你可以按以下方式检查结果:\nif (res.ec != std::errc{}) { ... // 错误处理 } else { process (str, res.ptr - str); //传递字符和长度 } 再次注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:\nif (res.ec) { // 错误：没有隐式转换为布尔值 或者：\nif (!res.ec) { // 错误：没有操作员！ 定义 由于未写入尾随空终止符，因此您必须确保仅使用写入的字符或添加尾随空字符，如本示例中使用返回值的 ptr 成员所做的那样：\n*res.ptr = \u0026#39;\\0\u0026#39;; // 确保后面有一个尾随空字符 同样，通过使用结构化绑定，如果使用初始化，您可以编写：\nif (auto [ptr, ec] = std::to_chars(str, str+10, value); ec != std::errc{}) { ... // 错误处理 } else { process (str, res.ptr - str); // 传递字符和长度 } 请注意，使用现有的std::to_string()函数，这种行为更安全，更容易实现。使用std::to_char()只有在进一步处理直接需要所写的 字符序列。\n29.1.2 支持浮点往返运算 如果没有给出精度，to_chars()和from_chars()保证对浮点值的往返支持。这意味着一个转换为字符序列的值在读回时正好是其原始值。不过，这种保证只适用于在同一实现中的写入和读取。 因此，浮点值必须被写成具有最高精度的最细粒度的字符序列。由于这个原因，数值被写入的字符序列可能有很大的尺寸。 请看下面的函数:\nlib/charconv.hpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;charconv\u0026gt; #include \u0026lt;cassert\u0026gt; void d2str2d(double value1) { std::cout \u0026lt;\u0026lt; \u0026#34;in: \u0026#34; \u0026lt;\u0026lt; value1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 转换为字符序列: char str[1000]; std::to_chars_result res1 = std::to_chars(str, str+999, value1); *res1.ptr = \u0026#39;\\0\u0026#39;; // 添加尾随空字符 std::cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(res1.ec == std::errc{}); // 从字符序列回读: double value2; std::from_chars_result res2 = std::from_chars(str, str+999, value2); std::cout \u0026lt;\u0026lt; \u0026#34;out: \u0026#34; \u0026lt;\u0026lt; value2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(res2.ec == std::errc{}); assert(value1 == value2); // should never fail } 在这里，我们将传递的双精度值转换为字符序列并将其解析回来。 最后的断言再次检查该值是否相同。 下面的程序演示了效果：\nlib/charconv.cpp #include \u0026#34;charconv.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; int main() { std::vector\u0026lt;double\u0026gt; coll{0.1, 0.3, 0.00001}; // 创建两个略有不同的浮点值: auto sum1 = std::accumulate(coll.begin(), coll.end(), 0.0, std::plus\u0026lt;\u0026gt;()); auto sum2 = std::accumulate(coll.rbegin(), coll.rend(), 0.0, std::plus\u0026lt;\u0026gt;()); // look the same: std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 但不一样: std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::setprecision(20); std::cout \u0026lt;\u0026lt; \u0026#34;equal: \u0026#34; \u0026lt;\u0026lt; (sum1==sum2) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // false !! std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 检查往返: d2str2d(sum1); d2str2d(sum2); } 我们以不同的顺序累积两个小的浮点序列。 sum1 是从左到右累积的总和，而 sum2 是从右到左累积的总和（使用反向迭代器）。 结果，这些值看起来相同但不是：\nsum1: 0.40001 sum1: 0.40001 equal: false sum1: 0.40001000000000003221 sum1: 0.40000999999999997669 将值传递给 d2str2d() 时，您可以看到这些值存储为具有必要粒度的不同字符序列：\nin: 0.40001000000000003221 str: 0.40001000000000003 out: 0.40001000000000003221 in: 0.40000999999999997669 str: 0.40001 out: 0.40000999999999997669 再次注意，粒度（以及字符序列的必要大小）取决于平台。 往返支持适用于所有浮点数，包括 NAN 和 INFINITY。 例如，将 INFINITY 传递给 d2st2d() 应该具有以下效果：\nvalue1: inf str: inf value2: inf 但是，请注意，对于 NAN，d2str2d() 中的断言将失败，因为它从不与任何东西进行比较，包括它自己。\n29.2 后记 字符序列和数字值之间的低级转换是由Jens Maurer在https://wg21.link/p0067r0 中首次提出的。最终被接受的措辞是由Jens Maurer在https://wg21.link/p0067r5。然而，重要的澄清和新的头文件被指定为Jens Maurer在https://wg21.link/p0682r1，作为针对C++17的缺陷报告。\n词汇表 ","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/c++/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/","title":"第五部分-专业工具"},{"content":"第四部分 标准库扩展和修改 这一部分介绍了用C++17对现有库组件的扩展和修改。\n21类型特征扩展 关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。\n21.1 类型特征的Suffix _v 从C++17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是\nstd::is_const\u0026lt;T\u0026gt;::value 你现在可以写:\nstd::is_const_v\u0026lt;T\u0026gt; // since C++17 这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:\nnamespace std { template\u0026lt;typename T\u0026gt; constexpr bool is_const_v = is_const\u0026lt;T\u0026gt;::value; } 通常，这有助于制定布尔条件，你可以在运行时使用:\nif (std::is_signed_v\u0026lt;char\u0026gt;) { ... } 但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:\nif constexpr (std::is_signed_v\u0026lt;char\u0026gt;) { ... } 或在实例化模板时:\n// C\u0026lt;T\u0026gt;类的主要模板 template\u0026lt;typename T, bool = std::is_pointer_v\u0026lt;T\u0026gt;\u0026gt; class C { ... }; // 指针类型的部分特殊化。 template\u0026lt;typename T\u0026gt; class C\u0026lt;T, true\u0026gt; { ... }; 在这里，以C类为例，它为指针类型提供了一个特殊的实现。 但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme\u0026lt;\u0026gt;。它产生的是一个原始数组的维度大小:\nint a[5][7]; std::cout \u0026lt;\u0026lt; std::extent_v\u0026lt;decltype(a)\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 5 std::cout \u0026lt;\u0026lt; std::extent_v\u0026lt;decltype(a),1\u0026gt; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints 7 21.2 新类型特征 C++17 引入了几个新的类型特征。 此外， is_literal_type\u0026lt;\u0026gt; 和 result_of\u0026lt;\u0026gt; 自 C++17 起已弃用。 正在建设中的详细说明\nis_aggregate\u0026lt;\u0026gt; std::is_aggregate 评估 T 是否为聚合类型：\ntemplate\u0026lt;typename T\u0026gt; struct D : std::string, std::complex\u0026lt;T\u0026gt; { std::string data; }; D\u0026lt;float\u0026gt; s{{\u0026#34;hello\u0026#34;}, {4.5,6.7}, \u0026#34;world\u0026#34;}; // OK since C++17 std::cout \u0026lt;\u0026lt; std::is_aggregate\u0026lt;decltype(s)\u0026gt;::value; // outputs: 1 (true) 21.3 std::bool_constant\u0026lt; \u0026gt;。 如果特征产生布尔值，它们现在使用别名模板 bool_constant\u0026lt;\u0026gt;：\nnamespace std { template\u0026lt;bool B\u0026gt; using bool_constant = integral_constant\u0026lt;bool, B\u0026gt;; // since C++17 using true_type = bool_constant\u0026lt;true\u0026gt;; using false_type = bool_constant\u0026lt;false\u0026gt;; } 特征 作用 is_aggregate 是聚合类型 has_unique_object_representations 任何两个具有相同值的对象在内存中具有相同的表示 is_invocable\u0026lt;T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用对象\u0026hellip; is_nothrow_invocable\u0026lt;T,Args\u0026hellip;\u0026gt; 可用作 Args\u0026hellip; 的可调用对象\u0026hellip;无需抛出 is_invocable_r\u0026lt;RT,T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用\u0026hellip; 返回 RT is_nothrow_invocable_r\u0026lt;RT,T,Args\u0026hellip;\u0026gt; 可用作 Args 的可调用对象\u0026hellip;返回 RT 而不抛出 invoke_result\u0026lt;T,Args\u0026hellip;\u0026gt; 如果用作 Args 的可调用结果类型\u0026hellip; is_swappable is_swappable 可以为此类型调用 swap() is_nothrow_swappable 可以为此类型调用 swap() 并且该操作不能抛出 is_swappable_with\u0026lt;T,T2\u0026gt; 可以为这两种具有特定值类别的类型调用 swap() is_nothrow_swappable_with\u0026lt;T,T2\u0026gt; 可以为这两种具有特定值类别的类型调用 swap() 并且该操作不能抛出 conjunction\u0026lt;B\u0026hellip;\u0026gt; 逻辑和布尔特征 B\u0026hellip; disjunction\u0026lt;B\u0026hellip; \u0026gt; 逻辑或布尔特征 B\u0026hellip; negation 逻辑不用于布尔特征 B 在C++17之前，std::true_type和std::false_type分别被直接定义为std::integral_constant\u0026lt;bool,true\u0026gt;和std::integral_constant\u0026lt;bool,false\u0026gt;的别名定义。 尽管如此，如果一个特定的属性适用，布尔特性通常继承自std::true_type，如果不适用则继承自std::false_type。比如说:\n// 主模板：通常 T 不是 void 类型 template\u0026lt;typename T\u0026gt; struct IsVoid : std::false_type { }; // void 类型的特化: template\u0026lt;\u0026gt; struct IsVoid\u0026lt;void\u0026gt; : std::true_type { }; 但是现在你可以通过派生自bool_constant\u0026lt;\u0026gt;来定义你自己的类型特质，如果你能够把相应的编译时表达式表述为布尔条件的话。比如说:\ntemplate\u0026lt;typename T\u0026gt; struct IsLargerThanInt : std::bool_constant\u0026lt;(sizeof(T) \u0026gt; sizeof(int))\u0026gt; { } 这样你就可以使用这样一个特性，根据一个类型是否大于int来进行编译:\ntemplate\u0026lt;typename T\u0026gt; void foo(T x) { if constexpr(IsLargerThanInt\u0026lt;T\u0026gt;::value) { ... } } 通过添加后缀_v的相应变量模板作为内联变量:\ntemplate\u0026lt;typename T\u0026gt; inline static constexpr auto IsLargerThanInt_v = IsLargerThanInt\u0026lt;T\u0026gt;::value; 你也可以缩短该特性的用法，如下所示:\ntemplate\u0026lt;typename T\u0026gt; void foo(T x) { if constexpr(IsLargerThanInt_v\u0026lt;T\u0026gt;) { ... } } 作为另一个例子，我们可以定义一个特质，检查一个类型T的移动构造函数是否保证不抛出，大致如下:\ntemplate\u0026lt;typename T\u0026gt; struct IsNothrowMoveConstructibleT : std::bool_constant\u0026lt;noexcept(T(std::declval\u0026lt;T\u0026gt;()))\u0026gt; { }; 21.4 std::void_t\u0026lt; \u0026gt; 在C++17中，一个小小的，但令人难以置信的有用的定义类型特征的辅助工具被标准化了：std::void_t\u0026lt;\u0026gt;。 它被简单地定义如下：\nnamespace std { template\u0026lt;typename...\u0026gt; using void_t = void; } 也就是说，它对任何模板参数的变量列表都会产生无效。这很有帮助，我们只想在参数列表中处理类型。 主要的应用是在定义新的类型特征时检查条件的能力。下面的例子演示了这个帮助器的应用：\n#include \u0026lt;utility\u0026gt; // 对于declval\u0026lt;\u0026gt;来说 #include \u0026lt;type_traits\u0026gt; // 为true_type，false_type，和void_t // 主模板: template\u0026lt;typename, typename = std::void_t\u0026lt;\u0026gt;\u0026gt; struct HasVarious : std::false_type { }; // 部分专业（可能会被SFINAE所取代）: template\u0026lt;typename T\u0026gt; struct HasVarious\u0026lt;T, std::void_t\u0026lt;decltype(std::declval\u0026lt;T\u0026gt;().begin()), typename T::difference_type, typename T::iterator\u0026gt;\u0026gt; : std::true_type { }; 在这里，我们定义了一个新的类型特质HasVariousT\u0026lt;\u0026gt;，它检查三件事。\n该类型是否有一个成员函数begin()？\n该类型是否有一个类型成员 difference_type？\n该类型是否有一个类型成员迭代器？ 只有当所有相应的表达式都对一个类型T有效时，才会使用部分专业化。那么它就比主模板更具体，而且由于我们从std::true_type派生出来，对这个特征的值进行检查会得到true。\nif constexpr (HasVarious\u0026lt;T\u0026gt;::value) { ... } 如果任何一个表达式的结果是无效的代码（即T没有begin()，或者没有类型成员difference_type，或者没有类型成员iterator），部分专业化就会被SFINAE\u0026rsquo;d掉，这意味着由于替换失败不是错误的规则，它被忽略。然后，只有主模板是可用的，它派生自std::false_type，所以对这个特质的值进行检查会产生false。 同样地，你可以使用std::void_t轻松地定义其他特质来检查一个或多个条件，其中一个成员或操作的存在/能力很重要。\n21.5 后记 标准类型性状的变量模板最早是由Stephan T. Lavavej在2014年提出的 https://wg21.link/n3854。它们最终被采纳为图书馆基本原理TS的一部分 的一部分，由Alisdair Meredith在https://wg21.link/p0006r0。\n类型特质std::is_aggregate\u0026lt;\u0026gt;是作为美国国家机构的评论引入的，用于C++17的标准化。C++17的标准化而引入的（见https://wg21.link/lwg2911）。\nstd::bool_constant\u0026lt;\u0026gt;是由袁志豪在https://wg21.link/n4334 中首次提出的。它们最终被采纳为袁志豪在https://wg21.link/n4389 中的提议。\nstd::void_t_\u0026lt;\u0026gt;是由Walter E. Brown在https://wg21.link/n3911 中提出的，被采用。建设中\n22 并行STL算法 为了从现代多核架构中获益，C++17标准库引入了让STL标准算法使用多线程运行的能力，以并行处理不同的元素。\n许多算法通过一个新的第一参数进行了扩展，以指定是否以及如何在并行线程中运行算法（当然，没有这个参数的老方法仍然被支持）。此外，还引入了一些专门支持并行处理的补充算法。\n一个简单的计时器助手 在本章的例子中，有时我们需要一个定时器来测量算法的速度。为此，我们使用了一个简单的辅助类，它初始化了一个定时器，并提供了printDiff()来打印消耗的毫秒数并重新初始化定时器:\nlib/timer.hpp #ifndef TIMER_HPP #define TIMER_HPP #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;chrono\u0026gt; /******************************************** * timer to print elapsed time ********************************************/ class Timer { private: std::chrono::steady_clock::time_point last; public: Timer() : la st{std::chrono::steady_clock::now()} { } void printDiff(const std::string\u0026amp; msg = \u0026#34;Timer diff: \u0026#34;) { auto now{std::chrono::steady_clock::now()}; std::chrono::duration\u0026lt;double, std::milli\u0026gt; diff{now - last}; std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34;ms\\n\u0026#34;; last = std::chrono::steady_clock::now(); } }; #endif // TIMER_HPP 22.1 使用并行算法 让我们从一些例子程序开始，展示让现有算法并行运行和使用新的并行算法的能力。\n22.1.1 使用并行的for_each() 这是并行运行标准算法 for_each() 的第一个非常简单的示例：\nlib/parforeach.cpp #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; // 对于执行策略 #include \u0026#34;timer.hpp\u0026#34; int main() { int numElems = 1000; struct Data { double value; // 初始值 double sqrt; // 并行计算平方根 }; // 初始化没有平方根的 NumElems 值: std::vector\u0026lt;Data\u0026gt; coll; coll.reserve(numElems); for (int i=0; i\u0026lt;numElems; ++i) { coll.push_back(Data{i * 4.37, 0}); } // 平方根的并行计算: for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); } 正如你所看到的，使用并行算法在原则上是非常容易的。\n包括头文件。 按照你通常调用算法的方式来调用算法，并附加一个第一个参数，这个参数通常是简单的std::execution::par。 在这种情况下，我们使用标准算法for_each()来计算传递的向量coll中所有元素的成员值的平方根。由于额外的第一个参数std::execution::par，我们要求该算法以并行模式运行:\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;execution\u0026gt; ... for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); 像往常一样，coll在这里可以是任何范围。但是请注意，所有的并行算法都要求迭代器至少是前向迭代器（我们在不同的线程中迭代相同的元素，如果迭代器不迭代相同的值，那就没有意义）。 算法并行运行的方式是具体实现的。当然，使用多线程也不一定更快，因为启动和处理多线程也需要时间。\n性能优势 为了找到如何、是否以及何时值得并行运行这个算法，让我们把这个例子修改如下。 lib/parforeach.cpp\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; // for the execution policy #include \u0026#34;timer.hpp\u0026#34; int main() { int numElems = 1000; struct Data { double value; // 初始值 double sqrt; // 并行计算平方根 }; // 初始化没有平方根的 NumElems 值: std::vector\u0026lt;Data\u0026gt; coll; coll.reserve(numElems); for (int i=0; i\u0026lt;numElems; ++i) { coll.push_back(Data{i * 4.37, 0}); } // 平方根的并行计算: for_each(std::execution::par, coll.begin(), coll.end(), [](auto\u0026amp; val) { val.sqrt = std::sqrt(val.value); }); } 关键的修改是。\n我们可以通过命令行传递我们操作的数值的多少。 我们使用类Timer来测量调用算法的持续时间。 我们在一个循环中进行多次测量，以使持续时间更加成熟。 结果在很大程度上取决于所使用的硬件、C++编译器和C++库。在我的笔记本电脑上（在英特尔i7上使用Visual C++，带有2个核心和超线程），我们得到的结果如下。 在100个元素的情况下，顺序算法要快10倍以上。这是因为启动和管理线程需要太多的时间，对于几个元素来说不值得。 对于10,000个元素，我们接近于收支平衡。 对于1,000,000个元素，并行执行的速度大约是3倍。 同样，这也不是一个一般性的证明，在什么地方和什么时候并行算法是值得的。但它表明，即使对于非微不足道的数字运算，也值得使用它们。关键是，它值得用在\n长操作 许多许多元素 例如，使用并行版本的算法count_if()计算一个ints vector中的偶数元素的数量是不值得的。元素的并行版本是不值得的；即使有1,000,000,000个元素也不值得。 auto num = std::count_if(std::execution::par, // execute policy coll.cbegin(), coll.cend(), // 范围 [](int elem){ //准则 return elem % 2 == 0; }); 事实上，对于本例中具有快速谓词的简单算法，并行运行可能永远不会有回报。每个元素都应该发生一些需要大量时间的事情，并且与其他元素的处理无关。 但你无法预测任何事情，因为何时以及如何使用并行线程，都取决于C++标准库的实现者。事实上，无法控制使用多少线程，实现者可能会决定只在一定数量的元素上使用多线程。 测量! 用你的目标平台上的典型场景。\n22.1.2 使用并行的sort() 排序是另一个例子，并行算法可以提供帮助。因为排序标准对每个元素的使用不只一次，你可以节省大量时间。 例如，考虑一下，我们初始化一个字符串的向量如下:\nstd::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; numElems / 2; ++i) { coll.emplace_back(\u0026#34;id\u0026#34; + std::to_string(i)); coll.emplace_back(\u0026#34;ID\u0026#34; + std::to_string(i)); } 也就是说，我们创建一个以 \u0026ldquo;id \u0026ldquo;或 \u0026ldquo;ID \u0026ldquo;开头的元素向量，后面是一个整数:\nid0 ID0 id1 ID1 id2 ID2 id3 ... id99 ID99 id100 ID100 ... 我们可以像往常一样按以下顺序对元素进行排序:\nsort(coll.begin(), coll.end()); 现在也可以通过明确传递一个 \u0026ldquo;顺序 \u0026ldquo;执行策略来实现:\nsort(std::execution::seq, coll.begin(), coll.end()); 如果在运行时决定是顺序运行还是并行运行，并且你不想有不同的函数调用，那么将顺序执行作为参数传递会很有用。 要求用并行排序来代替是很容易的:\nsort(std::execution::par, coll.begin(), coll.end()); 请注意，还有另一个并行执行策略：\nsort(std::execution::par_seq, coll.begin(), coll.end()); 我稍后将解释其中的区别。 所以，问题又来了，（什么时候）使用并行排序更好？在我的笔记本电脑上，只有10,000个字符串，你可以看到排序的时间是顺序排序的一半。而且，即使是对1000个字符串进行排序，使用并行执行也略胜一筹。\n与其他改进措施相结合 请注意，还有其他的修改可能会给你带来更多或额外的好处。例如，如果我们只按数字排序，使用没有两个前导字符的子串，我们可以在谓词中使用字符串操作，并再次看到并行执行的2倍的改进:\nsort(std::execution::par, coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return a.substr(2) \u0026lt; b.substr(2); }); 然而，substr()对于字符串来说是一个相当昂贵的成员函数，因为它创建并返回一个新的临时字符串。通过使用string_view类，我们甚至在连续执行的情况下，也会比以前好3倍。顺序执行的情况下，我们的速度也会提高3倍:\nsort(coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return std::string_view{a}.substr(2) \u0026lt; std::string_view{b}.substr(2); }); 结合使用并行算法，我们的速度提高了多达 10 倍：\nsort(std::execution::par, coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return std::string_view{a}.substr(2) \u0026lt; std::string_view{b}.substr(2); }); 与使用字符串的 substr() 成员的顺序执行相比：\nsort(coll.begin(), coll.end(), [] (const auto\u0026amp; a, const auto\u0026amp; b) { return a.substr(2) \u0026lt; b.substr(2); 22.2 执行策略 你可以把不同的执行策略作为第一个参数传递给并行STL算法。它们被定义在头文件中。表Execution Policies列出了标准化的执行策略。\n策略 意义 std::execution::seq 顺序执行 std::execution::par 并行顺序执行 std::execution::par_unseq 并行无序列（矢量）执行 让我们详细讨论一下执行策略。\n使用seq的顺序执行 意味着和非并行算法一样，当前的执行线程按顺序逐个元素执行必要的操作。使用这个策略的行为应该和使用非并行方式调用算法一样，根本不需要传递任何执行策略。然而，对于接受这个参数的并行算法，可能会有额外的限制，比如for_each()不返回任何值，或者所有的迭代器必须至少是前向迭代器。 提供这个策略是为了能够通过传递一个不同的参数而不是使用一个不同的签名来请求顺序执行。但是请注意，采用这种策略的并行算法的行为可能与相应的非并行算法略有不同。 使用par的并行顺序执行 意味着多个线程可能依次执行元素的必要操作。当一个算法开始执行必要的操作时，它在处理其他元素之前完成这一执行。 与par_unseq相比，这可以确保没有问题或死锁发生，因为在处理完一个元素的步骤后，需要在同一个线程对另一个元素执行第一步之前调用另一个步骤。 使用par_unseq的并行无序执行 意味着多个线程可能为多个元素执行必要的操作，但不能保证一个线程执行该元素的所有步骤而不切换到其他 元素。这特别是使矢量执行成为可能，在这种情况下，一个线程可能首先执行多个元素的第一步 在执行下一个步骤之前，一个线程可能首先执行多个元素的执行步骤。 并行的无序执行需要编译器/硬件的特别支持，以检测哪里和如何操作可以被矢量化。操作如何被矢量化。\n22.3 异常处理 所有的并行算法都会调用std::terminate()，如果元素访问函数通过一个未捕获的异常退出。 请注意，如果选择的是顺序执行策略，这也适用。如果不能接受这种情况，使用算法的非并行版本可能是更好的选择。 还要注意的是，并行算法仍有可能被抛出。如果它们不能为并行执行获得临时的内存资源，它们会抛出std::bad_alloc。然而，没有其他 可能会被抛出。\n22.4 不使用并行算法的好处 有了调用并行算法的能力，以及它们甚至提供了一个顺序执行策略的事实，可能会出现这样的问题：我们是否还需要非并行算法。 然而，除了向后兼容之外，使用非并行算法可能有很大的好处。\n可以使用输入和输出迭代器。 算法不会在异常情况下terminate()。 算法可以避免由于非故意使用元素而产生的副作用。 算法可能提供额外的功能，例如for_each()返回传递的可调用，以便能够处理其结果状态。 22.5 并行算法的概述 表Unmodified Parallel STL Algorithms列出了标准化的算法，可以不加任何修改地支持并行处理。 表Modified Parallel STL Algorithms列出了经过一些修改的支持并行处理的标准化算法。 表STL算法无并行化列出了不支持并行处理的算法。 请注意，对于 accumulate() 和 inner_product() ，新的并行算法被提供了宽松的要求。放宽了要求。\n算法 备注 find_end(), adjacent_find() 除了搜索者 search(), search_n() swap_ranges() replace(), replace_if() fill() generate() remove(), remove_if() unique() reverse() rotate() partition(), stable_partition() sort(), stable_sort(), partial_sort() is_sorted(), is_sorted_until() nth_element() inplace_merge() is_heap(), is_heap_until() min_element(), max_element(), min_max_element() 除了搜索者 for_each() 前向迭代器和返回类型 void all_of(), any_of(), none_of() 前向迭代器 for_each_n() find(), find_if(), find_if_not() find_first_of() count(), count_if() mismatch() equal() is_partitioned() partial_sort_copy() includes() lexicographical_compare() fill_n() generate_n() reverse_copy() rotate_copy() copy(), copy_n(), copy_if() move() transform() replace_copy(), replace_copy_if() remove_copy(), remove_copy_if() unique_copy() partition_copy() merge() set_union(), set_intersection() set_difference(), set_symmetric_difference() exclusive_scan(), inclusive_scan() 前向迭代器 accumulate(), inner_product(), partial_sum() 改用 reduce() 和 transform_reduce() search() with searcher copy_backward() move_backward() sample(), shuffle() partition_point() lower_bound(), upper_bound(), equal_range() binary_search() is_permutation(), next_permutation(), prev_permutation() push_heap(), pop_heap(), make_heap(), sort_heap() 改用 reduce() 和 transform_reduce() 22.6 并行处理的新算法 一些补充算法被引入，以处理自C++98以来可用的标准算法的并行处理。\n22.6.1 reduce() 例如，reduce()是作为 accumulate()的平行形式引入的，它 \u0026ldquo;累积 \u0026ldquo;所有元素（你可以定义，哪个操作执行 \u0026ldquo;累积\u0026rdquo;）。例如，考虑以下 accumulate() 的用法。\nlib/accumulate.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for accumulate() void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::accumulate(coll.begin(), coll.end(), 0L); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 我们计算所有元素的总和，输出：\naccumulate(): 10 accumulate(): 10000 accumulate(): 10000000 换算运算的平行化 这个程序可以通过改用reduce()来实现并行化:\nlib/reduce.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for reduce() #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::reduce(std::execution::par, coll.begin(), coll.end(), 0L); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在输出相同的情况下，现在的程序可能运行得更快或更慢（取决于是否支持启动多线程，以及所花费的时间是否比我们并行运行算法所节省的时间多）。 这里使用的操作是+，它是换元的，所以加入积分元素的顺序并不重要。\n非共轭运算的并行化 然而，对于浮点值来说，顺序很重要，这就证明了以下程序:\nlib/reducefloat.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 0.1 0.3 0.0001 的 num 个序列创建 coll: std::vector\u0026lt;double\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {0.1, 0.3, 0.00001}); } auto sum1 = std::accumulate(coll.begin(), coll.end(), 0.0); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; auto sum2 = std::reduce(std::execution::par, coll.begin(), coll.end(), 0.0); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; (sum1==sum2 ? \u0026#34;equal\\n\u0026#34; : \u0026#34;differ\\n\u0026#34;); } #include\u0026lt;iomanip\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::setprecision(20); printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 这里我们同时使用 accumulate() 和 reduce() 并比较结果。一个可能的输出是:\naccumulate(): 0.40001 reduce(): 0.40001 equal accumulate(): 400.01 reduce(): 400.01 differ accumulate(): 400010 reduce(): 400010 differ accumulate(): 4.0001e+06 reduce(): 4.0001e+06 differ 虽然结果看起来是一样的，但有时会有差异。这可能是以不同的顺序添加 的顺序不同而造成的。 如果我们改变打印浮点值的精度:\nstd::cout \u0026lt;\u0026lt; std::setprecision(20); 我们可以看到结果值略有不同：\naccumulate(): 0.40001000000000003221 reduce(): 0.40001000000000003221 equal accumulate(): 400.01000000000533419 reduce(): 400.01000000000010459 differ accumulate(): 400009.99999085225863 reduce(): 400009.9999999878346 differ accumulate(): 4000100.0004483023658 reduce(): 4000100.0000019222498 differ 由于没有定义是否、何时以及如何实现并行算法，因此在某些平台上的结果可能看起来是一样的（达到一定数量的元素）。\n非关联性操作的并行化 现在让我们改变一下操作，通过总是添加每个值的平方来累积值:\nlib/accumulate2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // 对于 accumulate() void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll： std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; auto sum = std::accumulate(coll.begin(), coll.end(), 0L, squaredSum); std::cout \u0026lt;\u0026lt; \u0026#34;accumulate(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在这里，我们传递一个lambda，对于每一个值，都要取当前的和，并加上新值的平方:\nauto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; 使用 accumulate() 输出看起来很好:\naccumulate(): 30 accumulate(): 30000 accumulate(): 30000000 accumulate(): 300000000 但是，让我们使用 reduce() 切换到并行处理：\nlib/reduce2.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // 对于reduce() #include \u0026lt;execution\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll： std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto squaredSum = [] (auto sum, auto val) { return sum + val * val; }; auto sum = std::reduce(std::execution::par, coll.begin(), coll.end(), 0L, squaredSum); std::cout \u0026lt;\u0026lt; \u0026#34;reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 输出可能会变成这样：\nreduce(): 30 reduce(): 30000 reduce(): -425251612 reduce(): 705991074 是的，结果有时可能是错误的。问题是，该操作不是关联性的。例如，如果我们对元素1、2和3应用这个操作，我们可能先计算0+11和2+33，但当我们把中间的结果结合起来时，我们又把3平方了，基本上是 计算:\n(0+1*1) + (2+3*3) * (2+3*3) 但为什么这里的结果有时是正确的呢？嗯，似乎在这个平台上，reduce()只在一定数量的元素中并行运行。而这是完全可以的。因此，使用有足够多元素的测试案例来检测这样的问题。 解决这个问题的方法是使用另一种新的算法，transform_reduce()。它把我们要对每个元素进行的修改（这是我们可以并行化的一件事）和结果的累积分开，只要它是换元的（这是我们可以并行化的另一件事）。\nlib/transformreduce.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; // for transform_reduce() #include \u0026lt;execution\u0026gt; #include \u0026lt;functional\u0026gt; void printSum(long num) { // 用 1 2 3 4 的 num 个序列创建 coll: std::vector\u0026lt;long\u0026gt; coll; coll.reserve(num * 4); for (long i=0; i \u0026lt; num; ++i) { coll.insert(coll.end(), {1, 2, 3, 4}); } auto sum = std::transform_reduce(std::execution::par, coll.begin(), coll.end(), 0L, std::plus{}, [] (auto val) { return val * val; }); std::cout \u0026lt;\u0026lt; \u0026#34;transform_reduce(): \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { printSum(1); printSum(1000); printSum(1000000); printSum(10000000); } 在调用transform_reduce()时，我们传递了\n执行策略，以便（允许）并行地运行这个程序 要处理的值的范围 0L作为外部累加的初始值 操作+作为外部累加的操作 一个lambda，用于在累加之前处理每个值 transform_reduce()可能是迄今为止最重要的并行算法，因为我们经常在合并数值之前修改它们（也称为map reduce原则）。\n用于文件系统操作的transform_reduce()函数 下面是另一个并行运行transform_reduce()的例子:\nlib/dirsize.cpp\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; // for transform_reduce() #include \u0026lt;execution\u0026gt; // 对于执行策略 #include \u0026lt;filesystem\u0026gt; // filesystem library int main(int argc, char* argv[]) { // 根目录作为命令行参数被传递: if (argc \u0026lt; 2) { std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;path\u0026gt; \\n\u0026#34;; return EXIT_FAILURE; } std::filesystem::path root{argv[1]}; // 在通过的文件树中启动所有文件路径的列表: std::vector\u0026lt;std::filesystem::path\u0026gt; paths; try { std::filesystem::recursive_directory_iterator dirpos{root}; std::copy(begin(dirpos), end(dirpos), std::back_inserter(paths)); } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;EXCEPTION: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } // 累积所有常规文件的大小: auto sz = std::transform_reduce( std::execution::par, // 并行执行 paths.cbegin(), paths.cend(), // range std::uintmax_t{0}, // 初始值 std::plus\u0026lt;\u0026gt;(), // accumulate ... [](const std::filesystem::path\u0026amp; p) { // 如果是普通文件，文件大小 return is_regular_file(p) ? file_size(p) : std::uintmax_t{0}; }); std::cout \u0026lt;\u0026lt; \u0026#34;size of all \u0026#34; \u0026lt;\u0026lt; paths.size() \u0026lt;\u0026lt; \u0026#34; regular files: \u0026#34; \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 首先，我们递归地收集作为命令行参数的目录中的所有文件系统路径:\nstd::filesystem::path root{argv[1]}; std::vector\u0026lt;std::filesystem::path\u0026gt; paths; std::filesystem::recursive_directory_iterator dirpos{root}; std::copy(begin(dirpos), end(dirpos), std::back_inserter(paths)); 请注意，由于我们可能会传递一个无效的路径，可能的（文件系统）异常会被捕获。 然后，我们遍历文件系统路径的集合，积累它们的大小，如果它们是 正常的文件:\nauto sz = std::transform_reduce( std::execution::par, // 并行执行 paths.cbegin(), paths.cend(), // range std::uintmax_t{0}, // initial value std::plus\u0026lt;\u0026gt;(), // accumulate ... [](const std::filesystem::path\u0026amp; p) { // 文件大小（如果是常规文件） return is_regular_file(p) ? file_size(p) : std::uintmax_t{0}; }); 新的标准算法transform_reduce()的操作方法如下。\n最后一个参数被应用于每个元素。在这里，对每个路径元素调用传递的lambda，如果它是一个普通文件，则查询其大小。 第二个但也是最后一个参数是合并所有大小的操作。因为我们要累积大小，所以我们使用标准函数对象std::plus\u0026lt;\u0026gt;。 第三个但也是最后一个参数是合并所有大小的操作的初始值。因此，如果路径列表是空的，我们从0开始。我们使用与file_size()的返回值相同的类型，std::uintmax_t。 请注意，询问文件的大小是一个相当昂贵的操作，因为它需要一个操作系统调用。由于这个原因，使用一个算法来调用这个转换（从路径到大小），并以任何顺序与多个线程并行，并计算出总和，是非常快的回报。第一次测量显示了一个明显的胜利（程序的速度提高了一倍）。 还要注意的是，你不能把目录迭代器所迭代的路径直接传递给并行的 算法，因为目录迭代器是输入迭代器，而并行算法需要正向的 迭代器。 最后请注意，transform_reduce()被定义在头文件中，而不是。 (就像 accumulate() 一样，它也算作数字算法。\n22.7 并行算法的详细介绍 22.8 后记 2012 年，Jared Hoberock Michael Garland Olivier Giroux Vinod Grover、Ujval Kapasi 和 Jaydeep Marathe 在 https://wg21.link/n3408 中首次提出了并行化 STL 算法。 它成为了一个正式的 beta 标准，即并行 C++ 扩展技术规范（参见 https://wg21.link/n3850）。 Jared Hoberock、Grant Mercer、Agustin Berge 和 Harmut Kaiser 在 https://wg21.link/n4276 中添加了其他算法。 通过 https://wg21.link/p0024r2，Jared Hoberock 提出的标准库采用了 C++ 并行扩展技术规范。 JF Bastien 和 Bryce Adelstein Lelbach 在 https://wg21.link/p0394r4 中提出的异常处理被接受。\n23 子字符串和子序列搜索 自C++98以来，C++标准库提供了一种搜索算法来寻找一个范围内元素的子序列。然而，存在着不同的搜索算法。例如，通过预先计算关于要搜索的模式的统计数据，这些算法对于特殊的任务，如在一个大文本中寻找子串，可以有明显的表现。 因此，C++17引入了Boyer-Moore和Boyer-Moore-Horspool搜索算法以及使用它们的各种接口。它们特别适用于搜索大文本中的子串，但也可以改进寻找容器或范围中的子序列。\n23.1 使用子串搜索器 新的搜索器是专门为搜索大型文本中的字符串（例如，单词或短语）而开发的。 因此，让我们首先演示一下在这种情况下如何使用它们，以及你如何利用它们来获益。\n23.1.1 通过search()使用搜索器 我们现在有以下选项来搜索一个字符串文本中的子串子:\n字符串成员 find(): std::size_type idx = text.find(sub)。 算法搜索()。 auto pos = std::search(text.begin(), text.end(), sub.begin(), sub.end())。 并行算法 search(): auto pos = std::search(std::execution::par, text.begin(), text.end(), sub.begin(), sub.end()）。 使用 default_searcher: auto pos = std::search(text.begin(), text.end(), std::default_searcher{sub.begin(), sub.end()})。 使用boyer_moore_searcher: auto pos = std::search(text.begin(), text.end(), std::boyer_moore_searcher{sub.begin(), sub.end()}）。 使用boyer_moore_horspool_searcher: auto pos = std::search(text.begin(), text.end(), std::boyer_moore_horspool_searcher{sub.begin(), sub.end()}）。 新的搜索器被定义在中。 Boyer-Moore和Boyer-Moore-Horspool搜索器是众所周知的算法，在搜索开始前预先计算表格（哈希值），以提高搜索的速度，如果搜索覆盖了相当大的文本和/或子串。使用它们，算法需要随机访问的迭代器（而不是正向迭代器，这对于天真的搜索（）来说已经足够了）。\n在lib/searcher1.cpp中，你可以找到一个完整的程序，演示如何使用这些不同的方式来搜索子串。 请注意，所有search()的应用都会产生一个指向匹配子串的第一个字符的迭代器。如果没有，则返回文本的末端。这样我们就可以搜索到一个子串的所有出现，如下所示。\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; for (auto pos = std::search(text.begin(), text.end(), bm); pos != text.end(); pos = std::search(pos+sub.size(), text.end(), bm)) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; pos - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 搜索器的性能 哪一种是搜索子字符串的最佳方法（最快和/或最少的内存）？ 这个问题的一个特殊方面是我们现在也可以在并行模式下使用传统的 search() （使用新的搜索器时这是不可能的）。 答案取决于具体情况：\n仅使用（非并行）search() 通常是最慢的，因为对于文本中的每个字符，我们开始找出子字符串是否匹配。\n使用 default_searcher 应该是等价的，但我看到更糟糕的运行时间高达 3 倍。\n使用find()可能会更快，但这取决于库中实现的质量。在我所做的测量中，我看到与search()相比，运行时间提高了20%到100倍之间。\n对于文本和相当大小的子串，boyer_moore_searcher应该是最快的。与search()相比，我看到了50倍甚至100倍的改进。在有大量子串的大文本中，这始终是最快的搜索。\nboyer_moore__horspool_searcher以空间换时间。它通常比boyer_moore_searcher慢，但不应该使用那么多内存。我看到的改进在不同的平台上确实有很大的不同。在一个平台上，它接近boyer_moore（比search()好50倍，比find()好10倍），而在其他平台上，对search()的改进只有2或3倍，而使用find()则快得多。\n使用并行的search()与普通的search()相比，我得到了3倍的支持，看起来使用Boyer-Moore搜索器通常还是要快很多。\n所以我只能给出一个建议。测量! 在你的目标平台上测试典型场景。 这是值得的，因为你可能会得到100倍的改进（例如，我在一个有1000万个字符的字符串中搜索一个接近结尾的1000个字符的子串）。 lib/searcher1.cpp中的代码还打印了不同搜索选项的测量值，这样你就可以比较你的平台上的数字。\n23.1.2 直接使用搜索器 或者，你可以使用搜索器的函数调用操作，它返回一对开始和结束的一对子序列。 代码看起来如下。\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; for (auto begend = bm(text.begin(), text.end()); begend.first != text.end(); begend = bm(begend.second, text.end())) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; begend.first - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; begend.second - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 然而，由于你可以使用std::tie()将新的值重新分配给结构化绑定的 std::pair\u0026lt;\u0026gt;，你可以将代码简化如下:\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; for (auto [beg, end] = bm(text.begin(), text.end()); beg != text.end(); std::tie(beg,end) = bm(end, text.end())) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; at index \u0026#34; \u0026lt;\u0026lt; beg - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; end - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 只是直接使用搜索器寻找子串的第一次出现，你可以使用如果与 初始化和结构化绑定:\nstd::boyer_moore_searcher bm{sub.begin(), sub.end()}; ...; if (auto [beg, end] = bm(text.begin(), text.end()); beg != text.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;found \u0026#39;\u0026#34; \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; \u0026#34;\u0026#39; first at index \u0026#34; \u0026lt;\u0026lt; beg - text.begin() \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; end - text.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 23.2 使用通用子序列搜索器 Boyer-Moore 和 Boyer-Moore-Horspool 是作为字符串搜索器开发的。 但是，C++17 采用它们作为通用算法，以便您可以使用它们在容器或范围中查找元素的子序列。 也就是说，您现在可以实现以下内容：\nstd::vector\u0026lt;int\u0026gt; coll; ...; std::deque\u0026lt;int\u0026gt; sub{0, 8, 15, ...}; pos = std::search(coll.begin(), coll.end(), std::boyer_moore_searcher{sub.begin(), sub.end()}); 同样，您还可以使用搜索器的函数调用运算符：\nstd::vector\u0026lt;int\u0026gt; coll; ...; std::deque\u0026lt;int\u0026gt; sub{0, 8, 15, ...}; std::boyer_moore_searcher bm{sub.begin(), sub.end()}; auto [beg, end] = bm(coll.begin(), coll.end()); if (beg != coll.end) { std::cout \u0026lt;\u0026lt; \u0026#34;found subsequence at \u0026lt;\u0026lt; \u0026#34; beg - coll.begin() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 为了实现这一点，元素必须能够在哈希表中使用（即必须提供一个默认的哈希函数，并且必须支持用==来比较两个元素）。如果不是这种情况，你可以使用谓词（如下所述）。 再说一遍。测量发现你在性能（速度和内存）方面的好处。在尝试一些例子时，我看到了更多不同的因素。例如，使用boyer_moore_searcher可以将搜索的速度再次提高100倍（这又比使用并行算法快多了）。但是使用boyer_moore_horspool_searcher可以使搜索速度提高50倍，但也会慢2倍。 lib/searcher2.cpp中的代码演示了对一个向量中的子序列的不同搜索，还打印了不同搜索选项的测量结果，这样你就可以比较 在你的平台上进行比较。\n23.3 使用搜索器的谓词 使用搜索时，您可以使用谓词，这可能是必要的，原因有两个：\n您想定义自己的方式来比较两个元素。\n你想提供一个哈希函数，这对于 Boyer-Moore(-Horspool) 搜索器是必需的。 您必须将谓词作为附加参数提供给搜索器的构造函数。 例如，这里我们不区分大小写地搜索子字符串：\nstd::boyer_moore_searcher bmic{substr.begin(), substr.end(), [](char c){ return std::hash\u0026lt;char\u0026gt;{}(std::toupper(c)); }, [](char c1, char c2){ return std::toupper(c1)==std::toupper(c2); } }; auto begend = bmic(sub.begin(), sub.end()); 在散列值之前不要忘记调用 toupper()，否则你违反了散列值对于所有值必须相同的要求，其中 operator== 产生 true。 在这里，如果我们有一个类 Customer 定义如下：\nclass Customer { ...; public: Customer() = default; std::string getID() const { return id; } friend bool operator== (const Customer\u0026amp; c1, const Customer\u0026amp; c2) { return c1.id == c2.id; } }; 我们可以在Customer vector中搜索客户子序列，如下所示：\nstd::vector\u0026lt;Customer\u0026gt; customers; ...; std::vector\u0026lt;Customer\u0026gt; sub{...}; ...; std::boyer_moore_searcher bmcust(sub.begin(), sub.end(), [](const Customer\u0026amp; c) { return std::hash\u0026lt;std::string\u0026gt;{}(c.getID()); }); auto pos = bmcust(customers.begin(), customers.end()); if (pos.first != customers.end()) { ...; } 但是请注意，使用谓词可能会给使用搜索器带来很大的开销，所以只有当你有大量的元素并搜索一个相当大的子序列时才值得使用它们（例如，在100万个客户的集合中寻找1000个客户的子序列）。 再次强调。要有大的思维，要有大的度量。\n23.4 后记 这些搜索最初是由 Marshall Clow 在 https://wg21.link/n3411 中提出的，将 Boost.Algorithm 作为参考实现。 它们成为第一个图书馆基础 TS 的一部分。 对于 C++17，它们随后与 Beman Dawes 和 Alisdair Meredith 在 https://wg21.link/p0220r1 中提出的其他组件一起采用，包括 Marshall Clow 在 https://wg21.link/p0253R1 中提出的接口修复。\n24 其他工具函数和算法 C++17 提供了一些新的实用函数和算法，本章将对其进行介绍。\n24.1 size(), empty(), and data() 为了支持通用代码的灵活性，C++标准库提供了三个新的辅助函数：size()、empty()和data()。 正如其他用于泛型代码迭代范围和集合的全局辅助函数std::begin(), std::end(), 和std::advance()一样，这些函数被定义在头文件中。\n24.1.1 通用的size()函数 通用的std::size()函数允许我们询问任何范围的大小，只要它有一个迭代器接口或者是一个原始数组。有了它，你可以写这样的代码:\nlib/last5.hpp\n#ifndef LAST5_HPP #define LAST5_HPP #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printLast5(const T\u0026amp; coll) { // 计算大小: auto size{std::size(coll)}; // 前进到从最后 5 个元素开始的位置 std::cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; elems: \u0026#34;; auto pos{std::begin(coll)}; if (size \u0026gt; 5) { std::advance(pos, size - 5); std::cout \u0026lt;\u0026lt; \u0026#34;... \u0026#34;; } // 打印剩余元素: for ( ; pos != std::end(coll); ++pos) { std::cout \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif // LAST5_HPP 在这里，与\nauto size{std::size(coll)}; 我们用传递的集合的大小来初始化 size，它要么映射到 coll.size() 要么映射到传递的原始数组的大小。 因此，如果我们调用：\nstd::array arr{27, 3, 5, 8, 7, 12, 22, 0, 55}; std::vector v{0.0, 8.8, 15.15}; std::initializer_list\u0026lt;std::string\u0026gt; il{\u0026#34;just\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;literals\u0026#34;}; printLast5(arr); printLast5(v); printLast5(il); 输出是：\n9 elems: ... 7 12 22 0 55 3 elems: 0 8.8 15.15 5 elems: just five small string literal 并且因为支持原始 C 数组，我们也可以调用:\nprintLast5(\u0026#34;hello world\u0026#34;); 打印:\n12 elems: ... o r l d 请注意，此函数模板因此替换了使用 countof 或 ARRAYSIZE 定义为类似以下内容的计算数组大小的常用方法：\n#define ARRAYSIZE(a) (sizeof(a)/sizeof(*(a))) 另请注意，您不能将内联定义的初始化列表传递给 last5\u0026lt;\u0026gt;()。 原因是模板参数不能推导出 std::initializer_list()。 为此，您必须使用以下声明重载 last5()：\ntemplate\u0026lt;typename T\u0026gt; void printLast5(const std::initializer_list\u0026lt;T\u0026gt;\u0026amp; coll) 最后，请注意此代码不适用于 forward_list\u0026lt;\u0026gt;，因为转发列表没有成员函数 size()。 所以，如果你只想检查集合是否为空，你最好使用std::empty()，这将在后面讨论。\n24.1.2 通用的empty()函数 与新的全局 size() 类似，新的通用 std::empty() 允许我们检查容器、原始 C 数组或 std::initializer_list\u0026lt;\u0026gt; 是否为空。 因此，与上面的示例类似，您可以一般地检查传递的集合是否为空：\nif (std::empty(coll)) { return; } 与 std::size() 相比，std::empty() 也适用于前向列表/\n24.1.3 通用的data()函数 最后，新的通用 std::data() 函数允许我们访问具有 data() 成员和原始数组的容器的原始数据。 容器、原始 C 数组或 std::initializer_list\u0026lt;\u0026gt;。 例如，以下代码每隔一个元素打印一次：\nlib/data.hpp #ifndef DATA_HPP #define DATA_HPP #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printData(const T\u0026amp; coll) { // 每隔一个元素打印一次: for (std::size_t idx{0}; idx \u0026lt; std::size(coll); ++idx) { if (idx % 2 == 0) { std::cout \u0026lt;\u0026lt; std::data(coll)[idx] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif // DATA_HPP 因此，如果我们调用：\nstd::array arr{27, 3, 5, 8, 7, 12, 22, 0, 55}; std::vector v{0.0, 8.8, 15.15}; std::initializer_list\u0026lt;std::string\u0026gt; il{\u0026#34;just\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;literals\u0026#34;}; printData(arr); printData(v); printData(il); printData(\u0026#34;hello world\u0026#34;); 输出：\n27 5 7 22 55 0 15.15 just small literals h l o w r d 24.2 as_const() 新的辅助函数 std::as_const() 将值转换为相应的 const 值，而不使用 static_cast\u0026lt;\u0026gt; 或 add_const_t\u0026lt;\u0026gt; 类型特征。 它允许我们强制为非 const 对象调用函数的 const 重载，以防万一：\nstd::vector\u0026lt;std::string\u0026gt; coll; foo(coll); // 喜欢非常量重载 foo(std::as_const(coll)); // 强制使用 const 重载 如果 foo() 是一个函数模板，这也将强制将模板实例化为 const 类型而不是原始的非常量类型。\n24.2.1 通过常量引用进行捕获 as_const() 的一种应用是通过 const 引用捕获 lambda 参数的能力。 例如：\nstd::vector\u0026lt;int\u0026gt; coll {8, 15, 7, 42}; auto printColl = [\u0026amp;coll = std::as_const(coll)] { std::cout \u0026lt;\u0026lt; \u0026#34;coll: \u0026#34;; for (int elem : coll) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; 现在调用:\nprintColl(); 将打印 coll 的当前状态，而不会有意外修改其值的危险。\n24.3 clamp() C++17 提供了一个新的实用函数clamp()，它可以在传递的最小值和最大值之间“钳制”一个值。 它是 min() 和 max() 的组合调用。 例如： lib/clamp.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // for sample() int main() { for (int i : {-7, 0, 8, 15}) { std::cout \u0026lt;\u0026lt; std::clamp(i, 5, 13) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 调用clamp(i, 5, 13) 与调用std::min(std::max(i, 5), 13) 的效果相同，因此程序具有以下输出：\n5 5 8 13 至于 min() 和 max()，clamp() 要求所有通过 const 引用传递的参数都具有相同的类型 T：\nnamespace std { template\u0026lt;typename T\u0026gt; constexpr const T\u0026amp; clamp(const T\u0026amp; value, const T\u0026amp; min, const T\u0026amp; max); } 返回值是对传递参数之一的 const 引用。 如果传递不同类型的参数，则可以显式指定模板参数 T：\ndouble d{4.3}; int max{13}; ... std::clamp(d, 0, max); // 编译时错误 std::clamp\u0026lt;double\u0026gt;(d, 0, max); // OK 你也可以传递浮点值，只要它们没有 NaN 值。 至于 min() 和 max() 你可以传递一个谓词作为比较操作。 例如：\nfor (int i : {-7, 0, 8, 15}) { std::cout \u0026lt;\u0026lt; std::clamp(i, 5, 13, [] (auto a, auto b) { return std::abs(a) \u0026lt; std::abs(b); }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 具有以下输出：\n-7 5 8 13 因为 -7 的绝对值介于 5 和 13 的绝对值之间，所以在这种情况下，clamp() 产生 -7。 没有采用值的初始化列表（如 min() 和 max() 所具有的）的 clamp() 的重载。\n24.4 sample() 通过sample()，C++17提供了一种算法，可以从一个给定的数值范围（群体）中提取一个随机子集（样本）。这有时被称为蓄水池采样或选择采样。 考虑一下下面的例子程序。\nlib/sample1.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; // for clamp() #include \u0026lt;random\u0026gt; // for default_random_engine int main() { // 初始化一个包含 10,000 个字符串值的vector: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(\u0026#34;value\u0026#34; + std::to_string(i)); } // 打印此集合的 10 个随机选择的值: sample(coll.begin(), coll.end(), std::ostream_iterator\u0026lt;std::string\u0026gt;{std::cout, \u0026#34;\\n\u0026#34;}, 10, std::default_random_engine{}); } 在使用大量字符串值（value0、value1、\u0026hellip;）初始化向量后，我们使用 sample() 来提取这些字符串值的随机子集：\n// 打印此集合的 10 个随机选择的值: sample(coll.begin(), coll.end(), std::ostream_iterator\u0026lt;std::string\u0026gt;{std::cout, \u0026#34;\\n\u0026#34;}, 10, std::default_random_engine{}); 我们通过：\n我们从中提取值子集的范围的开始和结束， 一个迭代器，用于将提取的值写入（这里是一个 ostream 迭代器将它们写入标准输出） 要提取的值的最大数量（我们可能会提取较少的值，范围太小） 用于计算随机子集的随机引擎 结果，我们打印了 coll 的 10 个元素的随机子集。 输出可能是：\nvalue0 value488 value963 value1994 value2540 value2709 value2835 value3518 value5172 value7996 如您所见，元素的顺序是稳定的（与它们在 coll 中的顺序相匹配）。 但是，只有在传递范围的迭代器至少是前向迭代器时，才能保证这一点。 算法声明如下：\nnamespace std { template\u0026lt;typename InputIterator, typename OutputIterator, typename Distance, typename UniformRandomBitGenerator\u0026gt; OutputIterator sample(InputIterator sourceBeg, InputIterator sourceEnd, OutputIterator destBeg, Distance num, UniformRandomBitGenerator\u0026amp;\u0026amp; eng); } 它具有以下规范和约束：\n源范围的迭代器必须至少是输入迭代器，目标范围的迭代器必须至少是输出迭代器。 但是，两者都不可能。 如果源迭代器不是最小前向迭代器，则目标迭代器必须是随机访问迭代器。 像往常一样，目标迭代器会覆盖，如果没有足够的元素可以覆盖并且没有使用插入器，则会导致未定义的行为。 该算法返回最后一个复制元素之后的位置。 目标迭代器不得在传递的源范围内。 num 可以是整数类型。 如果源范围内的元素不足，则提取源范围内的所有元素。 提取元素的顺序是稳定的，除非源范围内的迭代器是纯输入迭代器。 这是另一个演示 sample() 用法的示例：\nlib/sample2.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; // for clamp() #include \u0026lt;random\u0026gt; // for default_random_engine int main() { // initialize a vector of 10,000 string values: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(\u0026#34;value\u0026#34; + std::to_string(i)); } // 使用随机种子初始化 Mersenne Twister 引擎: std::random_device rd; // 随机种子（如果支持） std::mt19937 eng{rd()}; // Mersenne twister engine // 初始化目标范围（必须足够大以容纳 10 个元素）: std::vector\u0026lt;std::string\u0026gt; subset; subset.resize(100); // 将 10 个随机选择的值从源范围复制到目标范围: auto end = sample(coll.begin(), coll.end(), subset.begin(), 10, eng); // 打印提取的元素（使用返回值作为新的结束）: for_each(subset.begin(), end, [] (const auto\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;random elem: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); } 在再次用大量字符串值（value0，value1，\u0026hellip;）初始化一个vector之后，我们初始化一个用随机种子初始化的随机数引擎：\n// 用一个随机种子初始化一个Mersenne Twister引擎: std::random_device rd; // 随机种子（如果支持） std::mt19937 eng{rd()}; // Mersenne Twister引擎 和一个目标范围:\n// 初始化目标范围（必须足够大以容纳 10 个元素）: std::vector\u0026lt;std::string\u0026gt; subset; subset.resize(100); sample() 的调用现在将源范围的 10 个元素复制到目标范围：\n// 将 10 个随机选择的值从源范围复制到目标范围: auto end = sample(coll.begin(), coll.end(), subset.begin(), 10, eng); 返回值 end 初始化为包含最后一个随机提取的元素后面的位置，之后可以使用该位置，例如，打印提取的元素：\n// 打印提取的元素（使用返回值作为新的结束）： for_each(subset.begin(), end, [] (const auto\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;random elem: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); 24.5 for_each_n() 作为并行 STL 算法的一部分，提出了一种新算法 for_each_n()，该算法从 C++17 开始也以传统的非并行形式提供。 与 copy_n()、fill_n() 和 generate_n() 类似，它需要一个整数参数来将传递的可调用对象应用于给定范围的 n 个元素。 例如： lib/foreachn.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; // for for_each_n() int main() { // 初始化一个包含 10,000 个字符串值的vector: std::vector\u0026lt;std::string\u0026gt; coll; for (int i=0; i \u0026lt; 10000; ++i) { coll.push_back(std::to_string(i)); } // 修改前 5 个元素： for_each_n(coll.begin(), 5, [] (auto\u0026amp; elem) { elem = \u0026#34;value\u0026#34; + elem; }); // 打印前 10 个元素： for_each_n(coll.begin(), 10, [] (const auto\u0026amp; elem) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); } 在用大量字符串值（value0、value1、\u0026hellip;）初始化一个vector后，我们首先修改前 5 个字符串：\nfor_each_n(coll.begin(), 5, [] (auto\u0026amp; elem) { elem = \u0026#34;value\u0026#34; + elem; }); 然后打印前 10 个字符串：\nfor_each_n(coll.begin(), 10, [] (const auto\u0026amp; elem) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); 因此，该程序具有以下输出：\nvalue0 value1 value2 value3 value4 5 6 7 8 9 算法声明如下：\nnamespace std { template\u0026lt;typename InputIterator, typename Size, typename Function\u0026gt; InputIterator for_each_n(InputIterator first, Size n, Function f); } 请注意以下事项：\nfor_each_n() 的非并行版本保证为每个元素按顺序调用传递的可调用对象。 for_each_n() 算法作为迭代器返回最后处理的元素后面的位置。 由调用者确保给定范围有足够的元素。 传递的可调用对象的任何返回值都将被忽略。 该算法也可用作并行 STL 算法，它允许我们将任何函数应用于前 n 个元素，而无需保证任何顺序。\n24.6 后记 size()、empty() 和 data() 最早由 Riccardo Marcangelo 在 https://wg21.link/n4017 中提出。 最终接受的措辞由 Riccardo Marcangelo 在 https://wg21.link/n4280 中制定。 as_const() 由 ADAM David Alan Martin 和 Alisdair Meredith 在 https://wg21.link/n4380 中首次提出。 最终接受的措辞由 ADAM David Alan Martin 和 Alisdair Meredith 在 https://wg21.link/p0007r1 中制定。 clamp() 由 Martin Moene 和 Niels Dekker 在 https://wg21.link/n4536 中首次提出。 最终接受的措辞由 Martin Moene 和 Niels Dekker 在 https://wg21.link/p002501 中制定。\nsample() 由 Walter E. Brown 在 https://wg21.link/n3842 中首次提出。 最终接受的措辞由 Walter E. Brown 在 https://wg21.link/n3925 中制定。\n25 容器扩展 C++ 标准库的标准容器有一些细微的变化，本章将对此进行描述。\n25.1 支持不完整的容器类型 由于 C++17 需要 std::vector、std::list 和 std__forward_list 来支持不完整类型。 这样做的主要动机在 Matt Austern 的一篇名为“标准图书馆员：不完整类型的容器”的文章中进行了描述（参见 http://drdobbs.com/184403814）：您现在可以拥有一个类型，它递归地拥有一个成员 其类型的容器。 例如：\nstruct Node { std::string value; std::vector\u0026lt;Node\u0026gt; children; // 好的，因为 C++17（节点在这里是不完整的类型） }; 这也适用于具有私有成员和公共 API 的类。 这是一个完整的例子：\nlib/incomplete.hpp\n#ifndef NODE_HPP #define NODE_HPP #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Node { private: std::string value; std::vector\u0026lt;Node\u0026gt; children; // 好的，因为 C++17（节点在这里是不完整的类型） public: // 创建一个带值的节点: Node(std::string s) : value{std::move(s)}, children{} { } // 添加子节点: void add(Node n) { children.push_back(std::move(n)); } // 访问子节点: Node\u0026amp; operator[](std::size_t idx) { return children.at(idx); } // 递归打印节点树: void print(int indent = 0) const { std::cout \u0026lt;\u0026lt; std::string(indent, \u0026#39; \u0026#39;) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (const auto\u0026amp; n : children) { n.print(indent+2); } } ...; }; #endif // NODE_HPP 您可以使用此类，例如，如下所示：\nlib/incomplete.cpp\n#include \u0026#34;incomplete.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { // 创建节点树: Node root{\u0026#34;top\u0026#34;}; root.add(Node{\u0026#34;elem1\u0026#34;}); root.add(Node{\u0026#34;elem2\u0026#34;}); root[0].add(Node{\u0026#34;elem1.1\u0026#34;}); // print node tree: root.print(); } 该程序具有以下输出：\ntop elem1 elem1.1 elem2 25.2 节点处理程序 通过引入从关联或无序容器中拼接节点的能力，你可以轻松地：\n修改键或（无序）maps或maps或（无序）集合。 在（无序） sets 和 maps中使用移动语义，以及 在（无序）sets 和 maps之间移动元素。 例如，在定义和初始化一个map后，如下所示。\nstd::map\u0026lt;int, std::string\u0026gt; m{{1,\u0026#34;mango\u0026#34;}, {2,\u0026#34;papaya\u0026#34;}, {3,\u0026#34;guava\u0026#34;}}; 您可以使用键 2 修改元素，如下所示：\nauto nh = m.extract(2); // nh 的类型为 decltype(m)::node_type nh.key() = 4; m.insert(std::move(nh)); 代码将键为 2 的元素的节点从容器中取出，修改键，然后将其移回，如图 25.1 中所述。 请注意，不使用内存（取消）分配，并且对元素的指针和引用保持有效。 但是，在元素保存在节点句柄中时使用指针和引用会导致未定义的行为。\n节点句柄的类型是 container::node_type。 它为会员提供\n所有（无序）集合类型的value() 所有（无序）map类型的成员 key() 和 mapped() 您还可以使用节点句柄将元素从一个容器移动到另一个容器。 容器甚至可以通过以下方式有所不同：\n一个支持重复，而另一个不支持（例如，您可以将元素从多地图移动到地图） 比较函数和散列函数可能不同 例子：\nstd::multimap\u0026lt;double, std::string\u0026gt; src {{1.1,\u0026#34;one\u0026#34;}, {2.2,\u0026#34;two\u0026#34;}, {3.3,\u0026#34;three\u0026#34;}}; std::map\u0026lt;double, std::string\u0026gt; dst {{3.3,\u0026#34;old data\u0026#34;}}; // 将一些元素从 multimap src 移动到 map dst: dst.insert(src.extract(src.find(1.1))); // 使用迭代器拼接 dst.insert(src.extract(2.2)); // 使用键拼接 请注意， insert() 函数返回一个包含三个元素的结构（按以下顺序）：\n如果无法插入，则为现有元素的迭代器位置。 插入一个布尔值，表示插入是否成功。 如果无法插入，则带有节点句柄的 mode_type 节点。 即，关键信息是插入的第二个成员。 使用结构化绑定，您可以按如下方式使用返回值：\nauto [pos,done,node] = dst.insert(src.extract(3.3)); if (!done) { std::cout \u0026lt;\u0026lt; \u0026#34;insert() of node handle failed:\u0026#34; \u0026lt;\u0026lt; \u0026#34; tried to insert key \u0026#39;\u0026#34; \u0026lt;\u0026lt; node.key() \u0026lt;\u0026lt; \u0026#34;\u0026#39; with value \u0026#39;\u0026#34; \u0026lt;\u0026lt; node.mapped() \u0026lt;\u0026lt; \u0026#34;\u0026#39; but key exists with value \u0026#39;\u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; } 25.3 后记 容器对不完整类型的支持首先是由 Matt Austern 在 http://drdobbs.com/184403814 中讨论的，最初是由袁志豪在 https://wg21.link/n3890 中提出的。 最终接受的措辞由袁志豪在 https://wg21.link/n4510 中制定。\n节点句柄首先由 Alan Talbot 间接提出，请求拼接操作作为库问题 https://wg21.link/lwg839 和 Alisdair Meredith 请求对节点元素的移动支持作为库问题 https://wg21.link/lwg1041。 最终接受的措辞由 Alan Talbot、Jonathan Wakely、Howard Hinnant 和 James Dennett 在 https://wg21.link/p0083r3 中制定。 最终，Howard E. Hinnant 在 https://wg21.link/p0508r0 中稍微澄清了 API。\n26 多线程和并发 在多线程和并发领域引入了一些小的扩展和改进。\n26.1 补充的互斥和锁 26.1.1 std::scoped_lock C++11 引入了一个简单的 std::lock_guard 来以一种简单的 RAII 风格的方式来锁定互斥锁：\n构造函数锁 析构函数解锁（可能由异常引起） 不幸的是，这没有标准化为可变参数模板，以便能够通过单个声明锁定多个互斥锁。 std::scoped_lock\u0026lt;\u0026gt; 弥补了这一差距。 它允许我们锁定一个或多个互斥锁。 互斥锁可能有不同的互斥锁类型。 例如：\n#include \u0026lt;mutex\u0026gt; ...; std::vector\u0026lt;std::string\u0026gt; allIssues; std::mutex allIssuesMx; std::vector\u0026lt;std::string\u0026gt; openIssues; std::timed_mutex openIssuesMx; // lock both issue lists: { std::scoped_lock lg(allIssuesMx, openIssuesMx) ...; // 操作 allIssues 和 openIssues } 请注意，由于类模板参数推导，您在声明 lg 时不必指定互斥锁的类型。 此示例用法等价于以下代码，从 C++11 开始可以调用：\n// 锁定两个问题清单: { std::lock(allIssuesMx, openIssuesMx); // 避免死锁的锁 std::lock_guard\u0026lt;std::mutex\u0026gt; lg1(allIssuesMx, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lg2(openIssuesMx, std::adopt_lock); ... // 同时操作allIssues和openIssues } 因此，如果传递了多个互斥锁，则 scoped_lock 的构造函数使用可变参数便利函数 lock(\u0026hellip;)，它保证调用不会导致死锁（标准注释：“死锁避免算法，例如 因为必须使用try-and-back-off，但没有指定具体算法以避免过度约束实现”）。 如果只将一个互斥锁传递给 scoped_lock 的构造函数，它只会锁定互斥锁。 因此，在具有单个构造函数参数的 scoped_lock 中，其作用类似于 lock_guard）。 然后它甚至定义了没有为多个互斥锁定义的成员 mutex_type。1 因此，您可以将 lock_guard 的所有用法替换为 scoped_lock。 如果没有传递互斥体，则锁守卫不起作用。 请注意，您还可以采用多个锁：\n// 锁定两个问题清单: { std::lock(allIssuesMx, openIssuesMx); // 注意：使用的死锁避免算法 std::scoped_lock lg(std::adopt_lock, allIssuesMx, openIssuesMx); ... // 同时操作allIssues和openIssues } 然而，请注意，采用锁的构造函数现在在前面有 adopt_lock 参数。\n26.1.2 std::shared_mutex C++14添加了shared_timed_mutex来支持读/写锁，即多个线程同时读取一个值，而不时地有线程可能会更新这个值。因为在一些平台上，不支持定时锁的mutex可以更有效地实现，现在引入了shared_mutex类型（就像自C++11以来，除了std::timed_mutex之外，还有std::mutex存在）。 shared_mutex定义在头文件\u0026lt;shared_mutex\u0026gt;中，支持以下操作。\n对于独占锁：lock(), try_lock(), unlock() 对于共享的读访问：lock_shared(), try_lock_shared(), unlock_shared() native_handle() 也就是说，与shared_times_mutex不同，它不支持try_lock_for()、try_lock_until()。try_lock_shared_for(), and try_lock_shared_until()。\n使用 shared_mutex 使用shared_mutex的方法如下。假设你有一个共享vector，它通常被多个线程读取，但不时地被修改：\n#include \u0026lt;shared_mutex\u0026gt; #include \u0026lt;mutex\u0026gt; ... std::vector\u0026lt;double\u0026gt; v; // 共享资源 std::shared_mutex vMutex; // 控制对 v 的访问（C++14 中的 shared_timed_mutex） 要进行共享读取访问（以便多个读取器不会相互阻塞），请使用 shared_lock，它是共享读取访问的锁保护（在 C++14 中引入）。 例如：\nif (std::shared_lock sl(vMutex); v.size() \u0026gt; 0) { ... // （共享）对vector v 元素的读取访问 } 只有在排他性的写访问中，你才会使用排他性的锁防护，这可能是一个简单的lock_guard或scoped_lock（如刚刚介绍的），或者是一个复杂的unique_lock。比如说:\n{ std::scoped_lock sl(vMutex); ... // 对vector 的独占写读访问 } 26.2 原子的 is_always_lock_free() 你现在可以通过一个C++库的功能来检查一个特定的原子类型是否总是可以在没有锁的情况下使用不加锁。比如说：\nif constexpr(std::atomic\u0026lt;int\u0026gt;::is_always_lock_free) { ... } else { ... } 如果该值为真，那么对于相应的原子类型的任何对象来说，is_lock_free()产生真:\nif constexpr(atomic\u0026lt;T\u0026gt;::is_always_lock_free) { static_assert(atomic\u0026lt;T\u0026gt;().is_lock_free()); // 从未失败 } 如果有的话，这个值与相应的宏的值相匹配，在C++17之前必须使用。 例如，如果且仅当ATOMIC_INT_LOCK_FREE产生2（代表 \u0026ldquo;总是\u0026rdquo;），那么std::atomic::is_always_lock_free()产生true。:\nif constexpr(std::atomic\u0026lt;int\u0026gt;::is_always_lock_free) { // ATOMIC_INT_LOCK_FREE == 2 ... } else { // ATOMIC_INT_LOCK_FREE == 0 || ATOMIC_INT_LOCK_FREE == 1 ... } 用静态成员代替宏的原因是为了有更多的类型安全，并支持在棘手的通用代码中使用这种检查（例如，使用SFINAE）。 请记住，std::atomic\u0026lt;\u0026gt;也可以用于琐碎的可复制类型。因此，你也可以检查，如果你自己的结构在原子上使用，是否需要锁。比如说：\ntemplate\u0026lt;auto SZ\u0026gt; struct Data { bool set; int values[SZ]; double average; }; if constexpr(std::atomic\u0026lt;Data\u0026lt;4\u0026gt;\u0026gt;::is_always_lock_free) { ... } else { ... } 26.3 缓存线的大小 有时对于一个程序来说，处理缓存线的大小是很重要的。\n一方面，不同线程访问的不同对象不属于同一个缓存线，这对并发性很重要。否则，当不同的线程同时访问时，同样数量的内存必须在它们之间进行同步。 另一方面，你的目标可能是将多个对象放在同一个缓存线中，这样访问第一个对象就可以直接访问其他对象，而不是将它们加载到缓存中。 为此，C++标准库在头文件中引入了两个内联变量。\nnamespace std { inline constexpr size_t hardware_destructive_interference_size; inline constexpr size_t hardware_constructive_interference_size; } 这些对象有以下执行定义的值。\nhardware_destructive_interference_size是推荐的两个可能被不同线程同时访问的对象之间的最小偏移量，以避免因为同一L1缓存线受到影响而导致性能下降。 hardware_constructive_interference_size是推荐的两个对象放在同一L1缓存行内的最大连续内存大小。 这两个值只是提示，因为理想的值可能取决于具体的架构。这些常数是编译器在处理生成的代码所支持的各种平台时所能提供的最佳值。所以，如果你知道的更多，请使用特定的值，但对于支持多种平台的代码来说，使用这些值比任何假定的固定尺寸要好。 这些值至少都是alignof(std::max_align_t)。通常情况下，值是相同的。然而，从语义上讲，它们代表了使用不同对象的不同目的，所以你应该使用它们 相应地使用它们，\n如下所示:\n如果你想通过不同的线程访问两个不同的（原子）对象。 struct Data { alignas(std::hardware_destructive_interference_size) int valueForOneThread; alignas(std::hardware_destructive_interference_size) int valueForAnotherThread; }; 如果你想通过同一个线程访问两个不同的（原子）对象。 struct Data { int valueForOneThread; int valueForTheSameThread; }; // 仔细检查，由于共享缓存线，我们有最好的性能。 static_assert(sizeof(Data) \u0026lt;= std::hardware_constructive_interference_size); // 确保对象被正确对齐。 alignas(sizeof(Data)) Data myDataForAThread; 26.4 后记 scoped_locks 最初是由 Mike Spertus 在 https://wg21.link/n4470 中将 lock_guard 修改为可变参数，被接受为 https://wg21.link/p0156r0。然而，因为这被证明是 ABI 破坏，新名称 scoped_lock 由 Mike Spertus 用 https://wg21.link/p0156r2 引入并最终被接受。 Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 后来通过 https://wg21.link/p0739r0 将构造函数的顺序更改为针对 C++17 的缺陷：\nshared_mutex 最初是由 Howard Hinnant 在 https://wg21.link/n2406 中与 C++11 的所有其他互斥体一起提出的。然而，要让 C++ 标准化委员会相信所有提议的互斥锁都是有用的，需要时间。因此，最终接受的措辞是由 Gor Nishanov 在 https://wg21.link/n4508 中为 C++17 制定的。\nstd::atomic\u0026lt;\u0026gt; 静态成员 std::is_always_lock_free 由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 https://wg21.link/n4509 中首次提出。最终接受的措辞也是由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 https://wg21.link/p0152r1 中制定的。\nJF Bastien 和 Olivier Giroux 在 https://wg21.link/n4523 中首次提出了硬件干扰（缓存线）大小。最终接受的措辞也是由 JF Bastien 和 Olivier Giroux 在 https://wg21.link/p0154r1 中制定的。\n","date":"2022-03-19T00:01:15Z","permalink":"https://okokfun.github.io/post/c++/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/","title":"第四部分-标准库扩展和修改"},{"content":"第二部分: 模板特性 9 类模板参数推导 C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：\nstd::complex\u0026lt;double\u0026gt; c{5.1,3.3}; 也不能忽略第二次的std::mutex：\nstd::mutex mx; std::lock_guard\u0026lt;std::mutex\u0026gt; lg(mx); C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。\n比如：\n你可以这样声明： std::complex c{5.1,3.3}; // 好的：推断出 std::complex\u0026lt;double\u0026gt; 你可以这样实现： std::mutex mx; std::lock_guard lg{mx}; // OK: 推断出 std::lock_guard\u0026lt;std_mutex\u0026gt; 你甚至可以让容器推导其元素的类型： std::vector v1 {1, 2, 3} // OK: 推断出 std::vector\u0026lt;int\u0026gt; std::vector v2 {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; // OK: 推断出 std::vector\u0026lt;const char*\u0026gt; 9.1 类模板参数推导的使用 只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：\nstd::complex c1{1.1, 2.2}; // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c2(2.2, 3.3); // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c3 = 3.3; // 推断出 std::complex\u0026lt;double\u0026gt; std::complex c4 = {4.4}; // 推断出 std::complex\u0026lt;double\u0026gt; c3和c4的初始化方式是可行的，因为你可以传递一个值来初始化std::complex\u0026lt;\u0026gt;，这对于推导出模板参数T来说足够了，它会被用于实数和虚数部分：\nnamespace std { template\u0026lt;typename T\u0026gt; class complex { constexpr complex(const T\u0026amp; re = T(), const T\u0026amp; im = T()); ... } }; 假设有如下声明\nstd::complex c1{1.1, 2.2}; 编译器会在调用的地方找到构造函数\nconstexpr complex(const T\u0026amp; re = T(), const T\u0026amp; im = T()); 因为两个参数T都是double，所以编译器推导出T是double，然后编译下面的代码：\ncomplex\u0026lt;double\u0026gt;::complex(const double\u0026amp; re = double(), const double\u0026amp; im = double()); 注意模板参数必须是无歧义、可推导的。因此，下面的初始化是有问题的：\nstd::complex c5{5,3.3}; // 错误：尝试将 int 和 double 作为 T 对于模板来说，不会在推导模板参数的时候做类型转换。\n对于可变参数模板的类模板参数推导也是支持的。比如，std::tuple\u0026lt;\u0026gt;定义如下：\nnamespace std { template\u0026lt;typename... Types\u0026gt; class tuple; public: constexpr tuple(const Types\u0026amp;...); ... }; }; 这个声明：\nstd::tuple t{42, \u0026#39;x\u0026#39;, nullptr}; 推导出的类型是std::tuple。\n你也可以推导出非类型模板参数。举个例子，像下面例子中传递一个数组，在推导模板参数的时候可以同时推导出元素类型和数组大小：\ntemplate\u0026lt;typename T, int SZ\u0026gt; class MyClass { public: MyClass (T(\u0026amp;)[SZ]) { ... } }; MyClass mc(\u0026#34;hello\u0026#34;); // 将 T 推导出为 const char 并将 SZ 推导出为 6 SZ推导为6，因为模板参数类型传递了一个六个字符的字符串字面值。\n你甚至可以推导出用作基类的lambda的类型，或者推导出auto模板参数类型。\n9.1.1 默认复制 如果类模板参数推导发现一个行为更像是拷贝初始化，它就倾向于这么认为。比如，在用一个元素初始化std::vector后：\nstd::vector v1{42}; // 带有一个元素的vector\u0026lt;int\u0026gt; 用这个vector去初始化另一个vector：\nstd::vector v2{v1}; // v2 也是 vector\u0026lt;int\u0026gt; v2会被解释为vector而不是vector\u0026gt;\n又比如，这个规则适用于下面所有初始化形式：\nstd::vector v3(v1); // v3 也是 vector\u0026lt;int\u0026gt; std::vector v4 = {v1}; // v4 也是 vector\u0026lt;int\u0026gt; auto v5 = std::vector{v1}; // v5 也是 vector\u0026lt;int\u0026gt; 如果传递多个元素时，就不能被解释为拷贝初始化，此时initializer list的类型会成为新vector的元素类型：\nstd::vector vv{v, v}; // vv vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; 那么问题来了，如果传递可变参数模板，那么类模板参数推导会发生什么：\ntemplate\u0026lt;typename... Args\u0026gt; auto make_vector(const Args\u0026amp;... elems) { return std::vector{elems...}; } std::vector\u0026lt;int\u0026gt; v{1, 2, 3}; auto x1 = make_vector(v, v); // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; auto x2 = make_vector(v); // vector\u0026lt;int\u0026gt; 或vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ? 当前，不同的编译器有不同的处理方式，这个问题还在讨论中。\n9.1.2 推导 Lambda 的类型 有了类模板参数推导，我们现在终于可以用lambda的类型实例化类模板类。举个例子，我们可以提供一个泛型类，然后包装一下callback，并统计调用了多少次callback：\n// tmpl/classarglambda.hpp #include \u0026lt;utility\u0026gt; // for std::forward() template\u0026lt;typename CB\u0026gt; class CountCalls { private: CB callback; // callback to call long calls = 0; // counter for calls public: CountCalls(CB cb) : callback(cb) { } template\u0026lt;typename... Args\u0026gt; auto operator() (Args\u0026amp;\u0026amp;... args) { ++calls; return callback(std::forward\u0026lt;Args\u0026gt;(args)...); } long count() const { return calls; } }; 这里，构造函数接受一个callback，然后包装一下，用它的类型来推导出模板参数CB。比如，我们可以传一个lambda：\nCountCalls sc([](auto x, auto y) { return x \u0026gt; y; }); 这意味着sc的类型被推导为CountCalls。\n通过这种方式，我们可以计算传递给排序函数的sc的调用次数：\nstd::sort(v.begin(), v.end(), td::ref(sc)); std::cout \u0026lt;\u0026lt; \u0026#34;sorted with \u0026#34; \u0026lt;\u0026lt; sc.count() \u0026lt;\u0026lt; \u0026#34; calls\\n\u0026#34;; 包装后的lambda通过引用的方式传递给排序函数，因为如若不然std::sort()只会计算传递给他的lambda的拷贝的调用，毕竟是传值的方式。\n然而，我没可以传递包装后的lambda给std::for_each，因为这个算法可以返回传递给他的callback的拷贝：\nauto fo = std::for_each(v.begin(), v.end(), CountCalls([](auto i) { std::cout \u0026lt;\u0026lt; \u0026#34;elem: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; })); std::cout \u0026lt;\u0026lt; \u0026#34;output with \u0026#34; \u0026lt;\u0026lt; fo.count() \u0026lt;\u0026lt; \u0026#34; calls\\n\u0026#34;; 9.1.3 非部分类模板参数推导 不像函数模板那样，类模板参数不能部分推导（显示模板参数的一部分）。比如：\ntemplate\u0026lt;typename T1, typename T2, typename T3 = T2\u0026gt; class C { public: C (T1 x = T1{}, T2 y = T2{}, T3 z = T3{}) { ... } ... }; // all deduced: C c1(22, 44.3, \u0026#34;hi\u0026#34;); // OK：T1 是 int，T2 是 double，T3 是 const char* C c2(22, 44.3); // OK: T1 是 int，T2 和 T3 是 double C c3(\u0026#34;hi\u0026#34;, \u0026#34;guy\u0026#34;); // OK: T1、T2 和 T3 是 const char* // only some deduced: C\u0026lt;string\u0026gt; c4(\u0026#34;hi\u0026#34;, \u0026#34;my\u0026#34;); // ERROR: 只有 T1 明确定义 C\u0026lt;\u0026gt; c5(22, 44.3); // ERROR: 既不是 T1 也不是 T2 明确定义 C\u0026lt;\u0026gt; c6(22, 44.3, 42); // ERROR: T1 和 T2 都没有明确定义 // all specified: C\u0026lt;string,string,int\u0026gt; c7; // OK: T1,T2 是字符串，T3 是整数 C\u0026lt;int,string\u0026gt; c8(52, \u0026#34;my\u0026#34;); // OK: T1 是 int，T2 和 T3 是字符串 C\u0026lt;string,string\u0026gt; c9(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // OK: T1,T2,T3 是字符串 因为第三个模板参数类型有默认值，所以如果已经指定了第二个就可以省略第三个。\n如果i想知道为什么不支持偏特化，下面是造成这个抉择的原因：\nstd::tuple\u0026lt;int\u0026gt; t(42, 43); // still ERROR std::tuple是一个可变参数模板，所以你可以指定任意数量的参数。在这种情况下，到底是认为这是只指定了一个类型的而导致的错误还是有意为之很难说清。看起来是有问题的。后期有更多考量后，偏特化也有可能加入C++标准。尽管目前没有。\n不幸的是，缺少部分特化就不能解决一个常见代码需求。对于关联容器的排序规则，或者无序容器的hash函数，我们仍然不能简单的传一个lambda：\nstd::set\u0026lt;Cust\u0026gt; coll([](const Cust\u0026amp; x, const Cust\u0026amp; y) { // still ERROR return x.name() \u0026gt; y.name(); }); 我们还是得指定lambda的类型，因此需要像下面这样写：\nauto sortcrit = [](const Cust\u0026amp; x, const Cust\u0026amp; y) { return x.name() \u0026gt; y.name(); }; std::set\u0026lt;Cust, decltype(sortcrit)\u0026gt; coll(sortcrit); // OK 9.1.4 类模板参数推导代替便捷的工具函数。 有了类模板参数推导，我们可以不再使用那些目的仅是推导传的参数的类型的便捷工具函数。\n最明显的是make_pair，他允许我们不指定传的参数的类型。比如，对于v：\nstd::vector\u0026lt;int\u0026gt; v; 我们可以使用:\nauto p = std::make_pair(v.begin(), v.end()); 来代替\nstd::pair\u0026lt;typename std::vector\u0026lt;int\u0026gt;::iterator,typename std::vector\u0026lt;int\u0026gt;::iterator\u0026gt; p(v.begin(), v.end()); 现在，make_pair()不再需要了，可以直接这么写：\nstd::pair p(v.begin(), v.end()); 然而，std::make_pair() 也是一个很好的例子，它证明了有时便利函数不仅仅是推导模板参数。 事实上，std::make_pair() 也会衰减，这尤其意味着传递的字符串文字的类型被转换为 const char *：\nauto q = std::make_pair(\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;); // 一对指针 在这种情况下，q 的类型为 std::pair\u0026lt;const char*, const char*\u0026gt;。 通过使用类模板参数推导，事情变得更加复杂。 让我们看看像 std::pair 这样的简单类声明的相关部分：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair1 { T1 first; T2 second; Pair1(const T1\u0026amp; x, const T2\u0026amp; y) : first{x}, second{y} { } }; 关键是元素是通过引用传递的。 并且根据语言规则，当通过引用传递模板类型的参数时，参数类型不会衰减，这就是 将原始数组类型转换为相应的原始指针类型的机制。 因此，在调用时：\nPair1 p1{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 推导出一对不同大小的数组，但是...... T1 推导出为 char[3]，T2 推导为 char[6]。 原则上，这样的推导是有效的。 但是，我们使用 T1 和 T2 来声明成员 first 和 second。 结果，他们是 声明为：\nchar first[3]; char second[6]; 并且不允许从数组的左值初始化数组。 这就像尝试编译：\nconst char x[3] = \u0026#34;hi\u0026#34;; const char y[6] = \u0026#34;world\u0026#34;; char first[3] {x}; // ERROR char second[6] {y}; // ERROR 请注意，在声明要按值传递的参数时，我们不会遇到这个问题：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair2 { T1 first; T2 second; Pair2(T1 x, T2 y) : first{x}, second{y} { } }; 如果对于这种类型，我们会调用：\nPair2 p2{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 推导出一对指针 T1 和 T2 都将被推导出为 const char*。 因为声明了类 std::pair\u0026lt;\u0026gt; 以便构造函数通过引用获取参数， 您现在可能期望以下初始化不会编译：\nstd::pair p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 似乎推断出一对不同大小的数组，但是...... 但它编译。 原因是我们使用推到。\n9.2 推导指南 您可以定义特定的推导指南以提供额外的类模板参数推导 或修复构造函数定义的现有扣除。 例如，您可以定义每当 推导出 Pair3 的类型，类型推导应该像类型被传递一样操作 价值：\ntemplate\u0026lt;typename T1, typename T2\u0026gt; struct Pair3 { T1 first; T2 second; Pair3(const T1\u0026amp; x, const T2\u0026amp; y) : first{x}, second{y} { } }; // 构造函数的推导指南： template\u0026lt;typename T1, typename T2\u0026gt; Pair3(T1, T2) -\u0026gt; Pair3\u0026lt;T1, T2\u0026gt;; 在这里，在-\u0026gt;的左边，我们声明我们要推导的东西。在这个例子中，它是由两个任意类型的对象T1和T2通过值创建一个 Pair3，由两个任意类型的T1和T2的对象通过值传递。在\u0026quot;-\u0026gt;\u0026ldquo;的右边，我们 的右边定义了所产生的推理。在这个例子中，Pair3被实例化为两个类型的T1和T2。 你可能会说，这就是构造函数已经做的事情。然而，构造函数采用 参数的引用，这是不一样的。一般来说，即使在模板之外，参数 衰减，而通过引用传递的参数不会衰减。衰减意味着，原始 数组转换为指针，而顶级限定符，如const和引用，则被忽略。 如果没有推导指南，例如，在声明以下内容时：\nPair3 p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 参数 x 的类型，因此 T1 是 const char[3] 和参数 y 的类型，因此 T2 是 const char[6]。 由于推导，模板参数衰减，这意味着传递的数组或 字符串文字衰减为相应的指针类型。 现在，当声明以下内容时：\nPair3 p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 使用推导指南，它按值获取参数，以便两种类型都衰减为 const char*。 声明的效果就好像我们已经声明了：\nPair3\u0026lt;const char*, const char*\u0026gt; p3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 请注意，构造函数仍然通过引用获取参数。 推导指南只重要 用于推导模板类型。 这与类型之后的实际构造函数调用无关 推导出 T1 和 T2。\n9.2.1 使用推导引导强制衰减 正如前面的例子所展示的，一般来说，这些重载的一个非常有用的应用 规则是确保模板参数 T 在推导时衰减。考虑一个典型的类模板：\ntemplate\u0026lt;typename T\u0026gt; struct C { C(const T\u0026amp;) { } ... }; 如果我们在这里传递一个字符串字面量“hello”，则推导出 T 为字符串字面量的类型，即 const char[6]：\nC x{\u0026#34;hello\u0026#34;}; // T 推导出为 const char[6] 原因是模板参数推导没有衰减到对应的指针类型，当参数通过引用传递时。 有一个简单的推导指南\ntemplate\u0026lt;typename T\u0026gt; C(T) -\u0026gt; C\u0026lt;T\u0026gt;; 我们解决了这个问题：\nC x{\u0026#34;hello\u0026#34;}; // T 推导出为 const char* 现在，因为推导指南按值接受它，它的类型衰减了，所以\u0026quot;hello\u0026rdquo; 推导出 T 为 const char* 类型。 因此，对于任何类模板，相应的推导指南听起来都非常合理 有一个构造函数通过引用获取其模板参数的对象。 C++ 标准 库提供了 pair 和 tuple 的相应推导指南。\n9.2.2 非模板推导 推导指南不必是模板，也不必适用于构造函数。 例如， 给定以下结构和推导指南：\ntemplate\u0026lt;typename T\u0026gt; struct S { T val; }; S(const char*) -\u0026gt; S\u0026lt;std::string\u0026gt;; // 将字符串文字的 S\u0026lt;\u0026gt; 映射到 S\u0026lt;std::string\u0026gt; 以下声明是可能的，其中 std::string 从 const 推导出为 T 的类型 char* 因为传递的字符串文字隐式转换为它：\nS s1{\u0026#34;hello\u0026#34;}; // OK, 等同于： S\u0026lt;std::string\u0026gt; s1{\u0026#34;hello\u0026#34;}; S s2 = {\u0026#34;hello\u0026#34;}; // OK, 等同于: S\u0026lt;std::string\u0026gt; s2 = {\u0026#34;hello\u0026#34;}; S s3 = S{\u0026#34;hello\u0026#34;}; // OK, 两个 S 都推断为 S\u0026lt;std::string\u0026gt; 请注意，聚合需要列表初始化（推导有效，但不允许初始化）：\nS s4 = \u0026ldquo;hello\u0026rdquo;; // 错误（不能以这种方式初始化聚合）\n9.2.3 推导与构造函数 推导指南与类的构造函数竞争。类模板参数推导使用根据重载决议具有最高优先级的构造函数/指南。如果构造函数和推导指南同样匹配，则优选推导指南。\n考虑我们有以下定义：\ntemplate\u0026lt;typename T\u0026gt; struct C1 { C1(const T\u0026amp;) { } }; C1(int) -\u0026gt; C1\u0026lt;long\u0026gt;; 当传递一个int时，使用推导指南，因为它被重载解析所青睐。 因此，T被推导为long：\nC1 x1{42}; // T 被推导为 long 但是如果我们传递一个char，构造函数是更好的匹配（因为不需要类型转换），所以 我们将 T 推导出为 char：\nC1 x3{\u0026#39;x\u0026#39;}; // T 被推导为 char 因为通过值匹配取参数与通过引用取参数和演绎指南同样适用于同样好的匹配，所以通常让演绎指南取 价值论据（这也有衰减的优势）。\n9.2.4 显式推导 一个推导指南可以被声明为是明确的。然后它只在以下情况下被忽略，即 显式会使初始化或转换失效。例如，鉴于:\ntemplate\u0026lt;typename T\u0026gt; struct S { T val; }; explicit S(const char*) -\u0026gt; S\u0026lt;std::string\u0026gt;; 传递推导指南参数类型的 S 对象的复制初始化（使用 =）忽略 扣除指南。 在这里，这意味着初始化变得无效：\nS s1 = {\u0026#34;hello\u0026#34;}; // ERROR (推导指南被忽略，否则无效) 直接初始化或在右侧进行显式推导仍然是可能的：\nS s2{\u0026#34;hello\u0026#34;}; // OK, same as: S\u0026lt;std::string\u0026gt; s1{\u0026#34;hello\u0026#34;}; S s3 = S{\u0026#34;hello\u0026#34;}; // OK S s4 = {S{\u0026#34;hello\u0026#34;}}; // OK 作为另一个示例，我们可以执行以下操作：\ntemplate\u0026lt;typename T\u0026gt; struct Ptr { Ptr(T) { std::cout \u0026lt;\u0026lt; \u0026#34;Ptr(T)\\n\u0026#34;; } template\u0026lt;typename U\u0026gt; Ptr(U) { std::cout \u0026lt;\u0026lt; \u0026#34;Ptr(U)\\n\u0026#34;; } }; template\u0026lt;typename T\u0026gt; explicit Ptr(T) -\u0026gt; Ptr\u0026lt;T*\u0026gt;; 这将产生以下效果：\nPtr p1{42}; // 由于推导引导推导 Ptr\u0026lt;int*\u0026gt; Ptr p2 = 42; // 由于构造函数推导出 Ptr\u0026lt;int\u0026gt; int i = 42; Ptr p3{\u0026amp;i}; // 由于推导引导推导 Ptr\u0026lt;int**\u0026gt; Ptr p4 = \u0026amp;i; // 由于构造函数推导出 Ptr\u0026lt;int*\u0026gt; 9.2.5 集合体推导 推导指南可用于通用聚合以启用类模板参数推导 那里。 例如，对于：\ntemplate\u0026lt;typename T\u0026gt; struct A { T val; }; 任何没有推导指南的类模板参数推导试验都是错误的：\nA i1{42}; // ERROR A s1(\u0026#34;hi\u0026#34;); // ERROR A s2{\u0026#34;hi\u0026#34;}; // ERROR A s3 = \u0026#34;hi\u0026#34;; // ERROR A s4 = {\u0026#34;hi\u0026#34;}; // ERROR 您必须显式传递类型 T 的参数：\nA\u0026lt;int\u0026gt; i2{42}; A\u0026lt;std::string\u0026gt; s5 = {\u0026#34;hi\u0026#34;}; 但经过推导如：\nA(const char*) -\u0026gt; A\u0026lt;std::string\u0026gt;; 您可以按如下方式初始化聚合：\nA s2{\u0026#34;hi\u0026#34;}; // OK A s4 = {\u0026#34;hi\u0026#34;}; // OK 但是，与聚合一样，您仍然需要花括号。 否则，类型 T 成功 推导出来，但初始化是错误的：\nA s1(\u0026#34;hi\u0026#34;); // 错误：T 是字符串，但没有聚合初始化 A s3 = \u0026#34;hi\u0026#34;; // 错误：T 是字符串，但没有聚合初始化 std::array 的推导指南是聚合推导指南的另一个示例。\n9.2.6 标准推导 C++ 标准库在 C++17 中引入了一些推导指南。 Pairs 和 Tuples 推导指南 正如在推导指南的动机中所介绍的那样，std::pair 需要推导指南来确保 类模板参数推导使用传入参数的衰减类型：\nnamespace std { template\u0026lt;typename T1, typename T2\u0026gt; struct pair { ... constexpr pair(const T1\u0026amp; x, const T2\u0026amp; y); // 引用参数 ... }; template\u0026lt;typename T1, typename T2\u0026gt; pair(T1, T2) -\u0026gt; pair\u0026lt;T1, T2\u0026gt;; // 按值推断参数类型 } 因此，声明\nstd::pair p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // 采用 const char[3] 和 const char[6] 等价于: std::pair\u0026lt;const char*, const char*\u0026gt; p{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; 对于可变参数类模板 std::tuple，使用相同的方法：\nnamespace std { template\u0026lt;typename... Types\u0026gt; class tuple { public: constexpr tuple(const Types\u0026amp;...); // 通过引用获取参数 template\u0026lt;typename... UTypes\u0026gt; constexpr tuple(UTypes\u0026amp;\u0026amp;...); ... }; template\u0026lt;typename... Types\u0026gt; tuple(Types...) -\u0026gt; tuple\u0026lt;Types...\u0026gt;; // 按值推断参数类型 }; 因此，声明：\nstd::tuple t{42, \u0026#34;hello\u0026#34;, nullptr}; 将 t 的类型推导出为 std::tuple\u0026lt;int, const char*, std::nullptr_t\u0026gt;。\n迭代器的推导： 为了能够从定义初始化范围的迭代器中推断出元素的类型， 容器对 std::vector\u0026lt;\u0026gt; 有如下推导指南：\n// let std::vector\u0026lt;\u0026gt; 从初始化迭代器推断元素类型: namespace std { template\u0026lt;typename Iterator\u0026gt; vector(Iterator, Iterator) -\u0026gt; vector\u0026lt;typename iterator_traits\u0026lt;Iterator\u0026gt;::value_type\u0026gt;; } 例如，这允许：\nstd::set\u0026lt;float\u0026gt; s; std::vector v1(s.begin(), s.end()); // OK, 推导出 std::vector\u0026lt;float\u0026gt; 请注意，此处使用带括号的初始化很重要。 如果使用花括号：\nstd::vector v2{s.begin(), s.end()}; // 注意：不推断 std::vector\u0026lt;float\u0026gt; 这两个参数被视为初始化列表的元素（根据 重载决议规则）。 也就是说，相当于：\nstd::vector\u0026lt;std::set\u0026lt;float\u0026gt;::iterator\u0026gt; v2{s.begin(), s.end()}; 这样我们就初始化了一个包含两个元素的向量，第一个引用第一个元素，第二个引用表示最后一个元素后面的位置。 另一方面，考虑：\nstd::vector v3{\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;}; // OK, 推导std::vector\u0026lt;const char*\u0026gt; std::vector v4(\u0026#34;hi\u0026#34;, \u0026#34;world\u0026#34;); // OOPS：致命的运行时错误 虽然 v3 的声明还使用两个元素（都是 C 字符串）初始化向量，但 第二个导致致命的运行时错误，这可能会导致核心转储。 问题是那个字符串 文字转换为字符指针，这是有效的迭代器。 因此，我们传递了两个迭代器 不指向同一个对象。 换句话说：我们传递了一个无效的范围。 取决于两者在哪里 文字被存储，你会得到一个带有任意数量元素的 std::vector 。 如果 它太大了你得到一个 bad_alloc 异常，或者你得到一个核心转储，因为没有距离 全部，或者你会得到一些存储在它们之间的未定义字符的范围。 因此，在初始化向量的元素时，使用花括号总是最好的。 唯一的 例外是传递单个向量时（首选复制构造函数）。 通过时 别的东西，使用括号更好。\nstd::array\u0026lt;\u0026gt; 推导 一个更有趣的例子提供了 std::array\u0026lt;\u0026gt; 类：为了能够推导出这两个元素 类型和元素数量：\nstd::array a{42,45,77}; // OK, 推导出 std::array\u0026lt;int,3\u0026gt; 定义了以下推导指南：\n// let std::array\u0026lt;\u0026gt; 推断它们的元素数量（必须具有相同的类型）: namespace std { template\u0026lt;typename T, typename... U\u0026gt; array(T, U...) -\u0026gt; array\u0026lt;enable_if_t\u0026lt;(is_same_v\u0026lt;T,U\u0026gt; \u0026amp;\u0026amp; ...), T\u0026gt;, (1 + sizeof...(U))\u0026gt;; } 演绎指南使用折叠表达式\n(is_same_v\u0026lt;T,U\u0026gt; \u0026amp;\u0026amp; ...) 确保所有传递的参数的类型相同。 因此，以下是不可能的：\nstd::array a{42,45,77.7}; // ERROR: 类型不同 (无序)Map推导 可以证明获得行为正确的演绎指南所涉及的复杂性 通过试验为具有 key/value 对（map、multimap、 unordered_map，unordered_multimap）。 这些容器的元素具有 std::pair\u0026lt;const keytype, valuetype\u0026gt; 类型。 常量 是必要的，因为元素的位置取决于键的值，因此能够 修改密钥可能会在容器内产生不一致。 因此，C++17 标准中用于 std::map 的方法：\nnamespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; class map { ... }; } 例如，为以下构造函数定义：\nmap(initializer_list\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;, const Compare\u0026amp; = Compare(), const Allocator\u0026amp; = Allocator()); 以下推导指南：\nnamespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; map(initializer_list\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;, Compare = Compare(), Allocator = Allocator()) -\u0026gt; map\u0026lt;Key, T, Compare, Allocator\u0026gt;; } 由于所有参数都是按值传递的，因此本推导指南允许传递的比较器或分配器的类型如所讨论的那样衰减。 然而，我们天真地使用了相同的参数类型， 意味着初始化列表采用 const 键类型。 但结果是，以下不起作用 正如 Ville Voutilainen 在 https://wg21.link/lwg3025 中指出的那样：\nstd::pair elem1{1,2}; std::pair elem2{3,4}; ... std::map m1{elem1, elem2}; // 与原始 C++17 指南有关的错误 因为这里的元素被推导为 std::pair\u0026lt;int,int\u0026gt;，这与需要 const 类型作为第一对类型的推导指南不匹配。 因此，您仍然必须编写以下内容：\nstd::map\u0026lt;int,int\u0026gt; m1{elem1, elem2}; // OK, 因此，在推导指南中，应该删除 const： namespace std { template\u0026lt;typename Key, typename T, typename Compare = less\u0026lt;Key\u0026gt;, typename Allocator = allocator\u0026lt;pair\u0026lt;const Key, T\u0026gt;\u0026gt;\u0026gt; map(initializer_list\u0026lt;pair\u0026lt;Key, T\u0026gt;\u0026gt;, Compare = Compare(), Allocator = Allocator()) -\u0026gt; map\u0026lt;Key, T, Compare, Allocator\u0026gt;; } 然而，为了仍然支持比较器和分配器的衰减，我们还必须重载 具有 const 键类型的对的推导指南。 否则将使用构造函数，以便 当与 const 和配对时，类模板参数推导的行为会略有不同 非常量键被传递。\n智能指针无推导指南 请注意，C++ 标准库中的某些地方没有推导指南，尽管您可能 期望它们可用。 例如，您可能希望有共享和唯一指针的推导指南，以便 代替：\nstd::shared_ptr\u0026lt;int\u0026gt; sp{new int(7)}; 你可以写：\nstd::shared_ptr sp{new int(7)}; // 不支持 这不会自动工作，因为对应的构造函数是一个模板，所以没有 隐式推导指南适用：\nnamespace std { template\u0026lt;typename T\u0026gt; class shared_ptr { public: ... template\u0026lt;typename Y\u0026gt; explicit shared_ptr(Y* p); ... }; } Y 是与 T 不同的模板参数，因此从构造函数推导出 Y 并不意味着 我们可以推导出类型 T。这是一个能够调用类似以下内容的功能：\nstd::shared_ptr\u0026lt;Base\u0026gt; sp{new Derived(...)}; 相应的推导指南将很容易提供：\nnamespace std{ template\u0026lt;typename Y\u0026gt; shared_ptr(Y*) -\u0026gt; shared_ptr\u0026lt;Y\u0026gt;; } 但是，这也意味着在分配数组时会采用本指南：\nstd::shared_ptr sp{new int[10]}; // OOPS：会推导出 shared_ptr\u0026lt;int\u0026gt; 在 C++ 中，我们经常遇到令人讨厌的 C 问题，即指向一个对象的指针的类型和 对象数组具有或衰减为相同类型。 因为这个问题看起来很危险，所以 C++ 标准委员会决定不支持 (还没完成）。 您仍然需要调用单个对象：\nstd::shared_ptr\u0026lt;int\u0026gt; sp1{new int}; // OK auto sp2 = std::make_shared\u0026lt;int\u0026gt;(); // OK 对于数组：\nstd::shared_ptr\u0026lt;std::string\u0026gt; p(new std::string[10], [](std::string* p) { delete[] p; }); 或者：\nstd::shared_ptr\u0026lt;std::string\u0026gt; p(new std::string[10], std::default_delete\u0026lt;std::string[]\u0026gt;()); 9.3 后记 类模板参数推导由 Michael Spertus 于 2007 年在 https 中首次提出： //wg21.link/n2332。 该提案于 2013 年由 Michael Spertus 和 David Vandevoorde 在 https://wg21.link/n3602 中提出。 最终接受的措辞由迈克尔制定 Spertus、Faisal Vali 和 Richard Smith 在 https://wg21.link/p0091r3 中进行了修改 https://wg21.link/p0512r0 中的 Michael Spertus、Faisal Vali 和 Richard Smith，https://wg21.link/p0620r0 中的 Jason Merrill，以及 Michael Spertus 和 Jason Merrill（作为缺陷报告） 反对 C++17) 在 https://wg21.link/p702r1。 Michael 添加了对标准库中类模板参数推导的支持 Spertus、Walter E. Brown 和 Stephan T. Lavavej 在 https://wg21.link/p0433r2 和（作为 https://wg21.link/p0739r0 中针对 C++17 的缺陷报告。\n10 编译时if 使用 if constexpr(. . . ) 语法，编译器使用编译时表达式在编译时决定是使用 if 语句的 then 部分还是 else 部分（如果有）。 另一部分（如果 any) 被丢弃，因此不会生成任何代码。 这并不意味着它是丢弃的部分. 不过，完全忽略了。 它将像未使用模板的代码一样进行检查。 例如：\n#include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; std::string asString(T x) { if constexpr(std::is_same_v\u0026lt;T, std::string\u0026gt;) { return x; // 语句无效，如果没有转换为字符串 } else if constexpr(std::is_arithmetic_v\u0026lt;T\u0026gt;) { return std::to_string(x); // 声明无效，如果 x 不是数字 } else { return std::string(x); // 语句无效，如果没有转换为字符串 } } 在这里，我们使用这个特性在编译时决定是否只返回一个传递的字符串，调用 std::to_string() 获取传递的整数或浮点值，或尝试将传递的参数转换为 std::string。 因为无效调用被丢弃，下面的代码编译（其中 如果使用常规运行时，则不会出现这种情况）：\n#include \u0026#34;ifcomptime.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; asString(42) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; asString(std::string(\u0026#34;hello\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; asString(\u0026#34;hello\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 10.1 编译时if的时机 如果我们在刚刚介绍的示例中使用运行时 if：\n#include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; std::string asString(T x) { if (std::is_same_v\u0026lt;T, std::string\u0026gt;) { return x; // ERROR, 如果没有转换为字符串 } else if (std::is_numeric_v\u0026lt;T\u0026gt;) { return std::to_string(x); // ERROR, 如果 x 不是数字 } else { return std::string(x); // ERROR, 如果没有转换为字符串 } } 相应的代码永远不会编译。 这是函数模板通常不编译或作为一个整体编译的规则的结果。 if 条件的检查是 运行时功能。 即使在编译时很明显条件必须为假，那么 部分必须能够编译。 因此，当传递 std::string 或字符串文字时，编译失败， 因为对传递的参数调用 std::to_string() 无效。 当通过一个 数值，编译失败，因为第三个和第三个返回语句无效。 现在且仅通过使用编译时 if，无法使用的 then 和 else 部分变成 丢弃的语句：\n当传递一个std::string 值时，第一个if 的else 部分被丢弃。\n当传递一个数值时，第一个if 的then 部分和最后一个else 部分被丢弃。\n当传递一个字符串文字（即类型 const char*）时，第一个和第二个 if 的 then 部分 被丢弃。\n因此，每个无效组合在编译时都不会再出现，代码编译成功。 请注意，丢弃的语句不会被忽略。 效果是它没有被实例化，当 取决于模板参数。 语法必须正确，不依赖模板参数的调用必须有效。 实际上，执行第一个翻译阶段（定义时间）， 它检查正确的语法和所有不依赖于模板参数的名称的使用。 所有 static_asserts 也必须有效，即使在未编译的分支中也是如此。 例如：\ntemplate\u0026lt;typename T\u0026gt; void foo(T t) { if constexpr(std::is_integral_v\u0026lt;T\u0026gt;) { if (t \u0026gt; 0) { foo(t-1); // OK } } else { undeclared(t); // 如果未声明且未丢弃则错误（即 T 不是整数） undeclared(); // 如果未声明则错误（即使已丢弃） static_assert(false, \u0026#34;no integral\u0026#34;); // 总是断言（即使被丢弃） } } 使用符合标准的编译器，此示例永远不会编译，原因有两个：\n即使 T 是整数类型，调用\nundeclared(); // 如果未声明则错误（即使已丢弃） 如果没有声明这样的函数，则丢弃的 else 部分是一个错误，因为这个调用没有 依赖于模板参数\n调用：\nstatic_assert(false, \u0026#34;no integral\u0026#34;); // 总是断言（即使被丢弃） 即使它是被丢弃的 else 部分的一部分，它也总是会下降，因为这个调用再次不依赖于 模板参数。 重复编译时条件的静态断言会很好：\nstatic_assert(!std::is_integral_v\u0026lt;T\u0026gt;, \u0026#34;no integral\u0026#34;); 请注意，某些编译器（例如，Visual C++ 2013 和 2015）没有正确实现或执行模板的两阶段转换。 它们将第一阶段（定义时间）的大部分时间推迟到第二阶段（实例化时间），因此无效的函数调用甚至一些语法错误都可能编译。\n10.2 使用编译时if 原则上，如果条件是 编译时表达式。 在以下情况下，您还可以混合编译时和运行时：\nif constexpr (std::is_integral_v\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt;) { if (val \u0026gt; 10) { if constexpr (std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { ... } else { ... } } else { ... } } else { ... } 请注意，您不能在函数体之外使用 if constexpr。 因此，你不能用它来代替 条件预处理器指令。\n10.2.1 编译时if的注意事项 即使有可能使用 compile-time if ，如果可能有一些后果不是 很明显，这将在以下小节中讨论。\ncompile-time if 影响返回类型 compile-time if可能影响函数的返回类型。例如，下面的代码总是可以编译，但返回类型可能不同:\nauto foo() { if constexpr (sizeof(int) \u0026gt; 4) { return 42; } else { return 42u; } } 在这里，由于我们使用了auto，函数的返回类型取决于返回语句，而返回语句则 取决于int的大小。\n如果大小大于4，只有一个有效的返回语句返回42，所以返回 类型是int。 否则，只有一个返回语句返回42u，所以返回类型变成了 unsigned int.。 这样一来，带有if constexpr的函数的返回类型可能会有更大的差别例如，如果我们跳过else部分，返回类型可能是int或void。\nauto foo() // 返回类型可能是int或void { if constexpr (sizeof(int) \u0026gt; 4) { return 42; } } 请注意，如果这里使用了compile-time if，这段代码永远不会被编译，因为那样的话，两个返回语句都会被考虑在内，这样一来，对返回类型的推断就会变得模糊不清了。\nelse Matters Even if then Returns 对于compile-time if语句，有一种模式不适用于compile-time if语句。如果 代码的then和else部分都有返回语句，你可以跳过compile-time if语句中的else语句。也就是说，不要用:\nif (...) { return a; } else { return b; } 你总是可以写:\nif (...) { return a; } return b; 如果条件为真（int的大小大于4），编译器会推断出两种不同的返回类型，这是不成立的。否则，我们只有一个重要的返回语句，这样代码就可以编译了。\n短回路compile-time条件 考虑以下代码：\ntemplate\u0026lt;typename T\u0026gt; constexpr auto foo(const T\u0026amp; val) { if constexpr (std::is_integral\u0026lt;T\u0026gt;::value) { if constexpr (T{} \u0026lt; 10) { return val * 2; } } return val; } 这里我们有两个compile-time条件来决定是按原样返回传递的值还是加倍。\n这为两者编译：\nconstexpr auto x1 = foo(42); // yields 84 constexpr auto x2 = foo(\u0026#34;hi\u0026#34;); // OK, yields ”hi” 运行时ifs中的条件是短路的（评估带有\u0026amp;\u0026amp;的条件只到第一个false，评估带有||的条件只到第一个true）。这可能会导致人们期望compile-time if也是这种情况:\ntemplate\u0026lt;typename T\u0026gt; constexpr auto bar(const T\u0026amp; val) { if constexpr (std::is_integral\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; T{} \u0026lt; 10) { return val * 2; } return val; } 然而，compile-time if的条件总是被实例化的，并且需要整体有效，因此，传递一个不支持\u0026lt;10的类型不再能编译:\nconstexpr auto x2 = bar(\u0026#34;hi\u0026#34;); // compile-time ERROR 因此，compile-time if不会使实例化short-circuit。 如果编译时条件的有效性依赖于较早的编译时条件，则必须像在 foo() 中那样嵌套它们。 作为另一个例子，你必须写：\nif constexpr (std::is_same_v\u0026lt;MyType, T\u0026gt;) { if constexpr (T::i == 42) { ... } } 而不仅仅是：\nif constexpr (std::is_same_v\u0026lt;MyType, T\u0026gt; \u0026amp;\u0026amp; T::i == 42) { ... } 10.2.2 其他编译时if的例子 编译时的一种应用是返回值的完美转发，当它们必须得到处理才能返回时。 因为 void 不能推导出 decltype(auto) （因为 void 是一个不完整的类型），所以你必须编写如下内容：\n#include \u0026lt;functional\u0026gt; // for std::forward() #include \u0026lt;type_traits\u0026gt; // for std::is_same\u0026lt;\u0026gt; and std::invoke_result\u0026lt;\u0026gt; template\u0026lt;typename Callable, typename... Args\u0026gt; decltype(auto) call(Callable op, Args\u0026amp;\u0026amp;... args) { if constexpr(std::is_void_v\u0026lt;std::invoke_result_t\u0026lt;Callable, Args...\u0026gt;\u0026gt;) { // return type is void: op(std::forward\u0026lt;Args\u0026gt;(args)...); ... // do something before we return return; } else { // return type is not void: decltype(auto) ret{op(std::forward\u0026lt;Args\u0026gt;(args)...)}; ... // do something (with ret) before we return return ret; } } Compile-Time if用于标签调度 编译时 if 的一个典型应用是标签调度。 在 C+17 之前，您必须提供 为您要处理的每种类型设置一个单独的函数的重载。 现在，在编译时 如果，您可以将所有逻辑放在一个函数中。 例如，不要重载 std::advance() 算法：\ntemplate\u0026lt;typename Iterator, typename Distance\u0026gt; void advance(Iterator\u0026amp; pos, Distance n) { using cat = std::iterator_traits\u0026lt;Iterator\u0026gt;::iterator_category; advanceImpl(pos, n, cat); // 迭代器类别上的标签调度 } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::random_access_iterator_tag) { pos += n; } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::bidirectional_iterator_tag) { if (n \u0026gt;= 0) { while (n--) { ++pos; } } else { while (n++) { --pos; } } } template\u0026lt;typename Iterator, typename Distance\u0026gt; void advanceImpl(Iterator\u0026amp; pos, Distance n, std::input_iterator_tag) { while (n--) { ++pos; } } 我们现在可以在一个函数中实现所有行为：\ntemplate\u0026lt;typename Iterator, typename Distance\u0026gt; void advance(Iterator\u0026amp; pos, Distance n) { using cat = std::iterator_traits\u0026lt;Iterator\u0026gt;::iterator_category; if constexpr (std::is_same_v\u0026lt;cat, std::random_access_iterator_tag\u0026gt;) { pos += n; } else if constexpr (std::is_same_v\u0026lt;cat, std::bidirectional_access_iterator_tag\u0026gt;) { if (n \u0026gt;= 0) { while (n--) { ++pos; } } else { while (n++) { --pos; } } } else { // input_iterator_tag while (n--) { ++pos; } } } 所以，在某种程度上，我们现在有一个compile-time切换，不同的情况必须在这里得到 但是，由 if constexpr 子句制定。 但是，请注意一个可能很重要的区别：\n重载函数集为您提供最佳匹配语义。\n编译时if 的实现为您提供了第一个匹配语义。\n标签调度的另一个例子是使用编译时 if for get\u0026lt;\u0026gt;() 重载来实现结构绑定接口。\n第三个例子是通用 lambda 中不同类型的处理，如 std::variant\u0026lt;\u0026gt; visitors。\n10.3 带有初始化的编译时if 请注意，compile-time if 也可以使用新形式的 if with 初始化。 例如，如果 有一个 constexpr 函数 foo()，你可以使用：\ntemplate\u0026lt;typename T\u0026gt; void bar(const T x) { if constexpr (auto obj = foo(x); std::is_same_v\u0026lt;decltype(obj), T\u0026gt;) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(x) yields same type\\n\u0026#34;; ... } else { std::cout \u0026lt;\u0026lt; \u0026#34;foo(x) yields different type\\n\u0026#34;; ... } } 如果传递的类型有 constexpr 函数 foo()，您可以使用此代码提供不同的 关于 foo(x) 是否产生与 x 相同类型的行为。 要确定 foo(x) 返回的值，您可以编写：\nconstexpr auto c = ...; if constexpr (constexpr auto obj = foo(c); obj == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;foo() == 0\\n\u0026#34;; ... } 请注意，必须将 obj 声明为 constexpr 才能在条件中使用其值。\n10.4 在模板之外使用编译时if if constexpr 可以在任何函数中使用，而不仅仅是在模板中。 我们只需要一个编译时表达式，它会产生可转换为 bool 的东西。 但是，在那种情况下，在 then 和 the else 部分即使被丢弃，所有语句也必须始终有效。\n例如，下面的代码总是会编译失败，因为 undeclared() 的调用必须是有效的，即使 chars 被签名并且 else 部分被丢弃：\n#include \u0026lt;limits\u0026gt; template\u0026lt;typename T\u0026gt; void foo(T t); int main() { if constexpr(std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { foo(42); // OK } else { undeclared(42); // 如果没有声明总是错误（即使被丢弃） } } 此外，以下代码永远无法成功编译，因为其中一个静态断言将始终失败：\nif constexpr(std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { static_assert(std::numeric_limits\u0026lt;char\u0026gt;::is_signed); } else { static_assert(!std::numeric_limits\u0026lt;char\u0026gt;::is_signed); } 如果在泛型代码之外，编译时的（唯一）好处是被丢弃语句中的代码，尽管它必须是有效的，但不会成为结果程序的一部分，这减少了生成的可执行文件。 例如，在这个程序中：\n#include \u0026lt;limits\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;array\u0026gt; int main() { if (!std::numeric_limits\u0026lt;char\u0026gt;::is_signed) { static std::array\u0026lt;std::string,1000\u0026gt; arr1; ... } else { static std::array\u0026lt;std::string,1000\u0026gt; arr2; ... } } arr1或arr2是最终可执行文件的一部分，但不是两者都是。\n10.5 后记 Compile-time if最初是由Walter Bright, Herb Sutter, 和Andrei Alexandrescu在 https://wg21.link/n3329，以及Ville Voutilainen在https://wg21.link/n4461，提出了静态的if语言特性。 一个静态的if语言特性。在https://wg21.link/p0128r0，Ville Voutilainen提出了这个 该特性首次被称为constexpr_if（该特性的名称由此而来）。最终被接受的 措辞是由Jens Maurer https://wg21.link/p0292r2。\n11 折叠表达式 从C++17开始，有一个功能是计算在一个参数包的所有参数上使用二元运算符的结果（有一个可选的初始值）。 例如，下面的函数返回所有传递参数的总和:\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... args) { return (... + args); // ((arg1 + arg2) + arg3) ... } 注意，返回表达式周围的括号是折叠表达式的一部分，不能省略。\n调用函数时要注意\nfoldSum(47, 11, val, -1); 实例化要执行的模板：\nreturn 47 + 11 + val + -1; 调用它:\nfoldSum(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;); 实例化模板：\nreturn std::string(\u0026#34;hello\u0026#34;) + \u0026#34;world\u0026#34; + \u0026#34;!\u0026#34;; 另请注意，折叠表达式参数的顺序可能不同且很重要（并且可能看起来有点违反直觉）：如所写，\n(... + args) 结果是\n((arg1 + arg2) + arg3) ... 这意味着它会反复“添加”东西。 你也可以写\n(args + ...) 它反复“预添加”事物，因此结果表达式为：\n(arg1 + (arg2 + arg3)) ... 11.1 折叠表达式的动因 折叠表达式避免了递归实例化模板以对参数包的所有参数执行操作的需要。 在 C++17 之前，您必须实现：\ntemplate\u0026lt;typename T\u0026gt; auto foldSumRec (T arg) { return arg; } template\u0026lt;typename T1, typename... Ts\u0026gt; auto foldSumRec (T1 arg1, Ts... otherArgs) { return arg1 + foldSumRec(otherArgs...); } 这样的实现不仅写起来麻烦，而且对 C++ 编译器也有压力。 和\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... args) { return (... + args); // arg1 + arg2 + arg3 ... } 程序员和编译器的工作量都大大减少了。\n11.2 使用折叠表达式 给定参数 args 和运算符 op，C++17 允许我们编写\n要么是一元左折叠\n( ... op args ) 扩展为： ((arg1 op arg2) op arg3) op . . .\n或一元右折叠\n( args op ... ) 扩展为：arg1 op (arg2 op . . . (argN-1 op argN))\n括号是必需的。 但是，括号和省略号 (\u0026hellip;) 不必用空格分隔。 左右折叠之间的差异比预期的更重要。 例如，即使使用 operator + 也可能会有不同的效果。 使用左折叠表达式时：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSumL(T... args){ return (... + args); // ((arg1 + arg2) + arg3) ... } 调用\nfoldSumL(1, 2, 3) 计算结果为：\n(1 + 2) + 3) 这也意味着以下示例可以编译：\nstd::cout \u0026lt;\u0026lt; foldSumL(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 请记住，运算符 + 是为标准字符串定义的，前提是至少有一个操作数是 std::string。 因为使用了左折叠，所以调用首先计算:\nstd::string(\u0026#34;hello\u0026#34;) + \u0026#34;world\u0026#34; 它返回一个 std::string，以便添加字符串文字\u0026quot;!\u0026quot; 那么也是有效的。\n但是，诸如:\nstd::cout \u0026lt;\u0026lt; foldSumL(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, std::string(\u0026#34;!\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // ERROR 不会编译，因为它的计算结果为:\n(\u0026#34;hello\u0026#34; + \u0026#34;world\u0026#34;) + std::string(\u0026#34;!\u0026#34;) 并且不允许添加两个字符串文字。\n但是，如果我们将实现更改为：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSumR(T... args){ return (args + ...); // (arg1 + (arg2 + arg3)) ... } 调用：\nfoldSumR(1, 2, 3) 计算结果为：\n(1 + (2 + 3) 这意味着以下示例不再编译：\nstd::cout \u0026lt;\u0026lt; foldSumR(std::string(\u0026#34;hello\u0026#34;), \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // ERROR 而下面的调用现在编译：\nstd::cout \u0026lt;\u0026lt; foldSumR(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, std::string(\u0026#34;!\u0026#34;)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // OK 因为在几乎所有情况下，从左到右的评估都是意图，通常应该首选带有参数包的左折叠语法（除非这不起作用）：\n(... + args); // 折叠表达式的首选语法 11.2.1 处理空参数包 如果折叠表达式使用了一个空的参数包，那么以下规则适用。\n如果使用了操作符\u0026amp;\u0026amp;，其值为真。\n如果使用了操作符||，则值为假。\n如果使用了逗号运算符，值是void()。\n对于所有其他的操作符来说，调用是不符合格式的。 对于所有其他情况（以及一般情况下），你可以添加一个初始值。给定一个参数包args，一个初始值值和一个运算符op，C++17还允许我们写出以下两种情况\n或者二元左折叠\n( value op ... op args ) 扩展为： (((value op arg1) op arg2) op arg3) op . . .\n或二元右折叠\n( args op ... op value ) 省略号两边的运算符 op 必须相同。 例如，以下定义允许在添加值时传递一个空参数包：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... s){ return (0 + ... + s); // 如果 sizeof...(s)==0 甚至可以工作 } 从概念上讲，我们是否将 0 添加为第一个或最后一个操作数并不重要：\ntemplate\u0026lt;typename... T\u0026gt; auto foldSum (T... s){ return (s + ... + 0); // 如果 sizeof...(s)==0 甚至可以工作 } 但是对于一元折叠表达式，不同的评估顺序比想象的更重要，应该首选二元左折叠：\n(val + ... + args); // 二进制折叠表达式的首选语法 此外，第一个操作数可能是特殊的，例如在此示例中：\ntemplate\u0026lt;typename... T\u0026gt; void print (const T\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 在这里，重要的是第一个调用是第一个传递给 print() 的参数的输出，它返回流以执行其他输出调用。 其他实现可能无法编译甚至做一些意想不到的事情。 例如，与\nstd::cout \u0026lt;\u0026lt; (args \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;); 像 print(1) 这样的调用将编译但打印值 1 左移了 \u0026lsquo;\\n\u0026rsquo; 的值，通常为 10，因此结果输出为 1024。 请注意，在此 print() 示例中，没有空格将参数包的所有元素彼此分开。 诸如 print(\u0026ldquo;hello\u0026rdquo;, 42, \u0026ldquo;world\u0026rdquo;) 之类的调用将打印：\nhello42world 要通过空格分隔传递的元素，您需要一个帮助器来确保除第一个参数之外的任何输出都由前导空格扩展。 例如，这可以使用辅助函数模板 spaceBefore() 来完成：\ntemplate\u0026lt;typename T\u0026gt; const T\u0026amp; spaceBefore(const T\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; } template \u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这里，\n(std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) 是一个折叠表达式，展开为：\nstd::cout \u0026lt;\u0026lt; spaceBefore(arg1) \u0026lt;\u0026lt; spaceBefore(arg2) \u0026lt;\u0026lt; ... 因此，对于参数包 args 中的每个元素，它调用一个辅助函数，在返回传递的参数之前打印出一个空格字符，并将其写入 std::cout。 为了确保这不适用于第一个参数，我们添加了一个不使用 spaceBefore() 的附加第一个参数。 请注意，参数包输出的评估要求左侧的所有输出都在为实际元素调用 spaceBefore() 之前完成。 由于定义了运算符 \u0026laquo; 和函数调用的评估顺序，这保证从 C++17 开始就可以工作。 我们还可以使用 lambda 在 print() 中定义 spaceBefore()：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; auto spaceBefore = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 但是，请注意 lambdas 默认按值返回对象，这意味着这将创建传递参数的不必要副本。 避免这种情况的方法是将 lambda 的返回类型显式声明为 const auto\u0026amp; 或 decltype(auto)：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; auto spaceBefore = [](const auto\u0026amp; arg) -\u0026gt; const auto\u0026amp; { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; spaceBefore(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 如果你不能将这一切结合在一个语句中，C++ 就不会是 C++：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; firstarg; (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; [](const auto\u0026amp; arg) -\u0026gt; decltype(auto) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return arg; }(args)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 然而，实现 print() 的一种更简单的方法是使用 lambda 打印空间和参数并将其传递给一元折叠：\ntemplate\u0026lt;typename First, typename... Args\u0026gt; void print(First first, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; first; auto outWithSpace = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; arg; }; (... , outWithSpace(args)); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 通过使用使用 auto 声明的附加模板参数，我们可以使 print() 更加灵活，可以将分隔符参数化为字符、字符串或任何其他可打印类型。\n11.2.2 支持的操作符 您可以将所有二元运算符用于折叠表达式，除了 ., -\u0026gt;, and []。\n折叠函数调用 折叠表达式也可以用于逗号运算符，将多个表达式组合成一个语句。 例如，您可以折叠逗号运算符，它可以执行对可变数量的基类的成员函数的函数调用：\ntmpl/foldcalls.cpp #include \u0026lt;iostream\u0026gt; // template fo ame... Bases\u0026gt; class MultiBase : private Bases... { public: void print() { // call print() of all base classes: (... , Bases::print()); } }; struct A { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;A::print()\\n\u0026#34;; } }; struct B { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;B::print()\\n\u0026#34;; } }; struct C { void print() { std::cout \u0026lt;\u0026lt; \u0026#34;C::print()\\n\u0026#34;; } }; int main() { MultiBase\u0026lt;A,B,C\u0026gt; mb; mb.print(); } 这里，\ntemplate\u0026lt;typename... Bases\u0026gt; class MultiBase : private Bases... { ... }; 允许我们使用可变数量的基类来初始化对象：\nMultiBase\u0026lt;A,B,C\u0026gt; mb; 并与\n(... , Bases::print()); 折叠表达式用于扩展它以调用每个基类的打印。 也就是说，带有折叠表达式的语句扩展为以下内容：\n(A::print() , B::print()) , C::print(); 但是，请注意，由于逗号运算符的性质，我们使用左折叠运算符还是右折叠运算符并不重要。 函数总是从左到右调用。 和\n(Bases::print() , ...); 括号仅对调用进行分组，以便第一个 print() 调用与其他两个 print() 调用的结果组合如下：\nA::print() , (B::print() , C::print()); 但是因为逗号运算符的计算顺序总是从左到右，所以第一个调用发生在括号内的两个调用组之前，其中中间调用仍然发生在右调用之前。 尽管如此，由于左折叠表达式与结果求值顺序匹配，因此在将左折叠表达式用于多个函数调用时，再次建议使用左折叠表达式。\n结合哈希函数 使用逗号运算符的一个示例是组合散列值。 这可以按如下方式完成：\ntemplate\u0026lt;typename T\u0026gt; void hashCombine (std::size_t\u0026amp; seed, const T\u0026amp; val) { seed ^= std::hash\u0026lt;T\u0026gt;()(val) + 0x9e3779b9 + (seed\u0026lt;\u0026lt;6) + (seed\u0026gt;\u0026gt;2); } template\u0026lt;typename... Types\u0026gt; std::size_t combinedHashValue (const Types\u0026amp;... args) { std::size_t seed = 0; // initial seed (... , hashCombine(seed,args)); // chain of hashCombine() calls return seed; } 通过调用\nstd::size_t combinedHashValue (\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, 42,); 中间的语句扩展为：\nhashCombine(seed,\u0026#34;Hello\u0026#34;), (hashCombine(seed,\u0026#34;World\u0026#34;), hashCombine(seed,42); 通过这个定义，我们可以轻松地为诸如 Customer 的类型定义一个新的散列函数对象：\nstruct CustomerHash { std::size_t operator() (const Customer\u0026amp; c) const { return combinedHashValue(c.getFirstname(), c.getLastname(), c.getValue()); } }; 我们可以用它来把客户放在一个无序的集合中：\nstd::unordered_set\u0026lt;Customer, CustomerHash\u0026gt; coll; 折叠路径遍历\n您还可以使用折叠表达式通过运算符 -\u0026gt;* 遍历二叉树中的路径：\ntmpl/foldtraverse.cpp\n// 定义二叉树结构和遍历辅助函数: struct Node { int value; Node* left; Node* right; Node(int i=0) : value(i), left(nullptr), right(nullptr) { } ... }; auto left = \u0026amp;Node::left; auto right = \u0026amp;Node::right; // 遍历树，使用折叠表达式: template\u0026lt;typename T, typename... TP\u0026gt; Node* traverse (T np, TP... paths) { return (np -\u0026gt;* ... -\u0026gt;* paths); // np -\u0026gt;* paths1 -\u0026gt;* paths2 ... } int main() { // 初始化二叉树结构: Node* root = new Node{0}; root-\u0026gt;left = new Node{1}; root-\u0026gt;left-\u0026gt;right = new Node{2}; ... // 遍历二叉树: Node* node = traverse(root, left, right); ... } 这里，\n(np -\u0026gt;* ... -\u0026gt;* paths) 使用折叠表达式来遍历来自 np 的路径的可变参数元素。 调用时\ntraverse(root, left, right); fold 表达式的调用扩展为：\nroot -\u0026gt; left -\u0026gt; right 11.2.3 为类型使用折叠表达式 通过使用类型特征，我们还可以使用折叠表达式来处理模板参数包（作为模板参数传递的任意数量的类型）。 例如，您可以使用折叠表达式来确定类型列表是否是齐次的：\ntmpl/ishomogeneous.hpp\n#include \u0026lt;type_traits\u0026gt; // 检查传递的类型是否是同质的: template\u0026lt;typename T1, typename... TN\u0026gt; struct IsHomogeneous { static constexpr bool value = (std::is_same\u0026lt;T1,TN\u0026gt;::value \u0026amp;\u0026amp; ...); }; // 检查传递的参数是否具有相同的类型: template\u0026lt;typename T1, typename... TN\u0026gt; constexpr bool isHomogeneous(T1, TN...) { return (std::is_same\u0026lt;T1,TN\u0026gt;::value \u0026amp;\u0026amp; ...); } 可以使用类型特征 IsHomogeneous\u0026lt;\u0026gt;，例如，如下所示：\nIsHomogeneous\u0026lt;int, Size, decltype(42)\u0026gt;::value 在这种情况下，初始化成员值的折叠表达式扩展为：\nstd::is_same\u0026lt;int,MyType\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,decltype(42)\u0026gt;::value 可以使用函数模板isHomogeneous\u0026lt;\u0026gt;()，例如如下：\nisHomogeneous(43, -1, \u0026#34;hello\u0026#34;, nullptr) 在这种情况下，初始化成员值的折叠表达式扩展为：\nstd::is_same\u0026lt;int,int\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,const char*\u0026gt;::value \u0026amp;\u0026amp; std::is_same\u0026lt;int,std::nullptr_t\u0026gt;::value 像往常一样，操作符\u0026amp;\u0026amp;是短 循环的（在第一个假的之后中止评估）。 std::array\u0026lt;\u0026gt;的推导指南在标准库中使用了这个特性。\n11.3 后记 折叠表达式首先由 Andrew Sutton 和 Richard Smith 在 https://wg21.link/n4191 中提出。 最终接受的措辞由 Andrew Sutton 和 Richard Smith 在 https://wg21.link/n4295 中制定。 后来删除了对运算符 *、+、\u0026amp; 和 | 的空序列支持 正如 Thibaut Le Jehan 在 https://wg21.link/p0036 中提出的那样。\n12 将字符串作为模板参数处理 随着时间的推移，不同版本的 C++ 放宽了可用作模板参数的规则，而在 C++17 中，这种情况再次发生。 现在可以使用模板，而无需在当前范围之外定义它们。\n12.1 在模板中使用字符串 非类型模板参数只能是常量整数值（包括枚举）、指向对象/函数/成员的指针、对对象或函数的左值引用或 std::nullptr_t（nullptr 的类型）。 对于指针，链接是必需的，这意味着您不能直接传递字符串文字。 但是，从 C++17 开始，您可以拥有带有内部链接的指针。 例如：\ntemplate\u0026lt;const char* str\u0026gt; class Message { ... }; extern const char hello[] = \u0026#34;Hello World!\u0026#34;; // 外联 const char hello11[] = \u0026#34;Hello World!\u0026#34;; // 内部链接 void foo() { Message\u0026lt;hello\u0026gt; msg; // OK (all C++ versions) Message\u0026lt;hello11\u0026gt; msg11; // OK since C++11 static const char hello17[] = \u0026#34;Hello World!\u0026#34;; // 无联动 Message\u0026lt;hello17\u0026gt; msg17; // OK since C++17 } 也就是说，从 C++17 开始，您仍然需要两行来将字符串文字传递给模板。 但是您可以将第一行放在与类实例化相同的范围内。 这种能力也解决了一个不幸的限制：虽然你可以将指针传递给自 C++11 以来的类模板：\ntemplate\u0026lt;int* p\u0026gt; struct A { }; int num; A\u0026lt;\u0026amp;num\u0026gt; a; // OK since C++11 您不能使用返回地址的编译时函数，现在支持：\nint num; ... constexpr int* pNum() { return \u0026amp;num; } A\u0026lt;pNum()\u0026gt; b; // ERROR before C++17, now OK 12.2 后记 允许对所有非类型模板参数进行持续评估是由 Richard Smith 在 https://wg21.link/n4198 中首次提出的。 最终接受的措辞由 Richard Smith 在 https://wg21.link/n4268 中制定。\n13 占位符类型（例如 auto）作为模板参数 从 C++17 开始，您可以使用占位符类型（auto 和 decltype(auto)）作为非类型模板参数类型。 这意味着，我们可以为不同类型的非类型参数编写通用代码。\n13.1 使用auto作为模板参数 从 C++17 开始，您可以使用 auto 来声明非类型模板参数。 例如：\ntemplate\u0026lt;auto N\u0026gt; class S { ... }; 这允许我们为不同类型实例化非类型模板参数 N：\nS\u0026lt;42\u0026gt; s1; // OK: S 中 N 的类型是 int S\u0026lt;\u0026#39;a\u0026#39;\u0026gt; s2; // OK: S 中 N 的类型是 char 但是，您不能使用此功能来获取通常不允许作为模板参数的类型的实例化：\nS\u0026lt;2.5\u0026gt; s3； // 错误：模板参数类型仍然不能为双精度 我们甚至可以有一个特定的类型作为部分特化：\ntemplate\u0026lt;int N\u0026gt; class S\u0026lt;N\u0026gt; { ... }; 甚至支持类模板参数推导。 例如：\ntemplate\u0026lt;typename T, auto N\u0026gt; class A { public: A(const std::array\u0026lt;T,N\u0026gt;\u0026amp;) { } A(T(\u0026amp;)[N]) { } ... }; 这个类可以推导出T的类型，N的类型，N的值：\nA a2{\u0026#34;hello\u0026#34;}; // OK, 推导出 A\u0026lt;const char, 6\u0026gt; 其中 N 为 int std::array\u0026lt;double,10\u0026gt; sa1; A a1{sa1}; // OK, 推导出 A\u0026lt;double, 10\u0026gt; 其中 N 为 std::size_t 您还可以限定 auto，例如，要求模板参数的类型是指针：\ntemplate\u0026lt;const auto* P\u0026gt; struct S; 通过使用可变参数模板，您可以参数化模板以使用异构常量模板参数列表：\ntemplate\u0026lt;auto... VS\u0026gt; class HeteroValueList { }; 或同质常量模板参数列表：\ntemplate\u0026lt;auto V1, decltype(V1)... VS\u0026gt; class HomoValueList { }; 例如：\nHeteroValueList\u0026lt;1, 2, 3\u0026gt; vals1; // OK HeteroValueList\u0026lt;1, \u0026#39;a\u0026#39;, true\u0026gt; vals2; // OK HomoValueList\u0026lt;1, 2, 3\u0026gt; vals3; // OK HomoValueList\u0026lt;1, \u0026#39;a\u0026#39;, true\u0026gt; vals4; // ERROR 13.1.1 字符和字符串的参数化模板 此功能的一个应用是允许将字符或字符串作为模板参数传递。 例如，我们可以改进使用折叠表达式输出任意数量参数的方式，如下所示：\n#include \u0026lt;iostream\u0026gt; template\u0026lt;auto Sep = \u0026#39; \u0026#39;, typename First, typename... Args\u0026gt; void print(const First\u0026amp; first, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; first; auto outWithSep = [](const auto\u0026amp; arg) { std::cout \u0026lt;\u0026lt; Sep \u0026lt;\u0026lt; arg; }; (... , outWithSep(args)); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 尽管如此，我们可以打印带有空格的参数作为模板参数的默认参数 Sep:\ntemplate\u0026lt;auto Sep = \u0026#39; \u0026#39;, typename First, typename... Args\u0026gt; void print (const First\u0026amp; firstarg, const Args\u0026amp;... args) { ... } 也就是说，我们仍然可以调用：\nstd::string s{\u0026#34;world\u0026#34;}; print(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5 hello world 但是通过为分隔符 Sep 参数化 print()，我们现在可以显式传递一个不同的字符作为第一个模板参数：\nprint\u0026lt;\u0026#39;-\u0026#39;\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5-hello-world 由于使用了 auto，我们甚至可以传递一个字符串文字，我们必须将其声明为没有链接的对象，不过：\nstatic const char sep[] = \u0026#34;, \u0026#34;; print\u0026lt;sep\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5, hello, world 或者我们可以传递可用作模板参数的任何其他类型的分隔符（这比这里更有意义）：\nprint\u0026lt;-11\u0026gt;(7.5, \u0026#34;hello\u0026#34;, s); // prints: 7.5-11hello-11world 13.1.2 定义元编程常量 模板参数自动特性的另一个应用是更容易定义编译时常量。 而不是定义：\ntemplate\u0026lt;typename T, T v\u0026gt; struct constant { static constexpr T value = v; }; using i = constant\u0026lt;int, 42\u0026gt;; using c = constant\u0026lt;char, \u0026#39;x\u0026#39;\u0026gt;; using b = constant\u0026lt;bool, true\u0026gt;; 您现在可以执行以下操作：\ntemplate\u0026lt;auto v\u0026gt; struct constant { static constexpr auto value = v; }; using i = constant\u0026lt;42\u0026gt;; using c = constant\u0026lt;\u0026#39;x\u0026#39;\u0026gt;; using b = constant\u0026lt;true\u0026gt;; 而不是：\ntemplate\u0026lt;typename T, T... Elements\u0026gt; struct sequence { }; using indexes = sequence\u0026lt;int, 0, 3, 4\u0026gt;; 你现在可以实现：\ntemplate\u0026lt;auto... Elements\u0026gt; struct sequence { }; using indexes = sequence\u0026lt;0, 3, 4\u0026gt;; 您现在甚至可以定义表示异构值列表的编译时对象（类似于压缩元组）：\nusing tuple = sequence\u0026lt;0, \u0026#39;h\u0026#39;, true\u0026gt;; 13.2 使用 auto 作为可变模板参数 您还可以将 auto 用作带有变量模板的模板参数。 例如，以下可能出现在头文件中的声明定义了一个变量模板 arr 参数化为元素的类型以及元素数量的磁带和值：\ntemplate\u0026lt;typename T, auto N\u0026gt; std::array\u0026lt;T,N\u0026gt; arr; 在每个翻译单元中， arr\u0026lt;int,10\u0026gt; 的所有用法共享同一个全局对象，而 arr\u0026lt;long,10\u0026gt; 和 arr\u0026lt;int,10u\u0026gt; 将是不同的全局对象（同样，它们都可用于所有翻译单元）。\n作为一个完整的示例，请考虑以下头文件：\ntmpl/vartmplauto.hpp\n#ifndef VARTMPLAUTO_HPP #define VARTMPLAUTO_HPP #include \u0026lt;array\u0026gt; template\u0026lt;typename T, auto N\u0026gt; std::array\u0026lt;T,N\u0026gt; arr{}; void printArr(); #endif // VARTMPLAUTO_HPP 在这里，一个翻译单元可以修改这个变量模板的两个不同实例的值\ntmpl/vartmplauto1.cpp #include \u0026#34;vartmplauto.hpp\u0026#34; int main() { arr\u0026lt;int,5\u0026gt;[0] = 17; arr\u0026lt;int,5\u0026gt;[3] = 42; arr\u0026lt;int,5u\u0026gt;[1] = 11; arr\u0026lt;int,5u\u0026gt;[3] = 33; printArr(); } 另一个翻译单元可以打印这两个变量：\ntmpl/vartmplauto2.cpp #include \u0026#34;vartmplauto.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; void printArr() { std::cout \u0026lt;\u0026lt; \u0026#34;arr\u0026lt;int,5\u0026gt;: \u0026#34;; for (const auto\u0026amp; elem : arr\u0026lt;int,5\u0026gt;) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\narr\u0026lt;int,5u\u0026gt;: \u0026#34;; for (const auto\u0026amp; elem : arr\u0026lt;int,5u\u0026gt;) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 该程序的输出将是：\narr\u0026lt;int,5\u0026gt;: 17 0 0 42 0 arr\u0026lt;int,5u\u0026gt;: 0 11 0 33 0 与声明从其初始值推导出的任意类型的常量变量相同的方式：\ntemplate\u0026lt;auto N\u0026gt; constexpr auto val = N; // OK since C++17 并在以后使用它，例如，如下：\nauto v1 = val\u0026lt;5\u0026gt;; // v1 == 5, v1 is int auto v2 = val\u0026lt;true\u0026gt;; // v2 == true, v2 is bool auto v3 = val\u0026lt;\u0026#39;a\u0026#39;\u0026gt;; // v3 == ’a’, v3 is char 为了澄清这里发生了什么：\nstd::is_same_v\u0026lt;decltype(val\u0026lt;5\u0026gt;), int\u0026gt; // yields false std::is_same_v\u0026lt;decltype(val\u0026lt;5\u0026gt;), const int\u0026gt; // yields true std::is_same_v\u0026lt;decltype(v1), int\u0026gt;; // yields true (because auto decays) 13.3 使用decltype(auto)作为模板参数 您还可以使用 C++14 引入的其他占位符类型 decltype(auto)。 但是请注意，这种类型有非常特殊的规则来推断类型。 根据decltype，如果传递的是表达式而不是名称，它会根据表达式的值类别推导类型：\n纯右值的类型（例如，临时值） type\u0026amp; 用于左值（例如，具有名称的对象） xvalue 的类型\u0026amp;\u0026amp;（例如，转换为右值引用的对象，与 std::move() 一样。 这意味着，您可以轻松地将模板参数推导出为引用，这可能会产生令人惊讶的效果。 例如： tmpl/decltypeauto.cpp #include \u0026lt;iostream\u0026gt; template\u0026lt;decltype(auto) N\u0026gt; struct S { void printN() const { std::cout \u0026lt;\u0026lt; \u0026#34;N: \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; static const int c = 42; static int v = 42; int main() { S\u0026lt;c\u0026gt; s1; // 将 N 推导出为 const int 42 S\u0026lt;(c)\u0026gt; s2; // 将 N 推导出为 const int\u0026amp; 引用 c s1.printN(); s2.printN(); S\u0026lt;(v)\u0026gt; s3; // 将 N 推导出为 int\u0026amp; 引用 v v = 77; s3.printN(); // prints: N: 77 } 13.4 后记 非类型模板参数的占位符类型最早由 James Touton 和 Michael 提出 Spertus 作为 https://wg21.link/n4469 的一部分。 最终接受的措辞是由 https://wg21.link/p0127r2 中的 James Touton 和 Michael Spertus。\n14 扩展Using声明 使用声明被扩展为允许以逗号分隔的声明列表，以允许它们在包扩展中使用。 例如，您现在可以编程：\nclass Base { public: void a(); void b(); void c(); }; class Derived : private Base { public: using Base::a, Base::b, Base::c; }; 在 C++17 之前，您需要三种不同的 using 声明。\n14.1 使用可变参数using声明 使用逗号分隔的声明提供了从基类的可变参数列表中一般派生所有同类操作的能力。 这种技术的一个非常酷的应用是创建一组 lambda 重载。 通过定义以下内容：\ntmpl/overload.hpp\n// ”inherit” all function call operators of passed base types: template\u0026lt;typename... Ts\u0026gt; struct overload : Ts... { using Ts::operator()...; }; // base types are deduced from passed arguments: template\u0026lt;typename... Ts\u0026gt; overload(Ts...) -\u0026gt; overload\u0026lt;Ts...\u0026gt;; 您可以重载两个 lambda，如下所示：\nauto twice = overload { [](std::string\u0026amp; s) { s += s; }, [](auto\u0026amp; v) { v *= 2; } }; 这里我们创建了一个类型重载的对象，我们使用推导指南将 lambdas 的类型推导出为模板类型重载的基类，并使用聚合初始化来初始化具有闭包类型的复制构造函数的基类的子对象 ，每个 lambda 都有。 然后 using 声明使两个函数调用运算符都可用于类型重载。 如果没有 using 声明，基类将具有同一成员的两个不同重载 函数 operator()，这是模棱两可的。 因此，您可以传递一个字符串，它调用第一个重载或传递另一个类型，它（假设运算符 *= 有效）使用第二个重载：\nint i = 42; twice(i); std::cout \u0026lt;\u0026lt; \u0026#34;i: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: 84 std::string s = \u0026#34;hi\u0026#34;; twice(s); std::cout \u0026lt;\u0026lt; \u0026#34;s: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints: hihi 这种技术的一个应用是 std::variant 访问者。\n14.2 使用声明继承构造函数的可变参数 除了对继承构造函数的一些说明外，现在还可以进行以下操作：您可以声明一个可变参数类模板 Multi，该模板派生自其每个传递的类型的基类：\ntmpl/using2.hpp template\u0026lt;typename T\u0026gt; class Base { T value{}; public: Base() { ... } Base(T v) : value{v} { ... } ... }; template\u0026lt;typename... Types\u0026gt; class Multi : private Base\u0026lt;Types\u0026gt;... { public: // derive all constructors: using Base\u0026lt;Types\u0026gt;::Base...; ... }; 使用所有基类构造函数的 using 声明，您可以为每种类型派生一个对应的构造函数.\n现在，当为三种不同类型的值声明 Multi\u0026lt;\u0026gt; 类型时：\nusing MultiISB = Multi\u0026lt;int,std::string,bool\u0026gt;; 您可以使用每个相应的构造函数来声明对象：\nMultiISB m1 = 42; MultiISB m2 = std::string(\u0026#34;hello\u0026#34;); MultiISB m3 = true; 根据新的语言规则，每次初始化都会为匹配的基类调用相应的构造函数，并为所有其他基类调用默认构造函数。 因此:\nMultiISB m2 = std::string(\u0026#34;hello\u0026#34;); 调用 Base 的默认构造函数、Basestd::string 的字符串构造函数和 Base 的默认构造函数。 原则上，您还可以通过指定启用 Multi\u0026lt;\u0026gt; 中的所有赋值运算符：\ntemplate\u0026lt;typename... Types\u0026gt; class Multi : private Base\u0026lt;Types\u0026gt;... { ... // 导出所有赋值运算符: using Base\u0026lt;Types\u0026gt;::operator=...; } 14.3 后记 逗号分隔的 using 声明由 Robert Haberlach 在 https://wg21.link/p0195r0 中提出。 最终接受的措辞由 Robert Haberlach 和 Richard Smith 在 https://wg21.link/p0195r2 中制定。 各种核心问题要求对继承构造函数进行澄清。 最终接受的修复它们的措辞由 Richard Smith 在 https://wg21.link/n4429 中制定。 Vicente J. Botet Escriba 提出了一个建议，即添加一个泛型重载函数来重载 lambda，以及普通函数和成员函数。 然而，这篇论文并没有进入 C++17。 有关详细信息，请参阅 https://wg21.link/p0051r1。\n","date":"2022-03-19T00:01:14Z","permalink":"https://okokfun.github.io/post/c++/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/","title":"第二部分-模板特性"},{"content":" 此文档来自于👉 QtDocumentCN/QtDocumentCN: Qt中文文档翻译 (github.com)\n并由本人补充了一些文档\n","date":"2022-02-23T23:08:02Z","permalink":"https://okokfun.github.io/post/c++/qt%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/","title":"QT文档翻译"},{"content":" 左值有地址和值，可以出现在赋值运算符左边或者右边。\n右值只有值，只能出现在赋值运算符右边。\n右值只有值，没有地址， 右值是一个优化技巧（C++)，因为右值往往是临时变量的。\n左值代表另一个值，右值是值本身。\n","date":"2022-02-20T16:30:47Z","permalink":"https://okokfun.github.io/post/c++/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/","title":"左值和右值"},{"content":" 并发：\n​\t计算机可以同时执行多个任务；单核处理器可以通过分配时间片的方式 单线程 并行：\n针对多核处理器，不用用过分配时间片方式执行任务，少了线程的上下文切换 同步：\n上一个任务执行完毕后才可以进行下一个任务，所以没有并发和并行概念 多线程同步（资源争抢） 异步：\n不同任务不会相互等待，执行任务A时也可以在执行任务B，当任务A没有算出结果时，不会呆呆的等A，而是会去执行B，也有可能也同时执行C，D\u0026hellip;，等未来的某个时间A的结果返回也没问题。\n同步里面没有并行和异步的概念，异步是一种任务执行序列，其应用可以在多线程并行、单线程并发 多线程的应用场景下，如果有资源竞争的情况，适合使用异步（单线程） ","date":"2022-02-20T16:23:26Z","permalink":"https://okokfun.github.io/post/c++/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/","title":"并发_并行_同步_异步"},{"content":" 此篇是VS添加OpenCV库教程\n1. 创建一个新工程 2. 创建完工程后切到属性管理器 3. 添加新项目属性列表 然后切到Debug | x64添加新项目属性列表(P) 然后双击新建的文件。\n4. 添加库头文件路径和库文件路径 添加库头文件路径 添加库文件路径\n5. 填写要使用的库文件名 这里使用debug版\nEnd.\n","date":"2022-02-19T23:13:27Z","permalink":"https://okokfun.github.io/post/c++/visual-studio-2022-pre%E6%B7%BB%E5%8A%A0opencv%E5%BA%93/","title":"Visual_Studio_2022_PRE添加OpenCV库"},{"content":" 采用了linux下编译OpenCV, Visual Studio 2022, QT6.2.3都不成功。\n最终采用在win下编译OpenCV + Clion成功，此文记录踩下的坑。\n1. 下载OpenCV源码 源码地址👇\nGithub:\nhttps://github.com/opencv/opencv/archive/4.5.5.zip\n2. 编译OpenCV源码 解压文件夹 解压win下exe文件解压后由两个文件夹，source为源码目录 build为已经建好的库文件目录\nCMake-gui工具构建\nsource code选择带有源码的目录，binaries选择一个新创建一个mingw-build目录，然后点击Configure，弹出的窗口选择MinGW Makefiles,第一次可能会失败，失败后再点击Configure，还不行的百度吧。 配置成功后点击Generate cd到mingw-bulid目录执行mingw32-make -j8,根据自己机器性能设置线程数，这里设置8个线程，编译时间较久，等待完成。 然后执行mingw32-make install生成库，在mingw-build生成install保存了生成库库文件和头文件。 3. 后续配置 把C:\\\\Users\\\\用户名\\\\Downloads\\\\opencv\\\\mingw-build\\\\install\\\\x64\\\\mingw\\\\bin路径添加到win的环境变量\n👇此为一个CMakeLists.txt\ncmake_minimum_required(VERSION 3.19) project(opencv_learn) set(CMAKE_CXX_STANDARD 20) include_directories($ENV{CMAKE_INCLUDE_PATH}) set(OpenCV_DIR C:\\\\Users\\\\用户名\\\\Downloads\\\\opencv\\\\mingw-build\\\\install\\\\x64\\\\mingw\\\\bin) #需要的openCV库 FIND_PACKAGE(OpenCV REQUIRED) #显示OpenCV的版本号 MESSAGE(\u0026#34;OpenCV version : ${OpenCV_VERSION}\u0026#34;) MESSAGE(\u0026#34;OpenCV include : ${OpenCV_INCLUDE_DIRS}\u0026#34;) MESSAGE(\u0026#34;OpenCV libs11 : ${OpenCV_LIBS}\u0026#34;) MESSAGE(\u0026#34;OpenCV DIR : ${OpenCV_DIR}\u0026#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) MESSAGE(\u0026#34;OpenCV libs : ${OpenCV_LIBS}\u0026#34;) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBS}) set(SOURCE main.cpp) # 将源代码添加到此项目的可执行文件。 add_executable (${PROJECT_NAME} ${SOURCE}) TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS}) ","date":"2022-02-15T19:21:35+08:00","permalink":"https://okokfun.github.io/post/c++/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8Aclion%E4%BD%BF%E7%94%A8/","title":"cmake编译opencv及Clion使用"},{"content":"此文来自于👉由UP主神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译 【63】【Cherno C++】【中字】C++的计时_哔哩哔哩_bilibili ，并由我整理。\nC++计时器\nstd::chrono::high_resolution_clock高分辨率时钟在不同标准库有所区别，尽量不要使用。\n对时长度量使用 steady_clock 对壁钟时间使用 system_clock 。 基础计时器\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; int main(void) { auto start = std::chrono::steady_clock::now(); std::this_thread::sleep_for(std::chrono::seconds(1)); auto end = std::chrono::steady_clock::now(); std::chrono::duration\u0026lt;float\u0026gt; time = end - start; std::cout \u0026lt;\u0026lt; time.count() \u0026lt;\u0026lt; \u0026#34;s \\n\u0026#34;; std::cin.get(); } 计算打印hello用时\nstruct Timer { std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; start, end; std::chrono::duration\u0026lt;float\u0026gt; duration; Timer() { start = std::chrono::steady_clock::now(); } ~Timer() { end = std::chrono::steady_clock::now(); duration = end - start; float ms = duration.count() * 1000.0f; std::cout \u0026lt;\u0026lt; \u0026#34;Timer took \u0026#34; \u0026lt;\u0026lt; ms \u0026lt;\u0026lt; \u0026#34;ms \\n\u0026#34;; } }; void Function() { Timer timer; // 计算此函数生命周期耗时 for (int i = 0; i \u0026lt; 100; i++) std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\n\u0026#34;; } ","date":"2022-02-10T17:01:05Z","permalink":"https://okokfun.github.io/post/c++/c++%E8%AE%A1%E6%97%B6%E5%99%A8/","title":"C++计时器"},{"content":" 视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【80】【Cherno C++】【中字】如何让C++字符串更快_哔哩哔哩_bilibili 并由我整理。\n此本不会讲解为什么std::string会很慢和其背后的细节，只有些例子。\nstd::string的主要问题之一是 字符串格式化及字符串操作 时需要分配内存\nbad例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; static uint32_t s_AllocCount = 0; // 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符 void* operator new(size_t size) { s_AllocCount++; std::cout \u0026lt;\u0026lt; \u0026#34;allocating: \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; return malloc(size); } void PrintName(const std::string\u0026amp; name) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { std::string name = \u0026#34;Yan Chernikov\u0026#34;; std::string firstname = name.substr(0, 3); std::string lasttname = name.substr(4, 9); PrintName(firstname); std::cout \u0026lt;\u0026lt; s_AllocCount \u0026lt;\u0026lt; \u0026#34; allocations\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cin.get(); } std::string_views, 它本质上是一个指向内存的指针，就是const char指针，指向其他人拥有的现有字符串，再加上一个size；\n比如一个字符串 \u0026ldquo;hello world\u0026rdquo;,有一个指向第一个字符(h)的指针,大小是3 再比如有一个指针指向h的指针，大小是4个字节，把我带到那个lastname的开头，大小是9 这是在创建一个进入现有内存的小视窗，而不是分配一个新的字符串用substr()创建一个新的字符串，\n我想要的是一个窗口的视图，到一个已有自己内存的字符串\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; static uint32_t s_AllocCount = 0; // 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符 void* operator new(size_t size) { s_AllocCount++; std::cout \u0026lt;\u0026lt; \u0026#34;allocating: \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; return malloc(size); } void PrintName(std::string_virew name) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { std::string name = \u0026#34;Yan Chernikov\u0026#34;; std::string_view firstname(name.c_str(), 3); std::string_view firstname(name.c_str() + 4, 9); PrintName(firstname); std::cout \u0026lt;\u0026lt; s_AllocCount \u0026lt;\u0026lt; \u0026#34; allocations\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cin.get(); } ","date":"2022-02-07T17:25:55Z","permalink":"https://okokfun.github.io/post/c++/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/","title":"让字符串及字符操作更加快速"},{"content":" 视频由up神经元猫 神经元猫的个人空间_哔哩哔哩_bilibili 翻译自 youtube.com/cherno 并发布到👉 【79】【Cherno C++】【中字】如何让C++运行得更快_哔哩哔哩_bilibili 并由我整理。\n通过编码方式利用多核或多处理器 ,利用这些线程，不只是让你的程序顺序执行一条条指令，而是把一些东西，推迟到不同的线程，甚至不是推迟，二十把东西分派到不同的线程，让计算机更快地处理这些东西。\n每一个资源，每一个纹理模型，他们通常独立于彼此，意味着这是良好的多线程候选场景。\nstatic std::mutex s_MeshesMutex; static void LoadMesh(std::vector\u0026lt;Ref\u0026lt;Mesh\u0026gt;\u0026gt;* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard\u0026lt;std::mutex\u0026gt; lock(s_MeshesMutex); meshes.push_back(mesh); } void EditLayer::LoadMeshes() { std::ifstream stream(\u0026#34;src/Models.txt\u0026#34;); std::string line; std::vector\u0026lt;std::string\u0026gt; meshFilepaths; while (std::getline(stream, line)) meshFilepaths.push_back(line); #define ASYNC 1 #id ASYNC for (const auto\u0026amp; file : meshFilepaths) // std::launch::async告知std库创建一个线程处理。 // 我们需要保留std::async的返回值，如果不保留的话，因为它会被C++标准库摧毁，在摧毁时，标准库需要确保过程实际已被完成，这基本不是并行了，所以需要创建一个std::future的向量。 m_Futures.push_back(std::async(std::launch::async, LoadMesh, \u0026amp;m_Meshes, file)); #else for (const auto\u0026amp; file : meshFilepaths) m_Meshes.push_back(Mesh::Load(file)); } std::vector\u0026lt;std::future\u0026lt;void\u0026gt; m_Meshes; 通过把任务分派的不同的线程，资源加载速度由6.3s,缩减到600ms，速度快了10倍。\nEnd.\n","date":"2022-02-06T21:27:50Z","permalink":"https://okokfun.github.io/post/c++/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/","title":"让C++程序更快的运行"},{"content":" qt添加第三方库方法\n添加库 选择项目名右击\n选择添加库\n选择外部库，下一步 库文件填写库文件路径和库名字，包含路径是库头文件路径，平台选择一个或全部选择，链接选择动态，点击下一步 汇总将会显示添加到.pro文件中，在项目中可以添加头文件使用此库了 ","date":"2022-02-03T14:14:29Z","permalink":"https://okokfun.github.io/post/c++/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/","title":"qt添加第三方库方法"},{"content":" qt ui区别：\n无ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); }; #endif // MAINWINDOW_H 有ui的mainWindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE // 这个MainWindow和下边的MainWindow没有关系，在不同命名空间内。 class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private: Ui::MainWindow *ui;// ui的指针 }; #endif // MAINWINDOW_H 无ui的mainWindow.cpp #include \u0026#34;mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {} MainWindow::~MainWindow() {} 有ui的mainWindow.cpp #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;./ui_mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)// 实例化ui指针 { ui-\u0026gt;setupUi(this);// 设置ui指针 } MainWindow::~MainWindow() { delete ui;// 删除ui指针 } qt的ui文件实质是xml文件：👇\nmain.cpp #include \u0026#34;mainwindow.h\u0026#34; #include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWindow w;\t// 实例化mainWindow.h中的类MainWindow w.show();\t// 类MainWindow继承于QMainWindow，所以可以调用show() return a.exec(); } ","date":"2022-02-02T20:07:01Z","permalink":"https://okokfun.github.io/post/c++/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","title":"qt中ui简单介绍"},{"content":" 1. Qt概述 1.1 什么是Qt Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。\n1.2 Qt的发展史 1991年 Qt最早由奇趣科技开发\n1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础\n2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言\n2012年 Qt又被Digia公司收购\n2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。\n截至2022年1月31日Qt最新版本为 6.2.3\n1.3 支持的平台 Windows – XP、Vista、Win7、Win8、Win2008、Win10、Win11\nUinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD/OS、和其他很多X11平台\nMacintosh – Mac OS X\nEmbedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE\n1.4 Qt版本 Qt按照不同的版本发行，分为商业版和开源版\n商业版 为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。\n开源的LGPL版本： 为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。\n1.5 Qt的下载与安装 下载地址： 现在QT有两种安装方式\n在线安装：使用qt的安装器\nhttps://download.qt.io/archive/online_installers/4.2/ 不同系统下载对应安装器,然后安装\n离线安装\nqt最后的一个离线安装版本是5.14.2,超过此版本是在线安装版，不提供整合二进制版本。\nLinux Host 下载链接👉Qt 5.14.2 for Linux 64-bit ( 1.2G )\nOS X Host 下载链接👉Qt 5.14.2 for Mac 64-bit ( 2.6G )\nWindows Host 下载链接👉Qt 5.14.2 for Win 64-bit ( 2.3G )\n安装 默认安装（建议组件全部选中）\n· Qt对不同的平台提供了不同版本的安装包，可根据实际情况自行下载安装，本文档使用qt-opensource-windows-x86-5.14.2 版本进行讲解\n1.6 Qt的优点 跨平台，几乎支持所有的平台\n接口简单，容易上手，学习QT框架对学习其他框架有参考意义。\n一定程度上简化了内存回收机制\n有很好的社区氛围，市场份额在缓慢上升。\n可以进行嵌入式开发。\n1.7 成功案例 Linux桌面环境KDE\nWPS Office 办公软件\nSkype 网络电话\nGoogle Earth 谷歌地图\nVLC多媒体播放器\nVirtualBox虚拟机软件\n2 创建Qt项目 2.1 使用向导创建 打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项\n弹出New Project对话框，选择Qt Widgets Application，\n选择【Choose】按钮，弹出如下对话框\n选择项目构建系统\n向导会默认添加一个继承自MainWindow的类，可以在此修改类的名字和基类。默认的基类有QMainWindow、QWidget以及QDialog三个，我们可以选择QWidget（类似于空窗口），这里我们可以先创建一个不带UI的界面，继续下一步\n语言默认，下一步\n设置项目名称和路径，按照向导进行下一步，选择编译套件\n系统会默认给我们添加main.cpp、mywidget.cpp、 mywidget.h和一个CMakeLists.txt文件，点击完成，即可创建出一个Qt桌面程序。\n2.2 手动创建 添加一个空项目\n选择【choose】进行下一步。设置项目名称和路径 —\u0026gt; 选择编译套件 \u0026ndash;\u0026gt; 修改类信息 \u0026ndash;\u0026gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】\n弹出新建文件对话框\n在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。\n2.3 .pro文件 在使用Qt向导生成的应用程序.pro文件格式如下：\nQT += core gui //包含的模块\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4版本 才包含widget模块\nTARGET = QtFirst //应用程序名 生成的.exe程序名称\nTEMPLATE = app //模板类型 应用程序模板\nSOURCES += main.cpp\\ //源文件\n​ mywidget.cpp\nHEADERS += mywidget.h //头文件\n.pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：\n注释\n从“#”开始，到这一行结束。\n模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE = app\napp -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。\nlib - 建立一个库的makefile。\nvcapp - 建立一个应用程序的VisualStudio项目文件。\nvclib - 建立一个库的VisualStudio项目文件。\nsubdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。\n#指定生成的应用程序名：\nTARGET = QtDemo\n#工程中包含的头文件 HEADERS += include/painter.h\n#工程中包含的.ui设计文件 FORMS += forms/painter.ui\n#工程中包含的源文件 SOURCES += sources/main.cpp sources\n#工程中包含的资源文件 RESOURCES += qrc/painter.qrc\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。\n#配置信息 CONFIG用来告诉qmake关于应用程序的配置信息。\nCONFIG += c++11\t//使用c++11的特性\n在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那样替换已经指定的所有选项更安全。\n2.4 一个最简单的Qt应用程序 main入口函数中\n#include \u0026#34;widget.h\u0026#34; #include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Widget w; w.show(); return a.exec(); } 解释：\nQt系统提供的标准类名声明头文件没有.h后缀\nQt一个类对应一个头文件，类名就是头文件名\nQApplication应用程序类\n管理图形用户界面应用程序的控制流和主要设置。\n是Qt的整个后台管理的命脉它包含主事件循环，在其中来自窗口系统和其它资源的所有事件处理和调度。它也处理应用程序的初始化和结束，并且提供对话管理。\n对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。\na.exec()\n程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。\n3 第一个Qt小程序 3.1 按钮的创建 在Qt程序中，最常用的控件之一就是按钮了，首先我们来看下如何创建一个按钮\n#include \u0026lt;QPushButton\u0026gt; QPushButton * btn = new QPushButton; //设置父亲 btn-\u0026gt;setParent(this); //设置文字 btn-\u0026gt;setText(\u0026#34;德玛西亚\u0026#34;); //移动位置 btn-\u0026gt;move(100,100); //第二种创建 QPushButton * btn2 = new QPushButton(\u0026#34;孙悟空\u0026#34;,this); //重新指定窗口大小 this-\u0026gt;resize(600,400); //设置窗口标题 this-\u0026gt;setWindowTitle(\u0026#34;第一个项目\u0026#34;); //限制窗口大小 this-\u0026gt;setFixedSize(600,400); 上面代码中，一个按钮其实就是一个QPushButton类下的对象，如果只是创建出对象，是无法显示到窗口中的，所以我们需要依赖一个父窗口，也就是指定一个父亲利用setParent函数即可，如果想设置按钮上显示的文字利用setText，移动按钮位置用move\n​\t对于窗口而言，我们可以修改左上角窗口的标题setWindowTitle，重新指定窗口大小：resize，或者设置固定的窗口大小setFixedSize；\n3.2 对象模型（对象树） 在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什么的。\nQObject是以对象树的形式组织起来的。\nparent，也就是父对象指针。\n这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。\n当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！） 这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。\nQWidget是能够在屏幕上显示的一切组件的父类。\nQWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。\n当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。\nQt 引入对象树的概念，在一定程度上解决了内存问题。\n当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。\n任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。\n如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：\n{ QWidget window; QPushButton quit(\u0026#34;Quit\u0026#34;, \u0026amp;window); } 作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。\n但是，如果我们使用下面的代码：\n{ QPushButton quit(\u0026#34;Quit\u0026#34;); QWidget window; quit.setParent(\u0026amp;window); } 情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。\n由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。\n3.3 Qt窗口坐标体系 坐标体系：\n以左上角为原点（0,0），X向右增加，Y向下增加。\n对于嵌套窗口，其坐标是相对于父窗口来说的。\n4 信号和槽机制 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。\n4.1 系统自带的信号和槽 下面我们完成一个小功能，上面我们已经学习了按钮的创建，但是还没有体现出按钮的功能，按钮最大的功能也就是点击后触发一些事情，比如我们点击按钮，就把当前的窗口给关闭掉，那么在Qt中，这样的功能如何实现呢？\n​\t其实无法两行代码就可以搞定了，我们看下面的代码\nQPushButton * quitBtn = new QPushButton(\u0026#34;关闭窗口\u0026#34;,this); connect(quitBtn,\u0026amp;QPushButton::clicked,this,\u0026amp;MyWidget::close); 第一行是创建一个关闭按钮，这个之前已经学过，第二行就是核心了，也就是信号槽的使用方式\nconnect()函数最常用的一般形式：\nconnect(sender, signal, receiver, slot); 参数解释：\nsender：发出信号的对象\nsignal：发送对象发出的信号\nreceiver：接收信号的对象\nslot：接收对象在接收到信号之后所需要调用的函数（槽函数）\n那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个\n这里的clicked就是我们要找到，槽函数的寻找方式和信号一样，只不过他的关键字是slot。\n4.2 自定义信号和槽 使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。\n下面我们看看使用 Qt 的信号槽：\n首先定义一个学生类和老师类：\n​\t老师类中声明信号 饿了 hungry\nsignals: void hungury(); //学生类中声明槽 请客 treat public slots: void treat(); //在窗口中声明一个公共方法下课，这个方法的调用会触发老师饿了这个信号，而响应槽函数学生请客 void MyWidget::ClassIsOver() { //发送信号 emit teacher-\u0026gt;hungury(); } //学生响应了槽函数，并且打印信息 //自定义槽函数 实现 void Student::eat() { qDebug() \u0026lt;\u0026lt; \u0026#34;该吃饭了！\u0026#34;; } 在窗口中连接信号槽\nteacher = new Teacher(this); student = new Student(this); connect(teacher,\u0026amp;Teacher::hungury,student,\u0026amp;Student::treat); 并且调用下课函数，测试打印出 “该吃饭了”\n自定义的信号 hungry带参数，需要提供重载的自定义信号和 自定义槽\nvoid hungury(QString name); // 自定义信号 void treat(QString name ); // 自定义槽 但是由于有两个重名的自定义信号和自定义的槽，直接连接会报错，所以需要利用函数指针来指向函数地址， 然后在做连接\nvoid (Teacher:: * teacherSingal)(QString) = \u0026amp;Teacher::hungury; void (Student:: * studentSlot)(QString) = \u0026amp;Student::treat; connect(teacher,teacherSingal,student,studentSlot); 自定义信号槽需要注意的事项：\n发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；\n信号和槽函数返回值是 void\n信号只需要声明，不需要实现\n槽函数需要声明也需要实现\n槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；\n使用 emit 在恰当的位置发送信号；\n使用connect()函数连接信号和槽。\n任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数\n信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。\n如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。\n4.3信号槽的拓展 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。\n多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。\n一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。\n槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。\n信号槽可以断开 利用disconnect关键字是可以断开信号槽的\n使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。\n​\t在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。后面我们会详细介绍什么是Lambda表达式\n4.4 Qt4版本的信号槽写法 connect(zt, SIGNAL(hungry(QString)), st, SLOT(treat(QString)));\n这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。\nQt5在语法上完全兼容Qt4，而反之是不可以的。\n4.5 Lambda表达式 C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成：\n[capture](parameters) mutable -\u0026gt;return-type { statement } [函数对象参数](操作符重载函数参数)mutable -\u0026gt;返回值{函数体}\n① 函数对象参数；\n[]，标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：\n空。没有使用任何函数对象参数。\n=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。\n\u0026amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。\nthis。函数体内可以使用Lambda所在类中的成员变量。\na。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。\n\u0026amp;a。将a按引用进行传递。\na, \u0026amp;b。将a按值进行传递，b按引用进行传递。\n=，\u0026amp;a, \u0026amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。\n\u0026amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。\n② 操作符重载函数参数；\n标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(\u0026amp;a,\u0026amp;b)）两种方式进行传递。\n③ 可修改标示符；\nmutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。\nQPushButton * myBtn = new QPushButton (this); QPushButton * myBtn2 = new QPushButton (this); myBtn2-\u0026gt;move(100,100); int m = 10; connect(myBtn,\u0026amp;QPushButton::clicked,this,[m] ()mutable { m = 20; qDebug() \u0026lt;\u0026lt; m; }); connect(myBtn2,\u0026amp;QPushButton::clicked,this,[=] () { qDebug() \u0026lt;\u0026lt; m; }); qDebug() \u0026lt;\u0026lt; m; ④ 函数返回值；\n-\u0026gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n⑤ 是函数体；\n​\t{}，标识函数的实现，这部分不能省略，但函数体可以为空。\n5 QMainWindow QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。\n5.1 菜单栏 一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。\n创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针 QMenuBar *\tmenuBar() const; 创建菜单，调用QMenu的成员函数addMenu来添加菜单 QAction* addMenu(QMenu * menu) QMenu* addMenu(const QString \u0026amp; title) QMenu* addMenu(const QIcon \u0026amp; icon, const QString \u0026amp; title) 创建菜单项，调用QMenu的成员函数addAction来添加菜单项 QAction* activeAction() const QAction* addAction(const QString \u0026amp; text) QAction* addAction(const QIcon \u0026amp; icon, const QString \u0026amp; text) QAction* addAction(const QString \u0026amp; text, const QObject * receiver, const char * member, const QKeySequence \u0026amp; shortcut = 0) QAction* addAction(const QIcon \u0026amp; icon, const QString \u0026amp; text, const QObject * receiver, const char * member, const QKeySequence \u0026amp; shortcut = 0) Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。\n5.2 工具栏 主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。\n直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。\n插入属于工具条的动作，即在工具条上添加操作。\n通过QToolBar类的addAction函数添加。\n工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：\nQt::LeftToolBarArea\t停靠在左侧\nQt::RightToolBarArea\t停靠在右侧\nQt::TopToolBarArea\t停靠在顶部\nQt::BottomToolBarArea 停靠在底部\nQt::AllToolBarAreas\t以上四个位置都可停靠\n使用setAllowedAreas（）函数指定停靠区域：\nsetAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea） 使用setMoveable（）函数设定工具栏的可移动性：\nsetMoveable（false）//工具条不可移动, 只能停靠在初始化的位置上\n5.3 状态栏 派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：\n状态栏也只能最多有一个\n// 添加小部件\nvoid addWidget(QWidget * widget, int stretch = 0) // 插入小部件\nint\tinsertWidget(int index, QWidget * widget, int stretch = 0) // 删除小部件\nvoid removeWidget(QWidget * widget) 5.4 铆接部件 铆接部件 QDockWidget，也称浮动窗口，可以有多个。\nQDockWidget * dock = new QDockWidget(\u0026#34;标题\u0026#34;,this); addDockWidget(Qt::LeftDockWidgetArea,dock); dock-\u0026gt;setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea | Qt::TopDockWidgetArea); //设置区域范围 5.5 核心部件（中心部件） 除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit做核心部件\nQTextEdit * edit = new QTextEdit(this); setCentralWidget(edit); 5.6 资源文件 Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。\n使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”：\n点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：\n点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件：\n右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：\n接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 /images，文件是 document-open.png，那么就可以使用:/images/document-open.png找到这个文件。\n这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：\n这样，我们可以直接使用:/images/doc-open引用到这个资源，无需关心图片的真实文件名。\n如果我们使用文本编辑器打开 res.qrc 文件，就会看到一下内容：\n\u0026lt;RCC\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images\u0026#34;\u0026gt; \u0026lt;file alias=\u0026#34;doc-open\u0026#34;\u0026gt;document-open.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images/fr\u0026#34; lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;file alias=\u0026#34;doc-open\u0026#34;\u0026gt;document-open-fr.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 我们可以对比一下，看看 Qt Creator 帮我们生成的是怎样的 qrc 文件。当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。\n6 对话框QDialog 6.1 基本概念 对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。\nQt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。\n对话框分为模态对话框和非模态对话框。\n模态对话框，就是会阻塞同一应用程序中其它窗口的输入。 模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。\n与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。 6.2 标准对话框 所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。\nQt 的内置对话框大致分为以下几类：\nQColorDialog：\t选择颜色；\nQFileDialog：\t选择文件或者目录；\nQFontDialog：\t选择字体；\nQInputDialog：\t允许用户输入一个值，并将其值返回；\nQMessageBox：\t模态对话框，用于显示信息、询问问题等；\nQPageSetupDialog：\t为打印机提供纸张相关的选项；\nQPrintDialog：\t打印机配置；\nQPrintPreviewDialog：打印预览；\nQProgressDialog：\t显示操作过程。\n6.3 自定义消息框 Qt 支持模态对话框和非模态对话框。\n模态与非模态的实现：\n使用QDialog::exec()实现应用程序级别的模态对话框\n使用QDialog::open()实现窗口级别的模态对话框\n使用QDialog::show()实现非模态对话框。\n模态对话框 Qt 有两种级别的模态对话框： 应用程序级别的模态 当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。\n窗口级别的模态 该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。\n一般默认是应用程序级别的模态。\n在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。\nQDialog dialog; dialog.setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog.exec(); 非模态对话框 下面我们试着将exec()修改为show()，看看非模态对话框：\nQDialog dialog(this); dialog.setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog.show(); 是不是事与愿违？对话框竟然一闪而过！这是因为，show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：\nQDialog *dialog = new QDialog; dialog-\u0026gt;setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog-\u0026gt;show(); 如果你足够细心，应该发现上面的代码是有问题的：dialog 存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？\n不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：\nQDialog *dialog = new QDialog; dialog-\u0026gt;setAttribute(Qt::WA_DeleteOnClose); dialog-\u0026gt;setWindowTitle(tr(\u0026#34;Hello, dialog!\u0026#34;)); dialog-\u0026gt;show(); setAttribute()函数设置对话框关闭时，自动销毁对话框。\n6.4 消息对话框 QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：\n显示关于对话框。 void about(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text) 这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。\n显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。 void aboutQt(QWidget * parent, const QString \u0026amp; title = QString()) 显示严重错误对话框。 StandardButton critical(QWidget * parent,\nconst QString \u0026amp; title,\nconst QString \u0026amp; text,\nStandardButtons buttons = Ok,\nStandardButton defaultButton = NoButton)：\n这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。\n与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。 StandardButton information(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton) 与QMessageBox::critical ()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。 StandardButton question(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton) 与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。 StandardButton warning(QWidget * parent, const QString \u0026amp; title, const QString \u0026amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton) 我们可以通过下面的代码来演示下如何使用QMessageBox。\nif (QMessageBox::Yes == QMessageBox::question(this, tr(\u0026#34;Question\u0026#34;), tr(\u0026#34;Are you OK?\u0026#34;), QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes)) { QMessageBox::information(this, tr(\u0026#34;Hmmm...\u0026#34;), tr(\u0026#34;I\u0026#39;m glad to hear that!\u0026#34;)); } else { QMessageBox::information(this, tr(\u0026#34;Hmmm...\u0026#34;), tr(\u0026#34;I\u0026#39;m sorry!\u0026#34;)); } 我们使用QMessageBox::question()来询问一个问题。\n这个对话框的父窗口是 this。 QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。\n第二个参数是对话框的标题。\n第三个参数是我们想要显示的内容。\n第四个参数是关联的按键类型，我们可以使用或运算符（|）指定对话框应该出现的按钮。比如我们希望是一个 Yes 和一个 No。\n最后一个参数指定默认选择的按钮。\n这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。\nQMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：\nQMessageBox msgBox; msgBox.setText(tr(\u0026#34;The document has been modified.\u0026#34;)); msgBox.setInformativeText(tr(\u0026#34;Do you want to save your changes?\u0026#34;)); msgBox.setDetailedText(tr(\u0026#34;Differences here...\u0026#34;)); msgBox.setStandardButtons(QMessageBox::Save; QMessageBox::Discard; QMessageBox::Cancel); msgBox.setDefaultButton(QMessageBox::Save); int ret = msgBox.exec(); switch (ret) { case QMessageBox::Save: qDebug() \u0026lt;\u0026lt; \u0026#34;Save document!\u0026#34;; break; case QMessageBox::Discard: qDebug() \u0026lt;\u0026lt; \u0026#34;Discard changes!\u0026#34;; break; case QMessageBox::Cancel: qDebug() \u0026lt;\u0026lt; \u0026#34;Close document!\u0026#34;; break; } msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为“The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。\n6.5 标准文件对话框 QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。\n首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：\nopenAction = new QAction(QIcon(\u0026#34;:/images/file-open\u0026#34;),tr(\u0026#34;\u0026amp;Open...\u0026#34;), this); openAction-\u0026gt;setStatusTip(tr(\u0026#34;Open an existing file\u0026#34;)); saveAction = new QAction(QIcon(\u0026#34;:/images/file-save\u0026#34;), tr(\u0026#34;\u0026amp;Save...\u0026#34;), this); saveAction-\u0026gt;setStatusTip(tr(\u0026#34;Save a new file\u0026#34;)); QMenu *file = menuBar()-\u0026gt;addMenu(tr(\u0026#34;\u0026amp;File\u0026#34;)); file-\u0026gt;addAction(openAction); file-\u0026gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(\u0026#34;\u0026amp;File\u0026#34;)); toolBar-\u0026gt;addAction(openAction); toolBar-\u0026gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); 我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。\n我们使用connect()函数，为这两个QAction对象添加响应的动作：\nconnect(openAction, \u0026amp;QAction::triggered, this, \u0026amp;MainWindow::openFile); connect(saveAction, \u0026amp;QAction::triggered, this, \u0026amp;MainWindow::saveFile); 下面是最主要的openFile()和saveFile()这两个函数的代码：\n//打开文件 void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(\u0026#34;Open File\u0026#34;), \u0026#34;.\u0026#34;, tr(\u0026#34;Text Files(*.txt)\u0026#34;)); if(!path.isEmpty()) { QFile file(path); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { QMessageBox::warning(this, tr(\u0026#34;Read File\u0026#34;), tr(\u0026#34;Cannot open file:\\n%1\u0026#34;).arg(path)); return; } QTextStream in(\u0026amp;file); textEdit-\u0026gt;setText(in.readAll()); file.close(); } else { QMessageBox::warning(this, tr(\u0026#34;Path\u0026#34;), tr(\u0026#34;You did not select any file.\u0026#34;)); } } //保存文件 void MainWindow::saveFile() { QString path = QFileDialog::getSaveFileName(this, tr(\u0026#34;Open File\u0026#34;), \u0026#34;.\u0026#34;, tr(\u0026#34;Text Files(*.txt)\u0026#34;)); if(!path.isEmpty()) { QFile file(path); if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) { QMessageBox::warning(this, tr(\u0026#34;Write File\u0026#34;), tr(\u0026#34;Cannot open file:\\n%1\u0026#34;).arg(path)); return; } QTextStream out(\u0026amp;file); out \u0026lt;\u0026lt; textEdit-\u0026gt;toPlainText(); file.close(); } else { QMessageBox::warning(this, tr(\u0026#34;Path\u0026#34;), tr(\u0026#34;You did not select any file.\u0026#34;)); } } 在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：\nQString getOpenFileName(QWidget * parent = 0, const QString \u0026amp; caption = QString(), const QString \u0026amp; dir = QString(), const QString \u0026amp; filter = QString(), QString * selectedFilter = 0, Options options = 0) 不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：\nparent：父窗口。 Qt 的标准对话框提供静态函数，用于返回一个模态对话框；\ncaption：对话框标题；\ndir：对话框打开时的默认目录\n“.” 代表程序运行目录\n“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\\”等；\nfilter：过滤器。\n我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。过滤器就是用于过滤特定的后缀名。如果我们使用“Image Files(.jpg .png)”，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如“JPEG Files(.jpg);;PNG Files(.png)”；\nselectedFilter：默认选择的过滤器；\noptions：对话框的一些参数设定\n比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。\nQFileDialog::getOpenFileName()返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。\n在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。\n7 布局管理器 所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。\nQt 提供了两种组件定位机制：绝对定位和布局定位。\n绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。 这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。\n布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。 布局定位完美的解决了使用绝对定位的缺陷。\nQt 提供的布局中以下三种是我们最常用的：\nQHBoxLayout：按照水平方向从左到右布局；\nQVBoxLayout：按照竖直方向从上到下布局；\nQGridLayout：在一个网格中进行布局，类似于 HTML 的 table；\n7.1 系统提供的布局控件 这4个为系统给我们提供的布局的控件，但是使用起来不是非常的灵活，这里就不详细介绍了。\n7.2 利用widget做布局 第二种布局方式是利用控件里的widget来做布局，在Containers中\n在widget中的控件可以进行水平、垂直、栅格布局等操作，比较灵活。\n再布局的同时我们需要灵活运用弹簧的特性让我们的布局更加的美观，下面是一个登陆窗口，利用widget可以搭建出如下登陆界面：\n8 常用控件 Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用一些控件，所有控件的使用方法我们都可以通过帮助文档获取。\n8.1 QLabel控件使用 QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。\n显示文字 （普通文本、html） 通过QLabel类的setText函数设置显示的内容:\nvoid\tsetText(const QString \u0026amp;); 可以显示普通文本字符串 QLable *label = new QLable; label-\u0026gt;setText(“Hello, World!”); 可以显示HTML格式的字符串 比如显示一个链接:\nQLabel * label = new QLabel(this); label -\u0026gt;setText(\u0026#34;Hello, World\u0026#34;); label -\u0026gt;setText(\u0026#34;\u0026lt;h1\u0026gt;\u0026lt;a href=\\\u0026#34;https://www.baidu.com\\\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34;); label -\u0026gt;setOpenExternalLinks(true); 其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，如果参数指定为true则会自动打开。\n显示图片 可以使用QLabel的成员函数setPixmap设置图片\nvoid setPixmap(const QPixmap \u0026amp;) 首先定义QPixmap对象\nQPixmap pixmap; 然后加载图片\npixmap.load(\u0026#34;:/Image/boat.jpg\u0026#34;); 最后将图片设置到QLabel中\nQLabel *label = new QLabel; label.setPixmap(pixmap); 显示动画 可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件\nvoid\tsetMovie(QMovie * movie) 首先定义QMovied对象，并初始化:\nQMovie *movie = new QMovie(\u0026#34;:/Mario.gif\u0026#34;); 播放加载的动画：\nmovie-\u0026gt;start(); 将动画设置到QLabel中：\nQLabel *label = new QLabel； label-\u0026gt;setMovie(movie); 8.2 QLineEdit Qt提供的单行文本编辑框。\n设置/获取内容 获取编辑框内容使用text（），函数声明如下： QString\ttext() const 设置编辑框内容 void\tsetText(const QString \u0026amp;); 设置显示模式 使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:\nvoid\tsetEchoMode(EchoMode mode) EchoMode是一个枚举类型,一共定义了四种显示模式:\nQLineEdit::Normal\t模式显示方式，按照输入的内容显示。\nQLineEdit::NoEcho\t不显示任何内容，此模式下无法看到用户的输入。\nQLineEdit::Password\t密码模式，输入的字符会根据平台转换为特殊字符。\nQLineEdit::PasswordEchoOnEdit\t编辑时显示字符否则显示字符作为密码。\n另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么，就可以使用QLineEdit给我们提供的setTextMargins函数：\nvoid setTextMargins(int left, int top, int right, int bottom) 用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数。\n8.3 其他控件 Qt中控件的使用方法可参考Qt提供的帮助文档。\n8.4 自定义控件 在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。\n在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？\n例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，\n// smallwidget.h class SmallWidget : public QWidget { Q_OBJECT public: explicit SmallWidget(QWidget *parent = 0); signals: public slots: private: QSpinBox* spin; QSlider* slider; }; // smallwidget.cpp SmallWidget::SmallWidget(QWidget *parent) : QWidget(parent) { spin = new QSpinBox(this); slider = new QSlider(Qt::Horizontal, this); // 创建布局对象 QHBoxLayout* layout = new QHBoxLayout; // 将控件添加到布局中 layout-\u0026gt;addWidget(spin); layout-\u0026gt;addWidget(slider); // 将布局设置到窗口中 setLayout(layout); // 添加消息响应 connect(spin, static_cast\u0026lt;void (QSpinBox::*)(int)\u0026gt;(\u0026amp;QSpinBox::valueChanged), slider, \u0026amp;QSlider::setValue); connect(slider, \u0026amp;QSlider::valueChanged, spin, \u0026amp;QSpinBox::setValue); } 那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：\n打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键\n弹出提升窗口部件对话框\n添加要提升的类的名字,然后选择 添加\n添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.\n我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget\n再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.\n9 Qt消息机制和事件 9.1 事件 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。\n在前面我们也曾经简单提到，Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler），关于这一点，会在后边详细说明。\n在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如\nkeyPressEvent()\nkeyReleaseEvent()\nmouseDoubleClickEvent()\nmouseMoveEvent()\nmousePressEvent()\nmouseReleaseEvent() 等。\n这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：\nclass EventLabel : public QLabel { protected: void mouseMoveEvent(QMouseEvent *event); void mousePressEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); }; void EventLabel::mouseMoveEvent(QMouseEvent *event) { this-\u0026gt;setText(QString(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Move: (%1, %2) \u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;).arg(QString::number(event-\u0026gt;x()), QString::number(event-\u0026gt;y()))); } void EventLabel::mousePressEvent(QMouseEvent *event) { this-\u0026gt;setText(QString(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Press:(%1, %2) \u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;).arg(QString::number(event-\u0026gt;x()), QString::number(event-\u0026gt;y()))); } void EventLabel::mouseReleaseEvent(QMouseEvent *event) { QString msg; msg.sprintf(\u0026#34;\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Release: (%d, %d)\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\u0026#34;, event-\u0026gt;x(), event-\u0026gt;y()); this-\u0026gt;setText(msg); } int main(int argc, char *argv[]) { QApplication a(argc, argv); EventLabel *label = new EventLabel; label-\u0026gt;setWindowTitle(\u0026#34;MouseEvent Demo\u0026#34;); label-\u0026gt;resize(300, 200); label-\u0026gt;show(); return a.exec(); } EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。\nQString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。\nQString(\u0026#34;[%1, %2]\u0026#34;).arg(x).arg(y); 语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。\n在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。 运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。\n为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？\n这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。\n知道了这一点，我们就可以在main()函数中添加如下代码：\nlabel-\u0026gt;setMouseTracking(true); 在运行程序就没有这个问题了。\n9.2 event（） 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。\n如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。\n如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。\n我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：\nbool CustomTextEdit::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return false; } CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。\n通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：\n//!!! Qt5 bool QObject::event(QEvent *e) { switch (e-\u0026gt;type()) { case QEvent::Timer: timerEvent((QTimerEvent*)e); break; case QEvent::ChildAdded: case QEvent::ChildPolished: case QEvent::ChildRemoved: childEvent((QChildEvent*)e); break; // ... default: if (e-\u0026gt;type() \u0026gt;= QEvent::User) { customEvent(e); break; } return false; } return true; } 这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-\u0026gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：\nswitch (event-\u0026gt;type()) { case QEvent::MouseMove: mouseMoveEvent((QMouseEvent*)event); break; // ... } 事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。\n由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。\n9.3 事件过滤器 有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。\n通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。\nQObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：\nvirtual bool QObject::eventFilter ( QObject * watched, QEvent * event ); 这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。\n我们来看一段简单的代码：\nclass MainWindow : public QMainWindow { public: MainWindow(); protected: bool eventFilter(QObject *obj, QEvent *event); private: QTextEdit *textEdit; }; MainWindow::MainWindow() { textEdit = new QTextEdit; setCentralWidget(textEdit); textEdit-\u0026gt;installEventFilter(this); } bool MainWindow::eventFilter(QObject *obj, QEvent *event) { if (obj == textEdit) { if (event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); qDebug() \u0026lt;\u0026lt; \u0026#34;Ate key press\u0026#34; \u0026lt;\u0026lt; keyEvent-\u0026gt;key(); return true; } else { return false; } } else { // pass the event on to the parent class return QMainWindow::eventFilter(obj, event); } } MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。\neventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：\nvoid QObject::installEventFilter ( QObject * filterObj ) 这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。\n我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。 还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } 现在，我们可以给出一个使用事件过滤器的版本：\nbool FilterObject::eventFilter(QObject *object, QEvent *event) { if (object == target \u0026amp;\u0026amp; event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } else { return false; } } return false; } 事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。\n注意，\n事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。\n9.4 总结 Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。\nQt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：\nl 所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); 在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：\nswitch(message) { case WM_PAINT: // ... break; case WM_DESTROY: // ... break; ... } 每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制： mouseEvent()\nkeyPressEvent()\n…\nQt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是event()。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。\nevent()函数会有两个问题：\nevent()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？\nevent()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？\n这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意QObject类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。\n事件过滤器可以解决刚刚我们提出的event()函数的两点不足：\n首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；\n其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。\n事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，最大的控制权实际上是重写QCoreApplication::notify()。这个函数的声明是：\nvirtual bool QCoreApplication::notify ( QObject * receiver, QEvent * event ); 该函数会将event发送给receiver，也就是调用receiver-\u0026gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。\n现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：\n重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。\n重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。\n在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。\n在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。\n重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。\n10 绘图和绘图设备 10.1 QPainter Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。\nQPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。\n下图给出了这三个类之间的层次结构:\n上面的示意图告诉我们，Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。\n下面我们通过一个实例来介绍QPainter的使用：\nclass PaintedWidget : public QWidget { Q_OBJECT public: PaintedWidget(QWidget *parent = 0); protected: void paintEvent(QPaintEvent *); } 注意我们重写了QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：\nPaintedWidget::PaintedWidget(QWidget *parent) : QWidget(parent) { resize(800, 600); setWindowTitle(tr(\u0026#34;Paint Demo\u0026#34;)); } void PaintedWidget::paintEvent(QPaintEvent *) { QPainter painter(this); painter.drawLine(80, 100, 650, 500); painter.setPen(Qt::red); painter.drawRect(10, 10, 100, 400); painter.setPen(QPen(Qt::green, 5)); painter.setBrush(Qt::blue); painter.drawEllipse(50, 150, 400, 200); } 在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，这一点可能会引发某些细节问题：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。\nQPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。\nQPainter有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的drawLine()，drawRect()以及drawEllipse()等。当绘制轮廓线时，使用QPainter的pen()属性。比如，我们调用了painter.setPen(Qt::red)将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。\n10.2 绘图设备 绘图设备是指继承QPainterDevice的子类。Qt提供了很多这样的类，例如QPixmap、QBitmap、QImage和 QPicture。其中，\nQPixmap专门为图像在屏幕上的显示做了优化\nQBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。\nQImage专门为图像的像素级访问做了优化。\nQPicture则可以记录和重现QPainter的各条命令。\n10.2.1 QPixmap、QBitmap、QImage QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。\nQBitmap继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像。QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，QBitmap实际上是只有黑白两色的图像数据。\n由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。\n下面我们来看同一个图像文件在QPixmap和QBitmap下的不同表现：\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPixmap pixmap(\u0026#34;:/Image/butterfly.png\u0026#34;); QPixmap pixmap1(\u0026#34;:/Image/butterfly1.png\u0026#34;); QBitmap bitmap(\u0026#34;:/Image/butterfly.png\u0026#34;); QBitmap bitmap1(\u0026#34;:/Image/butterfly1.png\u0026#34;); QPainter painter(this); painter.drawPixmap(0, 0, pixmap); painter.drawPixmap(200, 0, pixmap1); painter.drawPixmap(0, 130, bitmap); painter.drawPixmap(200, 130, bitmap1); } 这里我们给出了两张png图片。butterfly1.png是没有透明色的纯白背景，而butterfly.png是具有透明色的背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。\nQPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。\n我们声明了一个QImage对象，大小是300 x 300，颜色模式是RGB32，即使用32位数值表示一个颜色的RGB值，也就是说每种颜色使用8位。然后我们对每个像素进行颜色赋值，从而构成了这个图像。我们可以把QImage想象成一个RGB颜色的二维数组，记录了每一像素的颜色。\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPainter painter(this); QImage image(300, 300, QImage::Format_RGB32); QRgb value; //将图片背景填充为白色 image.fill(Qt::white); //改变指定区域的像素点的值 for(int i=50; i\u0026lt;100; ++i) { for(int j=50; j\u0026lt;100; ++j) { value = qRgb(255, 0, 0); // 红色 image.setPixel(i, j, value); } } //将图片绘制到窗口中 painter.drawImage(QPoint(0, 0), image); } QImage与QPixmap的区别:\nQPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I/O、图片访问和像素修改而设计的\nQPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果\n由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。\nQImage可通过setPixpel()和pixel()等方法直接存取指定的像素。\nQImage与QPixmap之间的转换:\nQImage转QPixmap 使用QPixmap的静态成员函数: fromImage()\nQPixmap\tfromImage(const QImage \u0026amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor) QPixmap转QImage: 使用QPixmap类的成员函数: toImage()\nQImage toImage() cons 10.2.2 QPicture 最后一个需要说明的是QPicture。这是一个可以记录和重现QPainter命令的绘图设备。 QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。这种格式有时候会是“元文件(meta- files)”。Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。\nQPicture是平台无关的，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。\n如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：\nvoid PaintWidget::paintEvent(QPaintEvent *) { QPicture pic; QPainter painter; //将图像绘制到QPicture中,并保存到文件 painter.begin(\u0026amp;pic); painter.drawEllipse(20, 20, 100, 50); painter.fillRect(20, 100, 100, 100, Qt::red); painter.end(); pic.save(\u0026#34;D:\\\\drawing.pic\u0026#34;); //将保存的绘图动作重新绘制到设备上 pic.load(\u0026#34;D:\\\\drawing.pic\u0026#34;); painter.begin(this); painter.drawPicture(200, 200, pic); painter.end(); } 11 文件系统 文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图（Qt5）：\nQIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；\nQFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。\nQFlie：访问本地文件或者嵌入资源；\nQTemporaryFile：创建和访问本地文件系统的临时文件；\nQBuffer：读写QbyteArray, 内存文件；\nQProcess：运行外部程序，处理进程间通讯；\nQAbstractSocket：所有套接字类的父类；\nQTcpSocket：TCP协议网络数据传输；\nQUdpSocket：传输 UDP 报文；\nQSslSocket：使用 SSL/TLS 传输数据；\n文件系统分类:\n顺序访问设备: 是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节，这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。\n随机访问设备: 可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFile和QBuffer是随机访问设备，\n11.1 基本文件操作 文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。在所有的 I/O 设备中，文件 I/O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。QFile提供了从文件中读取和写入数据的能力。\n我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改。QFile需要使用 / 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:/windows 这样的路径在 Windows 平台下同样是可以的。\nQFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。\n下面我们使用一段代码来看看QFile的有关操作：\nint main(int argc, char *argv[]) { QApplication app(argc, argv); QFile file(\u0026#34;in.txt\u0026#34;); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { qDebug() \u0026lt;\u0026lt; \u0026#34;Open file failed.\u0026#34;; return -1; } else { while (!file.atEnd()) { qDebug() \u0026lt;\u0026lt; file.readLine(); } } QFileInfo info(file); qDebug() \u0026lt;\u0026lt; info.isDir(); qDebug() \u0026lt;\u0026lt; info.isExecutable(); qDebug() \u0026lt;\u0026lt; info.baseName(); qDebug() \u0026lt;\u0026lt; info.completeBaseName(); qDebug() \u0026lt;\u0026lt; info.suffix(); qDebug() \u0026lt;\u0026lt; info.completeSuffix(); return app.exec(); } 我们首先使用QFile创建了一个文件对象。 这个文件名字是 in.txt。如果你不知道应该把它放在哪里，可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。\n使用open()函数打开这个文件，打开形式是只读方式，文本格式。 这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。\n可以使用QFileInfo获取有关该文件的信息。 QFileInfo有很多类型的函数，我们只举出一些例子。比如：\nisDir()检查该文件是否是目录； isExecutable()\t检查该文件是否是可执行文件等。 baseName()\t可以直接获得文件名； completeBaseName() 获取完整的文件名 suffix()\t则直接获取文件后缀名。 completeSuffix() 获取完整的文件后缀 我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：\nQFileInfo fi(\u0026#34;/tmp/archive.tar.gz\u0026#34;); QString base = fi.baseName(); // base = \u0026#34;archive\u0026#34; QString base = fi.completeBaseName(); // base = \u0026#34;archive.tar\u0026#34; QString ext = fi.suffix(); // ext = \u0026#34;gz\u0026#34; QString ext = fi.completeSuffix(); // ext = \u0026#34;tar.gz\u0026#34; 11.2 二进制文件读写 QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。\nQDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。\n结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::WriteOnly); QDataStream out(\u0026amp;file); out \u0026lt;\u0026lt; QString(\u0026#34;the answer is\u0026#34;); out \u0026lt;\u0026lt; (qint32)42; 在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向\u0026laquo;运算符。后面的代码就很简单了：将“the answer is”和数字 42 输出到数据流。由于我们的 out 对象建立在file之上，因此相当于将问题和答案写入file。\n需要指出一点：最好使用 Qt 整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。\n如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：\nfile.close(); // 如果不想关闭文件，可以使用 file.flush();\n接下来我们将存储到文件中的答案取出来\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadOnly); QDataStream in(\u0026amp;file); QString str; qint32 a; in \u0026gt;\u0026gt; str \u0026gt;\u0026gt; a; 唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。\n那么，既然QIODevice提供了read()、readLine()之类的函数，为什么还要有QDataStream呢？QDataStream同QIODevice有什么区别？区别在于，QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。我们通过下面一段代码看看什么是流的形式：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadWrite); QDataStream stream(\u0026amp;file); QString str = \u0026#34;the answer is 42\u0026#34;; stream \u0026lt;\u0026lt; str; 11.3 文本文件读写 上一节我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用QTextStream类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。\nQTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。QTextStream使用 16 位的QChar作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。\nQTextStream同QDataStream的使用基本一致，例如下面的代码将把“The answer is 42”写入到 file.txt 文件中：\nQFile data(\u0026#34;file.txt\u0026#34;); if (data.open(QFile::WriteOnly | QIODevice::Truncate)) { QTextStream out(\u0026amp;data); out \u0026lt;\u0026lt; \u0026#34;The answer is \u0026#34; \u0026lt;\u0026lt; 42; } 这里，我们在open()函数中增加了QIODevice::Truncate打开方式。我们可以从下表中看到这些打开方式的区别：\n枚举值 描述 QIODevice::NotOpen 未打开 QIODevice::ReadOnly 以只读方式打开 QIODevice::WriteOnly 以只写方式打开 QIODevice::ReadWrite 以读写方式打开 QIODevice::Append 以追加的方式打开,新增加的内容将被追加到文件末尾 QIODevice::Truncate 以重写的方式打开，在写入新的数据时会将原有数据全部清除，游标设置在文件开头。 QIODevice::Text 在读取时，将行结束符转换成 \\n；在写入时，将行结束符转换成本地格式，例如 Win32 平台上是 \\r\\n QIODevice::Unbuffered 忽略缓存 我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。\n虽然QTextStream的写入内容与QDataStream一致，但是读取时却会有些困难：\nQFile data(\u0026#34;file.txt\u0026#34;); if (data.open(QFile::ReadOnly)) { QTextStream in(\u0026amp;data); QString str; int ans = 0; in \u0026gt;\u0026gt; str \u0026gt;\u0026gt; ans; } 在使用QDataStream的时候，这样的代码很方便，但是使用了QTextStream时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为当使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而以文本形式写入数据，是没有数据之间的分隔的。因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如使用：\nQTextStream::readLine()\t读取一行\nQTextStream::readAll()读取所有文本\n这种函数之后再对获得的QString对象进行处理。\n默认情况下，QTextStream的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用：\nstream.setCodec(\u0026quot;UTF-8\u0026quot;);\n这样的函数进行设置。\n","date":"2022-02-01T17:40:05Z","permalink":"https://okokfun.github.io/post/c++/qt%E6%A6%82%E8%BF%B0/","title":"Qt概述"},{"content":" 最终目的：高内聚，低耦合 1. 开放封闭原则 (OCP,Open For Extension, Closed For Modification Principle) 😎类的改动是通过增加代码进行的，而不是修改源代码。\n2. 单一职责原则 (SRP,Single Responsibility Principle) 类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。\n3. 依赖倒置原则 (DIP,Dependence Inversion Principle) 😎依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。\n4. 接口隔离原则 (ISP,Interface Segegation Principle) 不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。\n5. 里氏替换原则 (LSP, Liskov Substitution Principle) 任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。\n6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle) 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。 如果使用对象组合，就降低了这种依赖关系。\n7. 迪米特法则(LOD,Law of Demeter) 😎一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。(黑盒原理)\n","date":"2022-01-31T18:56:20Z","permalink":"https://okokfun.github.io/post/c++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/","title":"设计模式准则"},{"content":" 三段式for循环 // 变量声明在for里面，自增在里面 for (int i = 0; i \u0026lt; 10; ++i) { //... } // 变量声明在外面,自增在里面 int i = 0; for (; i \u0026lt; 10; ) { //... ++i; } bool condition = true; int i = 0; for (; condition; ) { //... ++i; if (!(i \u0026lt; 5)) condition = false; } 无限循环版本\nbool condition = true; int i = 0; for (; ; ) { //... ++i; if (!(i \u0026lt; 5)) condition = false; } 范围for循环 std::vector\u0026lt;int\u0026gt; l{1,2,3,4,5,6,7,8,9}; for (const auto\u0026amp; it : l) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; std::endl; } while 普通条件while,循环五次退出while\nint i = 0; do { ++i; } while ( i \u0026lt; 5 ) 循环一次推出while\ndo { } while ( false ) ","date":"2022-01-30T21:10:45Z","permalink":"https://okokfun.github.io/post/c++/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/","title":"for和while的几种用法"},{"content":" 用微软家的Visual Studio 2022创建项目，为了避免文件混乱，可以采用下边的设置方法,当然也可以使用默认的设置。\n点击解决方案下的项目名，例如sendbox👇\n在弹出的对话窗中点击属性👇\n然后在弹出的对话框中👇，选择所有配置,平台选择所有平台\n上图有一个错误去掉bin前面的\\.\n配置属性-\u0026gt;常规，\n在常规属性-\u0026gt;输出目录填写$(SolutionDir)bin\\$(Platform)\\$(Configuration)\\\n在常规属性-\u0026gt;中间目录填写$(SolutionDir)bin\\intermediates\\$(Platform)\\$(Configuration)\\\n其中Platform根据平台选择不同而不同，比如选择x64,那么Platform就是Win64，还有Win32\n设置完点击项目，选择清理，然后重新生成\n编译器语言标准\n配置属性-\u0026gt;常规-\u0026gt;C++语言标准\n配置属性-\u0026gt;常规-\u0026gt;C语言标准\nEnd.\n","date":"2022-01-30T19:14:50Z","permalink":"https://okokfun.github.io/post/c++/visual-studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","title":"Visual-Studio-2022基本设置"},{"content":" 此文来源于👉 【77】【Cherno C++】【中字】单一变量存放多种类型的数据_哔哩哔哩_bilibili\n用来处理可能存在也可能不存在的数据，也可能是与我们预期不同的类型。当然也不一定，而是让我们存储不同的数据。 std::variant的作用是让我们不用担心处理的确切类型，指定一个std::variant的东西，然后列出他可能的数据类型。 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;variant\u0026gt; int main(void) { std::variant\u0026lt;std::string, int\u0026gt; data; data = \u0026#34;Cherno\u0026#34;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; data = 2;// data被重新赋值为2 std::cout \u0026lt;\u0026lt; std::get\u0026lt;int\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; data.index();// index函数会告诉你类型的索引， 此时会打印1。 if (auto value = std::get_if\u0026lt;int\u0026gt;(\u0026amp;data)) { std::string\u0026amp;v = *value; } else { //... } /* std::cout \u0026lt;\u0026lt; std::get\u0026lt;std::string\u0026gt;(data) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 错误的访问方法，在data被置为int后依旧按照std::string访问，会抛出一个 bad variant access异常 */ std::cin.get(); return 0; } ","date":"2022-01-29T22:33:43Z","permalink":"https://okokfun.github.io/post/c++/c-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/","title":"C++单一变量存放多种类型的数据"},{"content":" 此文来源于👉 【76】【Cherno C++】【中字】如何处理OPTIONAL数据_哔哩哔哩_bilibili\n有一个返回的函数， 比如正在读取一个文件，但是如果这个文件不能被读取，会发生什么，虽然读取失败，但我们仍然需要从函数中返回一些东西，返回一个空字符串没有意义。\n如果文件是空的，应有办法看到数据存在或不存在，而std::optional可以给我们一些帮助，此特性在C++17加入。\n非std::optional版本\n例子：\n#incldue \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; std::string ReadStringFromFile(const std::\u0026amp;string filepath, bool\u0026amp; outSuccess) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); outSuccess = true; return result; } outSuccess = false; return {}; } int main(void) { bool fileOpenedSuccessfully; std::string data = ReadStringFromFile(\u0026#34;data.txt\u0026#34;, fileOpenedSuccessfully); if (fileOpenedSuccessfully) { //... } else { //... } return 0; } std::optional版本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;optional\u0026gt; std::optional\u0026lt;std::string\u0026gt; ReadStringFromFile(const std::string\u0026amp; filepath) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); return result; } return {}; } int main(void) { std::optional\u0026lt;std::string\u0026gt; data = ReadStringFromFile(\u0026#34;data.txt\u0026#34;); std::string value = data.value_or(\u0026#34;Not present\u0026#34;);// 如果数据确实存在std::optional中，它将返回给我们那个字符串。如果不存在，它将返回我们传入的任何值，比如\u0026#34; Not present \u0026#34; std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (data.has_value()) { std::cout \u0026lt;\u0026lt; \u0026#34;File read successfully!\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;File could not be opend!\\n\u0026#34;; } std::cin.get(); return 0; } ","date":"2022-01-29T21:22:58Z","permalink":"https://okokfun.github.io/post/c++/c-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","title":"C++数据存在或不存在处理方法"},{"content":" 来自于👉 tuple - C++ Reference (cplusplus.com) 并整理\n一个元组std::tuple是一个能够容纳 元素集合 的对象。每个元素都可以是 不同的类型。\nstd::make_pair()可以构建一个配对对象，其第一个元素设置为x，第二个元素设置为y，并返回。\nstd::tie可以绑定std::tuple\u0026lt;T,T,T,...\u0026gt;的实例，并分别给这些元素起别名\nstd::tuple 所在头文件 \u0026lt;tuple\u0026gt;\n例子：\n// tuple example #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;tuple\u0026gt; // std::tuple, std::get, std::tie, std::ignore int main () { std::tuple\u0026lt;int,char\u0026gt; foo (10,\u0026#39;x\u0026#39;); auto bar = std::make_tuple (\u0026#34;test\u0026#34;, 3.1, 14, \u0026#39;y\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#34;bar has \u0026#34;\u0026lt;\u0026lt;std::tuple_size\u0026lt;decltype(bar)\u0026gt;::value \u0026lt;\u0026lt; elements\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::tuple_element\u0026lt;0,decltype(bar)\u0026gt;::type first = std::get\u0026lt;0\u0026gt;(bar); std::cout \u0026lt;\u0026lt; \u0026#34;bar contains: \u0026#34; \u0026lt;\u0026lt; first \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::get\u0026lt;2\u0026gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get\u0026lt;3\u0026gt;(bar); std::get\u0026lt;0\u0026gt;(foo) = std::get\u0026lt;2\u0026gt;(bar); std::get\u0026lt;1\u0026gt;(foo) = mychar; std::cout \u0026lt;\u0026lt; \u0026#34;foo contains: \u0026#34;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 答案：\nbar has 4 elements bar contains: test foo contains: 100 y std::tie 所在头文件 \u0026lt;tuple\u0026gt;\n例子：\n// packing/unpacking tuples #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;tuple\u0026gt; // std::tuple, std::make_tuple, std::tie int main () { std::tuple\u0026lt;int,float,char\u0026gt; mytuple; mytuple = std::make_tuple (10, 2.6, \u0026#39;a\u0026#39;); // packing values into tuple int myint; char mychar; std::tie (myint, std::ignore, mychar) = mytuple; // unpacking tuple into variables std::cout \u0026lt;\u0026lt; \u0026#34;myint contains: \u0026#34; \u0026lt;\u0026lt; myint \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;mychar contains: \u0026#34; \u0026lt;\u0026lt; mychar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\nmyint contains: 10 mychar contains: a std::pair 所在头文件 \u0026lt;utility\u0026gt;\n例子：\n// make_pair example #include \u0026lt;utility\u0026gt; // std::pair #include \u0026lt;iostream\u0026gt; // std::cout int main () { std::pair \u0026lt;int,int\u0026gt; foo; std::pair \u0026lt;int,int\u0026gt; bar; foo = std::make_pair (10,20); bar = std::make_pair (10.5,\u0026#39;A\u0026#39;); // ok: implicit conversion from pair\u0026lt;double,char\u0026gt; std::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; foo.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; bar.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout\u0026lt;\u0026lt; \u0026#34;foo contains: \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\nfoo: 10, 20 bar: 10, 65 foo contains: 50 and x End.\n","date":"2022-01-29T17:41:10Z","permalink":"https://okokfun.github.io/post/c++/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/","title":"C++元组与对组"},{"content":" 此文总结与👉 神经元猫的个人空间_哔哩哔哩_bilibili 的 【75】【Cherno C++】【中字】C++的结构化绑定_哔哩哔哩_bilibili\n在如何处理C++多返回值得问题，返回的数据可以是结构体实例，也可以是元组或对组 从C++17引入的结构化绑定可以改善此项，\n以前忒麻烦的版本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, int\u0026gt; CreatPerson() { return { \u0026#34;Cherno\u0026#34;, 24 }; } int main(void) { auto person = CreatPerson(); std::string\u0026amp;name = std::get\u0026lt;0\u0026gt;(person); int age = std::get\u0026lt;1\u0026gt;(person); std::string name; int age; std::tie(name, age) = CreatPerson(); return 0; } 从C++17引入了结构化绑定解决了上诉问题\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, int\u0026gt; CreatPerson() { return { \u0026#34;Cherno\u0026#34;, 24 }; } int main(void) { auto[name, age] = CreatPerson(); // 简单，美观 std::cout \u0026lt;\u0026lt; name; return 0; } ","date":"2022-01-29T17:40:33Z","permalink":"https://okokfun.github.io/post/c++/c-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/","title":"C++结构化绑定"},{"content":" 此文来自于👉 C++ / typeinfo — DevDocs ，并整理\n判断数据是哪种数据类型 头文件\u0026lt;typeinfo\u0026gt;\nstd::type_info::name() 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; struct Base { virtual ~Base() = default; }; struct Derived : Base {}; int main() { Base b1; Derived d1; const Base *pb = \u0026amp;b1; std::cout \u0026lt;\u0026lt; typeid(*pb).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pb = \u0026amp;d1; std::cout \u0026lt;\u0026lt; typeid(*pb).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int i; int * pi; std::cout \u0026lt;\u0026lt; \u0026#34;int is: \u0026#34; \u0026lt;\u0026lt; typeid(int).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; i is: \u0026#34; \u0026lt;\u0026lt; typeid(i).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34; pi is: \u0026#34; \u0026lt;\u0026lt; typeid(pi).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;*pi is: \u0026#34; \u0026lt;\u0026lt; typeid(*pi).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 结果：\n4Base 7Derived int is: int i is: int pi is: int * *pi is: int 判断数据是否是对应的数据类型 头文件\u0026lt;type_traits\u0026gt;\n主要类型类别 Primary type categories is_array\nIs array (class template )\n// is_array example #include \u0026lt;iostream\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;type_traits\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_array:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int[3]: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;int[3]\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;array\u0026lt;int,3\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::array\u0026lt;int,3\u0026gt;\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;string[3]: \u0026#34; \u0026lt;\u0026lt; std::is_array\u0026lt;std::string[3]\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } 结果：\nis_array: int: false int[3]: true array\u0026lt;int,3\u0026gt;: false string: false string[3]: true is_class\nIs non-union class (class template )\nis_enum\nIs enum (class template )\nis_floating_point\nIs floating point (class template )\nis_function\nIs function (class template )\nis_integral\nIs integral (class template )\nis_lvalue_reference\nIs lvalue reference (class template )\nis_member_function_pointer\nIs member function pointer (class template )\nis_member_object_pointer\nIs member object pointer (class template )\nis_pointer\nIs pointer (class template )\nis_rvalue_reference\nIs rvalue reference (class template )\nis_union\nIs union (class template )\nis_void\nIs void (class template )\n复合类型范畴 Composite type categories is_arithmetic\nIs arithmetic type (class template )\n// is_arithmetic example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;complex\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_arithmetic:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;char\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;float: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;float\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;float*: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;float*\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;complex\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_arithmetic\u0026lt;std::complex\u0026lt;double\u0026gt;\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output: bash is_arithmetic: char: true float: true float*: false complex\u0026lt;double\u0026gt;: false is_compound\nIs compound type (class template )\nis_fundamental\nIs fundamental type (class template )\nis_member_pointer\nIs member pointer type (class template )\nis_object\nIs object type (class template )\nis_reference\nIs reference type (class template )\nis_scalar\nIs scalar type (class template )\n类型属性 Type properties is_abstract\nIs abstract class (class template )\n// is_abstract example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A { }; struct B { virtual void fn() = 0; // pure virtual function }; struct C : B { }; struct D : C { virtual void fn(){} }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_abstract:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;C: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;C\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;D: \u0026#34; \u0026lt;\u0026lt; std::is_abstract\u0026lt;D\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } 结果：\nis_abstract: A: false B: true C: true D: false is_const\nIs const-qualified (class template )\nis_empty\nIs empty class (class template )\nis_literal_type\nIs literal type (class template )\nis_pod\nIs POD type (class template )\nis_polymorphic\nIs polymorphic (class template )\nis_signed\nIs signed type (class template )\nis_standard_layout\nIs standard-layout type (class template )\nis_trivial\nIs trivial type (class template )\nis_trivially_copyable\nIs trivially copyable (class template )\nis_unsigned\nIs unsigned type (class template )\nis_volatile\nIs volatile-qualified (class template )\n类型特征 Type features has_virtual_destructor\nHas virtual destructor (class template )\n// has_virtual_destructor example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A { }; struct B { virtual ~B(){} }; struct C : B { }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;has_virtual_destructor:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;C: \u0026#34; \u0026lt;\u0026lt; std::has_virtual_destructor\u0026lt;C\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output:\nhas_virtual_destructor: int: false A: false B: true C: true is_assignable\nIs assignable (class template )\nis_constructible\nIs constructible (class template )\nis_copy_assignable\nIs copy assignable (class template )\nis_copy_constructible\nIs copy constructible (class template )\nis_destructible\nIs destructible (class template )\nis_default_constructible\nIs default constructible (class template )\nis_move_assignable\nIs move assignable (class template )\nis_move_constructible\nIs move constructible (class template )\nis_trivially_assignable\nIs trivially assignable (class template )\nis_trivially_constructible\nIs trivially constructible (class template )\nis_trivially_copy_assignable\nIs trivially copy assignable (class template )\nis_trivially_copy_constructible\nIs trivially copy constructible (class template )\nis_trivially_destructible\nIs trivially destructible (class template )\nis_trivially_default_constructible\nIs trivially default constructible (class template )\nis_trivially_move_assignable\nIs trivially move assignable (class template )\nis_trivially_move_constructible\nIs trivially move constructible (class template )\nis_nothrow_assignable\nIs assignable throwing no exceptions (class template )\nis_nothrow_constructible\nIs constructible throwing no exceptions (class template )\nis_nothrow_copy_assignable\nIs copy assignable throwing no exceptions (class template )\nis_nothrow_copy_constructible\nIs copy constructible throwing no exceptions (class template )\nis_nothrow_destructible\nIs nothrow destructible (class template )\nis_nothrow_default_constructible\nIs default constructible throwing no exceptions (class template )\nis_nothrow_move_assignable\nIs move assignable throwing no exception (class template )\nis_nothrow_move_constructible\nIs move constructible throwing no exceptions (class template )\n类型关系 Type relationships is_base_of\nIs base class of (class template )\n// is_base_of example #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct A {}; struct B : A {}; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; std::cout \u0026lt;\u0026lt; \u0026#34;is_base_of:\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;int, int: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;int,int\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, A: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,A\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, B: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A, const B: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A,const B\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;A\u0026amp;, B\u0026amp;: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;A\u0026amp;,B\u0026amp;\u0026gt;::value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;B, A: \u0026#34; \u0026lt;\u0026lt; std::is_base_of\u0026lt;B,A\u0026gt;::value \u0026lt;\u0026lt; std::endl; return 0; } Output:\nis_base_of: int, int: false A, A: true A, B: true A, const B: true A\u0026amp;, B\u0026amp;: false B, A: false is_convertible\nIs convertible (class template )\nis_same\nIs same type (class template )\n","date":"2022-01-28T17:51:19Z","permalink":"https://okokfun.github.io/post/c++/%E8%8E%B7%E5%8F%96c-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/","title":"获取C++中数据的类型的方法"},{"content":" 文章emoji支持\nnpm install hexo-filter-github-emojis --save 文章加密访问插件\nnpm install hexo-blog-encrypt --save 使用方法\n将 \u0026ldquo;password\u0026rdquo; 字段添加到您文章信息头就像这样. --- title: Hello World tags: - 作为日记加密 date: 2016-03-30 21:12:21 password: mikemessi abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. --- password下边几行可加可不加。\n编辑_config.yml 加入下列几行\n# Security encrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码, 请点击本文字. tags: - {name: tagName, password: 密码A} - {name: tagName, password: 密码B} wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 卸载对应的插件把install换为un\n","date":"2022-01-28T14:14:03Z","permalink":"https://okokfun.github.io/post/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/","title":"本人使用的hexo插件列表"},{"content":" 1. Variadic Templates 数量不定的模板参数\n...代表任意个数据\nvoid print(){} template \u0026lt;typename T, typename... Types\u0026gt; void print(const T\u0026amp; firstArg, const Types\u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } void print(const T\u0026amp; firstArg, const Types\u0026amp;...args){}中...代表任意个数据，Types任意类型的数据,\n表示接受任意个任意类型的数据\n例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;bitset\u0026gt; void print() {} template \u0026lt;typename T, typename... Types\u0026gt; void print(const T \u0026amp;firstArg, const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, \u0026#34;hello\u0026#34;, std::bitset\u0026lt;16\u0026gt;(377), 42); return 0; } 结果：\n7.5 hello 0000000101111001 42 解释：print(7.5, \u0026quot;hello\u0026quot;, bitset\u0026lt;16\u0026gt;(377), 42);,\n分解方式为递归\n第一次7.5和它右边会分成两部分放进void print(const T\u0026amp; firstArg, const Types\u0026amp;...args), 第一部分的是firstArg，第二部分会放进...args;\n第二次hello和它右边两部分放进firstArg,...args;\n特化比泛化权值更高，也即是更加倾向于选择特化\ntemplate \u0026lt;typename T, typename... Types\u0026gt; void print(const T \u0026amp;firstArg, const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } template \u0026lt;typename... Types\u0026gt; void print(const Types \u0026amp;...args) { std::cout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, \u0026#34;hello\u0026#34;, std::bitset\u0026lt;16\u0026gt;(377), 42); // 倾向于选择print(const T \u0026amp;firstArg, const Types \u0026amp;...args) return 0; } 2. nullptr and nullptr_t and auto nullptr C++改为使用nullptr为空指针，代替NULL或0;\n例子：\nvoid f(int); void f(void*); f(0);\t// 选择f(int) f(NULL);\t// 选择f(int) f(nullptr);\t// 选择f(void*) auto 数据类型自动推导\nauto是根据=右边的数据推导出变量的数据类型\nauto i = 42; // i has type int double f(); auto d = f(); // d has type double auto 用在容器中比较多\nlist\u0026lt;string\u0026gt; c; ... list\u0026lt;string\u0026gt;::iterator ite; ite = find(c.begin, c.end(), target); 变为\nlist\u0026lt;string\u0026gt; c; ... auto ite = find(c.begin, c.end(), target); 用在for循环中\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; int main(void) { std::vector\u0026lt;int\u0026gt; vec{1,2,3,4,5,6,7,8,9}; for (const auto\u0026amp;it : vec) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 3. Uniform Initialization 统一的初始化{}\nint i; // 初始值未定 int j{}; // 初始值为0 int* p;\t// 初始值未定义 int* q{};\t// 初始值为 nullptr int x1(5.3); // OK, 但初始值被设为5； int x2 = 5.3;// OK, 但初始值被设为5； int x3{5.0};\t// ERROR int values[] {1,2,3}; std::vector\u0026lt;int\u0026gt; v{1,2,3,4,5,6,7,8,9}; std::vector\u0026lt;string\u0026gt; cities{ \u0026#34;Beijing\u0026#34;, \u0026#34;xinjiang\u0026#34;, \u0026#34;henan\u0026#34;, \u0026#34;London\u0026#34; }; complex\u0026lt;double\u0026gt; c{4.0, 3.0}; 都是用{}来初始化；\n4. bind()和function\u0026lt;\u0026gt; 函数模板 bind 生成 f 的转发调用包装器。调用此包装器等价于以一些绑定到 args 的参数调用 f 。\n类模板 std::function 是通用多态函数封装器。 std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。\nstd::function\u0026lt;\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;iostream\u0026gt; struct Foo { Foo(int num) : num_(num) {} void print_add(int i) const { std::cout \u0026lt;\u0026lt; num_+i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int num_; }; void print_num(int i) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } struct PrintNum { void operator()(int i) const { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { // 存储自由函数 std::function\u0026lt;void(int)\u0026gt; f_display = print_num; f_display(-9); // 存储 lambda std::function\u0026lt;void()\u0026gt; f_display_42 = []() { print_num(42); }; f_display_42(); // 存储到 std::bind 调用的结果 std::function\u0026lt;void()\u0026gt; f_display_31337 = std::bind(print_num, 31337); f_display_31337(); // 存储到成员函数的调用 std::function\u0026lt;void(const Foo\u0026amp;, int)\u0026gt; f_add_display = \u0026amp;Foo::print_add; const Foo foo(314159); f_add_display(foo, 1); f_add_display(314159, 1); // 存储到数据成员访问器的调用 std::function\u0026lt;int(Foo const\u0026amp;)\u0026gt; f_num = \u0026amp;Foo::num_; std::cout \u0026lt;\u0026lt; \u0026#34;num_: \u0026#34; \u0026lt;\u0026lt; f_num(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 存储到成员函数及对象的调用 using std::placeholders::_1; std::function\u0026lt;void(int)\u0026gt; f_add_display2 = std::bind( \u0026amp;Foo::print_add, foo, _1 ); f_add_display2(2); // 存储到成员函数和对象指针的调用 std::function\u0026lt;void(int)\u0026gt; f_add_display3 = std::bind( \u0026amp;Foo::print_add, \u0026amp;foo, _1 ); f_add_display3(3); // 存储到函数对象的调用 std::function\u0026lt;void(int)\u0026gt; f_display_obj = PrintNum(); f_display_obj(18); } std::bind() #include \u0026lt;random\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;functional\u0026gt; void f(int n1, int n2, int n3, const int\u0026amp; n4, int n5) { std::cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n4 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; n5 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int g(int n1) { return n1; } struct Foo { void print_sum(int n1, int n2) { std::cout \u0026lt;\u0026lt; n1+n2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int data = 10; }; int main() { using namespace std::placeholders; // 对于 _1, _2, _3... // 演示参数重排序和按引用传递 int n = 7; // （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数） auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n); n = 10; f1(1, 2, 1001); // 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001 // 进行到 f(2, 42, 1, n, 7) 的调用 // 嵌套 bind 子表达式共享占位符 auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5); f2(10, 11, 12); // 进行到 f(12, g(12), 12, 4, 5); 的调用 // 常见使用情况：以分布绑定 RNG std::default_random_engine e; std::uniform_int_distribution\u0026lt;\u0026gt; d(0, 10); std::function\u0026lt;int()\u0026gt; rnd = std::bind(d, e); // e 的一个副本存储于 rnd for(int n=0; n\u0026lt;10; ++n) std::cout \u0026lt;\u0026lt; rnd() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 绑定指向成员函数指针 Foo foo; auto f3 = std::bind(\u0026amp;Foo::print_sum, \u0026amp;foo, 95, _1); f3(5); // 绑定指向数据成员指针 auto f4 = std::bind(\u0026amp;Foo::data, _1); std::cout \u0026lt;\u0026lt; f4(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 智能指针亦能用于调用被引用对象的成员 std::cout \u0026lt;\u0026lt; f4(std::make_shared\u0026lt;Foo\u0026gt;(foo)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; f4(std::make_unique\u0026lt;Foo\u0026gt;(foo)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2022-01-24T17:02:47Z","permalink":"https://okokfun.github.io/post/c++/c-%E6%96%B0%E7%89%B9%E6%80%A7/","title":"C++新特性"},{"content":" QT组件库第1-31 QT组件库第32-56 Layouts 布局组件库 1号 Vertical Layout 垂直布局\n2号 Horizontal Layout 水平布局\n3号 Grid Layout 网格布局\n4号 Form Layout 表单布局\nSpacers 空间间隔组(弹簧) 5号 Horizontal Spacer 水平间隔\n6号 Vertical Spacer 垂直间隔\nButtons 按钮 7号 Push Button 8号 Tool Button 9号 Radio Button 10号 Check Box 11号 Command Link Button 12号 Dialog Button Box Item Views (Model-Based) 清单视图组 13号 List View 清单视图\n14号 Tree View 树视图\n15号 Table View 表视图\n16号 Column View 列视图\n17号 Undo View 撤消视图\nItem Widgets (Item-Based) 清单控件组 18号 List Widget 清单控件\n19号 Tree Widget 树控件\n20号 Table Widget 表控件\nContainers 容器组 21号 Group Box 组框\n22号 Scroll Area 滚动区域\n23号 Tool Box 工具箱\n24号 Tab Widget 标签小部件\n25号 Stacked Widget 堆叠部件\n26号 Frame 帧\n27号 Widget 小部件\n28号 MDI Area MDI区域\n29号 Dock Widget 停靠窗口不见\n30号 QAx Widget 封装Flash的AciveX控件\nInput Widgets 输入部件组 31号 Combo Box 组合框\n32号 Font Combo Box 字体组合框\n33号 Line Edit 行编辑\n34号 Text Edit 文本编辑\n35号 Plain Text Edit 纯文本编辑\n36号 Spin Box 数字显示框\n37号 Double Spin Box 双数字显示框\n38号 Time Edit 时间编辑\n39号 Date Edit 日期编辑\n40号 Date/Time Edit 日期或时间编辑\n41号 Dial 拨号\n42号 Horizontal Scroll Bar 水平滚动条\n43号 Vertical Scroll Bar 垂直滚动条\n44号 Horizontal Slider 水平滑块\n45号 Vertical Slider 垂直滑块\n46号 Key Sequence Edit 按键序列编辑\nDisplay Widgets 显示控件组 47号 Label 标签\n48号 text Browser 文本浏览器\n49号 Graphics View 图形视图\n50号 Calendar Widget 日历\n51号 Lcd Number 液晶数字\n52号 Progress Bar 进度条\n53号 Horizontal Line 水平线\n54号 Vertical Line 垂直线\n55号 OpenGL Widget 开放式图形工具\n56号 QQuick Widget 嵌入QML工具\n","date":"2022-01-24T14:33:42Z","permalink":"https://okokfun.github.io/post/c++/qt-ui%E7%BB%84%E4%BB%B6%E5%BA%93/","title":"QT_UI组件库"},{"content":" 安乐死是对人最后的仁慈，让人可以有尊严和最后无痛苦的离开这个世界，当然前提是有病痛且无法医治，比如物理学家霍金的 肌萎缩性脊髓侧索硬化症（ALS）。\n","date":"2022-01-24T13:37:38Z","permalink":"https://okokfun.github.io/post/me/","title":"Me"},{"content":" 本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用\n1 模板 1.1 模板的概念 模板就是建立通用的模具，大大提高复用性\n模板的特点：\n模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板\nC++提供两种模板机制:函数模板和类模板\n1.2.1 函数模板语法 函数模板作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\ntemplate\u0026lt;typename T\u0026gt; 函数声明或定义 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n//交换整型函数 void swapInt(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b; b = temp; } //交换浮点型函数 void swapDouble(double\u0026amp; a, double\u0026amp; b) { double temp = a; a = b; b = temp; } //利用模板提供通用的交换函数 template\u0026lt;typename T\u0026gt; void mySwap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap\u0026lt;int\u0026gt;(a, b); cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项 注意事项：\n自动类型推导，必须推导出一致的数据类型T,才可以使用\n模板必须要确定出T的数据类型，才可以使用\n示例：\n//利用模板提供通用的交换函数 template\u0026lt;class T\u0026gt; void mySwap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } // 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型 } // 2、模板必须要确定出T的数据类型，才可以使用 template\u0026lt;class T\u0026gt; void func() { cout \u0026lt;\u0026lt; \u0026#34;func 调用\u0026#34; \u0026lt;\u0026lt; endl; } void test02() { //func(); //错误，模板不能独立使用，必须确定出T的类型 func\u0026lt;int\u0026gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例 案例描述：\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例：\n//交换的函数模板 template\u0026lt;typename T\u0026gt; void mySwap(T \u0026amp;a, T\u0026amp;b) { T temp = a; a = b; b = temp; } template\u0026lt;class T\u0026gt; // 也可以替换成typename //利用选择排序，进行对数组从大到小的排序 void mySort(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { int max = i; //最大数的下标 for (int j = i + 1; j \u0026lt; len; j++) { if (arr[max] \u0026lt; arr[j]) { max = j; } } if (max != i) //如果最大数的下标不是i，交换两者 { mySwap(arr[max], arr[i]); } } } template\u0026lt;typename T\u0026gt; void printArray(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { //测试char数组 char charArr[] = \u0026#34;bdcfeagh\u0026#34;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num); } void test02() { //测试int数组 int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：模板可以提高代码复用，需要熟练掌握\n1.2.4 普通函数与函数模板的区别 普通函数与函数模板区别：\n普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例：\n//普通函数 int myAdd01(int a, int b) { return a + b; } //函数模板 template\u0026lt;class T\u0026gt; T myAdd02(T a, T b) { return a + b; } //使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; cout \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl; //正确，将char类型的\u0026#39;c\u0026#39;隐式转换为int类型 \u0026#39;c\u0026#39; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02\u0026lt;int\u0026gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n1.2.5 普通函数与函数模板的调用规则 调用规则如下：\n如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例：\n//普通函数与函数模板调用规则 void myPrint(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用的普通函数\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void myPrint(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;调用的模板\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void myPrint(T a, T b, T c) { cout \u0026lt;\u0026lt; \u0026#34;调用重载的模板\u0026#34; \u0026lt;\u0026lt; endl; } void test01() { //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint\u0026lt;\u0026gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = \u0026#39;a\u0026#39;; char c2 = \u0026#39;b\u0026#39;; myPrint(c1, c2); //调用函数模板 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n1.2.6 模板的局限性 局限性：\n模板的通用性并不是万能的 例如：\ntemplate\u0026lt;class T\u0026gt; void f(T a, T b) { a = b; } 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\ntemplate\u0026lt;class T\u0026gt; void f(T a, T b) { if(a \u0026gt; b) { ... } } 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n示例：\n#include\u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; //普通函数模板 template\u0026lt;class T\u0026gt; bool myCompare(T\u0026amp; a, T\u0026amp; b) { if (a == b) { return true; } else { return false; } } //具体化，显示具体化的原型和定意思以template\u0026lt;\u0026gt;开头，并通过名称来指出类型 //具体化优先于常规模板 template\u0026lt;\u0026gt; bool myCompare(Person \u0026amp;p1, Person \u0026amp;p2) { if ( p1.m_Name == p2.m_Name \u0026amp;\u0026amp; p1.m_Age == p2.m_Age) { return true; } else { return false; } } void test01() { int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;a == b \u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a != b \u0026#34; \u0026lt;\u0026lt; endl; } } void test02() { Person p1(\u0026#34;Tom\u0026#34;, 10); Person p2(\u0026#34;Tom\u0026#34;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;p1 == p2 \u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;p1 != p2 \u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板 1.3.1 类模板语法 类模板作用：\n建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法：\ntemplate\u0026lt;typename T\u0026gt; 类 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; void test01() { // 指定NameType 为string类型，AgeType 为 int类型 Person\u0026lt;string, int\u0026gt;P1(\u0026#34;孙悟空\u0026#34;, 999); P1.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n1.3.2 类模板与函数模板区别 类模板与函数模板区别主要有两点：\n类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; //1、类模板没有自动类型推导的使用方式 void test01() { // Person p(\u0026#34;孙悟空\u0026#34;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson(); } //2、类模板在模板参数列表中可以有默认参数 void test02() { Person \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson(); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机 类模板中成员函数和普通类中成员函数创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例：\nclass Person1 { public: void showPerson1() { cout \u0026lt;\u0026lt; \u0026#34;Person1 show\u0026#34; \u0026lt;\u0026lt; endl; } }; class Person2 { public: void showPerson2() { cout \u0026lt;\u0026lt; \u0026#34;Person2 show\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;class T\u0026gt; class MyClass { public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() { obj.showPerson1(); } void fun2() { obj.showPerson2(); } }; void test01() { MyClass\u0026lt;Person1\u0026gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n1.3.4 类模板对象做函数参数 学习目标：\n类模板实例化出的对象，向函数传参的方式 一共有三种传入方式：\n指定传入的类型 \u0026mdash; 直接显示对象的数据类型 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型模板化进行传递 示例：\n#include \u0026lt;string\u0026gt; //类模板 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;mName = name; this-\u0026gt;mAge = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; } public: NameType mName; AgeType mAge; }; //1、指定传入的类型 void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p) { p.showPerson(); } void test01() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template \u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p) { p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } void test03() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承 当类模板碰到继承时，需要注意一下几点：\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例：\ntemplate\u0026lt;class T\u0026gt; class Base { T m; }; //class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 class Son :public Base\u0026lt;int\u0026gt; //必须指定一个类型 {}; void test01() { Son c; } //类模板继承类模板 ,可以用T2指定父类中的T类型 template\u0026lt;class T1, class T2\u0026gt; class Son2 :public Base\u0026lt;T2\u0026gt; { public: Son2() { cout \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } }; void test02() { Son2\u0026lt;int, char\u0026gt; child1; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果父类是类模板，子类需要指定出父类中T的数据类型\n1.3.6 类模板成员函数类外实现 学习目标：能够掌握类模板中的成员函数类外实现\n示例：\n#include \u0026lt;string\u0026gt; //类模板中成员函数类外实现 template\u0026lt;class T1, class T2\u0026gt; class Person { public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //成员函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } void test01() { Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 20); p.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：类模板中成员函数类外实现时，需要加上模板参数列表\n1.3.7 类模板分文件编写 学习目标：\n掌握类模板成员函数分文件编写产生的问题以及解决方式 问题：\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决：\n解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例：\nperson.hpp中代码：\n#pragma once #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;string\u0026gt; template\u0026lt;class T1, class T2\u0026gt; class Person { public: Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //成员函数 类外实现 template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } 类模板分文件编写.cpp中代码\n#include\u0026lt;iostream\u0026gt; using namespace std; //#include \u0026#34;person.h\u0026#34; #include \u0026#34;person.cpp\u0026#34; //解决方式1，包含cpp源文件 //解决方式2，将声明和实现写到一起，文件后缀名改为.hpp #include \u0026#34;person.hpp\u0026#34; void test01() { Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 10); p.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\n1.3.8 类模板与友元 学习目标：\n掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n示例：\n#include \u0026lt;string\u0026gt; //2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 template\u0026lt;class T1, class T2\u0026gt; class Person; //如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 //template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;类外实现 ---- 姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } template\u0026lt;class T1, class T2\u0026gt; class Person { //1、全局函数配合友元 类内实现 friend void printPerson(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } //全局函数配合友元 类外实现 friend void printPerson2\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); public: Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } private: T1 m_Name; T2 m_Age; }; //1、全局函数在类内实现 void test01() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;Tom\u0026#34;, 20); printPerson(p); } //2、全局函数在类外实现 void test02() { Person \u0026lt;string, int \u0026gt;p(\u0026#34;Jerry\u0026#34;, 30); printPerson2(p); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n1.3.9 类模板案例 案例描述: 实现一个通用的数组类，要求如下：\n可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例：\nmyArray.hpp中代码\n#pragma once #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; class MyArray { public: //构造函数 MyArray(int capacity) { this-\u0026gt;m_Capacity = capacity; this-\u0026gt;m_Size = 0; pAddress = new T[this-\u0026gt;m_Capacity]; } //拷贝构造 MyArray(const MyArray \u0026amp; arr) { this-\u0026gt;m_Capacity = arr.m_Capacity; this-\u0026gt;m_Size = arr.m_Size; this-\u0026gt;pAddress = new T[this-\u0026gt;m_Capacity]; for (int i = 0; i \u0026lt; this-\u0026gt;m_Size; i++) { //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-\u0026gt;pAddress[i] = arr.pAddress[i]; } } //重载= 操作符 防止浅拷贝问题 MyArray\u0026amp; operator=(const MyArray\u0026amp; myarray) { if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;m_Capacity = 0; this-\u0026gt;m_Size = 0; } this-\u0026gt;m_Capacity = myarray.m_Capacity; this-\u0026gt;m_Size = myarray.m_Size; this-\u0026gt;pAddress = new T[this-\u0026gt;m_Capacity]; for (int i = 0; i \u0026lt; this-\u0026gt;m_Size; i++) { this-\u0026gt;pAddress[i] = myarray[i]; } return *this; } //重载[] 操作符 arr[0] T\u0026amp; operator [](int index) { return this-\u0026gt;pAddress[index]; //不考虑越界，用户自己去处理 } //尾插法 void Push_back(const T \u0026amp; val) { if (this-\u0026gt;m_Capacity == this-\u0026gt;m_Size) { return; } this-\u0026gt;pAddress[this-\u0026gt;m_Size] = val; this-\u0026gt;m_Size++; } //尾删法 void Pop_back() { if (this-\u0026gt;m_Size == 0) { return; } this-\u0026gt;m_Size--; } //获取数组容量 int getCapacity() { return this-\u0026gt;m_Capacity; } //获取数组大小 int getSize() { return this-\u0026gt;m_Size; } //析构 ~MyArray() { if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;pAddress = NULL; this-\u0026gt;m_Capacity = 0; this-\u0026gt;m_Size = 0; } } private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小 }; 类模板案例—数组类封装.cpp中\n#include \u0026#34;myArray.hpp\u0026#34; #include \u0026lt;string\u0026gt; void printIntArray(MyArray\u0026lt;int\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.getSize(); i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //测试内置数据类型 void test01() { MyArray\u0026lt;int\u0026gt; array1(10); for (int i = 0; i \u0026lt; 10; i++) { array1.Push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;array1打印输出：\u0026#34; \u0026lt;\u0026lt; endl; printIntArray(array1); cout \u0026lt;\u0026lt; \u0026#34;array1的大小：\u0026#34; \u0026lt;\u0026lt; array1.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;array1的容量：\u0026#34; \u0026lt;\u0026lt; array1.getCapacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;--------------------------\u0026#34; \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt; array2(array1); array2.Pop_back(); cout \u0026lt;\u0026lt; \u0026#34;array2打印输出：\u0026#34; \u0026lt;\u0026lt; endl; printIntArray(array2); cout \u0026lt;\u0026lt; \u0026#34;array2的大小：\u0026#34; \u0026lt;\u0026lt; array2.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;array2的容量：\u0026#34; \u0026lt;\u0026lt; array2.getCapacity() \u0026lt;\u0026lt; endl; } //测试自定义数据类型 class Person { public: Person() {} Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } public: string m_Name; int m_Age; }; void printPersonArray(MyArray\u0026lt;Person\u0026gt;\u0026amp; personArr) { for (int i = 0; i \u0026lt; personArr.getSize(); i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; personArr[i].m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; personArr[i].m_Age \u0026lt;\u0026lt; endl; } } void test02() { //创建数组 MyArray\u0026lt;Person\u0026gt; pArray(10); Person p1(\u0026#34;孙悟空\u0026#34;, 30); Person p2(\u0026#34;韩信\u0026#34;, 20); Person p3(\u0026#34;妲己\u0026#34;, 18); Person p4(\u0026#34;王昭君\u0026#34;, 15); Person p5(\u0026#34;赵云\u0026#34;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout \u0026lt;\u0026lt; \u0026#34;pArray的大小：\u0026#34; \u0026lt;\u0026lt; pArray.getSize() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pArray的容量：\u0026#34; \u0026lt;\u0026lt; pArray.getCapacity() \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n能够利用所学知识点实现通用的数组\n2 STL初识 2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器 **容器：**置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n**算法：**问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n**迭代器：**容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、==、！= 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、\u0026ndash;， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、\u0026ndash;、[n]、-n、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;= 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n2.5 容器算法迭代器初识 了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力\nSTL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器\n2.5.1 vector存放内置数据类型 容器： vector\n算法： for_each\n迭代器： vector::iterator\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; void MyPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } void test01() { //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector\u0026lt;int\u0026gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector\u0026lt;int\u0026gt;::iterator 拿到vector\u0026lt;int\u0026gt;这种容器的迭代器类型 vector\u0026lt;int\u0026gt;::iterator pBegin = v.begin(); vector\u0026lt;int\u0026gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) { cout \u0026lt;\u0026lt; *pBegin \u0026lt;\u0026lt; endl; pBegin++; } //第二种遍历方式： for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.2 Vector存放自定义数据类型 学习目标：vector中存放自定义数据类型，并打印输出\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; //自定义数据类型 class Person { public: Person(string name, int age) { mName = name; mAge = age; } public: string mName; int mAge; }; //存放对象 void test01() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); Person p5(\u0026#34;eee\u0026#34;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; (*it).mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it).mAge \u0026lt;\u0026lt; endl; } } //放对象指针 void test02() { vector\u0026lt;Person*\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); Person p5(\u0026#34;eee\u0026#34;, 50); v.push_back(\u0026amp;p1); v.push_back(\u0026amp;p2); v.push_back(\u0026amp;p3); v.push_back(\u0026amp;p4); v.push_back(\u0026amp;p5); for (vector\u0026lt;Person*\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { Person * p = (*it); cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it)-\u0026gt;mAge \u0026lt;\u0026lt; endl; } } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.3 Vector容器嵌套容器 学习目标：容器中嵌套容器，我们将所有数据进行遍历输出\n示例：\n#include \u0026lt;vector\u0026gt; //容器嵌套容器 void test01() { vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; v; vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; vector\u0026lt;int\u0026gt; v3; vector\u0026lt;int\u0026gt; v4; for (int i = 0; i \u0026lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3 STL- 常用容器 3.1 string容器 3.1.1 string基本概念 本质：\nstring是C++风格的字符串，而string本质上是一个类 string和char * 区别：\nchar * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点：\nstring 类内部封装了很多成员方法\n例如：查找find，拷贝copy，删除delete 替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n3.1.2 string构造函数 构造函数原型：\nstring(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化 string(const string\u0026amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化 示例：\n#include \u0026lt;string\u0026gt; //string构造 void test01() { string s1; //创建空字符串，调用无参构造函数 cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; const char* str = \u0026#34;hello world\u0026#34;; string s2(str); //把c_string转换成了string cout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; string s3(s2); //调用拷贝构造函数 cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; string s4(10, \u0026#39;a\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：string的多种构造方式没有可比性，灵活使用即可\n3.1.3 string赋值操作 功能描述：\n给string字符串进行赋值 赋值的函数原型：\nstring\u0026amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s); //把字符串s赋给当前的字符串 string\u0026amp; operator=(char c); //字符赋值给当前的字符串 string\u0026amp; assign(const char *s); //把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s); //把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c); //用n个字符c赋给当前字符串 示例：\n//赋值 void test01() { string str1; str1 = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2; str2 = str1; cout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; string str3; str3 = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; string str4; str4.assign(\u0026#34;hello c++\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str4 = \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; string str5; str5.assign(\u0026#34;hello c++\u0026#34;,5); cout \u0026lt;\u0026lt; \u0026#34;str5 = \u0026#34; \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; string str6; str6.assign(str5); cout \u0026lt;\u0026lt; \u0026#34;str6 = \u0026#34; \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; string str7; str7.assign(5, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;str7 = \u0026#34; \u0026lt;\u0026lt; str7 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nstring的赋值方式很多，operator= 这种方式是比较实用的\n3.1.4 string字符串拼接 功能描述：\n实现在字符串末尾拼接字符串 函数原型：\nstring\u0026amp; operator+=(const char* str); //重载+=操作符 string\u0026amp; operator+=(const char c); //重载+=操作符 string\u0026amp; operator+=(const string\u0026amp; str); //重载+=操作符 string\u0026amp; append(const char *s); //把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s); //同operator+=(const string\u0026amp; str) string\u0026amp; append(const string \u0026amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 示例：\n//字符串拼接 void test01() { string str1 = \u0026#34;我\u0026#34;; str1 += \u0026#34;爱玩游戏\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; str1 += \u0026#39;:\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2 = \u0026#34;LOL DNF\u0026#34;; str1 += str2; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str3 = \u0026#34;I\u0026#34;; str3.append(\u0026#34; love \u0026#34;); str3.append(\u0026#34;game abcde\u0026#34;, 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：字符串拼接的重载版本很多，初学阶段记住几种即可\n3.1.5 string查找和替换 功能描述：\n查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型：\nint find(const string\u0026amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string\u0026amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string\u0026amp; replace(int pos, int n, const string\u0026amp; str); //替换从pos开始n个字符为字符串str string\u0026amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s 示例：\n//查找和替换 void test01() { //查找 string str1 = \u0026#34;abcdefgde\u0026#34;; int pos = str1.find(\u0026#34;de\u0026#34;); if (pos == -1) { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } pos = str1.rfind(\u0026#34;de\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } void test02() { //替换 string str1 = \u0026#34;abcdefgde\u0026#34;; str1.replace(1, 3, \u0026#34;1111\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; } int main() { //test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nfind查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较 功能描述：\n字符串之间的比较 比较方式：\n字符串比较是按字符的ASCII码进行对比 = 返回 0\n\u0026gt; 返回 1\n\u0026lt; 返回 -1\n函数原型：\nint compare(const string \u0026amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 示例：\n//字符串比较 void test01() { string s1 = \u0026#34;hello\u0026#34;; string s2 = \u0026#34;aello\u0026#34;; int ret = s1.compare(s2); if (ret == 0) { cout \u0026lt;\u0026lt; \u0026#34;s1 等于 s2\u0026#34; \u0026lt;\u0026lt; endl; } else if (ret \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;s1 大于 s2\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;s1 小于 s2\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n3.1.7 string字符存取 string中单个字符存取方式有两种\nchar\u0026amp; operator[](int n); //通过[]方式取字符 char\u0026amp; at(int n); //通过at方法获取字符 示例：\nvoid test01() { string str = \u0026#34;hello world\u0026#34;; for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //字符修改 str[0] = \u0026#39;x\u0026#39;; str.at(1) = \u0026#39;x\u0026#39;; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at\n3.1.8 string插入和删除 功能描述：\n对string字符串进行插入和删除字符操作 函数原型：\nstring\u0026amp; insert(int pos, const char* s); //插入字符串 string\u0026amp; insert(int pos, const string\u0026amp; str); //插入字符串 string\u0026amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string\u0026amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 示例：\n//字符串插入和删除 void test01() { string str = \u0026#34;hello\u0026#34;; str.insert(1, \u0026#34;111\u0026#34;); cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**插入和删除的起始下标都是从0开始\n3.1.9 string子串 功能描述：\n从字符串中获取想要的子串 函数原型：\nstring substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 示例：\n//子串 void test01() { string str = \u0026#34;abcdefg\u0026#34;; string subStr = str.substr(1, 3); cout \u0026lt;\u0026lt; \u0026#34;subStr = \u0026#34; \u0026lt;\u0026lt; subStr \u0026lt;\u0026lt; endl; string email = \u0026#34;hello@sina.com\u0026#34;; int pos = email.find(\u0026#34;@\u0026#34;); string username = email.substr(0, pos); cout \u0026lt;\u0026lt; \u0026#34;username: \u0026#34; \u0026lt;\u0026lt; username \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息\n3.2 vector容器 3.2.1 vector基本概念 功能：\nvector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别：\n不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展：\n并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数 功能描述：\n创建vector容器 函数原型：\nvector v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector \u0026amp;vec); //拷贝构造函数。 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt; v1; //无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); printVector(v2); vector\u0026lt;int\u0026gt; v3(10, 100); printVector(v3); vector\u0026lt;int\u0026gt; v4(v3); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**vector的多种构造方式没有可比性，灵活使用即可\n3.2.3 vector赋值操作 功能描述：\n给vector容器进行赋值 函数原型：\nvector\u0026amp; operator=(const vector \u0026amp;vec);//重载等号操作符\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem); //将n个elem拷贝赋值给本身。\n示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test01() { vector\u0026lt;int\u0026gt; v1; //无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt;v2; v2 = v1; printVector(v2); vector\u0026lt;int\u0026gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector\u0026lt;int\u0026gt;v4; v4.assign(10, 100); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： vector赋值方式比较简单，使用operator=，或者assign都可以\n3.2.4 vector容量和大小 功能描述：\n对vector容器的容量和大小操作 函数原型：\nempty(); //判断容器是否为空\ncapacity(); //容器的容量\nsize(); //返回容器中元素的个数\nresize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除\n示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;v1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;v1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的容量 = \u0026#34; \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的大小 = \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; } //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 返回容器容量 \u0026mdash; capacity 重新指定大小 \u0026mdash; resize 3.2.5 vector插入和删除 功能描述：\n对vector容器进行插入、删除操作 函数原型：\npush_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { vector\u0026lt;int\u0026gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n尾插 \u0026mdash; push_back 尾删 \u0026mdash; pop_back 插入 \u0026mdash; insert (位置迭代器) 删除 \u0026mdash; erase （位置迭代器） 清空 \u0026mdash; clear 3.2.6 vector数据存取 功能描述：\n对vector中的数据的存取操作 函数原型：\nat(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例：\n#include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的第一个元素为： \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的最后一个元素为： \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n除了用迭代器获取vector容器中元素， 和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器 功能描述：\n实现两个容器内元素进行互换 函数原型：\nswap(vec); // 将vec与本身的元素互换 示例：\n#include \u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); vector\u0026lt;int\u0026gt;v2; for (int i = 10; i \u0026gt; 0; i--) { v2.push_back(i); } printVector(v2); //互换容器 cout \u0026lt;\u0026lt; \u0026#34;互换后\u0026#34; \u0026lt;\u0026lt; endl; v1.swap(v2); printVector(v1); printVector(v2); } void test02() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; v.resize(3); cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; //收缩内存 vector\u0026lt;int\u0026gt;(v).swap(v); //匿名对象 cout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果\n3.2.8 vector预留空间 功能描述：\n减少vector在动态扩展容量时的扩展次数 函数原型：\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 示例：\n#include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (p != \u0026amp;v[0]) { p = \u0026amp;v[0]; num++; } } cout \u0026lt;\u0026lt; \u0026#34;num:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果数据量较大，可以一开始利用reserve预留空间\n3.3 deque容器 3.3.1 deque容器基本概念 功能：\n双端数组，可以对头端进行插入删除操作 deque与vector区别：\nvector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\ndeque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数 功能描述：\ndeque容器构造 函数原型：\ndeque deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque \u0026amp;deq); //拷贝构造函数 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //deque构造 void test01() { deque\u0026lt;int\u0026gt; d1; //无参构造函数 for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque\u0026lt;int\u0026gt; d2(d1.begin(),d1.end()); printDeque(d2); deque\u0026lt;int\u0026gt;d3(10,100); printDeque(d3); deque\u0026lt;int\u0026gt;d4 = d3; printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可\n3.3.3 deque赋值操作 功能描述：\n给deque容器进行赋值 函数原型：\ndeque\u0026amp; operator=(const deque \u0026amp;deq); //重载等号操作符\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem); //将n个elem拷贝赋值给本身。\n示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test01() { deque\u0026lt;int\u0026gt; d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque\u0026lt;int\u0026gt;d2; d2 = d1; printDeque(d2); deque\u0026lt;int\u0026gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque\u0026lt;int\u0026gt;d4; d4.assign(10, 100); printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：deque赋值操作也与vector相同，需熟练掌握\n3.3.4 deque大小操作 功能描述：\n对deque容器的大小进行操作 函数原型：\ndeque.empty(); //判断容器是否为空\ndeque.size(); //返回容器中元素的个数\ndeque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\n示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小操作 void test01() { deque\u0026lt;int\u0026gt; d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); //判断容器是否为空 if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;d1为空!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;d1不为空!\u0026#34; \u0026lt;\u0026lt; endl; //统计大小 cout \u0026lt;\u0026lt; \u0026#34;d1的大小为：\u0026#34; \u0026lt;\u0026lt; d1.size() \u0026lt;\u0026lt; endl; } //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\ndeque没有容量的概念 判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 重新指定个数 \u0026mdash; resize 3.3.5 deque 插入和删除 功能描述：\n向deque容器中插入和删除数据 函数原型：\n两端插入操作：\npush_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作：\ninsert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //两端操作 void test01() { deque\u0026lt;int\u0026gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d); } //插入 void test02() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque\u0026lt;int\u0026gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d); } //删除 void test03() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n插入和删除提供的位置是迭代器！ 尾插 \u0026mdash; push_back 尾删 \u0026mdash; pop_back 头插 \u0026mdash; push_front 头删 \u0026mdash; pop_front 3.3.6 deque 数据存取 功能描述：\n对deque 中的数据的存取操作 函数原型：\nat(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例：\n#include \u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //数据存取 void test01() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i \u0026lt; d.size(); i++) { cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; d.size(); i++) { cout \u0026lt;\u0026lt; d.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front:\u0026#34; \u0026lt;\u0026lt; d.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;back:\u0026#34; \u0026lt;\u0026lt; d.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n除了用迭代器获取deque容器中元素， 和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序 功能描述：\n利用算法实现对deque容器进行排序 算法：\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序 示例：\n#include \u0026lt;deque\u0026gt; #include \u0026lt;algorithm\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { deque\u0026lt;int\u0026gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：sort算法非常实用，使用时包含头文件 algorithm即可\n3.4 案例-评委打分 3.4.1 案例描述 有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码：\n//选手类 class Person { public: Person(string name, int score) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Score = score; } string m_Name; //姓名 int m_Score; //平均分 }; void createPerson(vector\u0026lt;Person\u0026gt;\u0026amp;v) { string nameSeed = \u0026#34;ABCDE\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { string name = \u0026#34;选手\u0026#34;; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); } } //打分 void setScore(vector\u0026lt;Person\u0026gt;\u0026amp;v) { for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { //将评委的分数 放入到deque容器中 deque\u0026lt;int\u0026gt;d; for (int i = 0; i \u0026lt; 10; i++) { int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); } //cout \u0026lt;\u0026lt; \u0026#34;选手： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 打分： \u0026#34; \u0026lt;\u0026lt; endl; //for (deque\u0026lt;int\u0026gt;::iterator dit = d.begin(); dit != d.end(); dit++) //{ // cout \u0026lt;\u0026lt; *dit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //} //cout \u0026lt;\u0026lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque\u0026lt;int\u0026gt;::iterator dit = d.begin(); dit != d.end(); dit++) { sum += *dit; //累加每个评委的分数 } int avg = sum / d.size(); //将平均分 赋值给选手身上 it-\u0026gt;m_Score = avg; } } void showScore(vector\u0026lt;Person\u0026gt;\u0026amp;v) { for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 平均分： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Score \u0026lt;\u0026lt; endl; } } int main() { //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector\u0026lt;Person\u0026gt;v; //存放选手容器 createPerson(v); //测试 //for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) //{ // cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; (*it).m_Name \u0026lt;\u0026lt; \u0026#34; 分数： \u0026#34; \u0026lt;\u0026lt; (*it).m_Score \u0026lt;\u0026lt; endl; //} //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 选取不同的容器操作数据，可以提升代码的效率\n3.5 stack容器 3.5.1 stack 基本概念 概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\n栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n栈中进入数据称为 \u0026mdash; 入栈 push\n栈中弹出数据称为 \u0026mdash; 出栈 pop\n3.5.2 stack 常用接口 功能描述：栈容器常用的对外接口\n构造函数：\nstack stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack \u0026amp;stk); //拷贝构造函数 赋值操作：\nstack\u0026amp; operator=(const stack \u0026amp;stk); //重载等号操作符 数据存取：\npush(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 大小操作：\nempty(); //判断堆栈是否为空 size(); //返回栈的大小 示例：\n#include \u0026lt;stack\u0026gt; //栈容器常用接口 void test01() { //创建栈容器 栈容器必须符合先进后出 stack\u0026lt;int\u0026gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) { //输出栈顶元素 cout \u0026lt;\u0026lt; \u0026#34;栈顶元素为： \u0026#34; \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; //弹出栈顶元素 s.pop(); } cout \u0026lt;\u0026lt; \u0026#34;栈的大小为：\u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n入栈 \u0026mdash; push 出栈 \u0026mdash; pop 返回栈顶 \u0026mdash; top 判断栈是否为空 \u0026mdash; empty 返回栈大小 \u0026mdash; size 3.6 queue 容器 3.6.1 queue 基本概念 概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\n队列容器允许从一端新增元素，从另一端移除元素\n队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n队列中进数据称为 \u0026mdash; 入队 push\n队列中出数据称为 \u0026mdash; 出队 pop\n3.6.2 queue 常用接口 功能描述：栈容器常用的对外接口\n构造函数：\nqueue que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue \u0026amp;que); //拷贝构造函数 赋值操作：\nqueue\u0026amp; operator=(const queue \u0026amp;que); //重载等号操作符 数据存取：\npush(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 大小操作：\nempty(); //判断堆栈是否为空 size(); //返回栈的大小 示例：\n#include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; void test01() { //创建队列 queue\u0026lt;Person\u0026gt; q; //准备数据 Person p1(\u0026#34;唐僧\u0026#34;, 30); Person p2(\u0026#34;孙悟空\u0026#34;, 1000); Person p3(\u0026#34;猪八戒\u0026#34;, 900); Person p4(\u0026#34;沙僧\u0026#34;, 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) { //输出队头元素 cout \u0026lt;\u0026lt; \u0026#34;队头元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.front().m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34;\u0026lt;\u0026lt; q.front().m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;队尾元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.back().m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; q.back().m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; //弹出队头元素 q.pop(); } cout \u0026lt;\u0026lt; \u0026#34;队列大小为：\u0026#34; \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n入队 \u0026mdash; push 出队 \u0026mdash; pop 返回队头元素 \u0026mdash; front 返回队尾元素 \u0026mdash; back 判断队是否为空 \u0026mdash; empty 返回队列大小 \u0026mdash; size 3.7 list容器 3.7.1 list基本概念 **功能：**将数据进行链式存储\n链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的\n链表的组成：链表由一系列结点组成\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\nSTL中的链表是一个双向循环链表\n由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nlist的优点：\n采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点：\n链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。\n总结：STL中List和vector是两个最常被使用的容器，各有优缺点\n3.7.2 list构造函数 功能描述：\n创建list容器 函数原型：\nlist lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list \u0026amp;lst); //拷贝构造函数。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list\u0026lt;int\u0026gt;L2(L1.begin(),L1.end()); printList(L2); list\u0026lt;int\u0026gt;L3(L2); printList(L3); list\u0026lt;int\u0026gt;L4(10, 1000); printList(L4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：list构造方式同其他几个STL常用容器，熟练掌握即可\n3.7.3 list 赋值和交换 功能描述：\n给list容器进行赋值，以及交换list容器 函数原型：\nassign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list\u0026amp; operator=(const list \u0026amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值和交换 void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list\u0026lt;int\u0026gt;L2; L2 = L1; printList(L2); list\u0026lt;int\u0026gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list\u0026lt;int\u0026gt;L4; L4.assign(10, 100); printList(L4); } //交换 void test02() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list\u0026lt;int\u0026gt;L2; L2.assign(10, 100); cout \u0026lt;\u0026lt; \u0026#34;交换前： \u0026#34; \u0026lt;\u0026lt; endl; printList(L1); printList(L2); cout \u0026lt;\u0026lt; endl; L1.swap(L2); cout \u0026lt;\u0026lt; \u0026#34;交换后： \u0026#34; \u0026lt;\u0026lt; endl; printList(L1); printList(L2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：list赋值和交换操作能够灵活运用即可\n3.7.4 list 大小操作 功能描述：\n对list容器的大小进行操作 函数原型：\nsize(); //返回容器中元素的个数\nempty(); //判断容器是否为空\nresize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。\nresize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n//如果容器变短，则末尾超出容器长度的元素被删除。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小操作 void test01() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;L1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;L1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;L1的大小为： \u0026#34; \u0026lt;\u0026lt; L1.size() \u0026lt;\u0026lt; endl; } //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n判断是否为空 \u0026mdash; empty 返回元素个数 \u0026mdash; size 重新指定个数 \u0026mdash; resize 3.7.5 list 插入和删除 功能描述：\n对list容器进行数据的插入和删除 函数原型：\npush_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例：\n#include \u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (const auto\u0026amp;it : L) { std::cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { list\u0026lt;int\u0026gt; L; //尾插 L.emplace_back(10); L.emplace_back(20); L.emplace_back(30); //头插 L.emplace_front(100); L.emplace_front(200); L.emplace_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list\u0026lt;int\u0026gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.pop_back(); L.pop_back(); L.pop_back(); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n尾插 \u0026mdash; push_back 尾部原位创造 \u0026mdash; emplace_back 尾删 \u0026mdash; pop_back 头插 \u0026mdash; push_front 头删 \u0026mdash; pop_front 插入 \u0026mdash; insert 删除 \u0026mdash; erase 移除 \u0026mdash; remove 清空 \u0026mdash; clear 3.7.6 list 数据存取 功能描述：\n对list容器中数据进行存取 函数原型：\nfront(); //返回第一个元素。 back(); //返回最后一个元素。 示例：\n#include \u0026lt;list\u0026gt; //数据存取 void test01() { list\u0026lt;int\u0026gt;L1; L1.emplace_back(10); L1.emplace_back(20); L1.emplace_back(30); L1.emplace_back(40); //cout \u0026lt;\u0026lt; L1.at(0) \u0026lt;\u0026lt; endl;//错误 不支持at访问数据 //cout \u0026lt;\u0026lt; L1[0] \u0026lt;\u0026lt; endl; //错误 不支持[]方式访问数据 cout \u0026lt;\u0026lt; \u0026#34;第一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;最后一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.back() \u0026lt;\u0026lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list\u0026lt;int\u0026gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nlist容器中不可以通过[]或者at方式访问数据 返回第一个元素 \u0026mdash; front 返回最后一个元素 \u0026mdash; back 3.7.7 list 反转和排序 功能描述：\n将容器中的元素反转，以及将容器中的数据进行排序 函数原型：\nreverse(); //反转链表 sort(); //链表排序 示例：\nvoid printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } bool myCompare(int val1 , int val2) { return val1 \u0026gt; val2; } //反转和排序 void test01() { list\u0026lt;int\u0026gt; L; L.emplace_back(90); L.emplace_back(30); L.emplace_back(20); L.emplace_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n反转 \u0026mdash; reverse 排序 \u0026mdash; sort （成员函数） 3.7.8 排序案例 案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\n示例：\n#include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age , int height) { m_Name = name; m_Age = age; m_Height = height; } public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高 }; bool ComparePerson(Person\u0026amp; p1, Person\u0026amp; p2) { if (p1.m_Age == p2.m_Age) { return p1.m_Height \u0026gt; p2.m_Height; } else { return p1.m_Age \u0026lt; p2.m_Age; } } void test01() { list\u0026lt;Person\u0026gt; L; Person p1(\u0026#34;刘备\u0026#34;, 35 , 175); Person p2(\u0026#34;曹操\u0026#34;, 45 , 180); Person p3(\u0026#34;孙权\u0026#34;, 40 , 170); Person p4(\u0026#34;赵云\u0026#34;, 25 , 190); Person p5(\u0026#34;张飞\u0026#34;, 35 , 160); Person p6(\u0026#34;关羽\u0026#34;, 35 , 200); L.emplace_back(move(p1)); L.emplace_back(move(p2)); L.emplace_back(move(p3)); L.emplace_back(move(p4)); L.emplace_back(move(p5)); L.emplace_back(move(p6)); for (list\u0026lt;Person\u0026gt;::iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Height \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;---------------------------------\u0026#34; \u0026lt;\u0026lt; endl; L.sort(ComparePerson); //排序 for (list\u0026lt;Person\u0026gt;::iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Height \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序\n高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂\n3.8 set/ multiset 容器 3.8.1 set基本概念 简介：\n所有元素都会在插入时自动被排序 本质：\nset/multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别：\nset不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值 功能描述：创建set容器以及赋值\n构造：\nset st; //默认构造函数： set(const set \u0026amp;st); //拷贝构造函数 赋值：\nset\u0026amp; operator=(const set \u0026amp;st); //重载等号操作符 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //构造和赋值 void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); printSet(s1); //拷贝构造 set\u0026lt;int\u0026gt;s2(s1); printSet(s2); //赋值 set\u0026lt;int\u0026gt;s3; s3 = s2; printSet(s3); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nset容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换 功能描述：\n统计set容器大小以及交换set容器 函数原型：\nsize(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //大小 void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); if (s1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;s1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;s1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1的大小为： \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } } //交换 void test02() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); set\u0026lt;int\u0026gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); s2.emplace(500); cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; printSet(s1); printSet(s2); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; s1.swap(s2); printSet(s1); printSet(s2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n统计大小 \u0026mdash; size 判断是否为空 \u0026mdash; empty 交换容器 \u0026mdash; swap 3.8.4 set插入和删除 功能描述：\nset容器进行插入数据和删除数据 函数原型：\ninsert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 示例：\n#include \u0026lt;set\u0026gt; void printSet(set\u0026lt;int\u0026gt; \u0026amp; s) { for (set\u0026lt;int\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test01() { set\u0026lt;int\u0026gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n插入 \u0026mdash; insert 删除 \u0026mdash; erase 清空 \u0026mdash; clear 3.8.5 set查找和统计 功能描述：\n对set容器进行查找数据以及统计数据 函数原型：\nfind(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例：\n#include \u0026lt;set\u0026gt; //查找和统计 void test01() { set\u0026lt;int\u0026gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.emplace(50); //查找 set\u0026lt;int\u0026gt;::iterator pos = s1.find(30); if (pos != s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到了元素 ： \u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; } //统计 int num = s1.count(30); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n查找 \u0026mdash; find （返回的是迭代器） 统计 \u0026mdash; count （对于set，结果为0或者1） 3.8.6 set和multiset区别 学习目标：\n掌握set和multiset的区别 区别：\nset不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例：\n#include \u0026lt;set\u0026gt; //set和multiset区别 void test01() { set\u0026lt;int\u0026gt; s; pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, bool\u0026gt; ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第一次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; } ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第二次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; } //multiset multiset\u0026lt;int\u0026gt; ms; ms.insert(10); ms.insert(10); ms.emplace(50); for (multiset\u0026lt;int\u0026gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建 功能描述：\n成对出现的数据，利用对组可以返回两个数据 两种创建方式：\npair p ( value1, value2 ); pair p = make_pair( value1, value2 ); 示例：\n#include \u0026lt;string\u0026gt; //对组创建 void test01() { pair\u0026lt;string, int\u0026gt; p(string(\u0026#34;Tom\u0026#34;), 20); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; pair\u0026lt;string, int\u0026gt; p2 = make_pair(\u0026#34;Jerry\u0026#34;, 10); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n两种方式都可以创建对组，记住一种即可\n3.8.8 set容器排序 学习目标：\nset容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点：\n利用仿函数，可以改变排序规则 示例一 set存放内置数据类型\n#include \u0026lt;set\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); s1.emplace(60); //默认从小到大 for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //指定排序规则 set\u0026lt;int,MyCompare\u0026gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); s1.emplace(60); for (set\u0026lt;int, MyCompare\u0026gt;::iterator it = s2.begin(); it != s2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：利用仿函数可以指定set容器的排序规则\n示例二 set存放自定义数据类型\n#include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; class comparePerson { public: bool operator()(const Person\u0026amp; p1, const Person \u0026amp;p2) { //按照年龄进行排序 降序 return p1.m_Age \u0026gt; p2.m_Age; } }; void test01() { set\u0026lt;Person, comparePerson\u0026gt; s; Person p1(\u0026#34;刘备\u0026#34;, 23); Person p2(\u0026#34;关羽\u0026#34;, 27); Person p3(\u0026#34;张飞\u0026#34;, 25); Person p4(\u0026#34;赵云\u0026#34;, 21); Person p5(\u0026#34;刘德华\u0026#34;, 51); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); s.emplace(p5); for (set\u0026lt;Person, comparePerson\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n对于自定义数据类型，set必须指定排序规则才可以插入数据\n3.9 map/ multimap容器 3.9.1 map基本概念 简介：\nmap中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质：\nmap/multimap属于关联式容器，底层结构是用二叉树实现。 优点：\n可以根据key值快速找到value值 map和multimap区别：\nmap不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值 功能描述：\n对map容器进行构造和赋值操作 函数原型：\n构造：\nmap mp; //map默认构造函数: map(const map \u0026amp;mp); //拷贝构造函数 赋值：\nmap\u0026amp; operator=(const map \u0026amp;mp); //重载等号操作符 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int,int\u0026gt;m; //默认构造 m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); printMap(m); map\u0026lt;int, int\u0026gt;m2(m); //拷贝构造 printMap(m2); map\u0026lt;int, int\u0026gt;m3; m3 = m2; //赋值 printMap(m3); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：map中所有元素都是成对出现，插入数据时候要使用对组\n3.9.3 map大小和交换 功能描述：\n统计map容器大小以及交换map容器 函数原型：\nsize(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); if (m.empty()) { cout \u0026lt;\u0026lt; \u0026#34;m为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;m不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;m的大小为： \u0026#34; \u0026lt;\u0026lt; m.size() \u0026lt;\u0026lt; endl; } } //交换 void test02() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); map\u0026lt;int, int\u0026gt;m2; m2.insert(pair\u0026lt;int, int\u0026gt;(4, 100)); m2.insert(pair\u0026lt;int, int\u0026gt;(5, 200)); m2.insert(pair\u0026lt;int, int\u0026gt;(6, 300)); cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; printMap(m); printMap(m2); cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; m.swap(m2); printMap(m); printMap(m2); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n统计大小 \u0026mdash; size 判断是否为空 \u0026mdash; empty 交换容器 \u0026mdash; swap 3.9.4 map插入和删除 功能描述：\nmap容器进行插入数据和删除数据 函数原型：\ninsert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。 示例：\n#include \u0026lt;map\u0026gt; void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { //插入 map\u0026lt;int, int\u0026gt; m; //第一种插入方式 m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map\u0026lt;int, int\u0026gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\nmap插入方式很多，记住其一即可\n插入 \u0026mdash; insert\n删除 \u0026mdash; erase\n清空 \u0026mdash; clear\n3.9.5 map查找和统计 功能描述：\n对map容器进行查找数据以及统计数据 函数原型：\nfind(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例：\n#include \u0026lt;map\u0026gt; //查找和统计 void test01() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); //查找 map\u0026lt;int, int\u0026gt;::iterator pos = m.find(3); if (pos != m.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到了元素 key = \u0026#34; \u0026lt;\u0026lt; (*pos).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; (*pos).second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; } //统计 int num = m.count(3); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n查找 \u0026mdash; find （返回的是迭代器） 统计 \u0026mdash; count （对于map，结果为0或者1） 3.9.6 map容器排序 学习目标：\nmap容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点:\n利用仿函数，可以改变排序规则 示例：\n#include \u0026lt;map\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { //默认从小到大排序 //利用仿函数实现从大到小排序 map\u0026lt;int, int, MyCompare\u0026gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map\u0026lt;int, int, MyCompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组 3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;ctime\u0026gt; /* - 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 - 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 - 随机给10名员工分配部门和工资 - 通过multimap进行信息的插入 key(部门编号) value(员工) - 分部门显示员工信息 */ #define CEHUA 0 #define MEISHU 1 #define YANFA 2 class Worker { public: string m_Name; int m_Salary; }; void createWorker(vector\u0026lt;Worker\u0026gt;\u0026amp;v) { string nameSeed = \u0026#34;ABCDEFGHIJ\u0026#34;; for (int i = 0; i \u0026lt; 10; i++) { Worker worker; worker.m_Name = \u0026#34;员工\u0026#34;; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); } } //员工分组 void setGroup(vector\u0026lt;Worker\u0026gt;\u0026amp;v,multimap\u0026lt;int,Worker\u0026gt;\u0026amp;m) { for (vector\u0026lt;Worker\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); } } void showWorkerByGourp(multimap\u0026lt;int,Worker\u0026gt;\u0026amp;m) { // 0 A B C 1 D E 2 F G ... cout \u0026lt;\u0026lt; \u0026#34;策划部门：\u0026#34; \u0026lt;\u0026lt; endl; multimap\u0026lt;int,Worker\u0026gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++ , index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;美术部门： \u0026#34; \u0026lt;\u0026lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++, index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;研发部门： \u0026#34; \u0026lt;\u0026lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() \u0026amp;\u0026amp; index \u0026lt; count; pos++, index++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; pos-\u0026gt;second.m_Salary \u0026lt;\u0026lt; endl; } } int main() { srand((unsigned int)time(NULL)); //1、创建员工 vector\u0026lt;Worker\u0026gt;vWorker; createWorker(vWorker); //2、员工分组 multimap\u0026lt;int, Worker\u0026gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector\u0026lt;Worker\u0026gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //{ // cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 工资： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Salary \u0026lt;\u0026lt; endl; //} system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n当数据以键值对形式存在，可以考虑用map 或 multimap 3.11 unordered_map/unordered_multimap容器 unordered_map(C++11 起) 键值对的集合，按照键生成散列，键是唯一的\nunordered_multimap(C++11 起)键值对的集合，按照键生成散列\nC++无序容器 - txt1994s\n3.12 unordered_set/unordered_multiset容器 unordered_set(C++11 起) 唯一键的集合，按照键生成散列\nunordered_multiset(C++11 起) 键的集合，按照键生成散列\nC++无序容器 - txt1994s\n4 STL- 函数对象 4.1 函数对象 4.1.1 函数对象概念 概念：\n重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质：\n函数对象(仿函数)是一个类，不是一个函数\n4.1.2 函数对象使用 特点：\n函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例:\n#include \u0026lt;string\u0026gt; //1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 class MyAdd { public : int operator()(int v1,int v2) { return v1 + v2; } }; void test01() { MyAdd myAdd; cout \u0026lt;\u0026lt; myAdd(10, 10) \u0026lt;\u0026lt; endl; } //2、函数对象可以有自己的状态 class MyPrint { public: MyPrint() { count = 0; } void operator()(string test) { cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; count++; //统计使用次数 } int count; //内部自己的状态 }; void test02() { MyPrint myPrint; myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;myPrint调用次数为： \u0026#34; \u0026lt;\u0026lt; myPrint.count \u0026lt;\u0026lt; endl; } //3、函数对象可以作为参数传递 void doPrint(MyPrint \u0026amp;mp , string test) { mp(test); } void test03() { MyPrint myPrint; doPrint(myPrint, \u0026#34;Hello C++\u0026#34;); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词 4.2.1 谓词概念 概念：\n返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; //1.一元谓词 struct GreaterFive{ bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：参数只有一个的谓词，称为一元谓词\n4.2.3 二元谓词 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; //二元谓词 class MyCompare { public: bool operator()(int num1, int num2) { return num1 \u0026gt; num2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.emplace_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;----------------------------\u0026#34; \u0026lt;\u0026lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：参数只有两个的谓词，称为二元谓词\n4.3 内建函数对象 4.3.1 内建函数对象意义 概念：\nSTL内建了一些函数对象 分类:\n算术仿函数 关系仿函数 逻辑仿函数 用法：\n这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include 4.3.2 算术仿函数 功能描述：\n实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型：\ntemplate T plus //加法仿函数 template T minus //减法仿函数 template T multiplies //乘法仿函数 template T divides //除法仿函数 template T modulus //取模仿函数 template T negate //取反仿函数 示例：\n#include \u0026lt;functional\u0026gt; //negate void test01() { negate\u0026lt;int\u0026gt; n; cout \u0026lt;\u0026lt; n(50) \u0026lt;\u0026lt; endl; } //plus void test02() { plus\u0026lt;int\u0026gt; p; cout \u0026lt;\u0026lt; p(10, 20) \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：使用内建函数对象时，需要引入头文件 #include 4.3.3 关系仿函数 功能描述：\n实现关系对比 仿函数原型：\ntemplate bool equal_to //等于 template bool not_equal_to //不等于 template bool greater //大于 template bool greater_equal //大于等于 template bool less //小于 template bool less_equal //小于等于 示例：\n#include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class MyCompare { public: bool operator()(int v1,int v2) { return v1 \u0026gt; v2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：关系仿函数中最常用的就是greater\u0026lt;\u0026gt;大于\n4.3.4 逻辑仿函数 功能描述：\n实现逻辑运算 函数原型：\ntemplate bool logical_and //逻辑与 template bool logical_or //逻辑或 template bool logical_not //逻辑非 示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;algorithm\u0026gt; void test01() { vector\u0026lt;bool\u0026gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector\u0026lt;bool\u0026gt;::iterator it = v.begin();it!= v.end();it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector\u0026lt;bool\u0026gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not\u0026lt;bool\u0026gt;()); for (vector\u0026lt;bool\u0026gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：逻辑仿函数实际应用较少，了解即可\n5 STL- 常用算法 概述:\n算法主要是由头文件 ``组成。\n``是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等\n``体积很小，只包括几个在序列上面进行简单数学运算的模板函数\n``定义了一些模板类,用以声明函数对象。\n5.1 常用遍历算法 学习目标：\n掌握常用的遍历算法 算法简介：\nfor_each //遍历容器 transform //搬运容器到另一个容器中 5.1.1 for_each 功能描述：\n实现遍历容器 函数原型：\nfor_each(iterator beg, iterator end, _func);\n// 遍历算法 遍历容器元素\n// beg 开始迭代器\n// end 结束迭代器\n// _func 函数或者函数对象\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; //普通函数 void print01(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } //函数对象 class print02 { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; //for_each算法基本用法 void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //遍历算法 for_each(v.begin(), v.end(), print01); cout \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), print02()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握\n5.1.2 transform 功能描述：\n搬运容器到另一个容器中 函数原型：\ntransform(iterator beg1, iterator end1, iterator beg2, _func); //beg1 源容器开始迭代器\n//end1 源容器结束迭代器\n//beg2 目标容器开始迭代器\n//_func 函数或者函数对象\n示例：\n#include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; //常用遍历算法 搬运 transform class TransForm { public: int operator()(int val) { return val; } }; class MyPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint()); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运\n5.2 常用查找算法 学习目标：\n掌握常用的查找算法 算法简介：\nfind //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 5.2.1 find 功能描述：\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型：\nfind(iterator beg, iterator end, value);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// value 查找的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i + 1); } //查找容器中是否有 5 这个元素 vector\u0026lt;int\u0026gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //重载== bool operator==(const Person\u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } return false; } public: string m_Name; int m_Age; }; void test02() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } 总结： 利用find可以在容器中找指定的元素，返回值是迭代器\n5.2.2 find_if 功能描述：\n按条件查找元素 函数原型：\nfind_if(iterator beg, iterator end, _Pred);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 函数或者谓词（返回bool类型的仿函数）\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; //内置数据类型 class GreaterFive { public: bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i + 1); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到大于5的数字:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } public: string m_Name; int m_Age; }; class Greater20 { public: bool operator()(Person \u0026amp;p) { return p.m_Age \u0026gt; 20; } }; void test02() { vector\u0026lt;Person\u0026gt; v; //创建数据 Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略\n5.2.3 adjacent_find 功能描述：\n查找相邻重复元素 函数原型：\nadjacent_find(iterator beg, iterator end);\n// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n// beg 开始迭代器\n// end 结束迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector\u0026lt;int\u0026gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;找不到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到相邻重复元素为:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法\n5.2.4 binary_search 功能描述：\n查找指定元素是否存在 函数原型：\nbool binary_search(iterator beg, iterator end, value);\n// 查找指定的元素，查到 返回true 否则false\n// 注意: 在无序序列中不可用\n// beg 开始迭代器\n// end 结束迭代器\n// value 查找的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;找到了\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列\n5.2.5 count 功能描述：\n统计元素个数 函数原型：\ncount(iterator beg, iterator end, value);\n// 统计元素出现次数\n// beg 开始迭代器\n// end 结束迭代器\n// value 统计的元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; //内置数据类型 void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout \u0026lt;\u0026lt; \u0026#34;4的个数为： \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } bool operator==(const Person \u0026amp; p) { if (this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age; }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;, 35); Person p2(\u0026#34;关羽\u0026#34;, 35); Person p3(\u0026#34;张飞\u0026#34;, 35); Person p4(\u0026#34;赵云\u0026#34;, 30); Person p5(\u0026#34;曹操\u0026#34;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(\u0026#34;诸葛亮\u0026#34;,35); int num = count(v.begin(), v.end(), p); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 统计自定义数据类型时候，需要配合重载 operator==\n5.2.6 count_if 功能描述：\n按条件统计元素个数 函数原型：\ncount_if(iterator beg, iterator end, _Pred);\n// 按条件统计元素出现次数\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 谓词\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class Greater4 { public: bool operator()(int val) { return val \u0026gt;= 4; } }; //内置数据类型 void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout \u0026lt;\u0026lt; \u0026#34;大于4的个数为： \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; class AgeLess35 { public: bool operator()(const Person \u0026amp;p) { return p.m_Age \u0026lt; 35; } }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;, 35); Person p2(\u0026#34;关羽\u0026#34;, 35); Person p3(\u0026#34;张飞\u0026#34;, 35); Person p4(\u0026#34;赵云\u0026#34;, 30); Person p5(\u0026#34;曹操\u0026#34;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout \u0026lt;\u0026lt; \u0026#34;小于35岁的个数：\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**按值统计用count，按条件统计用count_if\n5.3 常用排序算法 学习目标：\n掌握常用的排序算法 算法简介：\nsort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 5.3.1 sort 功能描述：\n对容器内元素进行排序 函数原型：\nsort(iterator beg, iterator end, _Pred);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// _Pred 谓词\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; void myPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**sort属于开发中最常用的算法之一，需熟练掌握\n5.3.2 shuffle 功能描述：\n洗牌 指定范围内的元素随机调整次序 函数原型：\n`shuffle(iterator beg, iterator end, std::mt19937{std::random_device{}()});\n// 指定范围内的元素随机调整次序\n// beg 开始迭代器\n// end 结束迭代器\n// std::mt19937{std::random_device{}()}随机数生成器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;ctime\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { srand((unsigned int)time(NULL)); vector\u0026lt;int\u0026gt; v; for(int i = 0 ; i \u0026lt; 10;i++) { v.push_back(i); } for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //打乱顺序 shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()}); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**shuffle洗牌算法比较实用，使用时记得加随机数种子\n5.3.3 merge 功能描述：\n两个容器元素合并，并存储到另一容器中 函数原型：\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 容器元素合并，并存储到另一容器中\n// 注意: 两个容器必须是有序的\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10 ; i++) { v1.push_back(i); v2.push_back(i + 1); } vector\u0026lt;int\u0026gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**merge合并的两个容器必须的有序序列\n5.3.4 reverse 功能描述：\n将容器内元素进行反转 函数原型：\nreverse(iterator beg, iterator end);\n// 反转指定范围的元素\n// beg 开始迭代器\n// end 结束迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout \u0026lt;\u0026lt; \u0026#34;反转前： \u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;反转后： \u0026#34; \u0026lt;\u0026lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**reverse反转区间内元素，面试题可能涉及到\n5.4 常用拷贝和替换算法 学习目标：\n掌握常用的拷贝和替换算法 算法简介：\ncopy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 5.4.1 copy 功能描述：\n容器内指定范围的元素拷贝到另一容器中 函数原型：\ncopy(iterator beg, iterator end, iterator dest);\n// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n// beg 开始迭代器\n// end 结束迭代器\n// dest 目标起始迭代器\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i + 1); } vector\u0026lt;int\u0026gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间\n5.4.2 replace 功能描述：\n将容器内指定范围的旧元素修改为新元素 函数原型：\nreplace(iterator beg, iterator end, oldvalue, newvalue);\n// 将区间内旧元素 替换成 新元素\n// beg 开始迭代器\n// end 结束迭代器\n// oldvalue 旧元素\n// newvalue 新元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前：\u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中的20 替换成 2000 cout \u0026lt;\u0026lt; \u0026#34;替换后：\u0026#34; \u0026lt;\u0026lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**replace会替换区间内满足条件的元素\n5.4.3 replace_if 功能描述:\n将区间内满足条件的元素，替换成指定元素 函数原型：\nreplace_if(iterator beg, iterator end, _pred, newvalue);\n// 按条件替换元素，满足条件的替换成指定元素\n// beg 开始迭代器\n// end 结束迭代器\n// _pred 谓词\n// newvalue 替换的新元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; class ReplaceGreater30 { public: bool operator()(int val) { return val \u0026gt;= 30; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前：\u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中大于等于的30 替换成 3000 cout \u0026lt;\u0026lt; \u0026#34;替换后：\u0026#34; \u0026lt;\u0026lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n5.4.4 swap 功能描述：\n互换两个容器的元素 函数原型：\nswap(container c1, container c2);\n// 互换两个容器的元素\n// c1容器1\n// c2容器2\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+100); } cout \u0026lt;\u0026lt; \u0026#34;交换前： \u0026#34; \u0026lt;\u0026lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后： \u0026#34; \u0026lt;\u0026lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**swap交换容器时，注意交换的容器要同种类型\n5.5 常用算术生成算法 学习目标：\n掌握常用的算术生成算法 注意：\n算术生成算法属于小型算法，使用时包含的头文件为 #include 算法简介：\naccumulate // 计算容器元素累计总和 fill // 向容器中添加元素 iota // 向容器中填充元素 5.5.1 accumulate 功能描述：\n计算区间内 容器元素累计总和 函数原型：\naccumulate(iterator beg, iterator end, value);\n// 计算容器元素累计总和\n// beg 开始迭代器\n// end 结束迭代器\n// value 起始值\n示例：\n#include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt;= 100; i++) { v.push_back(i); } int total = accumulate(v.begin(), v.end(), 0); cout \u0026lt;\u0026lt; \u0026#34;total = \u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**accumulate使用时头文件注意是 numeric，这个算法很实用\n5.5.2 fill 功能描述：\n向容器中填充指定的元素 函数原型：\nfill(iterator beg, iterator end, value);\n// 向容器中填充元素\n// beg 开始迭代器\n// end 结束迭代器\n// value 填充的值\n示例：\n#include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **总结：**利用fill可以将容器区间内元素填充为 指定的值\n5.5.3 iota 功能描述：\n用从起始值开始连续递增的值填充一个范围 函数原型：\niota(ForwardIterator first, ForwardIterator last, T value)\n// 以value为起始值，填充以[first, last);\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::list\u0026lt;int\u0026gt; l(10); std::iota(l.begin(), l.end(), -4); std::vector\u0026lt;std::list\u0026lt;int\u0026gt;::iterator\u0026gt; v(l.size()); std::iota(v.begin(), v.end(), l.begin()); std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()}); std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list: \u0026#34;; for(auto n: l) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Contents of the list, shuffled: \u0026#34;; for(auto i: v) std::cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 总结：\n以value为起始值，填充以[first, last); 5.6 常用集合算法 学习目标：\n掌握常用的集合算法 算法简介：\nset_intersection // 求两个容器的交集 set_union // 求两个容器的并集 set_difference // 求两个容器的差集 5.6.1 set_intersection 功能描述：\n求两个容器的交集 函数原型：\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的交集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union 功能描述：\n求两个集合的并集 函数原型：\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的并集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference 功能描述：\n求两个集合的差集 函数原型：\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);\n// 求两个集合的差集\n// 注意:两个集合必须是有序序列\n// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器\n示例：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; class myPrint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector\u0026lt;int\u0026gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout \u0026lt;\u0026lt; \u0026#34;v1与v2的差集为： \u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v2与v1的差集为： \u0026#34; \u0026lt;\u0026lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置 5.7 常用比较算法 学习目标：\n掌握常用的比较算法 算法简介：\nmax // 求各给定值中的较大者 min // 求范围中的最大元素 equal // 求两个元素集合是否是相同的 5.7.1 max 功能描述：\n求各给定值中的较大者 函数原型：\nmax( const T\u0026amp; a, const T\u0026amp; b ); // 求各给定值中的较大者\n// a为第一个元素， b为第一个元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;larger of 1 and 9999: \u0026#34; \u0026lt;\u0026lt; std::max(1, 9999) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;larger of \u0026#39;a\u0026#39;, and \u0026#39;b\u0026#39;: \u0026#34; \u0026lt;\u0026lt; std::max(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;longest of \\\u0026#34;foo\\\u0026#34;, \\\u0026#34;bar\\\u0026#34;, and \\\u0026#34;hello\\\u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::max( { \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34; }, [](const std::string\u0026amp; s1, const std::string\u0026amp; s2) { return s1.size() \u0026lt; s2.size(); }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 总结：\n返回两个元素中最大的那一个 5.7.2 min 功能描述：\n求范围中的最小元素 函数原型：\nmin( const T\u0026amp; a, const T\u0026amp; b ); // 求范围中的最小元素\n// a为第一个元素， b为第一个元素\n示例：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;smaller of 1 and 9999 is \u0026#34; \u0026lt;\u0026lt; std::min(1, 9999) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;smaller of \u0026#39;a\u0026#39;, and \u0026#39;b\u0026#39; is \u0026#39;\u0026#34; \u0026lt;\u0026lt; std::min(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;shortest of \\\u0026#34;foo\\\u0026#34;, \\\u0026#34;bar\\\u0026#34;, and \\\u0026#34;hello\\\u0026#34; is \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; std::min({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34; }, [](const std::string_view s1, const std::string_view s2) { return s1.size() \u0026lt; s2.size(); }) \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } 总结：\n返回两个元素中最小的那一个 5.7.3 equal 功能描述：\n求两个容器的元素是否相等 函数原型：\nequal(iterator beg1, iterator end1, iterator beg2, iterator end2); // 求两个容器的元素是否相等\n// beg1为第一个迭代器，end2为第一个迭代器， beg2为第一个迭代器， end2为第一个迭代器，\n示例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; void test(const std::string\u0026amp; s) { if(std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin())) { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is a palindrome\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; is not a palindrome\\n\u0026#34;; } } int main() { test(\u0026#34;radar\u0026#34;); test(\u0026#34;hello\u0026#34;); } 总结：\n求两个容器的元素是否相等 ","date":"2022-01-23T19:49:07Z","permalink":"https://okokfun.github.io/post/c++/%E6%A8%A1%E6%9D%BF/","title":"模板"},{"content":" 由于大家都知道原因，国内使用github下载源码和Releases文件时都慢如龟速 下边根据我所使用的方法介绍几种方法\n1. 通过命令行克隆源码 通过添加.cnpmjs.org 在\ngit clone https://github.com/MistEO/MeoAssistantArknights.git 的.com后边添加.cnpmjs.org\ngit clone https://github.com.cnpmjs.org/MistEO/MeoAssistantArknights.git 通过替换为hub.fastgit.org 喜欢的话请他喝杯茶捐赠相关 | FastGit UK Document\n在\ngit clone https://github.com/MistEO/MeoAssistantArknights.git 中把github.com替换为hub.fastgit.org\ngit clone https://hub.fastgit.org/MistEO/MeoAssistantArknights.git 2. 通过浏览器下载资源 下载例如源码zip包，releases文件。\n下载源码zip包 把\nhttps://github.com/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 中的github.com替换为download.fastgit.org\nhttps://download.fastgit.org/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip 下载二进制releases文件 此为个人项目喜欢的话请他喝杯茶GitHub Proxy 代理加速 (ghproxy.com)\n通过添加https://ghproxy.com/ 把\nhttps://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip 在https://github添加https://ghproxy.com/\nhttps://ghproxy.com/https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip ","date":"2022-01-19T23:46:32Z","permalink":"https://okokfun.github.io/post/c++/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/","title":"github资源资源下载加速"},{"content":" 容器适配器提供顺序容器的不同接口\nstd::stack 定义于头文件 \u0026lt;stack\u0026gt; std::stack 类是容器适配器，它给予程序员栈的功能——特别是 FILO （先进后出）数据结构。\n该类模板表现为底层容器的包装器——只提供特定函数集合。栈从被称作栈顶的容器尾部推弹元素。\n元素访问 top 访问栈顶元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向栈顶插入元素 (公开成员函数) emplace(C++11) 在顶部原位构造元素 (公开成员函数) pop 删除栈顶元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::queue 适配一个容器以提供队列（FIFO 数据结构） 定义于头文件 \u0026lt;queue\u0026gt;\nstd::queue 类是容器适配器，它给予程序员队列的功能——尤其是 FIFO （先进先出）数据结构。\n类模板表现为底层容器的包装器——只提供特定的函数集合。 queue 在底层容器尾端推入元素，从首端弹出元素。\n元素访问 front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 向队列尾部插入元素 (公开成员函数) emplace(C++11) 在尾部原位构造元素 (公开成员函数) pop 删除首个元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) std::priority_queue 定义于头文件 \u0026lt;queue\u0026gt; priority_queue 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与释出。\n可用用户提供的 Compare 更改顺序，例如，用 std::greater 将导致最小元素作为 top() 出现。\n用 priority_queue 工作类似管理某些随机访问容器中的堆，优势是不可能突然把堆非法化。\n元素访问 top 访问栈顶元素 (公开成员函数) 容量 empty 检查底层容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) 修改器 push 插入元素，并对底层容器排序 (公开成员函数) emplace(C++11) 原位构造元素并排序底层容器 (公开成员函数) pop 删除队首元素 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) ","date":"2022-01-19T16:53:19Z","permalink":"https://okokfun.github.io/post/c++/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/","title":"容器适配器"},{"content":" 此文整理与👉容器库 - cppreference.com\n关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。\nstd::set 定义于头文件 \u0026lt;set\u0026gt;\nstd::set 是关联容器，含有 Key 类型对象的已排序集并去重。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。\n返回指向 set 首元素的迭代器。\n若 set 为空，则返回的迭代器将等于 end() 。\n返回值\n指向首元素的迭代器。\n复杂度 常数。\nstd::set\u0026lt;\u0026gt;::begin,std::set\u0026lt;\u0026gt;::cbegin #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; int main() { std::set\u0026lt;int\u0026gt; set = { 3, 1, 4, 1, 5, 9, 2, 6, 5 }; std::for_each(set.cbegin(), set.cend(), [](int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::set\u0026lt;Key,Compare,Allocator\u0026gt;::empty 检查容器是否无元素\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::size 返回容器中的元素数\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::clear 从容器擦除所有元素。此调用后 size() 返回零\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::insert 插入元素到容器，若容器未含拥有等价关键的元素。\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::emplace 若容器中无拥有该关键的元素，则插入以给定的 args 原位构造的新元素到容器。\n细心地使用 emplace 允许在构造新元素的同时避免不必要的复制或移动操作\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::erase 擦除元素\nstd::set\u0026lt;Key,Compare,Allocator\u0026gt;::find 寻找键等于 key 的的元素。\n#include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::set\u0026lt;int\u0026gt; numbers; std::cout \u0026lt;\u0026lt; \u0026#34;Initially, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; numbers.insert(13317); numbers.insert(3); numbers.insert(2); std::cout \u0026lt;\u0026lt; \u0026#34;After adding elements, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::for_each(numbers.cbegin(), numbers.cend(), [](int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); numbers.emplace(1); numbers.erase(1); uint32_t size = numbers.size(); std::cout \u0026lt;\u0026lt; \u0026#34;nums contains \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; elements.\\n\u0026#34;; auto search = numbers.find(2); if (search != numbers.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; (*search) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } numbers.clear(); return 0; } std::map 键值对的集合，按照键排序，键是唯一的\nstd::map 是有序键值对容器，它的元素的键是唯一的。\n用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。\nmap 通常实现为红黑树。\n元素访问\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::at 返回到拥有等于 key 的关键的元素被映射值的引用。\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::empty 检查容器是否为空\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::size 返回容纳的元素数\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::clear 清除内容\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::insert 插入元素或结点 (C++17 起)\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::insert_or_assign 插入元素，或若键已存在则赋值给当前元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::emplace 原位构造元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::emplace_hint 使用提示原位构造元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::try_emplace 若键不存在则原位插入，若键存在则不做任何事\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::erase 擦除元素\nstd::map\u0026lt;Key,T,Compare,Allocator\u0026gt;::find 寻找带有特定键的元素\nstd::erase_if (std::map) 擦除所有满足特定判别标准的元素\n#include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; int main(void) { std::map\u0026lt;int,int\u0026gt; numbers; numbers.emplace(42, 13); numbers.emplace_hint(41, 12); numbers.insert(std::make_pair(13317, 123)); std::cout \u0026lt;\u0026lt; \u0026#34;After adding elements, numbers.empty(): \u0026#34; \u0026lt;\u0026lt; numbers.empty() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;After elements, numbers.size(): \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; numbers.try_emplace(40, 10); numbers.erase(40); const auto count = std::erase_if(data, [](const auto\u0026amp; item) { auto const\u0026amp; [key, value] = item; return (key \u0026amp; 1) == 1; }); std::cout \u0026lt;\u0026lt; \u0026#34;Erase items with odd keys:\\n\u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; items removed.\\n\u0026#34;; myMap.insert_or_assign(\u0026#34;a\u0026#34;, \u0026#34;apple\u0026#34;); numbers.find(42); std::cout \u0026lt;\u0026lt; \u0026#34;After elements, numbers.clear(): \u0026#34; \u0026lt;\u0026lt; numbers.clear() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } std::multiset 键的集合，按照键排序\n迭代器 begin cbegin(C++11) 返回指向起始的迭代器 (公开成员函数) end cend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegin crbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rend crend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素或结点 (C++17 起) (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) emplace_hint(C++11) 使用提示原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) swap 交换内容 (公开成员函数) extract(C++17) 从另一容器释出结点 (公开成员函数) merge(C++17) 从另一容器接合结点 (公开成员函数) 查找 count 返回匹配特定键的元素数量 (公开成员函数) find 寻找带有特定键的元素 (公开成员函数) contains(C++20) 检查容器是否含有带特定键的元素 (公开成员函数) equal_range 返回匹配特定键的元素范围 (公开成员函数) lower_bound 返回指向首个不小于给定键的元素的迭代器 (公开成员函数) upper_bound 返回指向首个大于给定键的元素的迭代器 erase_if(std::multiset)(C++20) 擦除所有满足特定判别标准的元素 std::multimap 键值对的集合，按照键排序\n迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素或结点 (C++17 起) (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) emplace_hint(C++11) 使用提示原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) swap 交换内容 (公开成员函数) extract(C++17) 从另一容器释出结点 (公开成员函数) merge(C++17) 从另一容器接合结点 (公开成员函数) 查找 count 返回匹配特定键的元素数量 (公开成员函数) find 寻找带有特定键的元素 (公开成员函数) contains(C++20) 检查容器是否含有带特定键的元素 (公开成员函数) equal_range 返回匹配特定键的元素范围 (公开成员函数) lower_bound 返回指向首个不小于给定键的元素的迭代器 (公开成员函数) upper_bound 返回指向首个大于给定键的元素的迭代器 (公开成员函数) 观察器 key_comp 返回用于比较键的函数 (公开成员函数) value_comp 返回用于在value_type类型的对象中比较键的函数。 erase_if(std::multimap)(C++20) 擦除所有满足特定判别标准的元素 ","date":"2022-01-19T16:53:07Z","permalink":"https://okokfun.github.io/post/c++/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","title":"关联容器"},{"content":" 顺序容器实现能按顺序访问的数据结构。\nstd::array 静态的连续数组\n定义于头文件 \u0026lt;array\u0026gt;\nstd::array 是封装 固定大小数组 的容器。 隐式定义的成员函数 (构造函数)(隐式声明) 遵循聚合初始化的规则初始化 array （注意默认初始化可以导致非类的 T 的不确定值） (公开成员函数) (析构函数)(隐式声明) 销毁 array 的每个元素 (公开成员函数) operator=(隐式声明) 以来自另一 array 的每个元素重写 array 的对应元素 (公开成员函数) 元素访问 at(C++11) 访问指定的元素，同时进行越界检查 (公开成员函数) [operator](C++11) 访问指定的元素 (公开成员函数) front(C++11) 访问第一个元素 (公开成员函数) back(C++11) 访问最后一个元素 (公开成员函数) data(C++11) 直接访问底层数组 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty(C++11) 检查容器是否为空 (公开成员函数) size(C++11) 返回容纳的元素数 (公开成员函数) max_size(C++11) 返回可容纳的最大元素数 (公开成员函数) 操作 fill(C++11) 以指定值填充容器 (公开成员函数) swap(C++11) 交换内容 std::vector 定义于头文件 \u0026lt;vector\u0026gt;\nstd::vector 是封装 动态数组 的顺序容器。 at 访问指定的元素，同时进行越界检查 (公开成员函数) [operator] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) data 直接访问底层数组 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) reserve 预留存储空间 (公开成员函数) capacity 返回当前存储空间能够容纳的元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数 (构造函数) 构造 vector (公开成员函数) (析构函数) 析构 vector (公开成员函数) operator= 赋值给容器 (公开成员函数) assign 将值赋给容器 (公开成员函数) get_allocator 返回相关的分配器 (公开成员函数) 元素访问 at 访问指定的元素，同时进行越界检查 (公开成员函数) operator[] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) data 直接访问底层数组 (公开成员函数) 迭代器 begin cbegin(C++11) 返回指向起始的迭代器 (公开成员函数) end cend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegin crbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rend crend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) reserve 预留存储空间 (公开成员函数) capacity 返回当前存储空间能够容纳的元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数\nstd::swap(std::vector)(C++20) 特化std::swap 算法 (函数模板) erase(std::vector) erase_if(std::vector)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::deque 定义于头文件 双端队列\nstd::deque （ double-ended queue ，双端队列）是有 下标顺序容器，它允许在其首尾两端快速插入及删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。\n与 std::vector 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。\ndeque 的存储按需自动扩展及收缩。扩张 deque 比扩张 std::vector 更优，因为它不涉及到复制既存元素到新内存位置。另一方面， deque 典型地拥有较大的最小内存开销；只保有一个元素的 deque 必须分配其整个内部数组（例如 64 位 libstdc++ 上为对象大小 8 倍； 64 位 libc++ 上为对象大小 16 倍或 4096 字节的较大者）。\ndeque 上常见操作的复杂度（效率）如下：\n随机访问——常数 O(1) 在结尾或起始插入或移除元素——常数 O(1) 插入或移除元素——线性 O(n) 元素访问 at 访问指定的元素，同时进行越界检查 (公开成员函数) [operator] 访问指定的元素 (公开成员函数) front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) shrink_to_fit(C++11) 通过释放未使用的内存减少内存的使用 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) push_front 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front 移除首元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 非成员函数\nstd::swap(std::deque) 特化 std::swap 算法 (函数模板) erase(std::deque) erase_if(std::deque)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::forward_list 定义于头文件 \u0026lt;forward_list\u0026gt;\n单链表 std::forward_list 是支持从容器中的任何位置快速插入和移除元素的容器。不支持快速随机访问。它实现为单链表，且实质上与其在 C 中实现相比无任何开销。与 std::list 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。\n在链表内或跨数个链表添加、移除和移动元素，不会非法化当前指代链表中其他元素的迭代器。然而，在从链表移除元素（通过 erase_after ）时，指代对应元素的迭代器或引用会被非法化。\n元素访问 front(C++11) 访问第一个元素 (公开成员函数) 迭代器 before_begincbefore_begin(C++11) 返回指向第一个元素之前迭代器 (公开成员函数) begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) 容量 empty(C++11) 检查容器是否为空 (公开成员函数) max_size(C++11) 返回可容纳的最大元素数 (公开成员函数) 修改器 clear(C++11) 清除内容 (公开成员函数) insert_after(C++11) 在某个元素后插入新元素 (公开成员函数) emplace_after(C++11) 在元素后原位构造元素 (公开成员函数) erase_after(C++11) 擦除元素后的元素 (公开成员函数) push_front(C++11) 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front(C++11) 移除首元素 (公开成员函数) resize(C++11) 改变容器中可存储元素的个数 (公开成员函数) swap(C++11) 交换内容 (公开成员函数) 操作 merge(C++11) 合并二个已排序列表 (公开成员函数) splice_after(C++11) 从另一 forward_list 移动元素 (公开成员函数) removeremove_if(C++11) 移除满足特定标准的元素 (公开成员函数) reverse(C++11) 将该链表的所有元素的顺序反转 (公开成员函数) unique(C++11) 删除连续的重复元素 (公开成员函数) sort(C++11) 对元素进行排序 (公开成员函数) std::swap(std::forward_list)(C++11) 特化 std::swap 算法 (函数模板) erase(std::forward_list) erase_if(std::forward_list)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) std::list 定义于头文件 \u0026lt;list\u0026gt;\n双链表\nstd::list 是支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。与 std::forward_list 相比，此容器提供双向迭代但在空间上效率稍低。\n在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。\n元素访问 front 访问第一个元素 (公开成员函数) back 访问最后一个元素 (公开成员函数) 迭代器 begincbegin(C++11) 返回指向起始的迭代器 (公开成员函数) endcend(C++11) 返回指向末尾的迭代器 (公开成员函数) rbegincrbegin(C++11) 返回指向起始的逆向迭代器 (公开成员函数) rendcrend(C++11) 返回指向末尾的逆向迭代器 (公开成员函数) 容量 empty 检查容器是否为空 (公开成员函数) size 返回容纳的元素数 (公开成员函数) max_size 返回可容纳的最大元素数 (公开成员函数) 修改器 clear 清除内容 (公开成员函数) insert 插入元素 (公开成员函数) emplace(C++11) 原位构造元素 (公开成员函数) erase 擦除元素 (公开成员函数) push_back 将元素添加到容器末尾 (公开成员函数) emplace_back(C++11) 在容器末尾就地构造元素 (公开成员函数) pop_back 移除末元素 (公开成员函数) push_front 插入元素到容器起始 (公开成员函数) emplace_front(C++11) 在容器头部原位构造元素 (公开成员函数) pop_front 移除首元素 (公开成员函数) resize 改变容器中可存储元素的个数 (公开成员函数) swap 交换内容 (公开成员函数) 操作 merge 合并二个已排序列表 (公开成员函数) splice 从另一个list中移动元素 (公开成员函数) removeremove_if 移除满足特定标准的元素 (公开成员函数) reverse 将该链表的所有元素的顺序反转 (公开成员函数) unique 删除连续的重复元素 (公开成员函数) sort 对元素进行排序 (公开成员函数) std::swap(std::list) 特化 std::swap 算法 (函数模板) erase(std::list)erase_if(std::list)(C++20) 擦除所有满足特定判别标准的元素 (函数模板) ","date":"2022-01-19T16:52:52Z","permalink":"https://okokfun.github.io/post/c++/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","title":"顺序容器"},{"content":" 此文来源于👉日期和时间工具 - cppreference.com\n日期和时间工具 std::chrono 库 时钟 时长 时间点 时钟 system_clock(C++11) 来自系统范畴实时时钟的挂钟时间 (类) steady_clock(C++11) 决不会调整的单调时钟 (类) high_resolution_clock(C++11) 拥有可用的最短嘀嗒周期的时钟 (类) is_clockis_clock_v(C++20) 确定类型是否为时钟 (Clock) (类模板) (变量模板) utc_clock(C++20) 协调世界时 (UTC) 的时钟 (Clock) (类) tai_clock(C++20) 国际原子时 (TAI) 的时钟 (Clock) (类) gps_clock(C++20) GPS 时间的时钟 (Clock) (类) file_clock(C++20) 用于文件时间的时钟 (Clock) (typedef) local_t(C++20) 表示本地时间的伪时钟 时间点 时间点是从特定时钟的纪元开始经过的时间时长。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono time_point(C++11) 时间中的点 (类模板) clock_time_conversion(C++20) 定义如何转换一个时钟的时间点为另一个的特性类 (类模板) clock_cast(C++20) 转换一个时钟的时间点为另一个 (函数模板) 时长 时长由时间跨度组成，定义为某时间单位的某个计次数。例如，“ 42 秒”可表示为由 42 个 1 秒时间点位的计次所组成的时长。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono duration(C++11) 时间区间 (类模板) 当天时刻 hh_mm_ss 只要可能就将表示自午夜起经过时间的时长分割成时、分、秒和秒的小数部分。它主要是格式化工具。\n定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono hh_mm_ss(C++20) 表示当天时刻 (类模板) is_am is_pm make12 make24(C++20) 在 12 时和 24 时格式当天时刻之间翻译 (函数) 日历 定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono last_spec(C++20) 指示一个月中最后日期或星期的标签类 (类) day(C++20) 表示月之日期 (类) month(C++20) 表示年之月份 (类) year(C++20) 表示格里高利历中的年 (类) weekday(C++20) 表示格里高利历中星期之日 (类) weekday_indexed(C++20) 表示月份的第 n 个 weekday (类) weekday_last(C++20) 表示月份的最后一个 weekday (类) month_day(C++20) 表示特定 month 的特定 day (类) month_day_last(C++20) 表示特定 month 的最后一日 (类) month_weekday(C++20) 表示特定 month 的第 n 个 weekday (类) month_weekday_last(C++20) 表示特定 month 的最后一个 weekday (类) year_month(C++20) 表示特定 year 的特定 month (类) year_month_day(C++20) 表示特定的 year 、 month 和 day (类) year_month_day_last(C++20) 表示特定 year 和 month 的最后一日 (类) year_month_weekday(C++20) 表示特定 year 和 month 的第 n 个 weekday (类) year_month_weekday_last(C++20) 表示特定 year 和 month 的最后一个 weekday (类) operator/(C++20) 创建格里高利历日期的约定语法 (函数) 时区 定义于头文件 \u0026lt;chrono\u0026gt; 定义于命名空间 std::chrono tzdb(C++20) 描述 IANA 时区数据库的副本 (类) tzdb_list(C++20) 表示 tzdb 的链表 (类) get_tzdbget_tzdb_listreload_tzdbremote_version(C++20) 访问和控制全球时区数据库信息 (函数) locate_zone(C++20) 定位基于其名称的 time_zone (函数) current_zone(C++20) 返回当前的 time_zone (函数) time_zone(C++20) 表示时区 (类) sys_info(C++20) 表示在特定时间点的关于时区的信息 (类) local_info(C++20) 表示关于从本地时间转换到 UNIX 时间的信息 (类) choose(C++20) 选择应如何解析歧义的本地时间 (枚举) zoned_traits(C++20) zoned_time 所用的时区指针的特性类 (类模板) zoned_time(C++20) 表示时区和时间点 (类) leap_second(C++20) 含有关于插入闰秒的信息 (类) time_zone_link(C++20) 表示时区的替用名 (类) nonexistent_local_time(C++20) 抛出以报告本地时间不存在的异常 (类) ambiguous_local_time(C++20) 抛出以报告本地时间有歧义的异常 (类) 时钟 std::chrono::system_clock::now() 返回表示当前时间的时间点。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;chrono\u0026gt; volatile int sink; int main() { for (auto size = 1ull; size \u0026lt; 1000000000ull; size *= 100) { // 记录开始时间 auto start = std::chrono::system_clock::now(); // 做一些工作 std::vector\u0026lt;int\u0026gt; v(size, 42); sink = std::accumulate(v.begin(), v.end(), 0u); // 确保其副效应 // 记录结束时间 auto end = std::chrono::system_clock::now(); std::chrono::duration\u0026lt;double\u0026gt; diff = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Time to fill and iterate a vector of \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; ints : \u0026#34; \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34; s\\n\u0026#34;; } } std::chrono::steady_clock::now() 返回表示当前时间的时间点。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;chrono\u0026gt; volatile int sink; int main() { for (auto size = 1ull; size \u0026lt; 1000000000ull; size *= 100) { // 记录开始时间 auto start = std::chrono::steady_clock::now(); // 做一些工作 std::vector\u0026lt;int\u0026gt; v(size, 42); sink = std::accumulate(v.begin(), v.end(), 0u); // 确保其副效应 // 记录结束时间 auto end = std::chrono::steady_clock::now(); std::chrono::duration\u0026lt;double\u0026gt; diff = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Time to fill and iterate a vector of \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; \u0026#34; ints : \u0026#34; \u0026lt;\u0026lt; diff.count() \u0026lt;\u0026lt; \u0026#34; s\\n\u0026#34;; } } 对时长度量使用 steady_clock ，对壁钟时间使用 system_clock 。\nstd::chrono::utc_clock::now() 返回表示当前时间的时间点\nstd::chrono::tai_clock::now() 返回表示当前时间的时间点。\nstd::chrono::gps_clock::now() 返回表示当前时间的时间点。\nstd::chrono::file_clock::now() 返回表示当前时间的时间点。\n时间点 时间点是从特定时钟的纪元开始经过的时间时长。\nstd::chrono::time_point\u0026lt;std::chrono::system_clock\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;chrono\u0026gt; void slow_motion() { static int a[] {1,2,3,4,5,6,7,8,9,10,11,12}; while (std::ranges::next_permutation(a).found) { } // 生成 12! 个排列 } int main() { using namespace std::literals; // 允许用 24h 、 1ms 、 1s 代替对应的 // std::chrono::hours(24) 等待 const std::chrono::time_point\u0026lt;std::chrono::system_clock\u0026gt; now = std::chrono::system_clock::now(); // “生产代码”可以简化为： // const auto now = std::chrono::system_clock::now(); const std::time_t t_c = std::chrono::system_clock::to_time_t(now - 24h); std::cout \u0026lt;\u0026lt; \u0026#34;24 hours ago, the time was \u0026#34; \u0026lt;\u0026lt; std::put_time(std::localtime(\u0026amp;t_c), \u0026#34;%F %T.\\n\u0026#34;) \u0026lt;\u0026lt; std::flush; const std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; start = std::chrono::steady_clock::now(); // “现实生活”的替用写法会是： // const auto start = std::chrono::steady_clock::now(); slow_motion(); const auto end = std::chrono::steady_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;Slow calculations took \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34;µs ≈ \u0026#34; \u0026lt;\u0026lt; (end - start) / 1ms \u0026lt;\u0026lt; \u0026#34;ms ≈ \u0026#34; // 几乎等价于以上形式， \u0026lt;\u0026lt; (end - start) / 1s \u0026lt;\u0026lt; \u0026#34;s.\\n\u0026#34;; // 但分别使用毫秒和秒 } 时长 摘录自MSVC标准库\nusing nanoseconds = duration\u0026lt;long long, nano\u0026gt; 纳秒 std::chrono::nanoseconds using microseconds = duration\u0026lt;long long, micro\u0026gt; 微秒 std::chrono::microseconds using milliseconds = duration\u0026lt;long long, milli\u0026gt; 毫秒 std::chrono::milliseconds using seconds = duration 秒 std::chrono::seconds using minutes = duration\u0026lt;int, ratio\u0026lt;60\u0026raquo; 分钟 std::chrono::minutes using hours = duration\u0026lt;int, ratio\u0026lt;3600\u0026raquo; 小时 std::chrono::hours using days = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;24\u0026gt;, hours::period\u0026raquo; 天 std::chrono::days using weeks = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;7\u0026gt;, days::period\u0026raquo; 周 std::chrono::weeks using years = duration\u0026lt;int, ratio_multiply\u0026lt;ratio\u0026lt;146097, 400\u0026gt;, days::period\u0026raquo; 年 std::chrono::years using months = duration\u0026lt;int, ratio_divide\u0026lt;years::period, ratio\u0026lt;12\u0026raquo;\u0026gt; 月 std::chrono::months 注意：到 hours 为止的每个预定义时长类型至少涵盖 ±292 年的范围。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; constexpr auto year = 31556952ll; // 格里高利历年的平均秒数 int main() { using shakes = std::chrono::duration\u0026lt;int, std::ratio\u0026lt;1, 100000000\u0026gt;\u0026gt;; using jiffies = std::chrono::duration\u0026lt;int, std::centi\u0026gt;; using microfortnights = std::chrono::duration\u0026lt;float, std::ratio\u0026lt;14*24*60*60, 1000000\u0026gt;\u0026gt;; using nanocenturies = std::chrono::duration\u0026lt;float, std::ratio\u0026lt;100*year, 1000000000\u0026gt;\u0026gt;; std::chrono::seconds sec(1); std::cout \u0026lt;\u0026lt; \u0026#34;1 second is:\\n\u0026#34;; // 无精度损失的整数尺度转换：无转型 std::cout \u0026lt;\u0026lt; std::chrono::microseconds(sec).count() \u0026lt;\u0026lt; \u0026#34; microseconds\\n\u0026#34; \u0026lt;\u0026lt; shakes(sec).count() \u0026lt;\u0026lt; \u0026#34; shakes\\n\u0026#34; \u0026lt;\u0026lt; jiffies(sec).count() \u0026lt;\u0026lt; \u0026#34; jiffies\\n\u0026#34;; // 有精度损失的整数尺度转换：需要转型 std::cout \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::minutes\u0026gt;(sec).count() \u0026lt;\u0026lt; \u0026#34; minutes\\n\u0026#34;; // 浮点尺度转换：无转型 std::cout \u0026lt;\u0026lt; microfortnights(sec).count() \u0026lt;\u0026lt; \u0026#34; microfortnights\\n\u0026#34; \u0026lt;\u0026lt; nanocenturies(sec).count() \u0026lt;\u0026lt; \u0026#34; nanocenturies\\n\u0026#34;; } ","date":"2022-01-18T19:17:29Z","permalink":"https://okokfun.github.io/post/c++/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/","title":"日期和时间工具"},{"content":" 此文来自👉容器库 - cppreference.com\n容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作\n无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。\n1. std::unordered_set 唯一键的集合，按照键生成散列\nunordered_set 是含有 Key 类型唯一对象集合的关联容器。搜索、插入和移除拥有平均常数时间复杂度。\n在内部，元素并 不以任何特别顺序排序，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。\n不可修改容器元素（即使通过非 const 迭代器），因为修改可能 更改元素的哈希，并破坏容器。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_set\u0026gt; int main() { // 创建三个 string 的 unordered_set（映射到 string ） std::unordered_set\u0026lt;std::string\u0026gt; u = { \u0026#34;RED\u0026#34;, \u0026#34;GREEN\u0026#34;, \u0026#34;BLUE\u0026#34; }; // 迭代并打印 unordered_set 的关键和值 for (const auto \u0026amp;n : u) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // // 添加新入口到 unordered_set // \u0026#34;BLACK\u0026#34;; // \u0026#34;WHITE\u0026#34;; u.emplace(\u0026#34;BLACK\u0026#34;); u.emplace(\u0026#34;WHITE\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;-----------------------------------------------\\n\u0026#34;; for (const auto \u0026amp;n : u) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 用关键输出值 for (const auto \u0026amp;n : {\u0026#34;BLACK\u0026#34;, \u0026#34;WHITE\u0026#34;}) { if (u.find(n) != u.end()) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;: Found\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;NOT found\\n\u0026#34;; } } return 0; } 2. std::unordered_map 键值对的集合，按照键生成散列，键是唯一的\nunordered_map 是关联容器，含有带唯一键的键-值 pair 。搜索、插入和元素移除拥有平均常数时间复杂度。\n元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; int main() { // 创建三个 string 的 unordered_map （映射到 string ） std::unordered_map\u0026lt;std::string, std::string\u0026gt; u = { {\u0026#34;RED\u0026#34;,\u0026#34;#FF0000\u0026#34;}, {\u0026#34;GREEN\u0026#34;,\u0026#34;#00FF00\u0026#34;}, {\u0026#34;BLUE\u0026#34;,\u0026#34;#0000FF\u0026#34;} }; // 迭代并打印 unordered_map 的关键和值 for( const auto\u0026amp; n : u ) { std::cout \u0026lt;\u0026lt; \u0026#34;Key:[\u0026#34; \u0026lt;\u0026lt; n.first \u0026lt;\u0026lt; \u0026#34;] Value:[\u0026#34; \u0026lt;\u0026lt; n.second \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; } // 添加新入口到 unordered_map u[\u0026#34;BLACK\u0026#34;] = \u0026#34;#000000\u0026#34;; u[\u0026#34;WHITE\u0026#34;] = \u0026#34;#FFFFFF\u0026#34;; // 用关键输出值 std::cout \u0026lt;\u0026lt; \u0026#34;The HEX of color RED is:[\u0026#34; \u0026lt;\u0026lt; u[\u0026#34;RED\u0026#34;] \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;The HEX of color BLACK is:[\u0026#34; \u0026lt;\u0026lt; u[\u0026#34;BLACK\u0026#34;] \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;; return 0; } 3. std::unordered_multiset 键的集合，按照键生成散列\nunordered_multiset 是关联容器，含有可能非唯一 Key 类型对象的集合。搜索、插入和移除拥有平均常数时间复杂度。\n元素在内部并不以任何顺序排序，只是被组织到桶中。元素被放入哪个桶完全依赖其值的哈希。这允许快速访问单独的元素，因为一旦计算哈希，它就指代放置该元素的准确的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_set\u0026gt; int main() { // 简单比较演示 std::unordered_multiset\u0026lt;int\u0026gt; example = {1, 2, 3, 4}; auto search = example.find(2); if (search != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; (*search) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } return 0; } 4. std::unordered_multimap 键值对的集合，按照键生成散列\nunordered_multimap 是无序关联容器，支持等价的关键（一个 unordered_multimap 可含有每个关键值的多个副本）和将关键与另一类型的值关联。 unordered_multimap 类支持向前迭代器。搜索、插入和移除拥有平均常数时间复杂度。\n元素在内部不以任何特定顺序排序，而是组织到桶中。元素被放进哪个桶完全依赖于其关键的哈希。这允许到单独元素的快速访问，因为哈希一旦计算，则它指代元素被放进的准确的桶。\n例子 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; int main() { // 简单比较演示 std::unordered_multimap\u0026lt;int,char\u0026gt; example = {{1,\u0026#39;a\u0026#39;},{2,\u0026#39;b\u0026#39;}}; auto search = example.find(2); if (search != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; search-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; search-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } return 0; } ","date":"2022-01-18T16:54:33Z","permalink":"https://okokfun.github.io/post/c++/c-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/","title":"C++无序容器"},{"content":" 此文取自于👉动态内存管理 - cppreference.com\nstd::unique_ptr 拥有独有对象所有权语义的智能指针\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;functional\u0026gt; struct B { virtual void bar() { std::cout \u0026lt;\u0026lt; \u0026#34;B::bar\\n\u0026#34;; } virtual ~B() = default; }; struct D : B{ D() { std::cout \u0026lt;\u0026lt; \u0026#34;D::D\\n\u0026#34;; } ~D() { std::cout \u0026lt;\u0026lt; \u0026#34;D::~D\\n\u0026#34;; } void bar() override { std::cout \u0026lt;\u0026lt; \u0026#34;D::bar\\n\u0026#34;; } }; // 消费 unique_ptr 的函数能以值或以右值引用接收它 std::unique_ptr\u0026lt;D\u0026gt; pass_through(std::unique_ptr\u0026lt;D\u0026gt; p) { p-\u0026gt;bar(); return p; } void close_file(std::FILE* fp) { std::fclose(fp); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;unique ownership semantics demo\\n\u0026#34;; { auto p = std::make_unique\u0026lt;D\u0026gt;(); // p 是占有 D 的 unique_ptr auto q = pass_through(std::move(p)); assert(!p); // 现在 p 不占有任何内容并保有空指针 q-\u0026gt;bar(); // 而 q 占有 D 对象 } // ~D 调用于此 std::cout \u0026lt;\u0026lt; \u0026#34;Runtime polymorphism demo\\n\u0026#34;; { std::unique_ptr\u0026lt;B\u0026gt; p = std::make_unique\u0026lt;D\u0026gt;(); // p 是占有 D 的 unique_ptr // 作为指向基类的指针 p-\u0026gt;bar(); // 虚派发 std::vector\u0026lt;std::unique_ptr\u0026lt;B\u0026gt;\u0026gt; v; // unique_ptr 能存储于容器 v.push_back(std::make_unique\u0026lt;D\u0026gt;()); v.push_back(std::move(p)); v.emplace_back(new D); for(auto\u0026amp; p: v) p-\u0026gt;bar(); // 虚派发 } // ~D called 3 times std::cout \u0026lt;\u0026lt; \u0026#34;Custom deleter demo\\n\u0026#34;; std::ofstream(\u0026#34;demo.txt\u0026#34;) \u0026lt;\u0026lt; \u0026#39;x\u0026#39;; // 准备要读的文件 { std::unique_ptr\u0026lt;std::FILE, void (*)(std::FILE*) \u0026gt; fp(std::fopen(\u0026#34;demo.txt\u0026#34;, \u0026#34;r\u0026#34;), close_file); if(fp) // fopen 可以打开失败；该情况下 fp 保有空指针 std::cout \u0026lt;\u0026lt; (char)std::fgetc(fp.get()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // fclose() 调用于此，但仅若 FILE* 不是空指针 // （即 fopen 成功） std::cout \u0026lt;\u0026lt; \u0026#34;Custom lambda-expression deleter demo\\n\u0026#34;; { std::unique_ptr\u0026lt;D, std::function\u0026lt;void(D*)\u0026gt;\u0026gt; p(new D, [](D* ptr) { std::cout \u0026lt;\u0026lt; \u0026#34;destroying from a custom deleter...\\n\u0026#34;; delete ptr; }); // p 占有 D p-\u0026gt;bar(); } // 调用上述 lambda 并销毁 D std::cout \u0026lt;\u0026lt; \u0026#34;Array form of unique_ptr demo\\n\u0026#34;; { std::unique_ptr\u0026lt;D[]\u0026gt; p{new D[3]}; } // 调用 ~D 3 次 } std::shared_ptr 拥有共享对象所有权语义的智能指针\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Sample{ public: Sample() { std::cout \u0026lt;\u0026lt; \u0026#34;This is Sample.\u0026#34; \u0026lt;\u0026lt; std::endl; } void smartpointer() { std::cout \u0026lt;\u0026lt; \u0026#34;This is smartpointer.\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Sample() { std::cout \u0026lt;\u0026lt; \u0026#34;Destory Sample.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { auto pointer = std::make_shared\u0026lt;Sample\u0026gt;(); // pointer-\u0026gt;smartpointer(); // std::shared_ptr\u0026lt;Sample\u0026gt; sample1(new Sample()); std::shared_ptr\u0026lt;Sample\u0026gt; sample1 = pointer; sample1-\u0026gt;smartpointer(); std::shared_ptr\u0026lt;Sample\u0026gt; sample12(std::make_shared\u0026lt;Sample\u0026gt;()); sample12-\u0026gt;smartpointer(); return 0; } std::weak_ptr 到 std::shared_ptr 所管理对象的弱引用\nstd::weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少\nstd::shared_ptr依然存在着资源无法释放的问题，比如class A中有class B成员变量，class B中有class A成员变量，这种情况就存在引用计数不为0的问题。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; struct A; struct B; struct A { //std::shared_ptr\u0026lt;B\u0026gt; pointer; std::weak_ptr\u0026lt;B\u0026gt; ptr; std::shared_ptr\u0026lt;B\u0026gt; ptr_ = ptr.lock(); ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A 被销毁\u0026#34; \u0026lt;\u0026lt; std::endl; } }; struct B { //std::shared_ptr\u0026lt;A\u0026gt; pointer; std::weak_ptr\u0026lt;A\u0026gt; ptr; std::shared_ptr\u0026lt;A\u0026gt; ptr_ = ptr.lock(); ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;B 被销毁\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { auto a = std::make_shared\u0026lt;A\u0026gt;(); //std::weak_ptr\u0026lt;A\u0026gt; ptr_a(a); auto b = std::make_shared\u0026lt;B\u0026gt;(); //std::weak_ptr\u0026lt;B\u0026gt; ptr_b(b); a-\u0026gt;ptr = b; //a-\u0026gt;pointer = b; b-\u0026gt;ptr = a; //b-\u0026gt;pointer = a; } 结果： End.\n","date":"2022-01-18T13:20:39Z","permalink":"https://okokfun.github.io/post/c++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"动态内存管理"},{"content":" 此文来源于👉文件系统库 - cppreference.com，并整理。\n库范畴定义 文件：持有数据的文件系统对象，能被写入或读取，或二者皆可。文件拥有名称及属性，属性之一是文件类型： 目录：表现为目录条目的容器的文件，目录条目标识其他文件（其中一些可以是另外的嵌套的目录）。讨论到具体文件时，包含该文件目录条目的目录是其父目录。父目录能以相对路径名 \u0026ldquo;..\u0026rdquo; 表示。 硬链接：关联一个名字到一个既存文件的目录条目。若支持多重硬链接，则文件在最后一个到它的硬链接被移除后才被移除。 符号链接：关联一个名词到一个路径的目录条目，路径可以存在亦可不存在。 常规文件：不是其他文件类型的文件。 文件名：命名一个文件的字符串。容许字符、大小写区别、最大长度以及被禁止名称是实现定义的。名称 \u0026ldquo;.\u0026rdquo; （点）与 \u0026ldquo;..\u0026rdquo; （双点）在库层次拥有特殊含义。 路径：标识一个文件的元素序列。它以可选的 根名 （例如 Windows 上的 \u0026ldquo;C:\u0026rdquo; 或 \u0026ldquo;//server\u0026rdquo; ）开始，后随可选的 根目录 （例如 Unix 上的 \u0026ldquo;/\u0026rdquo; ），后随零或更多个文件名（除了最后一个都必须是目录或到目录的链接）的序列。表示路径的字符串（路径名）的原生格式（如哪些字符被用作分隔符）与字符编码是实现定义的，库提供路径的可移植表示。 绝对路径：无歧义地标识一个文件位置的路径。 规范路径：不包含符号链接、 \u0026ldquo;.\u0026rdquo; 或 \u0026ldquo;..\u0026rdquo; 元素的绝对路径。 相对路径：标识相对于文件系统中某位置的文件位置的路径。特殊路径名 \u0026ldquo;.\u0026rdquo; （点，“当前目录”）和 \u0026ldquo;..\u0026rdquo; （双点、“父目录”）是相对路径。 类 定义于头文件 \u0026lt;filesystem\u0026gt; 定义于命名空间 std::filesystem path(C++17) 表示路径 (类) filesystem_error(C++17) 文件系统错误时抛出的异常 (类) directory_entry(C++17) 目录条目 (类) directory_iterator(C++17) 指向目录内容的迭代器 (类) recursive_directory_iterator(C++17) 指向一个目录及其子目录的内容的迭代器 (类) file_status(C++17) 表示文件类型及权限 (类) space_info(C++17) 关于文件系统上空闲及可用空间的信息 (类) file_type(C++17) 文件的类型 (枚举) perms(C++17) 标识文件系统权限 (枚举) perm_options(C++17) 指定权限操作的语义 (枚举) copy_options(C++17) 指定复制操作的语义 (枚举) directory_options(C++17) 用于迭代目录内容的选项 (枚举) file_time_type(C++17) 表示文件时间值 (typedef) 非成员函数 定义于头文件 \u0026lt;filesystem\u0026gt; 定义于命名空间 std::filesystem absolute(C++17) 组成一个绝对路径 (函数) canonicalweakly_canonical(C++17) 组成一个规范路径 (函数) relativeproximate(C++17) 组成一个相对路径 (函数) copy(C++17) 复制文件或目录 (函数) copy_file(C++17) 复制文件内容 (函数) copy_symlink(C++17) 复制一个符号链接 (函数) create_directory create_directories(C++17)(C++17) 创建新目录 (函数) create_hard_link(C++17) 创建一个硬链接 (函数) create_symlink create_directory_symlink(C++17)(C++17) 创建一个符号链接 (函数) current_path(C++17) 返回或设置当前工作目录 (函数) exists(C++17) 检查路径是否指代既存的文件系统对象 (函数) equivalent(C++17) 检查两个路径是否指代同一文件系统对象 (函数) file_size(C++17) 返回文件的大小 (函数) hard_link_count(C++17) 返回指代特定文件的硬链接数 (函数) last_write_time(C++17) 获取或设置最近一次数据修改的时间 (函数) permissions(C++17) 修改文件访问权限 (函数) read_symlink(C++17) 获得符号链接的目标 (函数) remove remove_all(C++17)(C++17) 移除一个文件或空目录 移除一个文件或递归地移除一个目录及其所有内容 (函数) rename(C++17) 移动或重命名一个文件或目录 (函数) resize_file(C++17) 以截断或填充零更改一个常规文件的大小 (函数) space(C++17) 确定文件系统上的可用空闲空间 (函数) status symlink_status(C++17)(C++17) 确定文件属性 确定文件属性，检查符号链接目标 (函数) temp_directory_path(C++17) 返回一个适用于临时文件的目录 (函数) 文件类型 is_block_file(C++17) 检查给定的路径是否表示块设备 (函数) is_character_file(C++17) 检查给定的路径是否表示字符设备 (函数) is_directory(C++17) 检查给定的路径是否表示一个目录 (函数) is_empty(C++17) 检查给定的路径是否表示一个空文件或空目录 (函数) is_fifo(C++17) 检查给定的路径是否表示一个命名管道 (函数) is_other(C++17) 检查参数是否表示一个其他文件 (函数) is_regular_file(C++17) 检查参数是否表示一个常规文件 (函数) is_socket(C++17) 检查参数是否表示一个具名 IPC 套接字 (函数) is_symlink(C++17) 检查参数是否表示一个符号链接 (函数) status_known(C++17) 检查参数是否表示一个符号链接 (函数) ","date":"2022-01-16T15:16:11Z","permalink":"https://okokfun.github.io/post/c++/c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/","title":"C++文件系统库"},{"content":" 此文章来源于👉正则表达式库 - cppreference.com,并整理\n正则表达式库提供表示正则表达式的类，正则表达式是一种用于在字符串中匹配模式的微型语言。\n定义于头文件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string s = \u0026#34;Some people, when confronted with a problem, think \u0026#34; \u0026#34;\\\u0026#34;I know, I\u0026#39;ll use regular expressions.\\\u0026#34; \u0026#34; \u0026#34;Now they have two problems.\u0026#34;; std::regex self_regex(\u0026#34;REGULAR EXPRESSIONS\u0026#34;, std::regex_constants::ECMAScript | std::regex_constants::icase); if (std::regex_search(s, self_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;Text contains the phrase \u0026#39;regular expressions\u0026#39;\\n\u0026#34;; } std::regex word_regex(\u0026#34;(\\\\w+)\u0026#34;); auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex); auto words_end = std::sregex_iterator(); std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; std::distance(words_begin, words_end) \u0026lt;\u0026lt; \u0026#34; words\\n\u0026#34;; const int N = 6; std::cout \u0026lt;\u0026lt; \u0026#34;Words longer than \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; characters:\\n\u0026#34;; for (std::sregex_iterator i = words_begin; i != words_end; ++i) { std::smatch match = *i; std::string match_str = match.str(); if (match_str.size() \u0026gt; N) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; match_str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } std::regex long_word_regex(\u0026#34;(\\\\w{7,})\u0026#34;); std::string new_s = std::regex_replace(s, long_word_regex, \u0026#34;[$\u0026amp;]\u0026#34;); std::cout \u0026lt;\u0026lt; new_s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 算法 regex_match(C++11) 尝试匹配一个正则表达式到整个字符序列 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { // 简单正则表达式匹配 std::string fnames[] = {\u0026#34;foo.txt\u0026#34;, \u0026#34;bar.txt\u0026#34;, \u0026#34;baz.dat\u0026#34;, \u0026#34;zoidberg\u0026#34;}; std::regex txt_regex(\u0026#34;[a-z]+\\\\.txt\u0026#34;); for (const auto \u0026amp;fname : fnames) { std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::regex_match(fname, txt_regex) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 提取子匹配 std::regex base_regex(\u0026#34;([a-z]+)\\\\.txt\u0026#34;); std::smatch base_match; for (const auto \u0026amp;fname : fnames) { if (std::regex_match(fname, base_match, base_regex)) { // 首个 sub_match 是整个字符串；下个 // sub_match 是首个有括号表达式。 if (base_match.size() == 2) { std::ssub_match base_sub_match = base_match[1]; std::string base = base_sub_match.str(); std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#34; has a base of \u0026#34; \u0026lt;\u0026lt; base \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } // 提取几个子匹配 std::regex pieces_regex(\u0026#34;([a-z]+)\\\\.([a-z]+)\u0026#34;); std::smatch pieces_match; for (const auto \u0026amp;fname : fnames) { if (std::regex_match(fname, pieces_match, pieces_regex)) { std::cout \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (size_t i = 0; i \u0026lt; pieces_match.size(); ++i) { std::ssub_match sub_match = pieces_match[i]; std::string piece = sub_match.str(); std::cout \u0026lt;\u0026lt; \u0026#34; submatch \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; piece \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } } regex_search(C++11) 尝试匹配一个正则表达式到字符序列的任何部分 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string lines[] = {\u0026#34;Roses are #ff0000\u0026#34;, \u0026#34;violets are #0000ff\u0026#34;, \u0026#34;all of my base are belong to you\u0026#34;}; std::regex color_regex(\u0026#34;#([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34;); // 简单匹配 for (const auto \u0026amp;line : lines) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::regex_search(line, color_regex) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 展示每个匹配中有标记子表达式的内容 std::smatch color_match; for (const auto\u0026amp; line : lines) { if(std::regex_search(line, color_match, color_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;matches for \u0026#39;\u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Prefix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.prefix() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; for (size_t i = 0; i \u0026lt; color_match.size(); ++i) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; color_match[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Suffix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.suffix() \u0026lt;\u0026lt; \u0026#34;\\\u0026#39;\\n\\n\u0026#34;; } } // 重复搜索（参阅 std::regex_iterator ） std::string log(R\u0026#34;( Speed:\t366 Mass:\t35 Speed:\t378 Mass:\t32 Speed:\t400 Mass:\t30)\u0026#34;); std::regex r(R\u0026#34;(Speed:\\t\\d*)\u0026#34;); std::smatch sm; while(regex_search(log, sm, r)) { std::cout \u0026lt;\u0026lt; sm.str() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; log = sm.suffix(); } // C 风格字符串演示 std::cmatch cm; if(std::regex_search(\u0026#34;this is a test\u0026#34;, cm, std::regex(\u0026#34;test\u0026#34;))) std::cout \u0026lt;\u0026lt; \u0026#34;\\nFound \u0026#34; \u0026lt;\u0026lt; cm[0] \u0026lt;\u0026lt; \u0026#34; at position \u0026#34; \u0026lt;\u0026lt; cm.prefix().length(); } regex_replace(C++11) 以格式化的替换文本来替换正则表达式匹配的出现位置 (函数模板)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string text = \u0026#34;Quick brown fox\u0026#34;; std::regex vowel_re(\u0026#34;a|e|i|o|u\u0026#34;); // 写结果到输出迭代器 std::regex_replace(std::ostreambuf_iterator\u0026lt;char\u0026gt;(std::cout), text.begin(), text.end(), vowel_re, \u0026#34;*\u0026#34;); // 构造保有结果的字符串 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; std::regex_replace(text, vowel_re, \u0026#34;[$\u0026amp;]\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 迭代器 regex_iterator 用于遍历在序列中找到的匹配正则表达式的整个集合。\nregex_iterator(C++11) 迭代一个字符序列中的所有正则表达式匹配 (类模板)\n#include \u0026lt;regex\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { const std::string s = \u0026#34;Quick brown fox.\u0026#34;; std::regex words_regex(\u0026#34;[^\\\\s]+\u0026#34;); auto words_begin = std::sregex_iterator(s.begin(), s.end(), words_regex); auto words_end = std::sregex_iterator(); std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; std::distance(words_begin, words_end) \u0026lt;\u0026lt; \u0026#34; words:\\n\u0026#34;; for (std::sregex_iterator i = words_begin; i != words_end; ++i) { std::smatch match = *i; std::string match_str = match.str(); std::cout \u0026lt;\u0026lt; match_str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } regex_token_iterator(C++11) 迭代给定字符串中的所有正则表达式匹配中的指定子表达式，或迭代未匹配的子字符串 (类模板)\n#include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;regex\u0026gt; int main() { std::string text = \u0026#34;Quick brown fox.\u0026#34;; // 记号化（非匹配碎片） // 注意仅匹配二次 regex ：在获得第三值时迭代器为后缀迭代器。 std::regex ws_re(\u0026#34;\\\\s+\u0026#34;); // 空白符 std::copy( std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1), std::sregex_token_iterator(), std::ostream_iterator\u0026lt;std::string\u0026gt;(std::cout, \u0026#34;\\n\u0026#34;)); // 迭代首个子匹配 std::string html = \u0026#34;\u0026lt;p\u0026gt;\u0026lt;a href=\\\u0026#34;http://google.com\\\u0026#34;\u0026gt;google\u0026lt;/a\u0026gt; \u0026#34; \u0026#34;\u0026lt; a HREF =\\\u0026#34;http://cppreference.com\\\u0026#34;\u0026gt;cppreference\u0026lt;/a\u0026gt;\\n\u0026lt;/p\u0026gt;\u0026#34;; std::regex url_re(\u0026#34;\u0026lt;\\\\s*A\\\\s+[^\u0026gt;]*href\\\\s*=\\\\s*\\\u0026#34;([^\\\u0026#34;]*)\\\u0026#34;\u0026#34;, std::regex::icase); std::copy( std::sregex_token_iterator(html.begin(), html.end(), url_re, 1), std::sregex_token_iterator(), std::ostream_iterator\u0026lt;std::string\u0026gt;(std::cout, \u0026#34;\\n\u0026#34;)); } ","date":"2022-01-16T14:45:25Z","permalink":"https://okokfun.github.io/post/c++/c-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"C++正则表达式"},{"content":" 此文来自于👉线程支持库 - cppreference.com\n线程支持库 thread(C++11) std::thread 类与支持函数 stop_token(C++20) std::jthread 的停止记号 mutex(C++11) 互斥元件 shared_mutex(C++14) 共享互斥元件 future(C++11) 异步计算元件 condition_variable(C++11) 线程等待条件 semaphore(C++20) 信号量 latch(C++20) 闩 barrier(C++20) 屏障 #include \u0026lt;thread\u0026gt; std::thread thread类 表示单个执行线程。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { std::thread th1; } std:🧵:id thread::id类 是轻量的可频繁复制类，它作为 std::thread 对象的唯一标识符工作。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; typedef unsigned long long ULL; std::string getThreadIdOfString(const std:🧵:id \u0026amp; id) { std::stringstream sin; sin \u0026lt;\u0026lt; id; return sin.str(); } ULL getThreadIdOfULL(const std:🧵:id \u0026amp; id) { return std::stoull(getThreadIdOfString(id)); } int main() { std:🧵:id id = std::this_thread::get_id(); std::cout \u0026lt;\u0026lt; \u0026#34;cout ----- id : \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;getThreadIdOfString ----- id : \u0026#34; \u0026lt;\u0026lt; getThreadIdOfString(id) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;getThreadIdOfULL ----- id : \u0026#34; \u0026lt;\u0026lt; getThreadIdOfULL(id) \u0026lt;\u0026lt; std::endl; return 0; } std:🧵:hardware_concurrency() 返回处理器支持的并发线程数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { unsigned int n = std:🧵:hardware_concurrency(); std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; concurrent threads are supported.\\n\u0026#34;; return 0; } std:🧵:native_handle() 返回实现定义的底层线程柄。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;pthread.h\u0026gt; std::mutex iomutex; void f(int num) { std::this_thread::sleep_for(std::chrono::seconds(1)); sched_param sch; int policy; pthread_getschedparam(pthread_self(), \u0026amp;policy, \u0026amp;sch); std::lock_guard\u0026lt;std::mutex\u0026gt; lk(iomutex); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; is executing at priority \u0026#34; \u0026lt;\u0026lt; sch.sched_priority \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::thread t1(f, 1), t2(f, 2); sched_param sch; int policy; pthread_getschedparam(t1.native_handle(), \u0026amp;policy, \u0026amp;sch); sch.sched_priority = 20; if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, \u0026amp;sch)) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to setschedparam: \u0026#34; \u0026lt;\u0026lt; std::strerror(errno) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } t1.join(); t2.join(); return 0; } std:🧵:join() 等待线程完成其执行\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void foo() { // 模拟耗费大量资源的操作 std::this_thread::sleep_for(std::chrono::seconds(1)); } void bar() { // 模拟耗费大量资源的操作 std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;starting first helper...\\n\u0026#34;; std::thread helper1(foo); std::cout \u0026lt;\u0026lt; \u0026#34;starting second helper...\\n\u0026#34;; std::thread helper2(bar); std::cout \u0026lt;\u0026lt; \u0026#34;waiting for helpers to finish...\u0026#34; \u0026lt;\u0026lt; std::endl; helper1.join(); helper2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;done!\\n\u0026#34;; return 0; } std:🧵:detach() 容许线程从线程句柄独立开来执行\n从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; void independentThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Starting concurrent thread.\\n\u0026#34;; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Exiting concurrent thread.\\n\u0026#34;; } void threadCaller() { std::cout \u0026lt;\u0026lt; \u0026#34;Starting thread caller.\\n\u0026#34;; std::thread t(independentThread); t.detach(); std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Exiting thread caller.\\n\u0026#34;; } int main() { threadCaller(); std::this_thread::sleep_for(std::chrono::seconds(5)); return 0; } std:🧵:swap 交换二个 thread 对象的底层柄。\n交换二个 thread 对象\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void foo() { std::this_thread::sleep_for(std::chrono::seconds(1)); } void bar() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::thread t1(foo); std::thread t2(bar); std::cout \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::swap(t1, t2); std::cout \u0026lt;\u0026lt; \u0026#34;after std::swap(t1, t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t1.swap(t2); std::cout \u0026lt;\u0026lt; \u0026#34;after t1.swap(t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t1.join(); t2.join(); return 0; } std::this_thread::yield() 建议实现重新调度各执行线程\n提供提示给实现，以重调度线程的执行，允许其他线程运行\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; // 建议其他线程运行一小段时间的“忙睡眠” void little_sleep(std::chrono::microseconds us) { auto start = std::chrono::high_resolution_clock::now(); auto end = start + us; do { std::this_thread::yield(); } while (std::chrono::high_resolution_clock::now() \u0026lt; end); } int main() { auto start = std::chrono::high_resolution_clock::now(); little_sleep(std::chrono::microseconds(100)); auto elapsed = std::chrono::high_resolution_clock::now() - start; std::cout \u0026lt;\u0026lt; \u0026#34;waited for \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(elapsed).count() \u0026lt;\u0026lt; \u0026#34; microseconds\\n\u0026#34;; return 0; } std::this_thread::get_id() 返回当前线程的线程 id\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex g_display_mutex; void foo() { std:🧵:id this_id = std::this_thread::get_id(); g_display_mutex.lock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; this_id \u0026lt;\u0026lt; \u0026#34; sleeping...\\n\u0026#34;; g_display_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { std::thread t1(foo); std::thread t2(foo); t1.join(); t2.join(); return 0; } std::this_thread::sleep_for() 使当前线程的执行停止指定的时间段\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; int main() { using namespace std::chrono_literals; std::cout \u0026lt;\u0026lt; \u0026#34;Hello waiter\\n\u0026#34; \u0026lt;\u0026lt; std::flush; auto start = std::chrono::high_resolution_clock::now(); std::this_thread::sleep_for(2000ms); auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; elapsed = end-start; std::cout \u0026lt;\u0026lt; \u0026#34;Waited \u0026#34; \u0026lt;\u0026lt; elapsed.count() \u0026lt;\u0026lt; \u0026#34; ms\\n\u0026#34;; return 0; } std::this_thread::sleep_until() 使当前线程的执行停止直到指定的时间点\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;thread\u0026gt; #pragma warning(disable:4996)//加上可去掉unsafe 请使用localtime_s的编译报错 int main() { using std::chrono::system_clock; std::time_t tt = system_clock::to_time_t(system_clock::now()); struct std::tm *ptm = std::localtime(\u0026amp;tt); std::cout \u0026lt;\u0026lt; \u0026#34;Current time: \u0026#34; \u0026lt;\u0026lt; std::put_time(ptm, \u0026#34;%X\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //必须大写X，若小写x，输出的为日期 std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for the next minute to begin...\\n\u0026#34;; ++ptm-\u0026gt;tm_min; ptm-\u0026gt;tm_sec = 0; std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm))); std::cout \u0026lt;\u0026lt; std::put_time(ptm, \u0026#34;%X\u0026#34;) \u0026lt;\u0026lt; \u0026#34;reached!\\n\u0026#34;; return 0; } 互斥 #include \u0026lt;mutex\u0026gt; std::mutex::lock() 锁定互斥。若另一线程已锁定互斥，则到 lock 的调用将阻塞执行，直至获得锁。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::mutex::try_lock() 尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (mutex.try_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; mutex.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::mutex::unlock() 解锁互斥\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex timed_mutex 类是能用于保护数据免受多个线程同时访问的同步原语。\nstd::timed_mutex::lock() 锁定互斥。若另一线程已锁定互斥，则到 lock 的调用将阻塞执行，直至获得锁。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex::unlock() 解锁互斥。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; int g_num = 0; // 为 g_num_mutex 所保护 std::mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; g_num_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); } } int main() { std::thread t1(slow_increment, 0); std::thread t2(slow_increment, 1); t1.join(); t2.join(); } std::timed_mutex::try_lock() 尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。\nstd::timed_mutex::try_lock_for() 尝试锁定互斥，若互斥在指定的时限时期中不可用则返回\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;sstream\u0026gt; std::mutex cout_mutex; // 控制到 std::cout 的访问 std::timed_mutex mutex; void job(int id) { using Ms = std::chrono::milliseconds; std::ostringstream stream; for (int i = 0; i \u0026lt; 3; ++i) { if (mutex.try_lock_for(Ms(100))) { stream \u0026lt;\u0026lt; \u0026#34;success \u0026#34;; std::this_thread::sleep_for(Ms(100)); mutex.unlock(); } else { stream \u0026lt;\u0026lt; \u0026#34;failed \u0026#34;; } std::this_thread::sleep_for(Ms(100)); } std::lock_guard\u0026lt;std::mutex\u0026gt; lock(cout_mutex); std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;] \u0026#34; \u0026lt;\u0026lt; stream.str() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; for (int i = 0; i \u0026lt; 4; ++i) { threads.emplace_back(job, i); } for (auto\u0026amp; i: threads) { i.join(); } } std::timed_mutex::try_lock_until() 尝试锁定互斥，若直至抵达指定时间点互斥不可用则返回\n尝试所互斥。阻塞直至抵达指定的 timeout_time 或得到锁，取决于何者先到来。成功获得锁时返回 true ，否则返回 false 。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; std::timed_mutex test_mutex; void f() { auto now=std::chrono::steady_clock::now(); test_mutex.try_lock_until(now + std::chrono::seconds(10)); std::cout \u0026lt;\u0026lt; \u0026#34;hello world\\n\u0026#34;; } int main() { std::lock_guard\u0026lt;std::timed_mutex\u0026gt; l(test_mutex); std::thread t(f); t.join(); return 0; } std::lock_guard\u0026lt;std::mutex\u0026gt; 实现严格基于作用域的互斥体所有权包装器\n创建 lock_guard 对象时，它试图接收给定互斥的所有权。控制离开创建 lock_guard 对象的作用域时，销毁 lock_guard 并释放互斥。\nlock_guard 类不可复制。\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; int g_i = 0; std::mutex g_i_mutex; // 保护 g_i void safe_increment() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(g_i_mutex); ++g_i; std::cout \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // g_i_mutex 在锁离开作用域时自动释放 } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;main: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::thread t1(safe_increment); std::thread t2(safe_increment); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;main: \u0026#34; \u0026lt;\u0026lt; g_i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } std::unique_lock\u0026lt;Mutex\u0026gt;::lock 等效地调用 mutex()-\u0026gt;lock()\n#include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { int counter = 0; std::mutex counter_mutex; std::vector\u0026lt;std::thread\u0026gt; threads; auto worker_task = [\u0026amp;](int id) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(counter_mutex); ++counter; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, initial counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; lock.unlock(); // 我们模拟昂贵操作时不保有锁 std::this_thread::sleep_for(std::chrono::seconds(1)); lock.lock(); // 可以不解锁，因为是智能锁 ++counter; std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, final counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; for (int i = 0; i \u0026lt; 10; ++i) threads.emplace_back(worker_task, i); for (auto \u0026amp;thread : threads) thread.join(); return 0; } std::unique_lock\u0026lt;std::mutex\u0026gt; 类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用\n类 unique_lock 可移动，但不可复制\n#include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; struct Box { explicit Box(int num) : num_things{num} {} int num_things; std::mutex m; }; void transfer(Box \u0026amp;from, Box \u0026amp;to, int num) { // 仍未实际取锁 std::unique_lock\u0026lt;std::mutex\u0026gt; lock1(from.m, std::defer_lock); std::unique_lock\u0026lt;std::mutex\u0026gt; lock2(to.m, std::defer_lock); // 锁两个 unique_lock 而不死锁 std::lock(lock1, lock2); from.num_things -= num; to.num_things += num; // \u0026#39;from.m\u0026#39; 与 \u0026#39;to.m\u0026#39; 互斥解锁于 \u0026#39;unique_lock\u0026#39; 析构函数 } int main() { Box acc1(100); Box acc2(50); std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10); std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5); t1.join(); t2.join(); return 0; } std::unique_lock\u0026lt;Mutex\u0026gt;::try_lock 尝试锁定关联互斥，若互斥不可用则返回\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (std::unique_lock\u0026lt;std::mutex\u0026gt;::try_lock lk(mutex)) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; lk.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::unique_lock\u0026lt;Mutex\u0026gt;::try_lock_for 试图锁定关联的可定时锁定 (TimedLockable) 互斥，若互斥在给定时长中不可用则返回\nbool try_lock_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration );\ntimeout_duration - 要阻塞的最大时长\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // std::cout std::chrono::milliseconds interval(100); std::mutex mutex; int job_shared = 0; // 两个线程都能修改 \u0026#39;job_shared\u0026#39;, // mutex 将保护此变量 int job_exclusive = 0; // 只有一个线程能修改 \u0026#39;job_exclusive\u0026#39; // 不需要保护 // 此线程能修改 \u0026#39;job_shared\u0026#39; 和 \u0026#39;job_exclusive\u0026#39; void job_1() { std::this_thread::sleep_for(interval); // 令 \u0026#39;job_2\u0026#39; 持锁 while (true) { // 尝试锁定 mutex 以修改 \u0026#39;job_shared\u0026#39; if (std::unique_lock\u0026lt;std::mutex\u0026gt;::try_lock_for lk(mutex)) { std::cout \u0026lt;\u0026lt; \u0026#34;job shared (\u0026#34; \u0026lt;\u0026lt; job_shared \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; lk.unlock(); return; } else { // 不能获取锁以修改 \u0026#39;job_shared\u0026#39; // 但有其他工作可做 ++job_exclusive; std::cout \u0026lt;\u0026lt; \u0026#34;job exclusive (\u0026#34; \u0026lt;\u0026lt; job_exclusive \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::this_thread::sleep_for(interval); } } } // 此线程只能修改 \u0026#39;job_shared\u0026#39; void job_2() { mutex.lock(); std::this_thread::sleep_for(5 * interval); ++job_shared; mutex.unlock(); } int main() { std::thread thread_1(job_1); std::thread thread_2(job_2); thread_1.join(); thread_2.join(); } std::call_once 仅调用函数一次，即使从多个线程调用\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::once_flag flag1, flag2; void simple_do_once() { std::call_once(flag1, [](){ std::cout \u0026lt;\u0026lt; \u0026#34;Simple example: called once\\n\u0026#34;; }); } void may_throw_function(bool do_throw) { if (do_throw) { std::cout \u0026lt;\u0026lt; \u0026#34;throw: call_once will retry\\n\u0026#34;; // 这会出现多于一次 throw std::exception(); } std::cout \u0026lt;\u0026lt; \u0026#34;Didn\u0026#39;t throw, call_once will not attempt again\\n\u0026#34;; // 保证一次 } void do_once(bool do_throw) { try { std::call_once(flag2, may_throw_function, do_throw); } catch (...) { } } int main() { std::thread st1(simple_do_once); std::thread st2(simple_do_once); std::thread st3(simple_do_once); std::thread st4(simple_do_once); st1.join(); st2.join(); st3.join(); st4.join(); std::thread t1(do_once, true); std::thread t2(do_once, true); std::thread t3(do_once, false); std::thread t4(do_once, true); t1.join(); t2.join(); t3.join(); t4.join(); return 0; } 结果\nSimple example: called once throw: call_once will retry 条件变量 条件变量是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥。\n定义于头文件 \u0026lt;condition_variable\u0026gt;\nstd::condition_variable 提供与 std::unique_lock 关联的条件变量\ncondition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex m; std::condition_variable cv; std::string data; bool ready = false; bool processed = false; void worker_thread() { // 等待直至 main() 发送数据 std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m); cv.wait(lk, []{return ready;}); // 等待后，我们占有锁。 std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is processing data\\n\u0026#34;; data += \u0026#34; after processing\u0026#34;; // 发送数据回 main() processed = true; std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread signals data processing completed\\n\u0026#34;; // 通知前完成手动解锁，以避免等待线程才被唤醒就阻塞（细节见 notify_one ） lk.unlock(); cv.notify_one(); } int main() { std::thread worker(worker_thread); data = \u0026#34;Example data\u0026#34;; // 发送数据到 worker 线程 { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); ready = true; std::cout \u0026lt;\u0026lt; \u0026#34;main() signals data ready for processing\\n\u0026#34;; } cv.notify_one(); // 等候 worker { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m); cv.wait(lk, []{return processed;}); } std::cout \u0026lt;\u0026lt; \u0026#34;Back in main(), data = \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker.join(); } std::condition_variable::notify_all() 解阻塞全部当前等待于 *this 的线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; // 此互斥用于三个目的： // 1) 同步到 i 的访问 // 2) 同步到 std::cerr 的访问 // 3) 为条件变量 cv int i = 0; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cerr \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; } cv.notify_all(); std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; } cv.notify_all(); } int main() { std::thread t1(waits), t2(waits), t3(waits), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } std::condition_variable::notify_one() 若任何线程在 *this 上等待，则调用 notify_one 会解除一个阻塞等待线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; int i = 0; bool done = false; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cout \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; done = true; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Notifying falsely...\\n\u0026#34;; cv.notify_one(); // 等待线程被通知 i == 0. // cv.wait 唤醒，检查 i ，再回到等待 std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; while (!done) { std::cout \u0026lt;\u0026lt; \u0026#34;Notifying true change...\\n\u0026#34;; lk.unlock(); cv.notify_one(); // 等待线程被通知 i == 1 ， cv.wait 返回 std::this_thread::sleep_for(std::chrono::seconds(1)); lk.lock(); } } int main() { std::thread t1(waits), t2(signals); t1.join(); t2.join(); } std::condition_variable::wait() wait 导致当前线程阻塞直至条件变量被通知，或虚假唤醒发生，可选地循环直至满足某谓词。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; // 此互斥用于三个目的： // 1) 同步到 i 的访问 // 2) 同步到 std::cerr 的访问 // 3) 为条件变量 cv int i = 0; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cerr \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; } cv.notify_all(); std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; } cv.notify_all(); } int main() { std::thread t1(waits), t2(waits), t3(waits), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } std::condition_variable::wait_for() 阻塞当前线程，直到条件变量被唤醒，或到指定时限时长后\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std::chrono_literals; std::condition_variable cv; std::mutex cv_m; std::atomic\u0026lt;int\u0026gt; i{0}; void waits(int idx) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); auto now = std::chrono::system_clock::now(); if(cv.wait_until(lk, now + idx*100ms, [](){return i == 1;})) std::cerr \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; finished waiting. i == \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cerr \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; timed out. i == \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void signals() { std::this_thread::sleep_for(120ms); std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying...\\n\u0026#34;; cv.notify_all(); std::this_thread::sleep_for(100ms); i = 1; std::cerr \u0026lt;\u0026lt; \u0026#34;Notifying again...\\n\u0026#34;; cv.notify_all(); } int main() { std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals); t1.join(); t2.join(); t3.join(); t4.join(); } 信号量 信号量 (semaphore) 是一种轻量的同步原件，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率。\n定义于头文件 \u0026lt;semaphore\u0026gt;\nstd::counting_semaphore, std::binary_semaphore \\1) counting_semaphore 是一个轻量同步元件，能控制对共享资源的访问。\n\\2) binary_semaphore 是 std::counting_semaphore 的特化的别名，其 LeastMaxValue 为 1 。实现可能将 binary_semaphore 实现得比 std::counting_semaphore 的默认实现更高效。\nstd::counting_semaphore #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;semaphore\u0026gt; using namespace std::literals; // 全局二元信号量实例 // 设置对象计数为零 // 对象在未被发信状态 std::binary_semaphore smphSignal(0); void ThreadProc() { // 通过尝试减少信号量的计数等待来自主程序的信号 smphSignal.acquire(); // 此调用阻塞直至信号量的计数被从主程序增加 std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Got the signal\u0026#34; \u0026lt;\u0026lt; std::endl; // 回应消息 // 等待 3 秒以模仿某种线程正在进行的工作 std::this_thread::sleep_for(3s); std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Send the signal\\n\u0026#34;; // 消息 // 对主程序回复发信 smphSignal.release(); } int main() { // 创建某个背景工作线程，它将长期存在 std::jthread thrWorker(ThreadProc); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Send the signal\\n\u0026#34;; // 消息 // 通过增加信号量的计数对工作线程发信以开始工作 smphSignal.release(); // release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟： std::this_thread::sleep_for(50ms); // 通过试图减少信号量的计数等待直至工作线程完成工作 smphSignal.acquire(); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Got the signal\\n\u0026#34;; // 回应消息 } std::binary_semaphore #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;semaphore\u0026gt; using namespace std::literals; // 全局二元信号量实例 // 设置对象计数为零 // 对象在未被发信状态 std::binary_semaphore smphSignal(0); void ThreadProc() { // 通过尝试减少信号量的计数等待来自主程序的信号 smphSignal.acquire(); // 此调用阻塞直至信号量的计数被从主程序增加 std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Got the signal\u0026#34; \u0026lt;\u0026lt; std::endl; // 回应消息 // 等待 3 秒以模仿某种线程正在进行的工作 std::this_thread::sleep_for(3s); std::cout \u0026lt;\u0026lt; \u0026#34;[thread] Send the signal\\n\u0026#34;; // 消息 // 对主程序回复发信 smphSignal.release(); } int main() { // 创建某个背景工作线程，它将长期存在 std::jthread thrWorker(ThreadProc); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Send the signal\\n\u0026#34;; // 消息 // 通过增加信号量的计数对工作线程发信以开始工作 smphSignal.release(); // release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟： std::this_thread::sleep_for(50ms); // 通过试图减少信号量的计数等待直至工作线程完成工作 smphSignal.acquire(); std::cout \u0026lt;\u0026lt; \u0026#34;[main] Got the signal\\n\u0026#34;; // 回应消息 } Future 标准库提供了一些工具来获取异步任务（即在单独的线程中启动的函数）的返回值，并捕捉其所抛出的异常。这些值在共享状态中传递，其中异步任务可以写入其返回值或存储异常，而且可以由持有该引用该共享态的 std::future 或 std::shared_future 实例的线程检验、等待或是操作这个状态。\n定义于头文件 \u0026lt;future\u0026gt;\n异步线程 Classes 承诺 std::promise 允诺结果\nstd::promise\u0026lt;T\u0026gt; std::promise\u0026lt;T\u0026gt;::set_value() std::promise\u0026lt;T\u0026gt;::get_future() #include \u0026lt;vector\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; void accumulate(std::vector\u0026lt;int\u0026gt;::iterator first, std::vector\u0026lt;int\u0026gt;::iterator last, std::promise\u0026lt;int\u0026gt; accumulate_promise) { int sum = std::accumulate(first, last, 0); accumulate_promise.set_value(sum); // Notify future } void do_work(std::promise\u0026lt;void\u0026gt; barrier) { std::this_thread::sleep_for(std::chrono::seconds(1)); barrier.set_value(); } int main() { // Demonstrate using promise\u0026lt;int\u0026gt; to transmit a result between threads. std::vector\u0026lt;int\u0026gt; numbers = { 1, 2, 3, 4, 5, 6 }; std::promise\u0026lt;int\u0026gt; accumulate_promise; std::future\u0026lt;int\u0026gt; accumulate_future = accumulate_promise.get_future(); std::thread work_thread(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise)); accumulate_future.wait(); // wait for result std::cout \u0026lt;\u0026lt; \u0026#34;result=\u0026#34; \u0026lt;\u0026lt; accumulate_future.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; work_thread.join(); // wait for thread completion // Demonstrate using promise\u0026lt;void\u0026gt; to signal state between threads. std::promise\u0026lt;void\u0026gt; barrier; std::future\u0026lt;void\u0026gt; barrier_future = barrier.get_future(); std::thread new_work_thread(do_work, std::move(barrier)); barrier_future.wait(); new_work_thread.join(); } std::packaged_task template\u0026lt; class R, class ...Args \u0026gt; class packaged_task\u0026lt;R(Args...)\u0026gt;; std::packaged_task\u0026lt;R(Args...)\u0026gt;::get_future std::packaged_task\u0026lt;R(Args...)\u0026gt;::reset 类模板包装任何可调用目标（函数、lambda 表达式、绑定表达式或其他函数对象），以便可以异步调用它。其返回值或引发的异常存储在可通过对象访问的共享状态中。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;functional\u0026gt; // unique function to avoid disambiguating the std::pow overload set int f(int x, int y) { return std::pow(x,y); } void task_lambda() { std::packaged_task\u0026lt;int(int,int)\u0026gt; task([](int a, int b) { return std::pow(a, b); }); std::future\u0026lt;int\u0026gt; result = task.get_future(); task(2, 9); std::cout \u0026lt;\u0026lt; \u0026#34;task_lambda:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void task_bind() { std::packaged_task\u0026lt;int()\u0026gt; task(std::bind(f, 2, 11)); std::future\u0026lt;int\u0026gt; result = task.get_future(); task(); std::cout \u0026lt;\u0026lt; \u0026#34;task_bind:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void task_thread() { std::packaged_task\u0026lt;int(int,int)\u0026gt; task(f); std::future\u0026lt;int\u0026gt; result = task.get_future(); std::thread task_td(std::move(task), 2, 10); task_td.join(); std::cout \u0026lt;\u0026lt; \u0026#34;task_thread:\\t\u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { task_lambda(); task_bind(); task_thread(); } 未来 std::future 等待一个值\nstd::future\u0026lt;T\u0026amp;\u0026gt; std::future\u0026lt;T\u0026amp;\u0026gt;::get() std::future\u0026lt;T\u0026amp;\u0026gt;::wait() #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; int main() { // future from a packaged_task std::packaged_task\u0026lt;int()\u0026gt; task([]{ return 7; }); // wrap the function std::future\u0026lt;int\u0026gt; f1 = task.get_future(); // get a future std::thread t(std::move(task)); // launch on a thread // future from an async() std::future\u0026lt;int\u0026gt; f2 = std::async(std::launch::async, []{ return 8; }); // future from a promise std::promise\u0026lt;int\u0026gt; p; std::future\u0026lt;int\u0026gt; f3 = p.get_future(); std::thread( [\u0026amp;p]{ p.set_value_at_thread_exit(9); }).detach(); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting...\u0026#34; \u0026lt;\u0026lt; std::flush; f1.wait(); f2.wait(); f3.wait(); std::cout \u0026lt;\u0026lt; \u0026#34;Done!\\nResults are: \u0026#34; \u0026lt;\u0026lt; f1.get() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f2.get() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f3.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; t.join(); } std::future_error 返回错误代码，和 返回特定于错误代码 的解释性字符串\nstd::future_error::code() std::future_error::what() #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::future\u0026lt;int\u0026gt; empty; try { int n = empty.get(); // The behavior is undefined, but // some implementations throw std::future_error } catch (const std::future_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught a future_error with code \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.code() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\nMessage: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } } std::shared_future 等待一个值 (possibly referenced by other futures）\nstd::shared_future\u0026lt;T\u0026amp;\u0026gt; std::shared_future::get() std::shared_future::wait() #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { std::promise\u0026lt;void\u0026gt; ready_promise, t1_ready_promise, t2_ready_promise; std::shared_future\u0026lt;void\u0026gt; ready_future(ready_promise.get_future()); std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; auto fun1 = [\u0026amp;, ready_future]() -\u0026gt; std::chrono::duration\u0026lt;double, std::milli\u0026gt; { t1_ready_promise.set_value(); ready_future.wait(); // waits for the signal from main() return std::chrono::high_resolution_clock::now() - start; }; auto fun2 = [\u0026amp;, ready_future]() -\u0026gt; std::chrono::duration\u0026lt;double, std::milli\u0026gt; { t2_ready_promise.set_value(); ready_future.wait(); // waits for the signal from main() return std::chrono::high_resolution_clock::now() - start; }; auto fut1 = t1_ready_promise.get_future(); auto fut2 = t2_ready_promise.get_future(); auto result1 = std::async(std::launch::async, fun1); auto result2 = std::async(std::launch::async, fun2); // wait for the threads to become ready fut1.wait(); fut2.wait(); // the threads are ready, start the clock start = std::chrono::high_resolution_clock::now(); // signal the threads to go ready_promise.set_value(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread 1 received the signal \u0026#34; \u0026lt;\u0026lt; result1.get().count() \u0026lt;\u0026lt; \u0026#34; ms after start\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Thread 2 received the signal \u0026#34; \u0026lt;\u0026lt; result2.get().count() \u0026lt;\u0026lt; \u0026#34; ms after start\\n\u0026#34;; } Functions 异步 std::async async( Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ) async( std::launch policy, Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex m; struct X { void foo(int i, const std::string\u0026amp; str) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void bar(const std::string\u0026amp; str) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int operator()(int i) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return i + 10; } }; template \u0026lt;typename RandomIt\u0026gt; int parallel_sum(RandomIt beg, RandomIt end) { auto len = end - beg; if (len \u0026lt; 1000) return std::accumulate(beg, end, 0); RandomIt mid = beg + len/2; auto handle = std::async(std::launch::async, parallel_sum\u0026lt;RandomIt\u0026gt;, mid, end); int sum = parallel_sum(beg, mid); return sum + handle.get(); } int main() { std::vector\u0026lt;int\u0026gt; v(10000, 1); std::cout \u0026lt;\u0026lt; \u0026#34;The sum is \u0026#34; \u0026lt;\u0026lt; parallel_sum(v.begin(), v.end()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; X x; // Calls (\u0026amp;x)-\u0026gt;foo(42, \u0026#34;Hello\u0026#34;) with default policy: // may print \u0026#34;Hello 42\u0026#34; concurrently or defer execution auto a1 = std::async(\u0026amp;X::foo, \u0026amp;x, 42, \u0026#34;Hello\u0026#34;); // Calls x.bar(\u0026#34;world!\u0026#34;) with deferred policy // prints \u0026#34;world!\u0026#34; when a2.get() or a2.wait() is called auto a2 = std::async(std::launch::deferred, \u0026amp;X::bar, x, \u0026#34;world!\u0026#34;); // Calls X()(43); with async policy // prints \u0026#34;43\u0026#34; concurrently auto a3 = std::async(std::launch::async, X(), 43); a2.wait(); // prints \u0026#34;world!\u0026#34; std::cout \u0026lt;\u0026lt; a3.get() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#34;53\u0026#34; } // if a1 is not done at this point, destructor of a1 prints \u0026#34;Hello 42\u0026#34; here 可能的结果：\n上边程序打印顺序不确定，\nThe sum is 10000 43 world! 53 Hello 42 ","date":"2022-01-15T17:13:05Z","permalink":"https://okokfun.github.io/post/c++/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/","title":"线程支持库"},{"content":" 此文章来自👉C++ 参考手册\nC++关键词： alignas (C++11 起) default(1) register(C++17弃用)(2) alignof (C++11 起) delete(1) reinterpret_cast and do requires (C++20 起) and_eq double return asm dynamic_cast short atomic_cancel (TM TS) else signed atomic_commit (TM TS) enum sizeof(1) atomic_noexcept (TM TS) explicit static auto(1) export(1)(3) static_assert (C++11 起) bitand extern(1) static_cast bitor false struct(1) bool float switch break for synchronized (TM TS) case friend template catch goto this char if thread_local (C++11 起) char8_t (C++20 起) inline(1) throw(C++17中移除) char16_t (C++11 起) int true char32_t (C++11 起) long try class(1) mutable(1) typedef compl namespace typeid concept (C++20 起) new typename const noexcept (C++11 起) union consteval (C++20 起) not unsigned constexpr (C++11 起) not_eq using(1) constinit (C++20 起) nullptr (C++11 起) virtual const_cast operator void continue or volatile co_await (C++20 起) or_eq wchar_t co_return (C++20 起) private while co_yield (C++20 起) protected xor decltype (C++11 起) public xor_eq reflexpr (反射 TS) override (C++11) final (C++11) import (C++20) module (C++20) transaction_safe (TM TS) transaction_safe_dynamic (TM TS) ","date":"2022-01-15T15:31:05Z","permalink":"https://okokfun.github.io/post/c++/c++%E5%85%B3%E9%94%AE%E8%AF%8D/","title":"C++关键词"},{"content":" 本文介绍的HTTP库👉libcpr/cpr: C++ Requests: Curl for People, a spiritual port of Python Requests. (github.com)\nHttpServer Url Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/hello.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic.json\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/error.html\u0026#34;}; Url url{\u0026#34;http://bad_host/\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/empty_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/check_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/v1_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/check_v1_cookies.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/basic_auth.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/bearer_token.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/digest_auth.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/header_reflect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/temporary_redirect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/permanent_redirect.html\u0026#34;}; Url url{server-\u0026gt;GetBaseUrl() + \u0026#34;/body_get.html\u0026#34;}; Get Response response = cpr::Get(url) Response response = cpr::Get(url, iface); Response response = cpr::Get(url, Timeout{0L}); Response response = cpr::Get(url, cookies); Response response = cpr::Get(url, parameters{}); Response response = cpr::Get(url, Authentication{}); Response response = cpr::Get(url, Header{}); Response response = cpr::Get(url, Bearer{}); Response response = cpr::Get(url, Digest{}); Response response = cpr::Get(url, Authentication{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Authentication{}); Response response = cpr::Get(url, Authentication{}, Header{}); Response response = cpr::Get(url, Authentication{}, Header{}); Response response = cpr::Get(url, Header{}, Authentication{}); Response response = cpr::Get(url, Header{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{}, Parameters{}, Header{}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{}); Response response = cpr::Get(url, Header{}, Authentication{}, Parameters{}); Response response = cpr::Get(url, Authentication{}, Header{}, Parameters{}); Response response = cpr::Get(url, Parameters{}, Authentication{}, Header{}); Response response = cpr::Get(url, Redirect(false)); Response response = cpr::Get(url, Redirect(0L)); Response response = cpr::Get(url, Authentication{}, Header{}, Redirect(true, true)); Response response = cpr::Get(url, body); Response response = cpr::Get(url, LimitRate(1024, 1024)); Response response = cpr::Get(url); Response response = cpr::Get(url, iface); Response response = cpr::Get(url, Timeout{0L}); Response response = cpr::Get(url, cookies); Response response = cpr::Get(url, parameters); Response response = cpr::Get(url, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer the_token\u0026#34;}}); Response response = cpr::Get(url, Bearer{\u0026#34;the_token\u0026#34;}); Response response = cpr::Get(url, Digest{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;}}); Response = session.Get(); cpr::Response response = session-\u0026gt;Post(); Response response = session.Get(); Response response = cpr::Get(url, Header{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;HeLlO\u0026#34;, \u0026#34;wOrLd\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}, {\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;}, {\u0026#34;test\u0026#34;, \u0026#34;case\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}, {\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;}, {\u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;}}, Header{{\u0026#34;HeLlO\u0026#34;, \u0026#34;wOrLd\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}); Response response = cpr::Get(url, Header{}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}); Response response = cpr::Get(url, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Parameters{{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}}, Authentication{\u0026#34;user\u0026#34;, \u0026#34;bad_password\u0026#34;}, Header{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Get(url, Redirect(false)); Response response = cpr::Get(url, Redirect(0L)); Response response = cpr::Get(url, Authentication{\u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;basic_auth.html\u0026#34;}}, Redirect(true, true)); Response response = cpr::Get(url, body); Response response = cpr::Get(url, LimitRate(1024, 1024)); cpr::Post Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}); Payload payload{{\u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;}}; payload.Add({\u0026#34;y\u0026#34;, \u0026#34;2\u0026#34;}); Response response = cpr::Post(url, payload); std::vector\u0026lt;Pair\u0026gt; payloadData; payloadData.emplace_back(\u0026#34;x\u0026#34;, \u0026#34;1\u0026#34;); payloadData.emplace_back(\u0026#34;y\u0026#34;, \u0026#34;2\u0026#34;); Response response = cpr::Post(url, Payload(payloadData.begin(), payloadData.end())); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;hello world!!~\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}, {\u0026#34;y\u0026#34;, \u0026#34;13\u0026#34;}}); Url url{\u0026#34;http://bad_host/\u0026#34;}; Response response = cpr::Post(url, Payload{{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, File{filename}}}); Multipart multipart{{\u0026#34;x\u0026#34;, File{filename}}}; Response response = cpr::Post(url, multipart); cpr::Response response = cpr::Post(url, cpr::Header{{\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;}}, cpr::Body{body}, cpr::ConnectTimeout{3000}, cpr::Timeout{3000}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{content.begin(), content.end(), \u0026#34;test_file\u0026#34;}}}); Multipart multipart{{\u0026#34;x\u0026#34;, Buffer{content.begin(), content.end(), \u0026#34;test_file\u0026#34;}}}; Response response = cpr::Post(url, multipart); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{content, 11 + content, \u0026#34;test_file\u0026#34;}}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, Buffer{std::begin(content), std::end(content) - 1, \u0026#34;test_file\u0026#34;}}}); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5}, {\u0026#34;y\u0026#34;, 13}}); Response response = cpr::Post(url, multipart); Response response = cpr::Post(url, Multipart{{\u0026#34;x\u0026#34;, 5, \u0026#34;application/number\u0026#34;}}); Multipart multipart{{\u0026#34;x\u0026#34;, 5, \u0026#34;application/number\u0026#34;}}; Response response = cpr::Post(url, multipart); Response response = cpr::Post(cpr::Url(uri), cpr::Header{{\u0026#34;content-type\u0026#34;, contentType}, {\u0026#34;Authorization\u0026#34;, signature}, {\u0026#34;log-type\u0026#34;, logType}, {\u0026#34;x-ms-date\u0026#34;, date}, {\u0026#34;content-length\u0026#34;, std::to_string(body.length())}}, cpr::Body(body)); cpr::Payload payload = cpr::Payload{{\u0026#34;email\u0026#34;, \u0026#34;\u0026#34;}, {\u0026#34;password\u0026#34;, \u0026#34;\u0026#34;}, {\u0026#34;devicetoken\u0026#34;, \u0026#34;\u0026#34;}}; cpr::Response response = cpr::Post(cpr::Url(uri), cpr::Timeout{10000}, payload); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}, Redirect(PostRedirectFlags::NONE)); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}); Response response = cpr::Post(url, Payload{{\u0026#34;x\u0026#34;, \u0026#34;5\u0026#34;}}, Header{{\u0026#34;RedirectLocation\u0026#34;, \u0026#34;url_post.html\u0026#34;}}, Redirect(PostRedirectFlags::NONE)); std::string expected_text{\u0026quot;\u0026quot;}; std::string expected_text{\u0026#34;Hello world!\u0026#34;}; std::string expected_text{ \u0026#34;[\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;first_key\\\u0026#34;: \\\u0026#34;first_value\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;second_key\\\u0026#34;: \\\u0026#34;second_value\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34;]\u0026#34;}; std::string expected_text{\u0026#34;Not Found\u0026#34;}; std::string expected_text{\u0026#34;Header reflect GET\u0026#34;}; EXPECT_EQ() EXPECT_EQ(expected_text, response.text); EXPECT_EQ(std::string{}, response.text); EXPECT_EQ(\u0026#34;Unauthorized\u0026#34;, response.text); EXPECT_EQ(std::string{\u0026#34;Header reflect POST\u0026#34;}, response.text); EXPECT_EQ(std::string{\u0026#34;Header reflect POST\u0026#34;}, response.text); EXPECT_EQ(url, response.url); EXPECT_EQ(\u0026#34;text/plain\u0026#34;, response.header[\u0026#34;content-type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;text/html\u0026#34;}, response.header[\u0026#34;content-type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;application/json\u0026#34;}, response.header[\u0026#34;Content-Type\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;Value1\u0026#34;}, response.header[\u0026#34;Header1\u0026#34;]); EXPECT_EQ(std::string{\u0026#34;Value2\u0026#34;}, response.header[\u0026#34;Header2\u0026#34;]); EXPECT_EQ(std::string{}, response.header[\u0026#34;Header2\u0026#34;]); cookies = response.cookies; EXPECT_EQ(cookies[\u0026#34;cookie\u0026#34;], response.cookies[\u0026#34;cookie\u0026#34;]); EXPECT_EQ(cookies[\u0026#34;icecream\u0026#34;], response.cookies[\u0026#34;icecream\u0026#34;]); EXPECT_EQ(cookies[\u0026#34;expires\u0026#34;], response.cookies[\u0026#34;expires\u0026#34;]); EXPECT_EQ(\u0026#34;\u0026#34;, response.cookies[\u0026#34;cookie\u0026#34;]); EXPECT_EQ(\u0026#34;\u0026#34;, response.cookies[\u0026#34;icecream\u0026#34;]); EXPECT_EQ(200, response.status_code); EXPECT_EQ(401, response.status_code); EXPECT_EQ(ErrorCode::OK, response.error.code); ","date":"2022-01-13T20:43:31Z","permalink":"https://okokfun.github.io/post/c++/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/","title":"cpr请求库"},{"content":" 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n此库是一个简单的TCP库👉sockpp\nTCP TCP Clien IPV4:tcp_clien sockpp::socket_initializer sockpp环境初始化 sockpp::tcp_connector conn({host, port}) // 初始化一个连接器，并尝试连接到{host, port} !conn.read_timeout(seconds(5)) // 读超时 conn.address() // 连接成功打印地址 conn.connect(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port)) // 链接{localhost, port} sockpp::inet_address(host, port) // 返回一个默认的端口号和地址 conn.clone() // clone一个sockpp::tcp_socket conn.last_error_str() // 返回根据平台各自的错误字符串 conn.last_error() conn.write(s) // 通过coon把字符串s写过去 conn.write_n(buf, n) // 从buf中取n个字节的数据并通过tcp写过去 conn.read(buf, sizeof(buf))) // 读sizeof(buf)个字节到buf中，并返回读到的字节数 conn.read_n() // conn.address() // 服务器的地址 conn.peer_address() conn.shutdown(SHUT_WR) 例子- 单线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/tcp_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; using namespace std::chrono; int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample TCP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; // Implicitly creates an inet_address from {host,port} // and then tries the connection. sockpp::tcp_connector conn({host, port}); if (!conn) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; sockpp::inet_address(host, port) \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection from \u0026#34; \u0026lt;\u0026lt; conn.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; endl; // Set a timeout for the responses if (!conn.read_timeout(seconds(5))) { cerr \u0026lt;\u0026lt; \u0026#34;Error setting timeout on TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; } string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } IPV6:tcp6_clien sockpp::tcp6_connector conn({host, port}); sockpp::inet6_address(host, port); conn.last_error_str(); conn.read_timeout(seconds(5)); conn.last_error_str(); conn.write(s); 例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/tcp6_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; using namespace std::chrono; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 TCP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; std::string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;::1\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; // Implicitly creates an inet6_address from {host,port} // and then tries the connection. sockpp::tcp6_connector conn({host, port}); if (!conn) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; sockpp::inet6_address(host, port) \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection from \u0026#34; \u0026lt;\u0026lt; conn.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; endl; // Set a timeout for the responses if (!conn.read_timeout(seconds(5))) { cerr \u0026lt;\u0026lt; \u0026#34;Error setting timeout on TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; } string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from TCP stream: \u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } TCP Server IPV4:tcp_server sockpp::tcp_acceptor acc(port) // 绑定port,并创建一个sockpp::tcp_socket的acc sockpp::tcp_socket sock = acc.accept(\u0026amp;peer) // 接受一个tcp连接并返回sockpp::tcp_socket 例子-多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/tcp_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::tcp_socket sock) { ssize_t n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed from \u0026#34; \u0026lt;\u0026lt; sock.peer_address() \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the TCP port acceptor. Each time a connection is // made, a new thread is spawned to handle it, leaving this main thread to // immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample TCP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp_acceptor acc(port); if (!acc) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } //cout \u0026lt;\u0026lt; \u0026#34;Acceptor bound to address: \u0026#34; \u0026lt;\u0026lt; acc.address() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Awaiting connections on port \u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { sockpp::inet_address peer; // Accept a new client connection sockpp::tcp_socket sock = acc.accept(\u0026amp;peer); cout \u0026lt;\u0026lt; \u0026#34;Received a connection request from \u0026#34; \u0026lt;\u0026lt; peer \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } IPV6:tcp6_server sockpp::tcp6_acceptor acc(port); sockpp::inet6_address peer; acc.accept(\u0026amp;peer); 例子 - 多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/tcp6_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::tcp6_socket sock) { ssize_t n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed from \u0026#34; \u0026lt;\u0026lt; sock.peer_address() \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the TCP port acceptor. Each time a connection is // made, a new thread is spawned to handle it, leaving this main thread to // immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 TCP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp6_acceptor acc(port); if (!acc) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Awaiting connections on port \u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { sockpp::inet6_address peer; // Accept a new client connection sockpp::tcp6_socket sock = acc.accept(\u0026amp;peer); cout \u0026lt;\u0026lt; \u0026#34;Received a connection request from \u0026#34; \u0026lt;\u0026lt; peer \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } UDP UDP Clien IPV4:udp_clien sockpp::socket_initializer sockInit; sockpp::udp_socket sock; sock.connect(sockpp::inet_address(host, port)); sock.last_error_str(); sockpp::inet_address addr(\u0026#34;localhost\u0026#34;, 12345); sock.send(s); sock.send_to(msg, addr); char buf[16]; ssize_t n = sock.recv(buf, sizeof(buf), \u0026amp;srcAddr); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/udp_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp_socket sock; if (!sock.connect(sockpp::inet_address(host, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; host \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created UDP socket at: \u0026#34; \u0026lt;\u0026lt; sock.address() \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (sock.send(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = sock.recv(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!sock) ? 1 : 0; } IPV6:udp6_clien sockpp::socket_initializer sockInit; sockpp::udp6_socket sock; sock.connect(sockpp::inet6_address(host, port)); sock.last_error_str(); sock.address(); sock.send(s); sock.recv(\u0026amp;sret[0], s.length()); 例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/udp6_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample IPv6 UDP echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string host = (argc \u0026gt; 1) ? argv[1] : \u0026#34;localhost\u0026#34;; in_port_t port = (argc \u0026gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp6_socket sock; if (!sock.connect(sockpp::inet6_address(host, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to server at \u0026#34; \u0026lt;\u0026lt; host \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; port \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created UDP socket at: \u0026#34; \u0026lt;\u0026lt; sock.address() \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (sock.send(s) != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); ssize_t n = sock.recv(\u0026amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UDP socket: \u0026#34; \u0026lt;\u0026lt; sock.last_error_str() \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!sock) ? 1 : 0; } UDP Server IPV4:udp_server sockpp::socket_initializer sockInit; sockpp::udp_socket\tudpsock; udpsock.bind(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port)); udpsock.last_error_str(); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/udp_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. template \u0026lt;typename UDPSOCK\u0026gt; void run_echo(UDPSOCK sock) { ssize_t n; char buf[512]; // Each UDP socket type knows its address type as `addr_t` typename UDPSOCK::addr_t srcAddr; // Read some data, also getting the address of the sender, // then just send it back. while ((n = sock.recv_from(buf, sizeof(buf), \u0026amp;srcAddr)) \u0026gt; 0) sock.send_to(buf, n, srcAddr); } // -------------------------------------------------------------------------- // The main thread creates the two UDP sockets (one each for IPv4 and IPv6), // and then starts them running the echo function each in a separate thread. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp_socket\tudpsock; if (!udpsock) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the UDP v4 socket: \u0026#34; \u0026lt;\u0026lt; udpsock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } if (!udpsock.bind(sockpp::inet_address(\u0026#34;localhost\u0026#34;, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error binding the UDP v4 socket: \u0026#34; \u0026lt;\u0026lt; udpsock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } // Spin up a thread to run the IPv4 socket. thread thr(run_echo\u0026lt;sockpp::udp_socket\u0026gt;, std::move(udpsock)); thr.detach(); return 0; } IPV6:udp6_server sockpp::socket_initializer sockInit; sockpp::udp6_socket\tudp6sock; udp6sock.last_error_str(); udp6sock.bind(sockpp::inet6_address(\u0026#34;localhost\u0026#34;, port)); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/udp6_socket.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. template \u0026lt;typename UDPSOCK\u0026gt; void run_echo(UDPSOCK sock) { ssize_t n; char buf[512]; // Each UDP socket type knows its address type as `addr_t` typename UDPSOCK::addr_t srcAddr; // Read some data, also getting the address of the sender, // then just send it back. while ((n = sock.recv_from(buf, sizeof(buf), \u0026amp;srcAddr)) \u0026gt; 0) sock.send_to(buf, n, srcAddr); } // -------------------------------------------------------------------------- // The main thread creates the two UDP sockets (one each for IPv4 and IPv6), // and then starts them running the echo function each in a separate thread. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample UDP echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; in_port_t port = (argc \u0026gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::udp6_socket\tudp6sock; if (!udp6sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the UDP v6 socket: \u0026#34; \u0026lt;\u0026lt; udp6sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } if (!udp6sock.bind(sockpp::inet6_address(\u0026#34;localhost\u0026#34;, port))) { cerr \u0026lt;\u0026lt; \u0026#34;Error binding the UDP v6 socket: \u0026#34; \u0026lt;\u0026lt; udp6sock.last_error_str() \u0026lt;\u0026lt; endl; return 1; } // Spin up a thread to run the IPv4 socket. thread thr(run_echo\u0026lt;sockpp::udp6_socket\u0026gt;, std::move(udp6sock)); thr.detach(); return 0; } UNIX UNIX Clien sockpp::socket_initializer sockInit; sockpp::unix_connector conn; conn.connect(sockpp::unix_address(path)); conn.last_error_str(); conn.peer_address(); 例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;sockpp/unix_connector.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample Unix-domain echo client for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string path = (argc \u0026gt; 1) ? argv[1] : \u0026#34;/tmp/unechosvr.sock\u0026#34;; sockpp::socket_initializer sockInit; sockpp::unix_connector conn; bool ok = conn.connect(sockpp::unix_address(path)); if (!ok) { cerr \u0026lt;\u0026lt; \u0026#34;Error connecting to UNIX socket at \u0026#34; \u0026lt;\u0026lt; path \u0026lt;\u0026lt; \u0026#34;\\n\\t\u0026#34; \u0026lt;\u0026lt; conn.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Created a connection to \u0026#39;\u0026#34; \u0026lt;\u0026lt; conn.peer_address() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; string s, sret; while (getline(cin, s) \u0026amp;\u0026amp; !s.empty()) { if (conn.write(s) != (int) s.length()) { cerr \u0026lt;\u0026lt; \u0026#34;Error writing to the UNIX stream\u0026#34; \u0026lt;\u0026lt; endl; break; } sret.resize(s.length()); int n = conn.read_n(\u0026amp;sret[0], s.length()); if (n != (int) s.length()) { cerr \u0026lt;\u0026lt; \u0026#34;Error reading from UNIX stream\u0026#34; \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; sret \u0026lt;\u0026lt; endl; } return (!conn) ? 1 : 0; } UNIX Server sockpp::socket_initializer sockInit; sockpp::unix_acceptor acc; acc.open(sockpp::unix_address(path)); acc.last_error_str(); acc.address(); acc.accept(); 例子 - 多线程\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;sockpp/unix_acceptor.h\u0026#34; #include \u0026#34;sockpp/version.h\u0026#34; using namespace std; // -------------------------------------------------------------------------- // The thread function. This is run in a separate thread for each socket. // Ownership of the socket object is transferred to the thread, so when this // function exits, the socket is automatically closed. void run_echo(sockpp::unix_socket sock) { int n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) \u0026gt; 0) sock.write_n(buf, n); cout \u0026lt;\u0026lt; \u0026#34;Connection closed\u0026#34; \u0026lt;\u0026lt; endl; } // -------------------------------------------------------------------------- // The main thread runs the UNIX acceptor. // Each time a connection is made, a new thread is spawned to handle it, // leaving this main thread to immediately wait for the next connection. int main(int argc, char* argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Sample Unix-domain echo server for \u0026#39;sockpp\u0026#39; \u0026#34; \u0026lt;\u0026lt; sockpp::SOCKPP_VERSION \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; endl; string path = \u0026#34;/tmp/unechosvr.sock\u0026#34;; if (argc \u0026gt; 1) { path = argv[1]; } sockpp::socket_initializer sockInit; sockpp::unix_acceptor acc; bool ok = acc.open(sockpp::unix_address(path)); if (!ok) { cerr \u0026lt;\u0026lt; \u0026#34;Error creating the acceptor: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;Acceptor bound to address: \u0026#39;\u0026#34; \u0026lt;\u0026lt; acc.address() \u0026lt;\u0026lt; \u0026#34;\u0026#39;...\u0026#34; \u0026lt;\u0026lt; endl; while (true) { // Accept a new client connection auto sock = acc.accept(); cout \u0026lt;\u0026lt; \u0026#34;Received a connection\u0026#34; \u0026lt;\u0026lt; endl; if (!sock) { cerr \u0026lt;\u0026lt; \u0026#34;Error accepting incoming connection: \u0026#34; \u0026lt;\u0026lt; acc.last_error_str() \u0026lt;\u0026lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } ","date":"2022-01-13T20:28:16Z","permalink":"https://okokfun.github.io/post/c++/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Socket_Cpp库的使用"},{"content":" 数据库介绍 什么是数据库?\n​\t数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.\n​\t举个例子来说明这个问题：每个人都有很多亲戚和朋友，为了保持与他们的联系，\n​\t我们常常用一个笔记本将他们的姓名、地址、电话等信息都记录下来，\n​\t这样要査谁的电话或地址就很方便了。\n​\t这个“通讯录”就是一个最简单的“数据库”，每个人的姓名、地址、电话等信息就是这个数据库中的“数据”。\n​\t我们可以在笔记本这个“数据库”中添加新朋友的个人信息，也可以由于某个朋友的电话变动而修改他的电话号码这个“数据”。\n​\t不过说到底，我们使用笔记本这个“数据库”还是为了能随时査到某位亲戚或朋友的地址、邮编或电话号码这些“数据”。\n数据库是干什么用的?\n存储和管理数据,便于程序开发.\noracle简介:\nOracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。\nOracle公司成立与1977年，总部位于美国加州；\nOracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。\nOracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。\n2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。\n2008年1月16日 sun公司收购了mysql 。\n2009年4月20日 oracle收购了sun 。\n常见的数据库有哪些？\noracle公司的oracle数据库\nIBM公司的DB2数据库\nInformix公司的Informix数据库\nsysbase公司的sysbase数据库\nMicrosoft公司的SQL Server\noracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）\nMongoDB数据库\nMariadb数据库 (由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发,MariaDB名称来自Michael Widenius的女儿Maria的名字)\nSQLite (设计目标是嵌入式)\n1 Oracle的体系结构 Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。\n1.1 表空间和数据文件 逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。\n物理概念：数据文件，在磁盘上（/home/oracle_11/app/oradata/orcl目录中的.DBF文件）；\n​ 一个表空间包含一个或者多个数据文件。\n1.2 段、区、块 段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。\n图请看讲义部分。\n1.3 DBA 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。从时间开销上看：安装占用6%，创建和配置占用12%，装载和存档数据占6%, 软件维护占6%，管理数据库系统占55%，可见，管理数据库系统占用了大部分的时间开销。\n1.4 如何启动数据库服务 Windows启动oracle数据库服务：\n启动服务：services.msc，找到下列两个服务，并启动。\nOracleServiceORCL： oracle数据库服务系统\nhome1TNSListene： 监听服务，用于远程连接的侦听\n注意：若把数据库默认设置为自启动，则开机时间会延长。\nLinux启动oracle数据库服务步骤(oracle数据库系统安装到linux系统上)\n​\t1. 执行sqlplus / as sysdba或sqlplus sys/sys as sysdba进入到命令行界面\n​\t2. 执行startup启动数据库服务\n​\t3. 执行exit退出sqlplus命令行界面\n​\t4. 执行lsnrctl start启动监听服务\n注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。\n1.5 如何登陆数据库服务 在本机登陆：\n普通用户身份登陆\nsqlplus ↙ 用户名 ↙\t密码 ↙\nsqlplus 用户名/密码，如sqlplus scott/tiger\n以管理员身份登陆 sqlplus / as sysdba（此处不用输入密码，在安装的时候已经输入密码） sqlplus sys/sys as sysdba 通过网络使用客户端远程登陆 远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。\n注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。\nD:\\oracle\\app\\HGUANG\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora，下面是经过Net Manager进行配置后得到的一个文件内容：\n客户端安装完成之后进行远程登陆之前最好先进行测试：\n首先测试网络是否是通的： ping IP ， 然后tnsping IP 或者 tnsping oracle_orcl。\n普通用户登陆\nsqlplus 用户名/密码@连接字符串，如sqlplus scott/tiger@oracle_orcl\n管理员用户登陆\nsqlplus sys/sys@oracle_orcl as sysdba 此外：还可以执行： sqlplus scott/tiger@//IP地址/实例名 进行登陆。\n使用scott用户或者sys用户登陆完之后，可以使用show user测试一下，如果显示用户名就表明已经登陆成功了，或者是执行select * from tab;进行一次查询, 有结果显示就表名已经登陆成功了.\n解锁用户：alter user scott account unlock (管理员身份登陆，给scott用户解锁。用户默认锁定)\n锁定用户：alter user scott account lock，（必须用管理员用户登陆）\n修改用户密码：alter user scott identified by 新密码 (管理员身份登陆，给scott用户修改密码)\n查看当前语言环境：select userenv('language') from dual;\n1.6 贯穿这门课程的方案 请看oracle讲义。\nscott用户的emp表, dept表和salgrade表.\n2基本的SQL select语句 2.1 sqlplus的基本操作 显示当前用户： show user;\n查看当前用户下的表：select * from tab;\n​\ttab:\t数据字典（记录数据库和应用程序源数据的目录），包含当前用户下的表。\n查看员工表的结构：desc emp;\n设置行宽：set linesize 120;\n设置页面：set pagesize 100;\n​\t或者将上述两行写入如下两个配置文件，可永久设置：\nC:\\app\\Administrator\\product\\11.2.0\\client_1\\sqlplus\\admin\\glogin.sql\nC:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\sqlplus\\admin\\glogin.sql\n设置员工名列宽：col ename for a20\t(a表示字符串)\n设置薪水列为4位数子：col sal for 9999\t(一个9表示一位数字)\n2.2 基本的select语句 Select语句的整体形式：\nSELECT col1, col2… FROM table_name WHERE condition GROUP BY col… HAVING condtion ORDER BY col… 其语法格式为：\nSELECT *|{[DISTINCT] *column|*expression [*alias],\u0026hellip;} FROM *table;\n案例\n1查询所有员工的所有记录\nSELECT * FROM emp; SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno FROM emp; 说明：尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)\n2 查询员工号、姓名、薪水\nSELECT empno, ename, sal FROM emp; 3 查询员工号、姓名、薪水和年薪\nSELECT empno, ename, sal, sal*12 FROM emp; 说明：select语句中可以使用表达式\n注意：在执行sql语句的时候，执行 / 会执行上一次执行的语句。\n若在写sql语句的时候, 写错了, 可以使用c（change）命令来修改. 默认, 光标闪烁位置指向上一条SQL语句的第一行。输入 2 则定位到第二行。\nc /错误关键字/正确关键字 ↙\n使用“/”来执行修改过的SQL语句\n例如：错误输入:\n`select empno, ename, sal, sal * 12\n​\tform emp`; （“from”书写错误，该错误位于整条SQL语句的第二行）\n（1） 输入：2↙ 终端提示：2* from emp\n（2） 输入：c /form/from ↙\t终端提示：2* from emp (意为改正后的sql语句样子)\n（3） 输入：/↙\n也可以使用ed(或者edit)命令来修改\ned ↙弹出系统默认的文本编辑器，(如记事本)\n修改、保存、退出、执行“/”。\n使用edit打开文件编辑sql语句:\n如果sql语句很长, 可以分行编写或者用ed命令打开一个文件,\n然后在文件中编写sql语句, 注意, sql语句末尾不要加; , 然后换行加上/表示结束.\n若想将显示结果保存到文件中:\nspool命令:\nspool d:\\result.txt; select * from emp; spool off; 使用别名：\n别名：as\n案例：查询员工号，姓名，月薪，年薪\nSELECT empno AS \u0026#34;员工号\u0026#34;, ename \u0026#34;姓名\u0026#34;, sal 月薪, sal*12 年薪 FROM emp; 说明：关键字as写与不写没有区别； \u0026ldquo;\u0026ldquo;有与没有取决于别名中是否有空格，建议在用别名的时候加上\u0026rdquo;\u0026quot;。\nDISTINCT\u0026mdash;à重复记录只取一次\n案例：\nSELECT deptno FROM emp; SELECT DISTINCT deptno FROM emp; SELECT job FROM emp; SELECT DISTINCT job FROM emp; SELECT DISTINCT deptno, job FROM emp; 说明: DISTINCT的作用范围不是距离它最近的列, 而是后面的所有的列。\n2.3 SQL语句使用注意事项 SQL 语言大小写不敏感。\nsql语句对关键字的大小写不敏感, 如SELECT和select一样, 但是对于内容敏感。\nSQL可以写在一行或者多行\n关键字不能被缩写也不能分行\n各子句一般要分行写。\n使用缩进提高语句的可读性\n2.4 算数运算 + - * / 乘除的优先级高于加减\n优先级相同时, 按照从左至右运算\n可以使用括号改变优先级\n查询: 员工号、姓名、月薪、年薪、奖金、年收入。\nSELECT deptno, ename, sal, sal*12, comm, comm+sal*12 FROM emp; ​\t结果不正确, 没有奖金的员工, 年收入不正确。\n说明： 在程序开发过程中, 数据是核心. 程序再正确也没有用, 必须保证数据不能丢, 且正确, 对于上面的结果, 有对有错的情况是最危险的.\n解决这个问题需要正确认识NULL值。\n2.5 NULL值 NULL值问题：\n包含NULL值的表达式都为空.\nNULL不等于NULL\nselect * from emp where NULL=NULL; 查不到任何记录。\n解决：滤空函数：nvl(a, b) 如果a为NULL，返回b；\n所以：使用sal * 12 + nvl(comm, 0) 表示年收入。\n在SQL中, 判断一值是否等于NULL不用“=” 和“!=”而使用is和is not 查询奖金为NULL的员工信息：\nselect * from emp where comm = NULL; (SQL中不使用==)\n​\t应该使用：select * from emp where comm is NULL;\n查询奖金不为NULL的员工信息：\nselect * from emp where comm is not NULL;\n总结: 空值是无效的, 未指定的, 未知的或不可预知的值, 空值不是空格或者0.\n2.6 连接符 ​\t在oracle中使用 || 连接字符串\n例如：\nSELECT ename || \u0026#39; is a \u0026#39; || job FROM emp; 若要显示hello world字符串应该怎么办呢?\noracle中语法规定：select后面必须接from关键字，所有需要有一个表名用来满足oracle的SQL99语法规定，为此定义了一个伪表dual。\nSELECT concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;) FROM dual; 若要连接三个字符串呢？\nSELECT concat(concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;), \u0026#39; i love you\u0026#39;) FROM dual; 注意：concat函数只支持两个参数，不支持三个参数形式。\n​\t也可以使用||连接三个以上的字符串：\nSELECT \u0026#39;hello \u0026#39; || \u0026#39;world \u0026#39; || \u0026#39;i love you\u0026#39; FROM dual; 说明：使用||比concat函数要灵活，其实||就是用来替换concat函数的。\n2.7 SQL和sqlplus 我们已经学习使用了select，应该知道还有update、delete、insert、create…\n同时，我们学习了ed、c、set、col、desc….\nSQL是语言，关键字不能缩写。\nsqlplus是oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。\nSQL\n一种语言\nANSI 标准\n关键字不能缩写\n使用语句控制数据库中的表的定义信息和表中的数据\nSQL*Plus\n一种环境\nOracle 的特性之一\n关键字可以缩写\n命令不能改变数据库中的数据的值\n集中运行\n3 过滤和排序数据 3.1 where条件过滤 在where条件中使用的列的值对大小写是敏感的, 如是字符串需要用单引号引起来, 如KING和king是不同的字符串。\n如select * from emp where ename= 'KiNg '；未选定行\nselect * from emp where ename= 'KING '； 正确\n说明： 对于列的值来说，大小写是敏感的。\n​ [未选定行]不是发生了错误，而是查不到记录。\n3.1.1 日期格式 查询入职日期为1981年11月17日的员工\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 会报错，ORA-01861: 文字与格式字符串不匹配。\n首先查询一下emp使用的日期格式：\nSELECT * FROM emp; 使用sysdate函数获取当前系统的日期：\nSELECT sysdate FROM dual; 查询得出格式为： DD-MON-RR\n应该使用当前系统指定的日期格式来查询：\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 如何获取当前系统的日期格式?\nSELECT * FROM v$nls_parameters; 若格式不太好看，可以执行col parameter for a30设置列的宽度。\n如何修改日期格式?\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd \u0026#39;; 查看修改结果：\nSELECT * FROM v$nls_parameters; 验证：再次查询emp表：\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 修改日期格式到秒\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;; 执行select sysdate from dual;验证修改结果.\n将日期格式改回默认设置\nalter session SET NLS_DATE_FORMAT = \u0026#39;DD-MON-RR\u0026#39;; 说明:\n字符和日期要包含在单引号中。\n字符大小写敏感, 日期格式敏感。\n默认的日期格式是DD-MON-RR\n3.1.2 比较运算 l 普通比较运算符：\n= 等于(不是==)\t\u0026gt; 大于\n\u0026gt;= 大于等于\t\u0026lt; 小于\n\u0026lt;= 小于等于\t\u0026lt;\u0026gt;\t不等于(也可以是!=)\n案例:\n1 查询薪水不等于1250的员工信息\nSELECT * FROM emp WHERE sal \u0026lt;\u0026gt; 1250; SELECT * FROM emp WHERE sal != 1250; between…and:介于两值之间,闭区间,包含两边的值.\n案例:\n查询工资在1000-2000之间的员工：\nSELECT * FROM emp WHERE sal \u0026gt;=1000 AND sal\u0026lt;=2000; SELECT * FROM emp WHERE sal BETWEEN 1000 AND 2000; ​\t注意：1.包含边界 2. 小值在前，大值在后。 (对于日期也是如此)\n2 查询81年2月至82年2月(不含2月)入职的员工信息：\nSELECT * FROM emp WHERE hiredate BETWEEN \u0026#39;1-2月-81\u0026#39; AND \u0026#39;30-1月-82\u0026#39;; in：在集合中, not in 不在集合中\n案例\n查询部门号为10和20的员工信息： SELECT * FROM emp WHERE deptno=10 OR deptno=20; SELECT * FROM emp WHERE deptno IN (10, 20); 查询部门号不是10和20的员工(除了10和20以外的部门) SELECT * FROM emp WHERE deptno NOT IN (10, 20); 使用比较运算符该怎么写呢？\rSELECT * FROM emp WHERE deptno!=10 AND deptno!=20; 如果是 ….. not in (10, 20, NULL) 可不可以呢?\n☆NULL空值:如果结果中含有NULL,不能使用not in 操作符,但可以使用in操作符。\r课后思考为什么???\r因为: not in (10, 20, NULL)相当于:\ndeptno!=10 and deptno!=20 and deptno!=NULL包含NULL的表达式都为空.\nlike：模糊查询\n%匹配任意多个字符, _匹配一个字符, 使用escape表示转义字符\n案例:\n查询名字以S开头的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;S% \u0026#39;; (注意：S小写、大写不同)\n查询名字是4个字的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;_ _ _ _\u0026#39;; 增加测试例子：向表中插入员工：\ninsert into emp(empno, ename, sal, deptno) values(1001, \u0026#39; TOM_ABC \u0026#39;, 3000, 10); 查询名字中包含_的员工：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;% _ % \u0026#39;; 查不到记录.\n转义字符：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;%\\_% \u0026#39; escape \u0026#39;\\\u0026#39;; 转义单引号本身使用两个单引号来完成转义\nSELECT \u0026#39;hello \u0026#39;\u0026#39; world\u0026#39; FROM dual; 3.1.3 逻辑运算 逻辑运算符\nAND\t逻辑并\nOR 逻辑或\nNOT\t逻辑非\n如果…..where 表达式1 and/or 表达式2;\n…..where 表达式2 and/or 表达式1;\t这两句SQL语句功能一样吗？效率一样吗？\n※SQL优化：\nSQL在解析where的时候，是从右至左解析的。\n所以： and时应该将易假的值放在右侧;\nor时应该将易真的值放在右侧.\r这样的话可以提高效率.\n案例:\n查询部门为30且工种为SALESMAN的员工 SELECT * FROM emp WHERE deptno=30 AND job=\u0026#39;SALESMAN\u0026#39;; 查询部门为10或者工资大于2000的员工 SELECT * FROM emp WHERE deptno=10 OR sal\u0026gt;2000; 查询工种不是MANAGER或者PRISIDENT的员工 SELECT * FROM emp WHERE job!=\u0026#39;MANAGER\u0026#39; AND job!=\u0026#39;PRISIDENT\u0026#39;; SELECT * FROM emp WHERE job NOT IN (\u0026#39;MANAGER\u0026#39;, \u0026#39;PRESIDENT\u0026#39;); 3.1.4 order by 排序 使用 ORDER BY 子句排序\nASC（ascend）: 升序。默认采用升序方式。\nDESC（descend）: 降序\nORDER BY子句在SELECT语句的最末尾, 是对select查询的最后的结果进行排序.\n案例:\n查询emp表, 按照入职日期先后排序 SELECT * FROM emp ORDER BY hiredate; 查询员工信息, 按月薪排序 SELECT * FROM emp ORDER BY sal; # ---从小到大排序, 默认方式.\tSELECT * FROM emp ORDER BY sal desc; # ---从大到小排序 order by 之后可以跟那些内容呢？\norder by + 列名, 序号, 表达式, 别名,\n注意：语法要求order by子句应放在select的结尾。\n案例:\n查询员工信息, 按月薪排序\u0026mdash;-à使用列名排序的情况 SELECT * FROM emp ORDER BY sal; 按照工资进行排序\u0026ndash;à使用序号进行排序的情况 SELECT ename, sal, sal*12, FROM emp ORDER BY 2 desc; 序号: 按照select后面列名出现的先后顺序, ename→1, sal→2, sal*12→3\n按照员工的年薪进行排序\u0026mdash;-à使用表达式排序的情况 SELECT ename, sal, sal*12 FROM emp ORDER BY sal * 12 desc; 按照员工的年薪进行排序\u0026mdash;-à使用别名进行排序的情况 SELECT ename, sal, sal*12 \u0026#34;年薪\u0026#34; FROM emp ORDER BY \u0026#34;年薪\u0026#34; desc; 按照两列或者多列进行排序\n案例:\n按照部门和工资进行排序 SELECT * FROM emp ORDER BY deptno, sal; order by后有多列时, 列名之间用逗号隔分, order by会同时作用于多列。上例的运行结果会在同一部门内升序, 部门间再升序。\nSELECT * FROM emp ORDER BY deptno, sal desc; 注意: desc只作用于最近的一列, 两列都要降序排, 则需要两个desc。即：\nSELECT * FROM emp ORDER BY deptno desc, sal desc; 查询员工信息, 按奖金由高到低排序： SELECT * FROM emp ORDER BY comm desc; 结果前面的值为NULL, 数据在后面, 如果是一个100页的报表，这样显示肯定不\n正确。较为人性化的显示应该将空值放在最后, 即：\nSELECT * FROM emp ORDER BY comm DESC nulls last; (注意：是 nulls 而不是null)\n排序的规则\n可以按照select语句中的列名排序\n可以按照别名排序\n可以按照表达式排序,如order by sal*12+nvl(comm, 0)\n可以按照select语句中的列名的顺序值(序号)排序\n如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推\ndesc和asc只作用于最近的一列.\n4 单行函数 单行函数:只对一行进行变换, 产生一个结果。函数可以没有参数, 但必须要有返回值。如：concat、nvl\n操作数据对象\n接受参数返回一个结果\n只对一行进行变换\n每行返回一个结果\n可以转换数据类型\n可以嵌套\n参数可以是一列或一个值\n4.1 字符函数 操作对象是字符串。\n大致可分为两大类: 一类是大小写控制函数, 主要有lower、upper、initcap:\n案例:\n大小写转换lower和upper, 首字母大写initcap函数测试\nSELECT lower(\u0026#39;HeLlo, WORld\u0026#39;) 转小写, upper(\u0026#39;HellO, woRld\u0026#39;) 转大写, initcap(\u0026#39;hello, world\u0026#39;) 首字母大写 FROM dual; 另一类是字符控制函数: 有CONCAT、SUBSTR、LENGTH/LENGTHB、INSTR、LPAD | RPAD、TRIM、REPLACE\nsubstr(a, b)：在字符串a中，从第b位开始取(计数从1开始)，取到结尾\n案例:\n从helloworld字符串中的第3位开始后面的所有字符\nselect substr('helloworld', 3) from dual; \u0026mdash;à得到lloworld\nsubstr(a, b, c)：从a中，第b位开始，向右取c位。\n案例:\n从hello world字符串中, 从第3位开始取连续取5个字符\nSELECT substr(\u0026#39;helloworld\u0026#39;, 3, 5) FROM dual; length:字符数, lengthb:字节数：\n案例:\nSELECT length(\u0026#39;hello world\u0026#39;) 字符数, lengthb(\u0026#39;hello world\u0026#39;) 字节数 FROM dual; SELECT length(\u0026#39;哈喽我的\u0026#39;) 字符数, lengthb(\u0026#39;哈喽我的\u0026#39;) 字节数 FROM dual; 注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,\n这两个函数对于普通字符串没有什么区别.\ninstr: 在母串中查找子串, 找到返回下标, 计数从1开始, 没有返回0\n案例\n查找hello world字符串中, llo子串首次出现的下标位置\nSELECT instr(\u0026#39;hello world\u0026#39;, \u0026#39;llo\u0026#39;), instr(\u0026#39;hello world\u0026#39;, \u0026#39;www\u0026#39;) FROM dual; 注意: 下标是从1开始的.\nlpad：左填充，\n参1: 待填充的字符串，\n参2: 填充后字符串的总长度(字节)，\n参3: 填充什么\nrpad: 右填充, 参数同lpad.\n案例\nselect lpad('abcd', 10, '*') 左, rpad('abcd', 10, '#') 右 from dual; 结果显示: ******abcd abcd######\nselect lpad('abcd', 15, '你')左填充, rpad('abcd', 16, '我') 右填充 from dual; 结果显示: 你你你你你abcd abcd我我我我我我\n注意: lpad(\u0026lsquo;abcd\u0026rsquo;, 15, \u0026lsquo;你\u0026rsquo;)由于abcd本身占4个字节, 需要填充11个字节才能\n够15个字节, 但是一个汉字占两个字节, 所以填充了1个空格+5个汉字.\ntrim:去掉前后指定的字符(不去掉中间的)\n案例\n去掉\u0026rsquo; hello world \u0026lsquo;两端的空格\nSELECT trim(\u0026#39; hello world \u0026#39;) FROM dual; 去掉Hello worldH字符串前后的H字符\nSELECT trim(\u0026#39;H\u0026#39; FROM \u0026#39;Hello worldH\u0026#39;) FROM dual; replace:替换\n案例\n将hello world字符串中的l替换成*\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;*\u0026#39;) FROM dual; 删除字符串\u0026rsquo;hello world\u0026rsquo;中的字符\u0026rsquo;l\u0026rsquo;\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;\u0026#39;) FROM dual; 4.2 数值函数 ROUND: 四舍五入\nROUND(45.926, 2)\t45.93\nTRUNC:\t截断\nTRUNC(45.926, 2)\t45.92\nMOD: 求余\nMOD(1600, 300)\t100\n案例: round(45.926, 2) :2表达的含义是小数点向右保留两位并四舍五入，第二个参数如果是0可以省略.\nSELECT round(45.926, 2), round(45.926, 1), round(45.926, 0) , round(45.926), round(45.926, -1) , round(45.926, -2) FROM dual; trunc函数, 正数表示小数点之后, 负数表示小数点之前的位数, 0可以不写. SELECT trunc(45.926, 2), trunc(45.926, 1), trunc(45.926, 0), trunc(45.926), trunc(45.926, -1) , trunc(45.926, -2) FROM dual; mod函数: 求余数 select mod(1600, 600) from dual; \u0026ndash;à结果为100\nceil函数:向上取整 floor函数:向下取整\nselect ceil(19.23), floor(19.23) from dual;\n4.3 时间函数 在Oracle中日期型的数据，既有日期部分，也有时间部分.\n案例:\nselect sysdate from dual; 这里没有时间部分，因为系统默认的格式中不显示时间\nselect to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual; 显示日期到秒\nselect to_char(sysdate, 'day') from dual ; 可以显示当前日期星期几\n日期加、减数字得到的结果仍为日期。单位：天\n显示 昨天、今天、明天\nSELECT (sysdate-1) 昨天, (sysdate) 今天, (sysdate + 1) 明天 FROM dual; SELECT to_char(sysdate-1, \u0026#39;yyyy-mm-dd\u0026#39;) 昨天, to_char(sysdate, \u0026#39;yyyy-mm-dd\u0026#39;) 今天, to_char(sysdate+1, \u0026#39;yyyy-mm-dd\u0026#39;) 明天 FROM dual; à转换日期格式; 既然一个日期型的数据加上或者减去一个数字得到的结果仍为日期，两个日期相减，得到的就是相差的天数。\n计算员工的工龄, 显示从入职以来的总天数, 星期数, 总月数, 总年数\nSELECT ename, hiredate, (sysdate - hiredate) 天, (sysdate - hiredate)/7 星期, (sysdate - hiredate)/30 月, (sysdate - hiredate)/365 年 FROM emp; 日期和日期可以相减表示相隔多少天, 但是不允许相加, 两个日期相加没有意义, 日期只能和数字相加\u0026mdash;-à类似于两个指针相加没有意义一样.\n​\tselect sysdate+hiredate from emp; 报错: ORA-00975: 不允许日期 + 日期\n4.4 日期函数 上面求取员工工龄的结果不精确，如果想将其算准确，可以使用日期函数来做。\nmonths_between\n两个日期值相差的月数(精确值)\nSELECT ename, hiredate, (sysdate-hiredate)/30 一, months_between(sysdate, hiredate) 二 FROM emp; months_between函数更精确, 在表示月份差的时候要使用months_between函数.\nadd_months\n在某个日期值上，加上多少的月，正数向后计算，负数向前计算。\n计算95个月以后是哪年、哪月、那天：\nselect add_months(sysdate, 95) 哪一天 from dual;\n结果是: 2025/10/11\nlast_day\n日期所在月的最后一天, 要么30, 31或者28\nSELECT last_day(sysdate) FROM dual; 上个月的最后一天\nSELECT last_day(add_months(sysdate, -1)) FROM dual; 下一个月的最后一天\nSELECT last_day(add_months(sysdate, 1)) FROM dual; next_day:指定日期的下一个日期\n从当前时间算起, 下一个星期一的日期\nSELECT next_day(sysdate, \u0026#39;星期一\u0026#39;) FROM dual; 从特定日期得到之后的第一个星期几的日期\nSELECT next_day(to_date(\u0026#39;2017-11-11\u0026#39;, \u0026#39;yyyy-mm-dd\u0026#39;), \u0026#39;星期三\u0026#39;) FROM dual; round、trunc 对日期型数据进行四舍五入和截断\nSELECT round(sysdate, \u0026#39;month\u0026#39;), round(sysdate, \u0026#39;year\u0026#39;) FROM dual; SELECT trunc (sysdate, \u0026#39;month\u0026#39;), trunc(sysdate, \u0026#39;year\u0026#39;) FROM dual; 4.5 转换函数 在不同的数据类型之间完成转换, 如将\u0026quot;123\u0026quot;转换为123, 有隐式转换和显示转换之分。\n隐式转换(由oracle数据库来完成)\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 若是显示转换:\nSELECT * FROM emp WHERE to_char(hiredate, \u0026#39;DD-MON-RR\u0026#39;) = \u0026#39;17-11月-81\u0026#39;; 或者\nSELECT * FROM emp WHERE hiredate = to_date(\u0026#39;17-11月-81\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;); 显示转换(通过转换函数来完成)\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;) FROM dual; 注意: 隐式转换，前提条件是：被转换的对象是可以转换的。（ABC→625 可以吗？）\n显示转换：借助to_char(数据，格式)、to_number、to_date函数来完成转换。\n​\n格式 说明 举例 YYYY Full year in numbers 2011 YEAR Year spelled out(年的英文全称) twenty eleven MM Two-digit value of month 月份（两位数字） 04 MONTH Full name of the month（月的全称） 4月 DY Three-letter abbreviation of the day of the week(星期几) 星期一 DAY Full name of the day of the week 星期一 DD Numeric day of the month 02 如果隐式转换和显示转换都可以使用，应该首选哪个呢？\n注意：如果隐式、显示都可以使用，应该首选显示，这样可以省去oracle的解析过程。\n练习：在屏幕上显示如下字符串：\n2015-05-11 16:17:06 今天是 星期一\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; 说明: 在固定的格式里加入自定义的格式，是可以的，必须要加””。\n反向操作：已知字符串'2015-05-11 15:17:06 今天是 星期一\u0026rsquo;转化成日期.\n使用to_date函数将字符串转换成date类型\nSELECT to_date(\u0026#39;2015-05-11 15:17:06 今天是 星期一\u0026#39;, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; 案例:\n查询员工的薪水: 使用2位小数, 本地货币代码, 千位符 SELECT to_char(sal, \u0026#39;L9,999.99\u0026#39;) FROM emp; 特别注意:\u0026lsquo;L9,999.99\u0026rsquo;之间没有空格\n将￥2,975.00转化成数字： SELECT to_number(\u0026#39;￥2,975.00\u0026#39;, \u0026#39;L9,999.99\u0026#39;) 转成数字 FROM dual; 4.6 通用函数(了解) 这些函数适用于任何数据类型，同时也适用于空值：\nNVL (expr1, expr2)\nNVL2 (expr1, expr2, expr3)\nNULLIF (expr1, expr2)\nCOALESCE (expr1, expr2, \u0026hellip;, exprn)\nnvl2:是nvl函数的增强版。\tnvl2(a, b, c) 当a = null 返回 c, 否则返回b\n使用nvl2求员工的年收入：\nSELECT empno, ename, sal, sal*12, sal * 12 + nvl2(comm, comm, 0) 年薪 FROM emp; nullif: nullif(a, b) 当 a = b 时返回null, 不相等的时候返回a值。\nselect nullif('hello', 'hello') from dual; 返回空\nselect nullif('hello', 'world') from dual; 返回hello\nselect ename, nullif(comm, null) from emp;\ncoalesce:coalesce(a, b, c, …, n) 从左向右找参数中第一个不为空的值。\nSELECT comm, sal, coalesce(comm, sal) 结果值 FROM emp; 4.7 条件表达式 例子：老板打算给员工涨工资, 要求：\n总裁(PRESIDENT)涨1000, 经理(MANAGER)涨800, 其他人涨400. 请将涨前, 涨后的薪水列出。\n涨后的薪水是根据job来判断的\n思路：\tif 是总裁(\u0026lsquo;PRESIDENT\u0026rsquo;) then + 1000\nelse if 是经理(\u0026#39;MANAGER\u0026#39;) then + 800 else + 400\t但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode\ncase:是一个表达式，其语法为：\nCASE *expr WHEN *comparison_expr1 THEN *return_expr1 [WHEN *comparison_expr2 THEN *return_expr2 WHEN *comparison_exprn THEN *return_exprn ELSE *else_expr] END SQL\u0026gt;SELECT ename, job, sal 涨前薪水, CASE job WHEN \u0026#39;PRESIDENT\u0026#39; THEN sal+1000 WHEN \u0026#39;MANAGER\u0026#39; THEN sal+800 ELSE sal + 400 END 涨后薪水 FROM emp; 注意语法：when then 与下一个when then以及end之间没有“,”分割符, 可以将when当成if.\ndecode：是一个函数，其语法为：\nDECODE(*col|expression, search1, result1\n[*, search2, result2,...,]\r[*, default])\r除第一个和最后一个参数之外，中间的参数都是成对呈现的 (参1, 条件, 值, 条件, 值, …, 条件, 值, 尾参)\nSELECT ename, job, sal 涨前薪水, decode(job, \u0026#39;PRESIDENT\u0026#39;, sal + 1000, \u0026#39;MANAGER\u0026#39;, sal + 800, sal + 400) AS 涨后薪水 FROM emp; 5 分组函数 5.1分组函数 多行函数也叫组函数，本章学习目标:\n了解组函数。\n描述组函数的用途。\n使用GROUP BY 子句数据分组。\n使用HAVING 子句过滤分组结果集。\n分组函数作用于一组数据，并对一组数据返回一个值\n常用的有5个函数: avg、count、max、min、sum操作的是一组数据，返回一个结果。\n案例\n求员工的工资总额 SELECT sum(sal) FROM emp; 求员工人数 SELECT count(*) FROM emp; 平均工资 SELECT sum(sal)/count(*) 方式一, avg(sal) 方式二 FROM emp; 方式一和方式二结果一样, 当有空值得时候结果有可能不一样。如：奖金。\n求员工的平均奖金 SELECT sum(comm)/count(*) 方式一, sum(comm)/count(comm) 方式二, avg(comm) 方式三 FROM emp; 结果：方式一结果不同，方式二 和 方式三结果一样。\n说明: avg(comm)是求comm有值的几个的平均值, 跟方式二是相同的.\nNULL空值：组函数都有自动滤空功能(忽略空值)，所以：\nselect count(*), count(comm) from emp; 执行结果不相同。\n说明: count(comm)返回不为空的comm的总个数\n如何屏蔽组函数的滤空功能?\nSELECT count(*), count(nvl(comm, 0)) FROM emp; 但是实际应用中, 结果为14和结果为4都有可能对，看问题本身是否要求统计空值。\n5 count函数\n求emp表的部门总个数, 如果要求不重复的个数, 使用distinct。\nSELECT count(distinct deptno) FROM emp; 求emp表中的工种的总个数\nSELECT count(distinct job) FROM emp; 5.2 分组数据 分组数据使用group by关键字.\n按照group by 后给定的表达式，将from后面的table进行分组。针对每一组，使用组函数, 即先分组, 再分组统计.\n案例\n查询“部门”的平均工资： 分析: 结合select * from emp order by deptno; 结果分析分组\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno; 上SQL语句可以抽象成：select a, 组函数(x) from 表 group by a; 这样的格式。\r如果select a, b, 组函数(x) …… group by 应该怎么写？\n注意: 在select列表中所有没有包含在组函数中的列, 都必须在group by的后面出现.所以上面的问题应该写成group by a, b; 没有b就会出错, 不会执行sql语句。但, 反之可以。group by a，b，c; c可以不出现在select语句中。\ngroup by后面有多列的情况：\n查询部门内部不同职位的平均工资: SELECT deptno, job, avg(sal) FROM emp GROUP BY deptno, job ORDER BY 1; 分析该SQL的作用：\n因为`deptno, job` 两列没有在组函数里面，所以必须同时在group by后面。\r该SQL的语义:按部门, 不同的职位统计平均工资。先按第一列分组, 如果第一列相同, 再按第二列分组, 所以查询结果中，同一部门中没有重复的职位。\n关于分组函数常见的问题:\n在select后面出现的列, 该列没有出现在分组函数中, 但是未出现在group by子句中. 如: select deptno, job, avg(sal) from emp group by deptno;\n\u0026mdash;-job未出现在group by子句中\n报错: ORA-00979: 不是 GROUP BY 表达式.\nselect count(*) from emp; 分析: count是分组函数, 但是select后面没有其他列, 所以不必非出现group by子句,\n该sql语句意思是统计emp表中员工总数;\n当然: `select count(*) from emp group by deptno; 也对, 但是查询出来的结果并不知道是\n哪个组的总数.\n5.3 Having 使用 HAVING 过滤分组:\n行已经被分组。\n使用了组函数。\n满足HAVING 子句中条件的分组将被显示。\n其语法：\nSELECT\tcolumn, group_function\nFROM\ttable\n[WHERE\tcondition]\n[GROUP BY\tgroup_by_expression]\n[HAVING\tgroup_condition]\n[ORDER BY\tcolumn];\n查询平均薪水大于2000的部门 ：\n分析：该问题实际上是在分组的基础上过滤分组。\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal)\u0026gt;2000; 注意：having后面不能使用别名, 可以使用函数\n​\n特别注意: 不能在 WHERE 子句中使用组函数.\n可以在 HAVING 子句中使用组函数。\n从功能上讲，where和having都是将满足条件的结果进行过滤。但是差别是where子句中不能使用组函数, 所以上句中的having不可以使用where代替。\r求10号部门的平均工资：\n分析：在上一条的基础上，having deptno=10;\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING deptno=10; 使用where也可以做这件事\nSELECT deptno, avg(sal) FROM emp WHERE deptno=10 GROUP BY deptno; 在子句中没有使用组函数的情况下，where、having都可以，应该怎么选择？\nSQL优化： 尽量采用where。\n如果有分组的话，where是先过滤再分组，而having是先分组再过滤。当数据量庞大如1亿条，where优势明显。\n6 多表查询 理论基础：——笛卡尔集\n笛卡尔集的行数 = table1的行数 x table2的行数\n笛卡尔集的列数 = table1的列数 + table2的列数\n在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。\n多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。\n根据连接条件的不同可以划分为：等值链接、不等值链接、外链接、自连接\nOracle 连接:\nEquijoin：等值连接\nNon-equijoin：不等值连接\nOuter join：外连接\nSelf join：自连接\nSQL: 1999\nCross joins\nNatural joins\nUsing clause\nFull or two sided outer joins\n6.1 等值连接： ​\t从概念上，区分等值连接和不等值连接非常简单，只需要辨别where子句后面的条件，是“=”为等值连接。不是“=”为不等值连接。\n查询员工信息：员工号 姓名 月薪和部门名称\n​\t分析：这个问题涉及emp(员工号，姓名，月薪) 和dept(部门名称)两张表 ——即为多表查询。\n​\t通常在进行多表查询的时，会给表起一个别名，使用“别名.列名”的方式来获取数据，直接使用“表名.列名”语法上是允许的，但是实际很少这样用。\n如果：select e.empno, e.ename, e.sal, e.deptno, d.dname, d.deptno from emp e, dept d; 直接得到的是笛卡尔全集。其中有错误结果。所以应该加 where 条件进行过滤.\nSELECT e.empno, e.ename, e.sal, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno; 如果有N个表，where后面的条件至少应该有N-1个, 才会不产生笛卡尔积.\n6.2 不等值连接： 将上面的问题稍微调整下，查询员工信息：员工号 姓名 月薪 和 薪水级别(salgrade表)\nSELECT * FROM salgrade; 看到员工总的薪水级别，共有5级，员工的薪水级别应该满足 \u0026gt;=当前级别的下限，\u0026lt;=该级别的上限：\n过滤子句应该：\twhere e.sal \u0026gt;= s.losal and e.sal \u0026lt;= s.hisal;\nSELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal \u0026gt;= s.losal AND e.sal \u0026lt;= s.hisal; 更好的写法应该使用between…and:\nSELECT s.grade, e.empno, e.ename, e.sal, e.job FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ORDER BY 1; 6.3 外链接： l 按部门统计员工人数，显示： 部门号 部门名称 人数\n分析:\n​\t人数：一定是在emp表中，使用count()函数统计emp表中任一非空列均可。\n​\t部门名称：在dept表dname中, 直接读取即可。\n​\t部门号：任意，两张表都有, 两个表的联系是deptno.\n所以:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno=d.deptno GROUP BY d.deptno, d.dname; 注意：由于使用了组函数count()，所以组函数外的d.deptno和d.dname必须放到group by后。\n得到查询结果，但是select * from dept发现40号部门没有显示出来，原因是40号部门没有员工，where没满足。结果不对，40号部门没有员工，应该在40号部门位置显示0。\n我们希望： 在最后的结果中，包含某些对于where条件来说不成立的记录 （外链接的作用）\nl 左外链接：当 where e.deptno=d.deptno 不成立的时候，=左边所表示的信息，仍然被包含。\n​\t写法：与叫法相反：where e.deptno=d.deptno(+)\nl 右外链接：当 where e.deptno=d.deptno 不成立的时候，=右边所表示的信息，仍然被包含。\n​\t写法：依然与叫法相反：where e.deptno(+)=d.deptno\n以上我们希望将没有员工的部门仍然包含到查询的结果当中。因此应该使用外链接的语法。\n写法1:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno(+)=d.deptno GROUP BY d.deptno, d.dname; 写法2:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE d.deptno = e.deptno(+) GROUP BY d.deptno, d.dname; 这样就可以将40号部门包含到整个查询结果中。人数是0\n注意：不能使用count(e.*), 应该是某个表的具体的列.\n思考: 能否使用count(), count()与count(e.empno)有什么不同???\n6.4 自连接： 核心，通过表的别名，将同一张表视为多张表。\n例如: 查询员工信息：xxx的老板是 yyy\n分析：执行select * from emp; 发现，员工的老板也在员工表之中，是一张表。要完成多表查询我们可以假设，有两张表，一张表e(emp)只存员工、另一张表b(boss)只存员工的老板。—— from e, b;\n老板和员工之间的关系应该是：where e.mgr=b.empno (即:员工表的老板 = 老板表的员工)\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || b.ename FROM emp e, emp b WHERE e.mgr=b.empno; 执行, 发现结果正确了, 但是KING没有显示出来. KING的老板是他自己. 应该怎么显示呢?\n使用外连接:\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || nvl(b.ename, \u0026#39;他自己\u0026#39; ) FROM emp e, emp b WHERE e.mgr=b.empno(+); 使用concat函数应该怎么做呢??\nSELECT concat(e.ename, concat(\u0026#39; 的老板是 \u0026#39;, nvl(b.ename, \u0026#39;他自己\u0026#39; ))) FROM emp e, emp b WHERE e.mgr = b.empno(+); 7 子查询 子查询语法很简单，就是select 语句的嵌套使用, 即sql嵌套sql。\n查询工资比SCOTT高的员工信息.\n分析：两步即可完成\r查出SCOTT的工资 SELECT ename, sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;; # 结果为3000 查询比3000高的员工 SELECT * FROM emp WHERE sal\u0026gt;3000; 通过两步可以将问题结果得到。子查询，可以将两步合成一步。\n——子查询解决的问题：问题本身不能一步求解的情况。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;); 子查询语法格式：\nSELECT *select_list FROM *table WHERE *expr operator (SELECT *select_list FROM *table); 本章学习目标:\n描述子查询可以解决的问题\n定义子查询(子查询的语法)\n列出子查询的类型。\n书写单行子查询和多行子查询。\n7.1 定义子查询 需要注意的问题 合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩 进)\n小括号( )\n主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可\n可以在主查询的where、select、having、from后都可以放置子查询\n不可以在主查询的group by后面放置子查询 (SQL语句的语法规范)\n强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)\n一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外\n一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by\n单行子查询只能使用单行操作符；多行子查询只能使用多行操作符\n子查询中的null值\n7.2 主、子查询在不同表间进行。 查询部门名称是“SALES”的员工信息\n主查询：查询员工信息。select * from emp;\n子查询：负责根据部门名称(在dept表中)得到部门号。\nSELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;; SELECT * FROM emp WHERE deptno= (SELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;); 主查询, 查询的是员工表emp, 子查询, 查询的是部门表dept。是两张不同的表。\r将该问题使用“多表查询”解决\nSELECT e.* FROM emp e, dept d WHERE e.deptno=d.deptno AND d.dname=\u0026#39;SALES\u0026#39;; 两种方式哪种好呢？\nSQL优化: 理论上，既可以使用子查询，也可以使用多表查询，尽量使用“多表查询”。子查询有2次from, 与数据库服务的交互多.\n不同数据库处理数据的方式不尽相同，如Oracle数据库中，子查询地位比较重要，做了深入的优化。有可能实际看到结果是子查询快于多表查询。\n7.3 在主查询的where select having from 放置子查询 子查询可以放在select后，但，要求该子查询必须是单行子查询：(该子查询本身只返回一条记录，2+叫多行子查询)\nSELECT empno, ename, (SELECT dname FROM dept) 部门 FROM emp; 注意：SQL中没有where是不可以的，那样是多行子查询。\u0026ndash;但这是不符合实际情况的.\n应该:\nSELECT empno, ename, (SELECT dname FROM dept WHERE deptno = 10) 部门 FROM emp WHERE deptno = 10; 进一步理解查询语句，实际上是在表或集合中通过列名来得到行数据，子查询如果是多行，select无法做到这一点。\n在 having 后 和 where 类似。但需注意在where后面不能使用组函数。\n在having后面使用子查询的例子:\n查询部门平均工资高于30号部门平均工资的部门和平均工资\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal) \u0026gt; (SELECT avg(sal) FROM emp WHERE deptno = 30); 7.4 在from后面放置的子查询(***) 表, 代表一个数据集合、查询结果(SQL)语句本身也代表一个集合, 把查询结果看成一个表.\n查询员工的姓名、薪水和年薪：\n说明：该问题不用子查询也可以完成。但如果是一道填空题：\rselect * from ___________________\n因为显示的告诉了，要使用select *, 所以只能:\nSELECT * FROM (SELECT ename, sal, sal*12 年薪 FROM emp); 将select 语句放置到from后面，表示将select语句的结果，当成表来看待. 这种查询方式在Oracle语句中使用比较频繁.\n7.5 单行子查询只能使用单行操作符；多行子查询只能使用多行操作符 7.5.1单行子查询： 单行子查询就是该条子查询执行结束时, 只返回一条记录(一行数据)。\n使用单行操作符:\n=、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=\n单行子查询:\n单行子查询, 只能使用单行操作符\n在一个主查询中可以有多个子查询。\n子查询里面可以嵌套多层子查询。\n子查询也可以使用组函数。子查询也是查询语句，适用于前面所有知识。\n案例:\n查询emp表部门编号为10且高于本部门的平均工资的员工信息 SELECT * FROM emp WHERE sal\u0026gt; (SELECT avg(sal) FROM emp WHERE deptno=10) AND deptno=10; 查询emp表中与SMITH职位相同的员工信息 SELECT * FROM emp WHERE job = (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询薪水低于本公司的平均薪水且职位与SMITH职位相同的所有员工信息 SELECT * FROM emp WHERE sal\u0026lt; (SELECT avg(sal) FROM emp) AND job= (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询emp表中最低工资员工和最高工资员工的信息 SELECT * FROM emp WHERE sal= (SELECT max(sal) FROM emp) OR sal= (SELECT min(sal) FROM emp); 5 思考??,下列sql语句正确吗?\nSELECT * FROM emp WHERE sal= (SELECT min(sal) FROM emp GROUP BY deptno); 注意: =、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=是单行操作符, 而后面的子查询会返回多条记录,所以会报错, 要解决这个问题要使用多行子查询.\n7.5.2多行子查询： 子查询返回2条记录以上就叫多行。\n多行操作符有：\nIN\t等于列表中的任意一个\nANY\t和子查询返回的任意一个值比较\nALL\t和子查询返回的所有值比较\nIN(表示在集合中)：\n解决上面的那个问题?\nSELECT * FROM emp WHERE sal IN (SELECT min(sal) FROM emp GROUP BY deptno); 查询部门名称为SALES和ACCOUNTING的员工信息。\n分析：部门名称在dept表中，员工信息在emp表中,子查询应先去dept表中将SALES和ACCOUNTING的部门号得到，交给主查询得员工信息.\nSELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept WHERE dname IN (\u0026#39;SALES\u0026#39;, \u0026#39;ACCOUNTING\u0026#39;)); 也可以使用多表查询来解决该问题：\rSELECT e.* FROM emp e, dept d WHERE e.deptno = d.deptno AND (d.dname = \u0026#39;SALES\u0026#39; OR d.dname = \u0026#39;ACCOUNTING\u0026#39;); 红色语句也可以用 d.dname in ('SALES ', 'ACCOUNTING ')\n这种解决方式，注意使用()来控制优先级。 如果查询不是这两个部门的员工，只要把in → not in就可以了，注意不能含有空值。\nANY(表示和集合中的任意一个值比较)：\n查询薪水比30号部门任意一个员工高的员工信息：\n分析：首先查出30号部门的员工薪水的集合，然后\u0026gt;它就得到了该员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE deptno=30); # 正确吗？ 这样是错的，子句返回多行结果。而‘\u0026gt;’是单行操作符。——应该将‘\u0026gt;’替换成‘\u0026gt; any’\n实际上\u0026gt;集合的任意一个值，就是大于集合的最小值。\nSELECT * FROM emp WHERE sal \u0026gt; any (SELECT sal FROM emp WHERE deptno=30); 若将这条语句改写成单行子查询应该怎么写呢？\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT min(sal) FROM emp WHERE deptno=30); ALL(表示和集合中的所有值比较)：\n查询薪水比30号部门所有员工高的员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; ALL (SELECT sal FROM emp WHERE deptno=30); 同样，将该题改写成单行子句查询：\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT max(sal) FROM emp WHERE deptno=30); 对于any 和 all 来说，究竟取最大值还是取最小值，不一定。将上面的两个例子中的“高”换成“低”，any和all就各自取相反的值了。\n子查询中null 判断一个值等于、不等于空，不能使用=和!=号，而应该使用is 和 not。\n如果集合中有NULL值，不能使用not in。如： not in (10， 20， NULL)，但是可以使用in。为什么呢？\n先看一个例子：\n查询不是老板的员工信息：\n分析：不是老板就是树上的叶子节点。在emp表中有列mgr，该列表示该员工的老板的员工号是多少。那么，如果一个员工的员工号在这列中，那么说明这员工是老板，如果不在，说明他不是老板。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp); 但是运行没有结果，因为有NULL\n查询是老板的员工信息：只需要将not去掉。\nSELECT * FROM emp WHERE empno IN (SELECT mgr FROM emp ); 还是我们之前null的结论：in (10, 20, null) 可以，not in (10, 20, null) 不可以\nselect * from emp where deptno in (10, 20, null);\u0026mdash;\u0026ndash;可以\nSELECT * FROM emp WHERE deptno NOT IN (10, 20, null);# -----不可以 例如：a not in(10, 20, NULL) 等价于 (a != 10) and (a != 20) and (a != NULL)\n因为, not in操作符等价于 !=All，最后一个表达式为假，整体假;\n而a in (10, 20, NULL)等价于(a = 10) or (a = 20) or (a = null)只要有一个为真即为真。\nin 操作符等价于 = Any SELECT * FROM emp WHERE deptno = any(10, 20, null);\t# 等价于 SELECT * FROM emp WHERE deptno IN (10, 20, null); 继续，查询不是老板的员工信息, 只要将空值去掉即可。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp WHERE mgr is NOT null); 注意: not in 后面的结合中不能有null\n一般不在子查询中使用order by 一般情况下，子查询使用order by或是不使用order by对主查询来说没有什么意义。子查询的结果给主查询当成集合来使用，所以没有必要将子查询order by。\n但，在Top-N分析问题中，必须使用order by\n一般先执行子查询，再执行主查询 含有子查询的SQL语句执行的顺序是，先子后主。\n但，相关子查询例外.\n8 集合运算 l 查询部门号是10和20的员工信息?\t有三种方法\nSELECT * FROM emp WHERE deptno in(10, 20); SELECT * FROM emp WHERE deptno=10 OR deptno=20; n 集合运算：\nSELECT * FROM emp WHERE deptno=10;\t# 加上 SELECT * FROM emp WHERE deptno=20; 集合运算所操作的对象是两个或者多个集合，而不再是表中的列(select一直在操作表中的列)\n8.1 集合运算符 集合运算的操作符。A∩B、A∪ B、A - B\nSELECT * FROM emp WHERE deptno=10 UNION SELECT * FROM emp WHERE deptno=20; union和union all的区别: union会去掉重复的, 而union all会全部显示\n注意：这是一条SQL语句。\n8.2 集合运算需要注意的问题： 参与运算的各个集合必须列数相同，且对应每个列的类型一致。\n采用第一个集合的表头作为最终使用的表头.\n可以使用括号()先执行后面的语句。\n问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出：\n分析SQL执行结果。\n第一部分数据是按照deptno和job进行分组；select 查询deptno、job、sum(sal)\n第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal)\n第三部分数据不按照任何条件分组，即group by null；select 查询sum(sal)\n所以，整体查询结果应该= group by deptno,job + group by deptno + group by null\n按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!\nSELECT deptno, job, sum(sal) FROM emp GROUP BY deptno,job UNION SELECT deptno, to_char(null), sum(sal) FROM emp GROUP BY deptno UNION SELECT to_number(null), to_char(null), sum(sal) FROM emp; 交集和差集与并集类似，也要注意以上三点。只不过算法不同而已。\n需要注意:集合运算的性能一般较差.\nSQL的执行时间：\n`set timing on/off`\t默认是off 9 数据处理 SQL语言的类型： 数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵 语言)，就是指代：insert、update、delete、select这四个操作。\nDDL语句。(Data Definition Language 数据定义语言)。 如：truncate table(截断/清空 一张表)\ncreate table(表)、create view(视图)、create index(索引)、create sequence(序列)、 create synonym(同义词)、alter table、drop table。 DCL语句。DCL（Data Control Language数据控制语言）如：\ncommit(提交)、rollback(回滚)\n插入数据insert： l 使用 INSERT 语句向表中插入数据。其语法为：\nINSERT INTO\t*table [(column [, column\u0026hellip;])]\nVALUES\t(value [, value\u0026hellip;]);\nl 如果：values后面的值，涵盖了表中的所有列，那么table的列名可以省略不写。\ndesc emp; 查看员工表的结构，得到所有的列名。\ninsert into emp values (1001, \u0026#39;Tom\u0026#39;, \u0026#39;Engineer\u0026#39;, 7839, sysdate, 5000, 200, 10 ); insert into emp values (1005, \u0026#39;Bone\u0026#39;, \u0026#39;Raphealy\u0026#39;, 7829, to_date(\u0026#39;17-12月-82\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;), NULL, 300, 20); l 如果:插入的时候没有插入所有的列, 就必须显式的写出这些列的名字。\ninsert into emp(empno, ename, sal, deptno) values(1002, \u0026#39;Marry\u0026#39;, 6000, 20); 注意：字符串和日期都应该使用 \u0026rsquo; \u0026lsquo;号引用起来.\nl 没有写出的列自动填NULL, 这种方式称之为“隐式插入空值”。\nl 显示插入空值: insert into emp(empno, ename, sal) values(1003, \u0026lsquo;Jim\u0026rsquo;, null);\n“\u0026amp;” 地址符： l 在insert语句中使用\u0026amp;可以让用户输入值:\ninsert into emp(empno, ename, sal, deptno) values(\u0026amp;empno, \u0026amp;ename, \u0026amp;sal, \u0026amp;deptno); 理论上“\u0026amp;”后面的变量名任意，习惯上一般与前面的列名相同，赋值的时候清楚在给谁赋值。\n当再次需要插入新员工的时候直接输入“/”就可以继续输入新员工的值, /表示重复刚刚执行过的sql语句.\nl 可以在DML的任意一个语句中输入“\u0026amp;”,\nSELECT empno, ename, sal, \u0026amp;t FROM emp ; 执行时，会提示你输入要查询的列名。当输入不同的列名时，显示不同的执行结果。\nselect * from \u0026amp;t; 修改t的值，可以查看不同表。\n总结: \u0026amp;类似于c语言中的宏替换, 只是进行简单的字符串替换操作, 但是select关键字不能用\u0026amp;指代. 如 \u0026amp;t * from emp; 而from, 表名, where 是可以用\u0026amp;指代的, 如: select * \u0026amp;t emp; select * from \u0026amp;t; select * from emp \u0026amp;t sal\u0026gt;2000;但是通常情况都是替换值.\n批处理： 一次插入多条数据, 使用一个新创建的表用来测试.\n创建一张与emp完全相同的表，用于测试。\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; SELECT * FROM tab; SELECT * FROM emp10; desc emp10; 一次性将emp表中所有10号部门的员工, 放到新表emp10中来。\ninsert into emp10SELECT * FROM emp WHERE deptno=10; 一次性将emp表中的指定列插入到表emp10中。\n注意：insert的列名, 要和select的列名一致\rinsert into emp10(empno, ename, sal, deptno); SELECT empno, ename, sal, deptno FROM emp WHERE deptno=10; 注意没有values关键字了, 但列名必须一一对应.\n总结: 子查询可以出现在DML的任何语句中.\n更新数据update 格式: update 表名 set col=值 where condtion\n对于更新操作来说，一般会有一个“where”条件，如果没有这限制条件，更新的就是整张表。\nUPDATE emp10 SET sal=4000, comm=300 WHERE ename = \u0026#39;CLARK\u0026#39;; 注意：若没有where限定，会将所有的员工的sal都设置成4000，comm设置成300；\n能否将某一列的值设置为null呢?\nUPDATE emp10 SET comm = null WHERE empno=1000; # ----可以 能否在查询的时候where条件中指定列的值为null吗?\nSELECT * FROM emp WHERE comm = null; # ----不可以 10 删除数据delete 格式: delete from 表名 where condtion\ndelete FROM emp10 WHERE empno=7782; 注意: 如不加\u0026quot;where\u0026quot;会将整张表的数据删除。\n“from”关键字在Oracle中可以省略不写，但MySQL中不可以;\r但在使用的时候建议还是加上from.\ndelete 和 truncate的区别： delete 逐条删除表“内容”，truncate 先摧毁表再重建。\n(由于delete使用频繁，Oracle对delete优化后delete快于truncate)\ndelete 是DML语句，truncate 是DDL语句。\nDML语句可以闪回(flashback)，DDL语句不可以闪回。\n（闪回： 做错了一个操作并且commit了，对应的撤销行为。了解）\n由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。\n（同样是由于Oracle对delete进行了优化，让delete不产生碎片）。\n两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动\ndelete不会释放空间，truncate 会释放空间\n用delete删除一张10M的表，空间不会释放。而truncate会。所以当确定表不再\n使用，应truncate\ndelete可以回滚rollback, truncate不可以回滚rollback。 delete和truncate的时效性 【做实验sql.sql】：验证delete和truncate的时效性。\t终端里@c:\\sql.sql\t可以执行脚本sql.sql\n语句执行时间记录开关：set timing on/off\r回显开关：set feedback on/off\r【测试步骤】：\t1. 关闭开关：\tSQL\u0026gt; set timing off;\tSQL\u0026gt; set feedback off; 2. 使用脚本创建表：\tSQL\u0026gt; @c:\\sql.sql 3. 打开时间开关：\tSQL\u0026gt; `set timing on; ` 4. 使用delete删除表内容：\tSQL\u0026gt; `delete from testdelete; ` 5. 删除表：\tSQL\u0026gt;`drop table testdelete purge;` 6. 关闭时间开关：\tSQL\u0026gt; `set timing off;` 7. 使用脚本创建表：\tSQL\u0026gt; `@c:\\sql.sql ` 8. 打开时间开关：\tSQL\u0026gt; `set timing on; `\r9. 使用truncate删除表内容：\tSQL\u0026gt; `truncate table testdelete;` 事务 联想现实生活中的银行转账业务, 从A账户把钱转给B账户.\n数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。\nn 数据库事务由以下的部分组成:\nØ 一个或多个DML 语句\nØ 一个 DDL(Data Definition Language – 数据定义语言) 语句\nØ 一个 DCL(Data Control Language – 数据控制语言) 语句\n事务的特点：要么都成功，要么都失败。\n事务的特性 l 事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。\n原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n一致性 (Consistency)：几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致。\n隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。\n持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。\n事务的起始标志：oracle中自动开启事务，以DML语句为开启标志。\n执行一个增删改查语句, 只要没有提交commit和回滚rollback, 操作都在一个事务中.\n事务的结束标志: 提交、回滚都是事务的结束标志。\n提交:\nØ 显示提交: commit\nØ 隐式提交\n有DDL语句，如：create table除了创建表之外还会隐式提交Create 之前所有没有提交的DML语句。\n正常退出(exit / quit) u 回滚:\nØ 显示回滚: rollback\nØ 隐式回滚: 掉电、宕机、非正常退出。\n控制事务 l 保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。\n【示例】：1. create table testsp ( tid number, tname varchar2(20)); DDL语句会隐式commit之前操作.\n2. `set feedback on; ` 打开回显\r3. `insert into testsp values(1, 'Tom');`\r4. `insert into testsp values(2, 'Mary');`\r5. `savepoint aaa;`\r6. `insert into testsp values(3, 'Moke');`\t故意将“Mike”错写成“Moke”。\r7. `select * from testsp; `\t三条数据都显示出来。\r8.` rollback to savepoint aaa;`\t回滚到保存点aaa\r9. `select * from testsp;` 发现表中的数据保存到第二条操作结束的位置\r需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。\nsavepoint主要用于在事务上下文中声明一个中间标记, 将一个长事务分隔为多个较小的部分, 和我们编写文档时, 习惯性保存一下一样, 都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一但commit之后，所有的savepoint将失效。\n隔离级别 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n脏读: 对于两个事物T1, T2, T1读取了已经被T2更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的\n不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.\n幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.\n​\nSQL99定义4中隔离级别：\nRead Uncommitted\t读未提交数据。\nRead Commited\t读已提交数据。\t（Oracle默认）\nRepeatable Read\t可重复读。\t（MySQL默认）\nSerializable\t序列化、串行化。 （查询也要等前一个事务结束）\nOracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。\nRead Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。\n11 创建和管理表 常见的数据库对象 数据库的对象: 经常使用的数据库对象有 表、视图、索引、序列、同义词等.\n表\t基本的数据存储集合，由行和列组成。\n视图\t从表中抽出的逻辑上相关的数据集合。\n序列\t提供有规律的数值。\n索引\t提高查询的效率\n同义词\t给对象起别名\n表的基本操作 基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：\n必须以字母开头\n必须在 1–30 个字符之间\n必须只能包含 A–Z, a–z, 0–9, _, $, 和 #\n必须不能和用户定义的其他对象重名\n必须不能是Oracle 的保留字\nOracle默认存储是都存为大写\n数据库名只能是1~8位, datalink可以是128位, 和其他一些特殊字符\n创建表 创建一张表必须具备：1. Create Table的权限 2. 存储空间。我们使用的scott/hr用户都具备这两点。\ncreate table test1 (tid number, tname varchar2(20), hiredate date default sysdate); default的作用是, 当向表中插入数据的时候, 没有指定时间的时候, 使用默认值sysdate。insert into test1(tid, tname) values(11, 'wangwu');\n插入时没有指定Hiredate列，取当前时间。\n创建表时， 列所使用的数据类型：\nrowid：行地址 ——伪列\nSELECT rowid, empno, deptno FROM emp; 看到该列存储的是一系列的地址(指针), 创建索引用.\n分析，之前我们使用过的创建表的语句：\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; 在这条语句中，“where 1=2”一定为假。所以是不能select到结果的，但是将这条子查询放到Create语句中，可以完成拷贝表结构的效果。最终emp10和emp有相同的结构。\n如果, “where”给定的是一个有效的条件, 就会在创建表的同时拷贝数据。如:\ncreate table emp20 ASSELECT * FROM emp WHERE deptno=20; 这样emp20在创建之初就有5条数据。\n创建一张表，要求包含：员工号 姓名 月薪 年薪 年收入 部门名称\n分析：[员工号 姓名 月薪 年薪 年收入]在emp表中, 部门名称在dept表中, 两个表是通过deptno部门编号联系起来的.\n根据要求，涉及emp和dept两张表(至少有一个where条件)，并且要使用表达式来计算年收入和年薪。\ncreate table empincome AS ↓SELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 必须要给表达式取别名(语法要求) 由于此时的“where”条件是有效的条件，就会在创建表的同时拷贝数据。\n创建“视图”的语法与上边表的语法、顺序几乎完全一样，只是将“table”→“view”即可。\n修改表 ALTER TABLE\n追加一列: 向test1表中加入新列 image 类型是blob\nalter table test1 add image blob; desc test1; 修改一列: 将tname列的大小有20→40.\nalter table test1 modify tname varchar2(40); 删除一列: 将刚加入的新列image删除.\nalter table test1 drop column image; 重命名一列: 将列tname重命名为username.\nalter table test1 rename column tname to username;\t注意: 若是修改表的字段的长度, 若是增加长度没有问题, 若是减少字段的长度, 有可能会报错.\n删除表 当表被删除：\n数据和结构都被删除\n所有正在运行的相关事物被提交\n所有相关索引被删除\nDROP TABLE 语句不能回滚，但是可以闪回\nselect * from tab; 查看当前用户下有哪些表, 拷贝保存表名。\ndrop table testsp; 将测试保存点的表删除。\nselect * from tab; 再次查询跟刚刚保存的表名比对，少了testsp，但多了另外一张命名复杂的表。\nOracle的回收站：\n查看回收站：show recyclebin (sqlplus 命令)那个复杂的命名即是testsp在回收站中的名字。 select * from testsp; 这样是不能访问的。\nselect * from \u0026ldquo;BIN$+vu2thd8TiaX5pA3GKHsng==$0\u0026rdquo; 要使用“回收站中的名字”\n清空回收站：purge recyclebin\ndrop table test1 purge 表示直接删除表，不经过回收站。\n将表从回收站里恢复，涉及“闪回”的知识，作为了解性知识点。\n将表从回收站闪回\nflashback table t2 to before drop; 清空回收站\npurge recyclebin; 注意：并不是所有的用户都有“回收站”，对于没有回收站的用户（管理员）来说，删除操作是不可逆的.\n重命名表 rename test1 to test8;\tTruncate Table：DDL语句\t——注意：不能回滚(rollback)\n约束： 约束的种类 Not Null\t非空约束\n例如：人的名字，不允许为空。\rUnique\t唯一性约束\n例如：电子邮件地址，不可以重复。\rPrimary Key\t主键约束\n通过这个列的值可以唯一的确认一行记录，主键约束隐含Not null + Unique\rForeign Key\t外键约束\n​\n例如：部门表dept和员工表emp，不应该存在不属于任何一个部门的员工。用来约束两张表的关系。\n注意：如果父表的记录被子表引用的话，父表的记录默认不能删除。解决方法：\n1）\t先将子表的内容删除，然后在删除父表。\r2）\t将子表外键一列设置为NULL值，断开引用关系，然后删除父表。\r无论哪种方法，都要在两个表进行操作。所以定义外键时，可以通过references指定如下参数：\nON DELETE CASCADE：当删除父表时，如发现父表内容被子表引用，级联删除子表引用记录。\nON DELETE SET NULL：当发现上述情况，先把子表中对应外键值置空，再删除父表。\n多数情况下，使用SET NULL方法，防止子表列被删除，数据出错。\nCheck检查性约束\n如：教室中所有人的性别；工作后薪水满足的条件。\r新建一个测试表: test7\ncreate table test7 (tid number, tname varchar2(20), gender varchar(6) check (gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)),\tsal number check (sal \u0026gt; 0)\t); 说明:\ncheck (gender in (\u0026lsquo;男\u0026rsquo;, \u0026lsquo;女\u0026rsquo;)) 检查插入的性别是不是‘男’或‘女’（单引号）。\ncheck (sal \u0026gt; 0)\t检查薪水必须是一个正数。\r测试: insert into test7 values(1, 'Tom', '男', 1000); 没有问题.\n如果插入: insert into test7 values(2, \u0026lsquo;Mary\u0026rsquo;, \u0026lsquo;啊\u0026rsquo;, 2000); 会报错.\nORA-02290：违反检查约束条件SCOTT.SYS_C005523, gender的值只能取’男’或者’女’.\n其中的“SYS_C005523”是约束的名字，由于在定义约束时没有显式指定，系统默认给起了这样一个名称。所以我们建议，创建约束的时候，自定义一个见名知意的约束名。\nconstraint: 使用该关键字，来给约束起别名。\n约束举例 【约束举例】：\ncreate table student ( sid number constraint student_PK primary key, # --学生Id主键约束 sname varchar2(20) constraint student_name_notnull not null, # --学生姓名非空约束 email varchar2(20) constraint student_email_unique unique\t# --学生邮件唯一约束 constraint student_email_notnull not null,\t# --同时邮件可再设非空，没有, age number constraint student_age_min check(age \u0026gt; 10),\t# --学生年龄设置check约束 gender varchar2(6) constraint gender_female_or_male check(gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)), deptno number constraint student_FK references dept (deptno) ON DELETE SET NULL ); 在定义学生deptno列的时候，引用部门表的部门号一列作为外键，同时使用references设置级联操作\n——当删除dept表的deptno的时候，将student表的deptno置空。\r查看student表各列的约束\ndesc student; student的建表语句:\nSELECT dbms_metadata.get_ddl(\u0026#39;TABLE\u0026#39;, \u0026#39;STUDENT\u0026#39;) FROM dual; 测试用例：\ninsert into student values(1, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 20, \u0026#39;男\u0026#39;, 10); # 正确插入表数据。 insert into student values(2, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 15, \u0026#39;男\u0026#39;, 10); 违反student_email_unique约束。\rinsert into student values(3, \u0026#39;Tom3\u0026#39;, \u0026#39;tom3@126.com\u0026#39;, 14, \u0026#39;男\u0026#39;,100 ); 违反完整约束条件 (SCOTT.STUDENT_FK) - 未找到父项关键字\r问题：是不是父表的所有列，都可以设置为子表的外键？作外键有要求吗？\n外键：必须是父表的主键.\r查看指定表（如student）的约束, 注意表名必须大写。\nSELECT constraint_name, constraint_Type, search_condition FROM user_constraints WHERE table_name=\u0026#39;STUDENT\u0026#39;; 12 其它数据库对象 视图： 视图是一种常见数据库对象, 它是从表中抽出的逻辑上相关的数据集合。\n所以：1. 视图基于表。2. 视图是逻辑概念。3. 视图本身没有数据。\n创建视图 创建语法与创建表类似，只需要将table → view即可:\ncreate view empincomeview ASSELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 出错提示：权限不足。因为创建视图需要“create view”的权限。默认scott用户没有该种权限。加之！\r添加步骤：\n使用管理员登陆：sqlplus / as sysdba\n给scott用户增加权限\ngrant create view to scott; 执行“/”可成功创建视图empincomeview.\n视图的操作和表的操作完全一样.\nSELECT * FROM empincomeview; 视图的优点： 视图的优点\n简化复杂查询: 原来分组、多表、子查询等可以用一条select * from xxxview代替,视图可以看做是表的复杂的SQL一种封装。\n限制数据访问: 只看视图的结构和数据是无法清楚视图是怎样得来的。可以限制数据的访问。例如：银行项目，所谓的各个“表”都是“视图”，并有可能只是“只读视图”\n注意：1. 视图不能提高性能 2. 不建议通过视图对表进行修改。\n创建视图细节： 使用下面的语法格式创建视图：\nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view\n[(alias[, alias]\u0026hellip;)]\nAS subquery\n[WITH CHECK OPTION [CONSTRAINT constraint]]\n[WITH READ ONLY [CONSTRAINT constraint]];\n视图只能创建、删除、替换。（不能修改，修改即替换replace）\n如：刚刚创建的empincomeview，其他语句不变，将create一行改写成：\ncreate # 视图不存在则创建、存在则替换。 OR replace view empincomeview AS select…… from…..where….. WITH read only; # 可以将视图设为只读视图。 别名: 可以写在子查询select各个列的后面，也可以写在视图的名字后面。\nwith read only 表示该视图为只读视图。\nwith check option\t了解即可， 举例：\ncreate view testview ASSELECT * FROM emp WHERE deptno=10 WITH check option; insert into testview values(******, 10); 不建议向视图插入，但可以做。向视图插入10号员工。\ninsert into testview values(******, 20); 因为创建视图时加了“with check option”，所以失败。\n视图中使用DML的规定：\n一：\n当视图定义中包含以下元素之一时不能使用delete:\n组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n二：\n当视图定义中包含以下元素之一时不能使用update :\r组函数\nGROUP BY子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n三：\n当视图定义中包含以下元素之一时不能使用insert :\r组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n表中非空的列在视图定义中未包括\n总结一句话：不通过视图做insert、update、delete操作。因为视图提供的目的就是为了简化查询。\n删除视图:\ndrop view testview; \u0026mdash;\u0026mdash;à不加“purge”关键字。\n序列： 可以理解成数组：默认，从[1]开始，长度[20]\t[1, 2, 3, 4, 5, 6, …, 20]\t在内存中。\n由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。\n序列的使用： 初始状态下：指针指向1前面的位置。欲取出第一个值，应该将向后移动。每取出一个值指针都向后移。\n常常用序列来指定表中的主键。\n创建序列：create sequence myseq 来创建一个序列。\n​\n创建序列：\nCREATE SEQUENCE sequence [INCREMENT BY n] [START WITH n] [{MAXVALUE n | NOMAXVALUE}] [{MINVALUE n | NOMINVALUE}] [{CYCLE | NOCYCLE}] [{CACHE n | NOCACHE}]; NOCACHE表示没有缓存，一次不产生20个，而只产生一个。\n创建序列 创建序列、表，以备后续测试使用：\n`create sequence myseq;` 按默认属性创建一个序列。\rcreate table tableA (tid number, tname varchar2(20)); tid作为主键，准备使用序列来向表中插入值。\n序列的属性： 每个序列都有两个属性, nextval和currval.\nNextVal 必须在CurrVal之前被指定。因为初始状态下，CurrVal指向1前面的位置，无值\n对于新创建的序列使用select myseq.currval from dual; 得到出错。\n但select myseq.nextval from dual; 可以得到序列的第一值1.\n此时再执行select myseq.currval from dual; currval的值也得到1\n使用序列给tableA表创建主键tid：\ninsert into tableA values(myseq.nextval, ‘aaa’) 只有nextval取完会向后移动，使用currval不会移动。\rinsert into tableA values(myseq.nextval, ‘bbb’) 继续使用nextval向表中添加主键tid\rinsert into tableA values(myseq.nextval, \u0026amp;name) 可以使用“\u0026amp;”和“/”来指定名字。\rSELECT * FROM tableA; 由于前面测试currval和nextval关系时调用过nextval，所以tableA的tid起始从2开始。\n查询序列的属性：``select * from user_sequences; user_sequences`为数据字典视图。\n修改序列：\n必须是序列的拥有者或对序列有 ALTER 权限\n只有将来的序列值会被改变\n改变序列的初始值只能通过删除序列之后重建序列的方法实现\n删除序列：drop sequence myseq; 使用序列需要注意的地方: 应首先执行nextval, 之后才能使用currval的值, 刚刚创建的序列不能直接使用currval的值.\n使用序列需要注意的问题： 序列是公有对象，所以多张表同时使用序列，会造成主键不连续。\t如：[1, 2, 3, 4, 5, …, 20] tableA:\t1\t2\t4\ntableB:\t3\t5\tA、B表有可能主键不连续。\n回滚也可能造成主键不连续。\t如：多次调用insert操作使用序列创建主键。但是当执行了rollback后再次使用insert借助序列创建主键的时候，nextval不会随着回滚操作回退。\n掉电等原因，也可能造成不连续。由于代表序列的数组保存在内存中，断电的时候内存的内容丢失。恢复供电时候，序列直接从21开始。\n索引： 索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）\n一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中\n索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度\n索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引\n在删除一个表时, 所有基于该表的索引会自动被删除\n通过指针加速 Oracle 服务器的查询速度\n通过快速定位数据的方法，减少磁盘 I/O\n上图中：\nemp表中保存数据，其中包含部门号列。有10号部门，有20部门员工\n当 select * from emp where deptno=10 的时候。由于10号部门员工不连续，没规律。\n为了提高访问速度，可以在数据库中，依照rowid给deptno列建立索引\ncreate index myindex ON emp(deptno); 这样就建立了“索引表”可以通过rowid保存的行地址快速的找到表中数据。即使表中数据不连续。\r建立了索引以后，如果再执行select语句的时候，会先检查表上是否有索引表。如果有，可以通过有规律的rowid找到连续的数据。\nOracle的数据库中，索引有 B树索引（默认）和 位图索引两种。\n使用create index 索引表名 on 表名（列名1， 列名2…）;来创建索引表。由数据库自动进行维护。\n使用主键查询数据最快速，因为主键本身就是“索引”，所以检索比较快。\n索引使用的场景：\n以下情况可以创建索引:\n列中数据值分布范围很广\n列经常在 WHERE 子句或连接条件中出现\n表经常被访问而且数据量很大, 访问的数据大概占数据总量的2%到4%\n下列情况不要创建索引:\n表很小\n列不经常作为连接条件或出现在WHERE子句中\n查询的数据大于2%到4%\n表经常更新\n删除索引: drop index myindex;\nsynonym同义词： 就是指表的别名。\n如：scott用户想访问hr用户下的表employees。默认是不能访问的。需要hr用户为scott用户授权.\n`sqplus hr/11\t或 conn hr/11`（已登录界面， 切换登陆）\rgrant select ON employees to scott; hr用户为scott用户开放了employees表的查询权限。\n这时scott用户就可以使用select语句，来查询hr用户下的employees表的信息了。\nSELECT count(*) FROM hr.employees; ​\t若用户名叫zhangsanfeng则zhangsanfeng.employees\nhr.employees名字过长，为了方便操作，scott用户为它重设别名:\ncreate synonym hremp for hr.employees; # 为hr.employees创建了同义词。 如有权限限制，那么切换管理员登录，给scott用户添加设置同义词权限。\nconn / as sysdba; grant create synonym to scott; SELECT count(*) FROM hremp; # 使用同义词进行表查询操作。 同义词、视图 等用法在数据保密要求较高的机构使用广泛，如银行机构。好处是既不影响对数据的操作，同时又能保证数据的安全。\nOCA\nOCP\nOCM\t认证\nSELECT rownum, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) WHERE rownum \u0026lt;=3; SELECT * FROM (SELECT rownum rn, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) ) WHERE rn\u0026gt;=4 AND rn\u0026lt;=7; SELECT d.deptno, e.empno, e.ename, d.avgsal, e.sal FROM emp e, (SELECT deptno, avg(sal) avgsal FROM emp GROUP BY deptno) d WHERE e.deptno=d.deptno AND e.sal\u0026gt;d.avgsal; ","date":"2022-01-09T16:51:29Z","permalink":"https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Oracle数据库介绍"},{"content":" 1. 一些基本概念 ###1.1 Nginx初步认识\nNginx介绍\nengine x\n俄罗斯\n开源的框架\nc语言\nTengine - 淘宝基于nginx修改的\nNginx能干什么?\n作为web服务器 解析http协议 反向代理服务器 了解反向代理的概念 邮件服务器 解析邮件相关的协议: pop3/smtp/imap Nginx的优势?\n更快\n高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求 高扩展\n低耦合设计的模块组成,丰富的第三方模块支持 高可靠\n经过大批网站检验 www.sina.com.cn www.xunlei.com www.163.com 每个worker进程相对独立, 出错之后可以快速开启新的worker worker进程的个数是可以控制的 在后台干活的进程 低内存消耗\n一般情况下,10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗 2.5M内存 单机支持10万以上的并发连接\n取决于内存,10万远未封顶 热部署\nmaster和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件 最自由的BSD许可协议\nBSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布 淘宝: tengine 1.2 正向/反向代理 正向代理\n正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。\n正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径, 比如:\n学校的局域网\n单位局域网访问外部资源\n正向代理服务器是为用户服务的\n反向代理\n反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。\n客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的\n请求直接发给反向代理服务器\n反向代理服务器将请求转发给后边的web服务器\nweb服务器 N 台 反向代理服务器转发请求会轮询进行 web服务器收到请求进行处理, 得到结果\nweb服务器将处理结果发送给反向代理服务器\n反向代理服务器将拿到的结果转发给客户端\n1.3 域名和IP 什么是域名？ https://www.baidu.com https://www.jd.com https://taobao.com 什么是IP地址？ 点分十进制的字符串 11.22.34.45 域名和IP地址的关系？ 域名绑定IP 一个域名只能绑定一个IP 一个IP地址被多个域名绑定 2. Nginx 安装和配置 2.1 安装 切换到/usr/local/src目录\n下载\n官方地址: nginx: download 下载 wget http://nginx.org/download/nginx-1.19.9.tar.gz 解压 tar -zxvf nginx-1.19.9.tar.gz Nginx相关依赖: OpenSSL: http://www.openssl.org/ 密码库 使用https进行通信的时候使用 下载 git clone https://github.com.cnpmjs.org/openssl/openssl.git 安装 cd openssl ./Configure make make install ZLib下载: http://www.zlib.net/ 数据压缩 下载 wget http://zlib.net/zlib-1.2.11.tar.gz 安装: tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make sudo make install PCRE下载: http://www.pcre.org/ 解析正则表达式 下载 wget https://ftp.pcre.org/pub/pcre/pcre-8.45.tar.gz 安装 tar -zxvf pcre-8.45.tar.gz cd pcre-8.45 ./configure make sudo make install 安装\nnginx的安装\n进入nginx目录cd nginx-1.19.9\n# nginx工作时候需要依赖三个库 # 三个参数=这三个库对应的源码安装目录 # 根据自己的电脑的库安装包的位置进行指定 ./configure --with-openssl=/usr/local/src/openssl \\ --sbin-path=/usr/local/nginx/sbin/nginx \\ --with-pcre=/usr/local/src/pcre-8.45 \\ --with-zlib=/usr/local/src/zlib-1.2.11 \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/conf/nginx.pid \\ --lock-path=/usr/local/nginx/conf/nginx.lock \\ --with-http_gzip_static_module \\ --with-http_stub_status_module \\ --with-file-aio \\ --with-http_realip_module \\ --with-http_ssl_module \\ --with-ipv6 make -j2 sudo make install Nginx 相关的指令\nNginx的默认安装目录\n/usr/local/nginx conf -\u0026gt; 存储配置文件的目录 html -\u0026gt; 默认的存储网站(服务器)静态资源的目录 [图片, html, js, css] logs -\u0026gt; 存储log日志 sbin -\u0026gt; 启动nginx的可执行程序 Nginx可执行程序的路径\n/usr/local/nginx/sbin/nginx # 快速启动的方式 # 1. 将/usr/local/nginx/sbin/添加到环境变量PATH中 # 2. /usr/local/nginx/sbin/nginx创建软连接, 放到PATH对应的路径中, 比如: /usr/bin ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 启动Nginx - 需要管理器权限\n# 假设软连接已经创建完毕 sudo nginx # 启动 关闭Nginx\n# 第一种, 马上关闭 sudo nginx -s stop # 第二种, 等nginx作为当前操作之后关闭 sudo nginx -s quit 重新加载Nginx\nsudo nginx -s reload # 修改了nginx的配置文件之后, 需要执行该命令 测试是否安装成功\n知道nginx对应的主机的IP地址 - \u0026gt; 192.168.1.100 在浏览器中访问该IP地址 看到一个welcom nginx的欢迎界面 2.2 配置 Nginx配置文件的位置\n/usr/local/nginx/conf/nginx.conf Nginx配置文件的组织格式\nhttp -\u0026gt; 模块, http相关的通信设置 server模块 -\u0026gt; 每个server对应的是一台web服务器 location 模块 处理的是客户端的请求 mail -\u0026gt; 模块, 处理邮件相关的动作 常用配置项介绍\nuser nobody; # 启动之后的worker进程属于谁 - 错误提示: nginx操作xxx文件时候失败, 原因: Permission denied - 将nobody -\u0026gt; root worker_processes 1; # 设置worker进程的个数, 最大 == cpu的核数 (推荐) error_log logs/error.log; # 错误日志, /usr/local/nginx pid logs/nginx.pid; # pid文件, 里边是nginx的进程ID # nginx的事件处理 events { use epoll;\t# 多路IO转接模型使用epoll worker_connections 1024;\t// 每个工作的进程的最大连接数 } http-\u0026gt;server -\u0026gt; 每个server模块可以看做一台web服务器 server{ listen 80; # web服务器监听的端口, http协议的默认端口 server_name localhost; # 对应一个域名, 客户端通过该域名访问服务器 charset utf8; # 字符串编码 location {\t// 模块, 处理客户端的请求 } # 客户端 (浏览器), 请求: http://192.168.10.100:80/login.html # 服务器处理客户端的请求 服务器要处理的指令如何从url中提取? - 去掉协议: http - 去掉IP/域名+端口: 192.168.10.100:80 - 最后如果是文件名, 去掉该名字: login.html - 剩下的: / 服务器要处理的location指令: location / { 处理动作 } 3. Nginx的使用 3.1 部署静态网页 静态网页存储目录\n默认的存储目录:\n/usr/local/nginx/html 自己创建新的目录:\n应该在 /usr/local/nginx/ mkdir /usr/local/nginx/mydir 练习\n在Nginx服务器上进行网页部署, 实现如下访问:\n在/usr/local/nginx/创建新的目录, yundisk用来存储静态网页\n访问地址: http://192.168.80.254/login.html\nlogin.html放到什么位置?\n/ -\u0026gt; 服务器的资源根目录, /usr/local/nginx/yundisk login.htm-\u0026gt; 放到yundisk中 服务器要处理的动作\n# 对应这个请求服务器要添加一个location location 指令(/) { # 找一个静态网页 root yundisk; # 相对于/usr/local/nginx/来找 # 客户端的请求是一个目录, nginx需要找一默认显示的网页 index index.html index.htm; } # 配置之后重启nginx sudo nginx -s reload 访问地址: http://192.168.80.254/hello/reg.html\nhello是什么?\n目录 reg.html放到哪儿?\nhello目录中 如何添加location\nlocation /hello/ { root yundisk; index xx.html; } 访问地址: http://192.168.80.254/upload/ 浏览器显示upload.html\n直接访问一个目录, 得到一默认网页\nupload是一个目录, uplaod.html应该再upload目录中\nlocation /upload/ { root yundisk; index upload.html; } 3.2 反向代理和负载均衡 反向代理和负载均衡是两码事儿\n准备工作:\n需要客户端 - 1个 Window中的浏览器作为客户端 反向代理服务器 -\u0026gt; 1个 window作为反向代理服务器 web服务器 -\u0026gt; 2个 ubuntu - robin: 192.168.247.135 ubuntu - luffy : 192.168.26.250 反向代理设置\n找window上对应的nginx的配置文件 - conf/nginx.conf # 代理几台服务器就需要几个server模块 # 客户端访问的url: http://192.168.1.100/login.html server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name ubuntu.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://robin.test.com; } } # 添加一个代理模块 upstream robin.test.com { server 192.168.247.135:80; } # luffy server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name hello.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://luffy.test.com; } } # 添加一个代理模块 upstream luffy.test.com { server 192.168.26.250:80; } } 负载均衡设置\nserver { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name localhost; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /hello/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /upload/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } } # 添加一个代理模块 upstream linux.com { server 192.168.247.135:80 weight=1; server 192.168.26.250:80 weight=3; } ## ===================================== web服务器需要做什么? # 192.168.247.135 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } # 192.168.26.250 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } 课外知识导读 1. URL和URI 概念:\nURL（Uniform Resource Locator）: 统一资源定位符\n表示资源位置的字符串\n基本格式: \u0026ldquo;协议://IP地址/路径和文件名\u0026rdquo; ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt telnet://192.0.2.16:80/ URN（Uniform Resource Name）: 统一资源名称\nP2P下载中使用的磁力链接 URI（Uniform Resource Identifier）: 统一资源标识符\n是一个紧凑的字符串用来标示抽象或物理资源, URL是URI的一种 让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. http:// or ftp://。 files.hp.com tel:+1-816-555-1212 ftp://ftp.is.co.za/rfc/rfc1808.txt （also a URL） http://www.ietf.org/rfc/rfc2396.txt （also a URL） telnet://192.0.2.16:80/ （also a URL） 经验式理解:\n从包含关系上说: URI包含URL\n字符串长度上说: URL包含URI\nUIRI可以没有协议, 没有地址(IP/域名)\nURL 红色字体部分+绿色字体部分 URI 绿色字体部分 2. DNS解析过程 DNS解析的过程\n在浏览器中输入www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到www.magedu.com主机。 如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 域名解析服务器\nPod DNS+:\n首选：119.29.29.29 备选：182.254.116.116 114DNS:\n首选：114.114.114.114 备选：114.114.114.115 阿里 AliDNS:\n首选：223.5.5.5\n备选：223.6.6.6\nhosts文件\n# 存储的是域名和IP的对应关系 -windows目录: \u0026#34;C:\\Windows\\System32\\drivers\\etc\\hosts\u0026#34; 复习 redis\n是什么?\n非关系型数据库 - nosql 数据存储在内存里边 能干什么?\n提高程序效率 程序中频繁访问的数据, 可以存储到redis中 我们需要干什么?\n会安装\n掌握启动redis服务器和客户端的启动命令\n# 服务器 redis-server (配置文件名) # 客户端 redis-cli (-h redis服务器IP -p 端口) redis中支持的数据类型 - value\n键值对方式存储数据\nkey - 字符串 value 字符串 - string 列表 - list 集合 - set 排序集合 - sortedSet 哈希 - hash 关于服务器使用的配置文件的修改\nredis中持久化\nrdb aof 能够在程序中操作redis服务器\n需要使用以下函数接口 官方地址 - \u0026gt; 客户端 -\u0026gt; 选择语言 ","date":"2022-01-08T16:07:29Z","permalink":"https://okokfun.github.io/post/nginx%E5%AE%89%E8%A3%85/","title":"nginx安装"},{"content":" MySQL数据库API库 访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。\n可使用mysql -V 命令查看当前系统内所使用的mysql数据库版本信息。数据库版本为5.6.20版。因此，我们可从帮助手册refman-5.6-en.a4.pdf入手，了解学习MySQL C API使用的一般信息。\n从API手册23.8中可获取信息，MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数-I、-L、-l。\n从手册中可获知，函数库名为mysqlclient。\n因此我们使用命令:\nfind / -name libmysqlclient* 查找该库的路径。得到 /usr/lib64/mysql/libmysqlclient.a。 nm /usr/lib64/mysql/libmysqlclient.a命令可查看库内包含的函数。\n编写hello应用链接函数库 编写一个hello.c应用程序，链接使用该库。\n用到头文件 \u0026lt;mysql.h\u0026gt; 可使用locate mysql.h查看其目录位置/usr/include/mysql/mysql.h。\n编译引用了库的应用程序。\ngcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient 参见帮助手册refman-5.6-en.a4.pdf：23.8.4.3小节。\nMySQL API常用函数 总体印象 使用MySQL库API函数的一般步骤：\na. 初始化. MYSQL *mysql_init(MYSQL *mysql);\nb. 错误处理\tunsigned int mysql_errno(MYSQL *mysql);\rchar *mysql_error(MYSQL *mysql);\nc. 建立连接.\tMYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);\nd. 执行SQL语句\tint mysql_query(MYSQL *mysql, const char *stmt_str);\ne. 获取结果\tMYSQL_RES *mysql_store_result(MYSQL *mysql) MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);\nf. 释放内存\tvoid mysql_free_result(MYSQL_RES *result);\ng. 关闭连接\tvoid mysql_close(MYSQL *mysql);\n初始化 编写程序测试 初始化函数MYSQL *mysql_init(MYSQL *mysql)。\n其中有一种新数据类型MYSQL。可在头文件mysql.h → 263. typedef struct st_mysql {\u0026hellip;} MYSQL;找到其定义。是一个结构体。\n处理错误码的函数：unsigned int mysql_errno(MYSQL *mysql) #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); return 0; } 编译出错，原因是64位Linux环境下，动态库配置不完整。 需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：\n__gxx_personality_v0 \u0026ndash;\u0026gt; -lstdc++\t使用g++相关的环境\ndlclose/dlopen/dlsym\t\u0026ndash;\u0026gt;\t-ldl\t完成用一个程序加载其他动态库的作用。\npthread_*\t\u0026ndash;\u0026gt; -lpthread\t线程库\nmy_getsystime'/clock_gettime\u0026rsquo;\t\u0026ndash;\u0026gt; -lrt\tlibrt.so是glibc中对real-time的支持库\n使用ldd命令可以查看该可执行文件运行所依赖的库文件。\nMakefile 管理 src = $(wildcard *.c) target = $(patsubst %.c, %, $(src)) inc_path = /usr/include/mysql/ lib_path = /usr/lib64/mysql/ all: $(target) %:%.c gcc $\u0026lt; -o $@ -I$(inc_path) -L$(lib_path) -lmysqlclient -lstdc++ -lpthread -ldl -lrt clean: -rm -rf $(target) .PHONY: all clean 注意：在测试makefile时，应先使用-n参数，检查无误再执行。\n连接数据库关闭连接 // 依据proc猜想应该是一个类似于connect的函数，查看API文档发现：mysql_connect();但该函数已经过时，应该使用手册中推荐的mysql_real_connect函数取而代之。 MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag ); // 根据手册中的描述，我们可以使用基础的链接方式与MySQL数据库建立连接。 mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0 ); // 连接数据库成功。对表中数据进行访问， //\t访问结束需调用void mysql_close(MYSQL *mysql) 函数关闭连接。 // 该函数在断开连接的同时，还可以解除分配由mysql指向的连接句柄。 mysql_close(mysql); 读取数据 查询表数据 // mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。 // 是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。查询以\\0结尾的字符串。 // 如果语句中包含二进制数据，则需要调用mysql_real_query来执行查询语句。 // 函数原型：int mysql_query(MYSQL *mysql, const char *query);\t//\t成功返回0，失败返回非0 char *psql = \u0026#34;select * from emp\u0026#34;; ret = mysql_query(mysql, psql); 若执行的是UPDATE, DELETE或INSERT语句，则可通过mysql_affected_rows()获知受影响的记录数。\n若执行的是SELECT语句，查询结束后，查询结果被保存在mysql句柄中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。\n注意: mysql_query执行的SQL语句不应为语句添加终结分号（‘;’）或“\\g”。\n获取结果集 一种方式是通过mysql_store_result()将整个结果集全部取回来。另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过mysql_fetch_row()来访问每一条记录。\nMYSQL_RES *mysql_store_result(MYSQL *mysql) // 成功返回MYSQL_RES结果集指针，失败返回NULL。 // MYSQL_RES是一个结构体类型，可以从mysql.h头文件中找到该结构体的定义： mysql.h → 308. typedef struct st_mysql_res {...} MYSQL_RES; 整体获取的结果集，保存在 MYSQL_RES 结构体指针中，通过检查mysql_store_result()是否返回NULL，可检测函数执行是否成功：\nMYSQL_RES *result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} 该函数调用成功，则SQL查询的结果被保存在result中，但我们不清楚有多少条数据。所以应使用游标的方式将结果集中的数据逐条取出。\n解析结果集 通过游标一行一行fetch结果集中的数据。根据游标使用的一般特性，应使用循环结构，到达结尾或者出错，返回NULL。\n// 函数原型：MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) 成功返回下一行的MYSQL_ROW结构。 // 如果没有更多要检索的行或出现了错误，返回NULL。-----MYSQL_ROW定义在118行 select * from emp // 可以看到emp表一共有8列数据。可以循环将每行上每一列的数据显示到屏幕。 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); } MYSQL_ROW的本质是 typedef char ** MYSQL_ROW; 数据信息存储的形式如下图所示：\n从mysql.h头文件可查看MYSQL_ROW定义: 118. typedef char **MYSQL_ROW; /return data as array of string/\n// 从上图分析MYSQL_ROW为什么被定义为char**类型呢？推测mysq_fetch_row()的函数实现大致思想如下： char **mysql_fetch_row() { char **tmp = (char **) malloc(sizeof(char *) * 8); for (i = 0; i \u0026lt; 8; i++) { tmp[i] = (char *)malloc(50); } strcpy(tmp[0], \u0026#34;7369\u0026#34;); strcpy(tmp[1], \u0026#34;SMITH\u0026#34;); strcpy(tmp[2], \u0026#34;CLERK\u0026#34;); ... return tmp; } 释放结果集 结果集处理完成，应调用对应的函数释放所占用的内存。\nvoid mysql_free_result(MYSQL_RES *result); 成功释放参数传递的结果集。没有失败情况。\nmysql_free_result(result); 思考：上述实现是直接在MySQL工具中数出列数。找寻能获取列数的API函数、获取表头的API函数。\n获取列数 // 查看帮助手册可以看到，有两个函数具备获取列数的功能： unsigned int mysql_field_count(MYSQL *mysql) // 从mysql句柄中获取有多少列。 unsigned int mysql_num_fields(MYSQL_RES *result) // 从返回的结果集中获取有多少列。 // 选择任意一种方式均可以完成该功能。 int num = mysql_field_count(connect); while (row = mysql_fetch_row(result)) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); //printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); 获取表头 // 获取表头的API函数同样有两个： MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result) // 全部获取 MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result) // 获取单个 // MYSQL_FIELD也是一个结构体类型，其内部保存了选择列表项的信息， // 其中的name成员变量就保存着列名。可从头文件mysql.h中94-116行找到其定义。 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result);\t//得到表头的结构体数组 for (i = 0; i \u0026lt; num; i++) {\t//已通过 mysql_field_count\t获取了总列数\tprintf(\u0026#34;%s\\t\u0026#34;, fields[i].name);\t//每一列的列名保存在name成员中 } printf(\u0026#34;\\n\u0026#34;); 示例程序 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; char *psql = \u0026#34;select * from emp\u0026#34;;\tMYSQL_RES *result = NULL; MYSQL_FIELD *fields = NULL; MYSQL_ROW row = NULL;\tMYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, psql); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} num = mysql_field_count(mysql); result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } mysql_free_result(result); mysql_close(mysql); return 0;\t} MySQL tools实现 依托我们所学习的MySQL基础类API函数，可以编写程序实现简单的sqlplus/mysql 工具的功能。\n思路分析 \\1. 仿照mysql工具，应在连接数据库成功之后，在一个while循环中不断的接受用户输入的SQL语句。定义char sqlbuf[1024] 存储用户输入的SQL语句。初始化该buf，并提示用户输入SQL语句。使用gets函数在循环中动态接收用户输入。\nwhile (1) { memset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;\\nYourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin); } 在mysql_query(connect, sqlbuf)之前，如果用户输入了“exit”那么程序直接结束。\n在执行完 mysql_query(connect, sqlbuf)之后，应该判别用户输入的是否为select语句。如不是select语句不需要查询结果集、处理结果集等繁复操作。\n如用户输入的是有结果集的SQL语句，将获取列数、获取结果集、获取表头、解析结果集、释放结果集等相关代码一起并入if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6))中。\n测试注意：执行SQL语句时不要在结尾加“;”\n程序实现 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; //char *psql = \u0026#34;select * from emp\u0026#34;;\tchar sqlbuf[1024]; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, \u0026#34;set names utf8\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} while (1) {\tmemset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;YourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin);\tif (strncmp(sqlbuf, \u0026#34;exit\u0026#34;, 4) || strncmp(sqlbuf, \u0026#34;quit\u0026#34;, 4) ) { break; } ret = mysql_query(mysql, sqlbuf); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} if (strncmp(sqlbuf, \u0026#34;select\u0026#34;, 6) || strncmp(sqlbuf, \u0026#34;SELECT\u0026#34;, 6)) { num = mysql_field_count(mysql);\tMYSQL_RES *result = NULL; result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} //打印表头 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;);\t//解析结果集 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); }\tmysql_free_result(result);\t} else { printf(\u0026#34;\\n--- not select sql---\\n\u0026#34;); printf(\u0026#34;affected: %ld\\n\u0026#34;, (long)mysql_affected_rows(mysql)); } } mysql_close(mysql); return 0;\t} 中文问题： 修改mysql_real_connect()参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用mysql_query函数来解决该问题。\n在 while (1) 之前使用 ret = mysql_query(mysql, \u0026quot;set names utf8\u0026quot;); 来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。\n或者mysql_set_character_set(mysql, \u0026quot;utf8\u0026quot;);\n获取当前使用的字符集: const char *mysql_character_set_name(MYSQL *mysql)\n预处理类API函数： 该类函数解决问题：处理带有占位符的SQL语句。insert into table111(col1, col2, col3) values(?, ?, ?);\n这种SQL语句由两部分组成，一部分是SQL语句体模型部分，另一部分是？所匹配的值。\n性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。\n元数据（Metadata）：又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\n根据API提供的案例学习该部分内容。主要有 4 个函数：\nmysql_stmt_init()\t初始化预处理环境句柄。\t返回一个结构体指针 MYSQL_STMT *stmt\nmysql_stmt_prepare()\t向上面句柄中添加SQL语句，带有 (?,?,?) 占位符\nmysql_stmt_param_count() 求绑定变量的个数(辅助函数)， 有多少个\u0026rsquo;?\u0026lsquo;就返回多少\nmysql_stmt_bind_param()\t将?对应的实参，设置到预处理环境句柄中\nmysql_stmt_execute()\t执行预处理的SQL语句\n在不熟悉这套API函数的情况下，如何能快速的找到一个完整的案例，使用这套函数呢？分析：在以上4个过程中，哪个最重要呢？找到它，去查看API文档！发现有对应的demo程序。将该demo导入到我们的程序中，运行，观察它的作用。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define STRING_SIZE 50 #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(40),\\ col3 SMALLINT,\\ col4 TIMESTAMP)\u0026#34; #define INSERT_SAMPLE \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ////////////////////////以下为demo源码//////////////////////////////// MYSQL_STMT *stmt; MYSQL_BIND bind[3]; my_ulonglong affected_rows; int param_count; short small_data; int int_data; char str_data[STRING_SIZE]; unsigned long str_length; my_bool is_null; if (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } /* Prepare an INSERT query with 3 parameters */ /* (the TIMESTAMP column is not named; the server */ /* sets it to the current date and time) */ stmt = mysql_stmt_init(mysql); if (!stmt) { fprintf(stderr, \u0026#34; mysql_stmt_init(), out of memory\\n\u0026#34;); exit(0); } if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) { fprintf(stderr, \u0026#34; mysql_stmt_prepare(), INSERT failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } fprintf(stdout, \u0026#34; prepare, INSERT successful\\n\u0026#34;); /* Get the parameter count from the statement */ param_count= mysql_stmt_param_count(stmt); fprintf(stdout, \u0026#34; total parameters in INSERT: %d\\n\u0026#34;, param_count); if (param_count != 3) /* validate parameter count */ { fprintf(stderr, \u0026#34; invalid parameter count returned by MySQL\\n\u0026#34;); exit(0); } /* Bind the data for all 3 parameters */ memset(bind, 0, sizeof(bind)); /* INTEGER PARAM */ /* This is a number type, so there is no need to specify buffer_length */ bind[0].buffer_type = MYSQL_TYPE_LONG; bind[0].buffer = (char *)\u0026amp;int_data; bind[0].is_null = 0; bind[0].length = 0; /* STRING PARAM */ bind[1].buffer_type = MYSQL_TYPE_STRING; bind[1].buffer = (char *)str_data; bind[1].buffer_length = STRING_SIZE; bind[1].is_null = 0; bind[1].length = \u0026amp;str_length; /* SMALLINT PARAM */ bind[2].buffer_type = MYSQL_TYPE_SHORT; bind[2].buffer = (char *)\u0026amp;small_data; bind[2].is_null = \u0026amp;is_null; bind[2].length = 0; /* Bind the buffers */ if (mysql_stmt_bind_param(stmt, bind)) { fprintf(stderr, \u0026#34; mysql_stmt_bind_param() failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); }\t/* Specify the data values for the first row */ int_data= 10; /* integer */ strncpy(str_data, \u0026#34;MySQL\u0026#34;, STRING_SIZE); /* string */ str_length= strlen(str_data); /* INSERT SMALLINT data as NULL */ is_null= 1; /* Execute the INSERT statement - 1*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute(), 1 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } /* Get the total number of affected rows */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 1): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Specify data values for second row, then re-execute the statement */ int_data= 1000; strncpy(str_data, \u0026#34;The most popular Open Source database\u0026#34;, STRING_SIZE); str_length= strlen(str_data); small_data= 1000; /* smallint */ is_null= 0; /* reset */ /* Execute the INSERT statement - 2*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute, 2 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt));\texit(0); } /* Get the total rows affected */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 2): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Close the statement */ if (mysql_stmt_close(stmt)) { fprintf(stderr, \u0026#34; failed while closing the statement\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } mysql_close(mysql); printf(\u0026#34;hello mysql...\\n\u0026#34;); return 0;\t} 注意：bind \u0026ndash;\u0026gt; mysql.h下 MYSQL_BIND结构体 bind[3]; 是一个结构体数组。有3个‘?’占位符，所以用三个结构体(数组)来对应保存信息。0-\u0026gt;第一列；1-\u0026gt;第二列；2-\u0026gt;第三列。\nmysql.h中查找 MYSQL_BIND 结构体原型。对比：select * from teat_table; 和 desc test_table; 的查询结果。\n帮助理解bind的小程序框架：\ntypedef struct xxx{ char *p1; char *p2; char *p3; } MYSQL_BIND; void saveXXXInfo(MYSQL_BIND *bind, int num) { insert into test_table valudes(bind[0].p2, bind[1].p3, bind[2].p1); } int main(void) { MYSQL_BIND bind[3]; bind[0].p1 = \u0026#34;类型1\u0026#34;;\t//第一列 bind[0].p2 = \u0026#34;10\u0026#34;; bind[0].p3 = \u0026#34;其他数据\u0026#34;; bind[1].p1 = \u0026#34;类型\u0026#34;;\t//第二列 bind[1].p2 = \u0026#34;数据\u0026#34;; bind[1].p3 = \u0026#34;描述\u0026#34;; bind[2].p1 = \u0026#34;p1p1p1\u0026#34;;\t//第三列 //第四列是时间戳，不需要用户使用?来指定，直接使用了系统时间。 bind[2].p2 = \u0026#34;数据\u0026#34;; bind[2].p3 = \u0026#34;其他限定条件\u0026#34;;\tsaveXXXInfo(bind, 3); } 日期时间类API函数 练习：熟悉上述预处理类工作模式，模拟精简一个将时间插入数据库的程序。将时间存入数据库有两种方式：\n使用SQL语句方式\n预处理环境句柄变量方式存入\n提示：\nMYSQL_TIME ts;\t// 浏览头文件 mysql_time.h 熟悉MYSQL_TIME结构体。 MYSQL_BIND bind[3]; MYSQL_STMT *stmt; // 可直接使用SQL语句提前创建表test_table2，也可以使用mysql_query函数来创建。 create table test_table2 (date_field date, time_field time, timestamp_field timestamp); char query[1024] = \u0026#34;INSERT INTO test_table2(date_field, time_field, timestamp_field) VALUES(?,?,?)\u0026#34;; stmt = mysql_stmt_init(mysql); // MYSQL_TIME 是一个结构体，使用typedef定义。位于mysql_time.h文件中。\tAPI参考：refman-5.6-en.a4.pdf手册25.2.10. 日期和时间值的C API处理\n多查询执行的C API函数 一次性执行多条SQL语句，包括select、drop、update、create等。 如：\nmysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\\ DROP TABLE test_table\u0026#34;); 文档：25.2.9. 多查询执行的C API处理。中文文档只有demo框架。查阅对应英文文档refman-5.6-en.a4.pdf。关键字Multiple 23.8.17\r注意：打桩函数——函数接口\rif (mysql_real_connect (mysql, host_name, user_name, password,\rdb_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL)\rCLIENT_MULTI_STATEMENTS：客户端通知Server，将要发送多个SQL语句。\rmysql_field_count(mysql)：影响的行数。 如：\r当select * from dept;\t执行结束，提示：“5 rows in set”\t表示影响了4行。\r当Create一张表，\t执行结束，提示：“Query OK, 0 rows affected (0.01 sec)”\r当delete一行，\t执行结束，提示：“Query OK, 1 row affected (0.00 sec)”\rmysql_field_count函数调用后会将影响的行数保存到句柄 mysql 中。\r下方是帮助文档中demo程序，它将帮助我们分析与之前掌握的API函数间的区别与联系：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; void process_result_set(MYSQL *mysql, MYSQL_RES *result) { int i, num; num = mysql_field_count(mysql); MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); MYSQL_ROW row = NULL; while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int ret = 0, status = 0; MYSQL_RES *result = NULL; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, CLIENT_MULTI_STATEMENTS); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } /////////////////////////////以下为demo源码////////////////////////////// /* execute multiple statements */ status = mysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\u0026#34;); DROP TABLE test_table if (status) { printf(\u0026#34;Could not execute statement(s)\u0026#34;); mysql_close(mysql); exit(0); } /* process each statement result */ do { /* did current statement return data? */ result = mysql_store_result(mysql); if (result)\t{ /* yes; process rows and free the result set */ process_result_set(mysql, result); mysql_free_result(result); } else /* no result set or error */ { if (mysql_field_count(mysql) == 0) { printf(\u0026#34;%lld rows affected\\n\u0026#34;, mysql_affected_rows(mysql)); } else /* some error occurred */ { printf(\u0026#34;Could not retrieve result set\\n\u0026#34;); break; }\t} /* more results? -1 = no, \u0026gt;0 = error, 0 = yes (keep looping) */ if ((status = mysql_next_result(mysql)) \u0026gt; 0) printf(\u0026#34;Could not execute statement\\n\u0026#34;); printf(\u0026#34;------------status: %d\\n\u0026#34;, status); } while (status == 0); mysql_close(mysql);\treturn 0; } process_result_set函数是文档中给我们预留的打桩函数，需要我们在使用的过程中，自己实现它。\n函数实现就是借助mysql和result两个参数打印一条sql语句查询到的结果集到屏幕。\n可以直接使用mysq_tool.c中if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6) == 0 || strncmp(sqlbuf, \u0026quot;SELECT\u0026quot;, 6) == 0)内的代码。“获取结果集”片段可以删除。“释放结果集”片段可以删除。API示例中含有该部分内容。\n常见错误：在process_result_set函数实现中，不要使用mysql_store_result(mysql)再次获取结果集， 该result已经在API函数接口传入，直接使用参数result即可。否则会出现【段错误】。\nMySQL中的事务 测试MySQL中事务的特性。\nMySQL的事务的默认自动提交的，每执行一个sql语句都自动commit\rOracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit\r在程序中设置autocommit修改MySQL事务的属性。\nset autocommit = 0 禁止自动提交\rset autocommit = 1 开启自动提交MySQL中InnoDB引擎才支持事务默认自动提交机制。MYISAM引擎不支持。\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define SET_TRAN\t\u0026#34;SET AUTOCOMMIT=0\u0026#34; //手动commit\t#define UNSET_TRAN\t\u0026#34;SET AUTOCOMMIT=1\u0026#34;\t//自动commit //设置事务为手动提交 int mysql_OperationTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为手动提交 ret = mysql_query(mysql, SET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; }\t//设置事务为自动提交 int mysql_AutoTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为自动提交 ret = mysql_query(mysql, UNSET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret;\t} //执行commit，手动提交事务 int mysql_Commit(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;COMMIT\u0026#34;); if (ret != 0) { printf(\u0026#34;commit err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } //执行rollback，回滚事务\tint mysql_Rollback(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;ROLLBACK\u0026#34;); if (ret != 0) { printf(\u0026#34;rollback err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(10),\\ col3 VARCHAR(10))\u0026#34; #define sql01 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(10, \u0026#39;AAA\u0026#39;, \u0026#39;A1\u0026#39;)\u0026#34; #define sql02 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(20, \u0026#39;BBB\u0026#39;, \u0026#39;B2\u0026#39;)\u0026#34; #define sql03 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(30, \u0026#39;CCC\u0026#39;, \u0026#39;C3\u0026#39;)\u0026#34; #define sql04 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(40, \u0026#39;DDD\u0026#39;, \u0026#39;D4\u0026#39;)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb2\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;func mysql_real_connect() err：%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34; --- connect ok......\\n\u0026#34;);\tif (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); }\tret = mysql_OperationTran(mysql); //开启事务，并修改事务属性为手动commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql01);\t//向表中插入第一行数据 ‘AAA’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret);\treturn ret; } ret = mysql_query(mysql, sql02);\t//向表中插入第二行数据 ‘BBB’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Commit(mysql); //手动提交事务 if (ret != 0) { printf(\u0026#34;mysql_Commit() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_AutoTran(mysql); // =再次= 修改事务属性为【自动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_OperationTran(mysql); // =再次= 修改事务属性为【手动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql03);\t//向表中插入第三行数据 ‘CCC’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql04);\t//向表中插入第四行数据 ‘DDD’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Rollback(mysql);\t//直接rollback操作 if (ret != 0) { printf(\u0026#34;mysql_Rollback() err:%d\\n\u0026#34;, ret); return ret; } //rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。 mysql_close(mysql); return 0;\t} 对应参考API手册。中文：25.2.3.2.\t英文：23.8.7.2\n","date":"2022-01-05T20:21:29Z","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93api%E5%BA%93/","title":"MySQL数据库API库"},{"content":" 1 MySQL基础知识 瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。\nMySQL是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低、MySQL软件采用了双授权政策，分为社区版和企业版。\n1.1 MySQL版本及下载 MySQL数据库版本相对比较繁杂。常见的有：Community社区版、Enterprise企业版。\nMySQL Community Server 版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。\nMySQL Enterprise Edition 企业版收费的，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。\n其中Community Server 可以直接从mysql 的官网下载。但Enterprice Edition只能从Oracle edelivery上下载，而Edelivery有时会屏蔽中国IP。\nMySQL各版本区别参见：\nhttp://www.admin10000.com/Document/62.html\n下载mysql时注意区分版本细节及所应用的系统平台：linux(32/64) 、win(32/64)\n举例：\nwin版本：\nmysql-installer-community-8.0.26.0.msi版本\n​ GA 是指软件的通用版本，一般指正式发布的版本 (Generally Available (GA) Release)\n​ mysql-essential-5.1.60-win32.msi精简版，如果只需要mysql服务，就选择此版本。\n​ mysql-5.1.60-win32.msi 是完 是整版，包含安装程序和配置向导，有MySQL文档。\nmysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导\n​ mysql-5.1.60.zip 是用于windows的Mysql源码压缩包\nlinux版本\n​ 在http://www.mysql.com/downloads/网站上下载不了\n​ 在 www.oracle.com/downloads 找mysql 注册用户, 选择操作系统平台和mysql版本 进行下载\n官方文档上有关MySQL安装，介绍了3种类型及其对应安装方式来安装MySQL数据库：\nLinux supports a number of different solutions for installing MySQL. The recommended method is to use one of the distributions from Oracle. If you choose this method, there are three options available:\n(1) Installing from a generic binary package in .tar.gz format. See Section 2.2,“Installing MySQL from Generic Binaries on Unix/Linux”for more information.\n(2) Extracting and compiling MySQL from a source distribution. For detailed instructions, see Section 2.9, “Installing MySQL from Source”.\n(3) Installing using a pre-compiled RPM package. For more information on using the RPM solution, see Section 2.5.1,“Installing MySQL from RPM Packages on Linux”\n我们选用较简单的RPM 包来安装。\n1.2 下载安装包 Community Server 下载地址：https://dev.mysql.com/downloads/mysql/\nMySQL Community Server. mysql社区版，开源、免费\nMySQL Enterprise Edition. mysql企业版，非免费\nMySQL Cluster. mysql集群版，开源、免费\n2 MySQL服务器安装和启动 2.1 查询服务器上已经安装的mysql ​ 在终端提示符输入：rpm -aq | grep mysql 命令。查询结果如下显示：\nqt-mysql-4.6.2-25.el6.x86_64 mysql-connector-odbc-5.1.5r1144-7.el6.x86_64 mysql-bench-5.1.66-2.el6_3.x86_64 mysql-devel-5.1.66-2.el6_3.x86_64 libdbi-dbd-mysql-0.8.3-5.1.el6.x86_64 mysql-test-5.1.66-2.el6_3.x86_64 mysql-libs-5.1.66-2.el6_3.x86_64 mysql-5.1.66-2.el6_3.x86_64 mysql-connector-java-5.1.17-6.el6.noarch mysql-server-5.1.66-2.el6_3.x86_64 ​ 注：各机器有可能不相同，软件列表视实际情况。\n2.2 卸载旧的版本 rpm -e 软件包名 \u0026ndash;nodeps \u0026ndash;allmatches (不理会依赖关系，删除所有上一步查出来的相同的mysql)\n[root@localhost home]# rpm -e mysql-connector-odbc-3.51.26r1127-1.el5 --nodeps --allmatches [root@localhost home]# rpm -e libdbi-dbd-mysql-0.8.1a-1.2.2 --nodeps --allmatches [root@localhost home]# rpm -e mysql-server-5.0.77-3.el5 --nodeps --allmatches [root@localhost home]# rpm -aq | grep mysql [root@localhost home]# ​ 将老版本的几个文件手动删除\nrm -f /etc/my.cnf rm -rf /var/lib/mysql rm -rf /var/share/mysql rm -rf /usr/bin/mysql* 2.3 安装 解压.zip安装包\nunzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip 得到如下软件包：\nMySQL-client-advanced-5.6.20-1.el6.x86_64.rpm MySQL-devil-advanced-5.6.20-1.el6.x86_64.rpm MySQL-server-advanced-5.6.20-1.el6.x86_64.rpm MySQL-embedded-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-compal-advanced-5.6.20-1.el6.x86_64.rpm MySQL-test-advanced-5.6.20-1.el6.x86_64.rpm README.txt 2.3.1 安装服务器 rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER ! You will find that password in \u0026#39;/root/.mysql_secret\u0026#39;. You must change that password on your first connect, no other statement but \u0026#39;SET PASSWORD\u0026#39; will be accepted. See the manual for the semantics of the \u0026#39;password expired\u0026#39; flag. Also, the account for the anonymous user has been removed. In addition, you can run: /usr/bin/mysql_secure_installation which will also give you the option of removing the test database. This is strongly recommended for production servers. See the manual for more instructions. Please report any problems at http://bugs.mysql.com/ The latest information about MySQL is available on the web at http://www.mysql.com Support MySQL by buying support/licenses at http://shop.mysql.com New default config file was created as /usr/my.cnf and will be used by default by the server when you start it. You may edit this file to change server settings 2.3.2 安装客户端： rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm 说明:不安装mysql-client是不能使用mysql工具登陆到mysql数据库\n​ 其他软件包选择性安装： rpm -ivh MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm\n2.4 查看mysql服务器是否已经启动 # 查看状态 systemctl status mysqld # 启动mysql systemctl start mysqld # 关闭mysql systemctl stop mysqld # 重新启动mysql systemctl restart mysqld # 开机启动mysql systemctl enable mysqld # 关闭开机启动mysql systemctl disable mysqld # 另外一种操作方式 service mysqld status 2.5 登录Mysql oracle收购Mysql后, 新版的mysql刚安装完mysql后不能直接输入mysql登录数据库, 而是设置了默认free password密码, 默认密码放在了/root/.mysql_secret文件中, 登陆后需要修改密码。\n1.查看文件寻找密码 cat /root/.mysql_secret 2.以root用户身份登陆MySQL 服务启动和关闭：\nservice mysql start service mysql stop ps -u mysql #可以查看mysql用户（安装MySQL时，系统自动创建该用户）的进程\nPID TTY TIME CMD 7586 ? 00:00:50 mysqld 守护进程 登陆服务器：\nmysql -uroot –p 密码\n输入从.mysql_secret中读到的密码登录。\n如果登录期间发生异常，无法登陆：\n使用root将mysql的后台进程kill -9 PID\n3.修改密码 mysql\u0026gt; set password=password('123456'); 将密码设置为：123456\n密码修改成后，再次登录使用：\n$mysql -uroot -p123456 即可。\n4.查看数据库 mysql\u0026gt; show databases; 5.远程root登录mysql 5.1Mysql8.0创建用户和授权 mysql8.0需要先创建用户和设置密码,然后才能授权.\n#先创建一个用户 create user \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123123\u0026#39;; #再进行授权 grant all privileges on *.* to \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; with grant option; 5.2MySQL8.0 的远程链接 MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题.\n5.2.1登录MySQL mysql -u root -p #然后输入您的密码 5.2.2选择 mysql 数据库 use mysql; --因为 mysql 数据库中存储了用户信息的 user 表。 5.2.3在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 select host, user, authentication_string, plugin from user; --执行完上面的命令后会显示一个表格 --查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。 5.2.4授权 root 用户的所有权限并设置远程访问 GRANT ALL ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;你自己的密码\u0026#39;; 5.2.5刷新权限 --所有操作后，应执行 flush privileges; 5.2.6查看 root 用户的 host use mysql;\rselect host, user, authentication_string, plugin from user;\r--会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。\r5.3访问数据库 --输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.7 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。 --出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password. --解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. --这里采用第二种方式 ： --修改加密规则: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39; PASSWORD EXPIRE NEVER; password 为你当前密码。 --更新 root 用户密码: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; password 为你新设置的密码。 --刷新权限: FLUSH PRIVILEGES; --OK，设置完成，再次使用 Navicat 连接数据库 6. 数据库的CURD 对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。\n6.1查看数据库 显示所有数据库 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | itcast | | itcast1 | | itcast2 | | mysql | | performance_schema | | sys | +--------------------+ 7 rows in set (0.01 sec) 显示创建数据库的语句信息 mysql\u0026gt; show create database itcast; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | itcast | CREATE DATABASE `itcast` /*!40100 DEFAULT CHARACTER SET utf8 */ | +----------+-----------------------------------------------------------------+ 1 row in set (0.00 sec) /* `itcast` 两端是反单引号, esc下的键, 使用``包含数据库的名字是区分大小写的 */ 使用数据库 /* 我们以root用户登录, 用户下有很多数据库, 需要指定, 当前使用哪一个数据库, 操作的就是那个数据库中的数据 */ mysql\u0026gt; use itcast1; Database changed mysql\u0026gt; use itcast2; Database changed 6.2创建数据库 -- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句\r-- create_specification是建库的一些选项\r-- 关键字不区分大小写\rCREATE {DATABASE} [IF NOT EXISTS] db_name\r[create_specification [, create_specification] ...]\r创建一名为itcast的数据库 mysql\u0026gt; create database itheima; /* utf8 */ 创建一个使用 latin1 字符集的数据库 mysql\u0026gt; create database itheima character set latin1; 6.3修改数据库 -- 修改字符集, 不能改名 alter database itcast character set utf8; 6.4删除数据库 drop database itcast; 7. 表的CURD 对表本身进行操作：创建，查看，修改，删除\n7.1 查看表 查看当前数据库下的数据库表\n\u0026ndash; 当前使用的数据库下的表 mysql\u0026gt; show tables;\n查看指定表的创建语句\nmysql\u0026gt; show create table 表名;\n查看表结构\nmysql\u0026gt; desc 表名;\n7.2创建表 mysql中表名区分大小写, 列名不区分大小写\n数据类型 float/double: 指定精确到小数点以后第几位, 比如: 精确到后3位 通过计算得到一个数据: 12.345678 这个数的678会被抹掉 decimal 完整的保存精度, 最少有小数后有两位 12.3 保存为: 12.30 创建表 create table 表名( 列名 text [default \u0026#39;xxx\u0026#39;], 列名 类型 [default value], 类名 类型 [default value], ...... ); 7.3修改表 修改表名\n-- oracle和mysql相同 rename table oldN to newN; 添加一个字段\n-- oracle alter table 表名 add 列名 列的类型; -- mysql alter table 表名 add column 列名 列的类型; 修改一个字段\n-- oracle alter table 表名 modify 列名 列的类型; -- mysql alter table 表名 modify column 列名 列的类型; 删除一个字段\n-- mysql和oracle相同 alter table 表名 drop column 列; -- mysql中没有对对字段的rename操作 修改表的字符集\nalter table 表名 character set utf8; 7.4 删除表 drop table 表名; -- oracle中可以这么做, mysql中不行 drop table 表名 purge 8. 表数据的CURD 插入数据\n表名后的列名什么时候可以省略? 在values(列的值, 列的值, \u0026hellip;.)中将表有的字段值都指定出来的时候, 列名可以省略 insert into 表名[(列名, 列名, ...)] values(列的值, 列的值, ....); 更新数据\nupdate 表名 set 列名=新值 where 列名=值; 删除数据\ndelete from 表名; -- 删除所有行 delete from 表名 where 列名=值; -- 删除满足条件的行 查询数据\nselect *|列名|表达式 from 表名 where 条件 group by 列名 having 条件 order by asc|desc; 练习\n创建数据库 student 表 create table student( id int, name varchar(20), chinese int, english int, math int ); 插入数据 insert into student(id,name,chinese,english,math) values(1, \u0026#39;范建\u0026#39;,80,85,90); insert into student(id,name,chinese,english,math) values(2,\u0026#39;罗况\u0026#39;,90,95,95); insert into student(id,name,chinese,english,math) values(3,\u0026#39;杜子腾\u0026#39;,80,96,96); insert into student(id,name,chinese,english,math) values(4,\u0026#39;范冰\u0026#39;,81,97,85); insert into student(id,name,chinese,english,math) values(5,\u0026#39;申晶冰\u0026#39;,85,84,90); insert into student(id,name,chinese,english,math) values(6,\u0026#39;郝丽海\u0026#39;,92,85,87); insert into student(id,name,chinese,english,math) values(7,\u0026#39;郭迪辉\u0026#39;,75,81,80); insert into student(id,name,chinese,english,math) values(8,\u0026#39;拎壶冲\u0026#39;,77,80,79); insert into student(id,name,chinese,english,math) values(9,\u0026#39;任我行\u0026#39;,95,85,85); insert into student(id,name,chinese,english,math) values(10,\u0026#39;史泰香\u0026#39;,94,85,84); 查询表中所有学生的信息。 查询表中所有学生的姓名和对应的英语成绩。 将第二步查询结果中的重复成绩过滤掉。\n在所有学生英语分数上加10分特长分。\n统计每个学生的总分。\n使用别名表示学生分数\n查询姓名为何东的学生成绩\n查询英语成绩大于90分的同学\n查询总分大于250分的所有同学\n查询英语分数在 85－95之间的同学。\n查询数学分数为84,90,91的同学。\n查询所有姓何的学生成绩。\n查询数学分\u0026gt;85，语文分\u0026gt;90的同学。\n对数学成绩排序后输出。\n对总分排序后输出，然后再按从高到低的顺序输出\n对姓何的学生成绩排序输出\n统计一个班级共有多少学生？\n统计数学成绩大于90的学生有多少个？\n统计总分大于250的人数有多少？\n统计一个班级数学总成绩？\n统计一个班级语文、英语、数学各科的总成绩\n统计一个班级语文、英语、数学的成绩总和\n求一个班级数学平均分？\n求一个班级总分平均分\n求班级最高分和最低分\n9. mysql函数的使用 9.1 日期函数 MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。\n-- 当前时间: now() == sysdate() mysql\u0026gt; select sysdate() from dual; +---------------------+ | sysdate() | +---------------------+ | 2019-12-02 09:03:42 | +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select now() from dual; +---------------------+ | now() | +---------------------+ | 2019-12-02 09:04:35 | +---------------------+ 1 row in set (0.00 sec) -- addtime(time, s) 给当前实际, 添加对应的秒数 select addtime(\u0026#39;09:04:35\u0026#39;,20) from dual; +------------------------+ | addtime(\u0026#39;09:04:35\u0026#39;,20) | +------------------------+ | 09:04:55 | +------------------------+ -- 当前日期: 年, 月, 日 mysql\u0026gt; select current_date() from dual; +----------------+ | current_date() | +----------------+ | 2019-12-02 | +----------------+ 1 row in set (0.00 sec) -- 当前时间: 时, 分, 秒 mysql\u0026gt; select current_time() from dual; +----------------+ | current_time() | +----------------+ | 09:08:10 | +----------------+ 1 row in set (0.00 sec) -- 时间戳 mysql\u0026gt; select current_timestamp() from dual; +---------------------+ | current_timestamp() | +---------------------+ | 2019-12-02 09:09:47 | +---------------------+ 1 row in set (0.00 sec) -- 将给定时间的日期取出 select date(now()) from dual; +-------------+ | date(now()) | +-------------+ | 2019-12-02 | +-------------+ 1 row in set (0.00 sec) -- date_add(), 第二个参数的type: 天: day, 月:month, 年: year mysql\u0026gt; select date_add(now(), interval 1 day) from dual; +---------------------------------+ | date_add(now(), interval 1 day) | +---------------------------------+ | 2019-12-03 09:14:57 | +---------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 month) from dual; +-----------------------------------+ | date_add(now(), interval 1 month) | +-----------------------------------+ | 2020-01-02 09:15:27 | +-----------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 year) from dual; +----------------------------------+ | date_add(now(), interval 1 year) | +----------------------------------+ | 2020-12-02 09:15:37 | +----------------------------------+ 1 row in set (0.00 sec) -- 计算两个日期的差值 mysql\u0026gt; select datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | 333 | +-------------------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | -32 | +-------------------------------------------------------+ 1 row in set (0.00 sec) -- 单独显示当前年, 月, 日 select year(now()) \u0026#34;年\u0026#34;, month(now()) \u0026#34;月\u0026#34;, day(now()) \u0026#34;日\u0026#34; from dual; -- 单独显示当前日期, 时间, 时间戳 -- 显示昨天, 今天, 明天 select date_sub(now(), interval 1 day), now(), date_add(now(), interval 1 day) from dual; 9.2 字符串函数 -- 字符串连接 -- mydql中可以连接多个字符串, oracle中只能连接两个字符串 mysql\u0026gt; select concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) from dual; +-------------------------------------------------+ | concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) | +-------------------------------------------------+ | hello world 你好,世界 | +-------------------------------------------------+ -- 大小写转换 mysql\u0026gt; select ucase(\u0026#34;hello\u0026#34;), lcase(\u0026#34;WORLD\u0026#34;) from dual; +----------------+----------------+ | ucase(\u0026#34;hello\u0026#34;) | lcase(\u0026#34;WORLD\u0026#34;) | +----------------+----------------+ | HELLO | world | +----------------+----------------+ 1 row in set (0.00 sec) -- 字符串截取, 从左侧开始 mysql\u0026gt; select left(\u0026#34;hello,world\u0026#34;, 5) from dual; +------------------------+ | left(\u0026#34;hello,world\u0026#34;, 5) | +------------------------+ | hello | +------------------------+ 1 row in set (0.00 sec) -- 字符串比较 mysql\u0026gt; select strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) | +----------------------+ | -1 | -- 小于 +----------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) from dual; +---------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) | +---------------------+ | 1 | -- 大于 +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) | +----------------------+ | 0 | -- 等于 +----------------------+ 1 row in set (0.00 sec) 9.3 数学函数 \u0026ndash; 向上取整 \u0026ndash; mysql ceiling(小数) \u0026ndash; oracle ceil(小数)\n-- 进制转换 mysql\u0026gt; select conv(100, 10, 16) from dual; +-------------------+ | conv(100, 10, 16) | +-------------------+ | 64 | +-------------------+ -- 保留指定的小数位数, 可以四舍五入 mysql\u0026gt; select format(12.345, 2) from dual; +-------------------+ | format(12.345, 2) | +-------------------+ | 12.35 | +-------------------+ 1 row in set (0.00 sec) -- 取集合中的最小值 mysql\u0026gt; select least(12, 1, 3, 4, 0) from dual; +-----------------------+ | least(12, 1, 3, 4, 0) | +-----------------------+ | 0 | +-----------------------+ 1 row in set (0.00 sec) -- 生成随机数 -- 生成的随机数范围: 0-1 mysql\u0026gt; select rand(now()) from dual; +--------------------+ | rand(now()) | +--------------------+ | 0.8633374812671333 | +--------------------+ 1 row in set (0.00 sec) 9.4 日期转换 -- oracle 日期格式: yyyy-mm-dd hh24:mi:ss 不区分大小写 to_char() 日期转字符串 to_date() 字符串转日期 -- mysql 日期格式: %Y-%m-%d %H:%i:%s 区分大小写 date_format() 日期转字符串 str_to_date() 字符串转日期 值 含义 秒 %S、%s 两位数字形式的秒（ 00,01, \u0026hellip;, 59） 分 %i 两位数字形式的分（ 00,01, \u0026hellip;, 59） 小时 %H 24小时制，两位数形式小时（00,01, \u0026hellip;,23） %h 12小时制，两位数形式小时（00,01, \u0026hellip;,12） %k 24小时制，数形式小时（0,1, \u0026hellip;,23） %l 12小时制，数形式小时（0,1, \u0026hellip;,12） %T 24小时制，时间形式（HH:mm:ss） %r 12小时制，时间形式（hh:mm:ss AM 或 PM） %p AM上午或PM下午 周 %W 一周中每一天的名称（Sunday,Monday, \u0026hellip;,Saturday） %a 一周中每一天名称的缩写（Sun,Mon, \u0026hellip;,Sat） %w 以数字形式标识周（0=Sunday,1=Monday, \u0026hellip;,6=Saturday） %U 数字表示周数，星期天为周中第一天 %u 数字表示周数，星期一为周中第一天 天 %d 两位数字表示月中天数（01,02, \u0026hellip;,31） %e 数字表示月中天数（1,2, \u0026hellip;,31） %D 英文后缀表示月中天数（1st,2nd,3rd \u0026hellip;） %j 以三位数字表示年中天数（001,002, \u0026hellip;,366） %M 英文月名（January,February, \u0026hellip;,December） %b 英文缩写月名（Jan,Feb, \u0026hellip;,Dec） %m 两位数字表示月份（01,02, \u0026hellip;,12） %c 数字表示月份（1,2, \u0026hellip;,12） 年 %Y 四位数字表示的年份（2015,2016\u0026hellip;） %y 两位数字表示的年份（15,16\u0026hellip;） 文字输出 %文字 直接输出文字内容 date类型装换为varchar类型\n-- date_format(日期, fmt) mysql\u0026gt; select date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) from dual; +-----------------------------------------+ | date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) | +-----------------------------------------+ | 2019/12/02 10:07:37 | +-----------------------------------------+ varchar类型转换为date类型\n-- 参数fmt的个数应该和日期字符串的形式一致 -- str_to_date(日期字符串, fmt) mysql\u0026gt; select str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) from dual; +---------------------------------------------------------+ | str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) | +---------------------------------------------------------+ | 2019-12-02 10:07:37 | +---------------------------------------------------------+ 1 row in set (0.00 sec) 10. 多表查询 -- 分组函数 count(); -- 求总数 avg(); -- 求平均值 sum(); -- 求和 min(); -- 最小值 max(); -- 最大值 -- having 必须出现在group by 后边, 不能写where -- where 写在 from 的后边 -- order by: 默认升序 asc, 降序 desc select 列名|表达式 as \u0026#34;别名\u0026#34; from 表名 \u0026#34;表的别名\u0026#34; where 表达式 group by 列名 having 条件 order by asc | desc -- 求两个表的笛卡尔积 cross join -- 最简单的两个表查询 select * from dept, emp; select * from dept cross join emp; 10.1 内连接 \u0026ndash; inner join 显示部门名称, 部门编号, 员工编号,和员工姓名\n-- mysql+oracle select d.deptno, d.dname, e.empno, e.ename from dept d, emp e where d.deptno=e.deptno; -- mysql+oracle -- 将表之间的逗号替换为 inner join --\u0026gt; 简写为 join -- 将 where 替换为 on select d.deptno, d.dname, e.empno, e.ename from dept d join emp e on d.deptno=e.deptno; 10.2 外连接 \u0026ndash; outer join 外连接: 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 必须使用外连接的方式, 才能够使其显示在结果集中.\n按部门统计员工人数，显示如下信息：部门号，部门名称，人数(所有部门的人数都统计)\n左外连接 \u0026ndash; left outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where d.deptno=e.deptno(+) group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: left outer join -\u0026gt; outer 可以省略 -\u0026gt; left join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from dept d left outer join emp e on d.deptno=e.deptno group by d.deptno, d.dname; 右外连接 \u0026ndash; right outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where e.deptno(+)=d.deptno group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: right outer join -\u0026gt; outer 可以省略 -\u0026gt; right join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from emp e right join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 全外连接 \u0026ndash; full outer join 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 不知道的那个表的字段不满足条件或者是左侧不满足条件或右侧表不满足条件, 需要将这些不满条件对数据全部显示到结果集中, 可以使用全外连接.\n两个表互相补充 -- 在mysql中不支持全外连接, oracle中是支持的 -- full outer join -\u0026gt; 简写: full join -- 有可能emp表给dept提供补充, 也有可能dept给emp提供补充 select d.deptno, d.dname, count(e.empno) from emp e full join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 10.3 自连接 查询员工、老板信息，显示: xxx的老板是xxx\n-- oracle select e.ename \u0026#34;员工\u0026#34;, nvl(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e, emp b where e.mgr=b.empno(+); -- mysql -- mysql 中的ifnull 等价于 oracle 中的 nvl select e.ename \u0026#34;员工\u0026#34;, ifnull(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e left join emp b on e.mgr=b.empno; 11. 表的约束 create table 表名( 列名 列的类型 default 默认值, 列名 列的类型, 列名 列的类型 ); 11.1 约束种类 mysql中常用的约束有五种:\n主键约束　primary key\n非空 + 唯一 主键自动增长　auto_increment\n给主键用的, 只有列是主键才能加这个约束 主键是数字的时候使用 唯一约束　unique\n非空约束　not null\n外键约束　foreign key\n检查约束 check (在MySQL中语法保留，但没有效果)\n11.2 约束的使用 create table persion( id int, -- 主键, 自动增长 age int, -- 非空 name varchar(20), -- 唯一 deptno int -- 外键 ); 表级别的约束 -- auto_increment只能放到列的位置 -- not null 非空只能在列上添加约束 create table persion( id int auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20), -- 唯一 deptno int, -- 外键 constraint pk_id_xxx primary key(id) , constraint un_name_xxx unique(name), constraint fk_deptno_xx foreign key(deptno) references dept(deptno) ); 列级别的约束 create table persion1( id int primary key auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20) unique, -- 唯一 deptno int references dept(deptno) -- 外键 ); 12. 事务 在mysql中事务默认是自动提交的，oracle中默认是手动提交的。\n原子性 一致性 隔离性 永久性 -- 修改事务提交方式 -- 手动提交 mysql\u0026gt; set autocommit=0; Query OK, 0 rows affected (0.00 sec) -- 提交数据 mysql\u0026gt; commit; Query OK, 0 rows affected (0.00 sec) -- 数据回滚 mysql\u0026gt; rollback; Query OK, 0 rows affected (0.00 sec) -- 自动提交 mysql\u0026gt; set autocommit=1; Query OK, 0 rows affected (0.00 sec) 13. mysql API 初始化连接环境 连接mysql的服务器 执行sql语句 查询 插入 更新 删除 创建/删除/修改数据库表 如果是插入/删除/修改数据等操作只能看到状态 成功 失败 如果sql语句是查询, 得到结果集 遍历结果集 释放资源 初始化连接环境 // 参数: NULL // 返回值: 返回函数申请的内存的地址 MYSQL *mysql_init(MYSQL *mysql) 连接mysql服务器 // 返回值: 失败-\u0026gt; NULL, 成功了-\u0026gt; 返回值和第一个参数的地址相同 MYSQL *mysql_real_connect( MYSQL *mysql, // mysql_init函数的返回值 // 本地: localhost, 远程连接:192.168.xx.xx; const char *host, // mysql服务器地址, IP/主机名 const char *user, // mysql数据用户名, root const char *passwd, // root用户的密码 const char *db, // 数据库的名字 // 如果port==0, 使用默认端口, !=0是使用指定的端口 unsigned int port, // 数据库的端口, 默认3306 const char *unix_socket, // NULL unsigned long client_flag // 0 ); 执行sql语句 // 添删查改的sql语句都是可以执行的 // 参数: // mysql: mysql_real_connect()函数的返回值 // query: sql语句, 语句的结尾不要加 ; // 返回值: 成功-\u0026gt; 0, 失败-\u0026gt;非0 int mysql_query(MYSQL *mysql, const char *query); 获取结果集 // 将结果集保存到本地内存中 // 返回值: 错误-\u0026gt;null, 成功-\u0026gt;非空 // 参数 mysql: mysql_real_connect() 返回值 // 结果集中保存了多条记录, 每条记录中有若干个字段 MYSQL_RES *mysql_store_result(MYSQL *mysql); 得到结果集的列数 unsigned int mysql_num_fields(MYSQL_RES *result) 获取表头 -\u0026gt; 列名(字段名) / mysql.h typedef struct st_mysql_field { char *name; /* Name of column */ char *org_name; /* Original column name, if an alias */ char *table; /* Table of column if column was a field */ char *org_table; /* Org table name, if table was an alias */ char *db; /* Database for table */ char *catalog; /* Catalog for table */ char *def; /* Default value (set by mysql_list_fields) */ unsigned long length; /* Width of column (create length) */ unsigned long max_length; /* Max width for selected set */ unsigned int name_length; unsigned int org_name_length; unsigned int table_length; unsigned int org_table_length; unsigned int db_length; unsigned int catalog_length; unsigned int def_length; unsigned int flags; /* Div flags */ unsigned int decimals; /* Number of decimals in field */ unsigned int charsetnr; /* Character set */ enum enum_field_types type; /* Type of field. See mysql_com.h for types */ void *extension; } MYSQL_FIELD; // 返回值 中保存了所有的字段名, 返回值是一个数组 MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result); MYSQL_FIELD *fields = mysql_fetch_fields(result); for(int i=0; i\u0026lt;num; ++i) { fields[i].name } 遍历结果集 typedef char** MYSQL_ROW; // 函数每调用一次, 从结果集中取出一条记录(行) // 参数: 结果集, mysql_store_result()返回值 // 返回值: char* row[], char**执向一个指针数组, 数组中的每一个元素都是一个字符串, 字符串就是字段值 // 不管字段原来是什么类型, 结果集中都是以字符串形式保存的 // 如果还有下一行返回非空, 没有下一行, 或者失败了返回NULL MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 资源回收 // 参数是 mysql_store_result() 函数的返回值 void mysql_free_result(MYSQL_RES *result); // 参数是: mysql_init() 函数的返回值 void mysql_close(MYSQL *mysql); 字符编码 // 获取字节编码 const char *mysql_character_set_name(MYSQL *mysql); // 设置字节编码 // csname: 编码的名字, utf8 int mysql_set_character_set(MYSQL *mysql, char *csname); 事务操作 // mode==0 -\u0026gt; 手动提交, mode1 -\u0026gt; 自动提交事务 my_bool mysql_autocommit(MYSQL *mysql, my_bool mode); my_bool mysql_commit(MYSQL *mysql); my_bool mysql_rollback(MYSQL *mysql); 打印错误信息 // 返回错误的描述 const char *mysql_error(MYSQL *mysql); // 返回错误的编号 unsigned int mysql_errno(MYSQL *mysql); 需要的头文件 #include \u0026lt;mysql.h\u0026gt; // 动态库名: libmysqlclient.so // 静态库名: libmysqlclient.a 搜索文件 find 路径 -name 文件名 locate 文件名 # centos # 切换到root下安装 yum install mlocate updatedb # 只需要做一次, 安装完成之后做 完整实例 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;mysql.h\u0026gt; int main() { MYSQL *mysql = mysql_init(NULL); if (mysql == nullptr) { printf(\u0026#34;mysql_init() failed\\n\u0026#34;); return -1; } mysql_real_connect(mysql, \u0026#34;192.168.213.128\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;zzc123\u0026#34;, \u0026#34;scott\u0026#34;, 0, NULL, 0); if (mysql == NULL) { printf(\u0026#34;mysql_real_connect() failed\\n\u0026#34;); return -1; } printf(\u0026#34;服务器连接成功!\\n\u0026#34;); printf(\u0026#34;原字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); mysql_set_character_set(mysql, \u0026#34;utf8\u0026#34;); printf(\u0026#34;现字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); int ret = mysql_query(mysql, \u0026#34;select * from emp\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query(select) failed: %s\\n\u0026#34;, mysql_error(mysql)); return -1; } MYSQL_RES *res = mysql_store_result(mysql); int colNum = mysql_num_fields(res); //fields是一个结构体数组 MYSQL_FIELD *fields = mysql_fetch_fields(res); for (int i = 0; i \u0026lt; colNum; i ++) { //遍历结构体内名字字段 printf(\u0026#34;%s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); //读取每一行 //二级指针 MYSQL_ROW row; while ((row = mysql_fetch_row(res)) != NULL) { for (int i = 0; i \u0026lt; colNum; i ++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); } //释放结果集 mysql_free_result(res); //设置事务手动提交 mysql_autocommit(mysql, 0); //将下面的四个操作设置为事务 //插入数据 int fl1 = mysql_query(mysql, \u0026#34;insert into dept values(11, \u0026#39;海军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl2 = mysql_query(mysql, \u0026#34;insert into dept values(12, \u0026#39;革命军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl3 = mysql_query(mysql, \u0026#34;insert into dept values(13, \u0026#39;马戏团\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); //更新数据 int fl4 = mysql_query(mysql, \u0026#34;update dept set dname=\u0026#39;群众\u0026#39; where loc=\u0026#39;china\u0026#39;\u0026#34;); //全部成功 if (!fl1 \u0026amp;\u0026amp; !fl2 \u0026amp;\u0026amp; !fl3 \u0026amp;\u0026amp; !fl4) { //提交事务 mysql_commit(mysql); } else { //事务回滚 mysql_roolback(mysql); } //释放资源 mysql_close(mysql); return 0; } mysql和oracle区别\n结构不同\nmsyql 基于数据库\n表存储在数据库中 oracle 基于用户的\n表属于用户 mysql没有表空间, oracle有表空间\n管理员\nmysql\nroot oralce\nsys -\u0026gt; 管理员, 身份 sysdba system -\u0026gt; 管理员, 登录的时候需要使用normal身份登录 其他的普通用户 事务\noracle默认手动提交\nocci接口 (C++接口), 这个接口中是自动提交事务的 mysql中默认是自动提交\nsql语句\n外连接\noralce中可以使用 (+) mysql中必须使用 , 不支持(+) right outer join -\u0026gt; oracle也支持这种写法 left outer join mysql不支持全外连接, oracle支持的 full outer join 函数:\nnvl -\u0026gt; oralce\nifnull -\u0026gt; mysql\n日期\n字符串\n数学函数\n建表的时候的约束指定\n都有:\n主键 -\u0026gt; primary key 非空: not null 唯一性: unique 外键约束: foreign key 不同:\noralce: check, 在mysql中也有, 但是不起作用 mysql 主键自动增长: auto_increment\n需要和主键约束一起使用 删除表\noracle\ndrop talbe 表名 purge; msyql\ndrop talbe 表名; \u0026ndash;\u0026gt; 不能使用 purge 字段的修改\noralce\n列的添加 alter table 表名 add 列名 列的属性; alter table 表名 modify 列名 列的属性; mysql\n列的添加修改 alter table 表名 add column 列名 列的属性; alter table 表名 modify column 列名 列的属性; ","date":"2022-01-05T12:57:29+08:00","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Mysql数据库"},{"content":" 百度百科 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n本文采用\nMistEO哥哥写的项目。\n他写两个很棒的项目\nJson:MistEO/meojson: A fast and easy-to-use JSON parser/generator for C++ (github.com)\n明日方舟助手：MistEO/MeoAssistantArknights: 明日方舟助手，自动刷图、智能基建换班，全日常一键长草！ (github.com)\n他的博客肝！ (misteo.top)，不过是鸽王。\n好了开始正题了\njson下载 下载玛丽写的Json项目MistEO:Json\ngit clone https://github.com.cnpmjs.org/MistEO/meojson.git 编译 json静态库 make 运行命令后会在build文件夹生成libmeojson.a,然后就在项目中可以使用了\n在代码中添加头文件 #include \u0026#34;json.h\u0026#34; 若您需要解析 Json5, 则请包含 json5.hpp 头文件 #include \u0026#34;json5.hpp\u0026#34; meojson 仅依赖 STL, 但需要 c++17 标准 使用 json /*** * from sample/sample.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json.hpp\u0026#34; void parsing() { std::string content = R\u0026#34;( { \u0026#34;repo\u0026#34;: \u0026#34;meojson\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;MistEO\u0026#34;: \u0026#34;https://github.com/MistEO\u0026#34;, \u0026#34;ChingCdesu\u0026#34;: \u0026#34;https://github.com/ChingCdesu\u0026#34; }, \u0026#34;list\u0026#34;: [ 1, 2, 3 ], \u0026#34;str\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;num\u0026#34;: 3.1416 } )\u0026#34;; auto ret = json::parse(content); if (!ret) { std::cerr \u0026lt;\u0026lt; \u0026#34;Parsing failed\u0026#34; \u0026lt;\u0026lt; std::endl; return; } auto value = ret.value(); // As also, you can use rvalues, like // `auto value = std::move(ret).value();` // Output: meojson std::cout \u0026lt;\u0026lt; value[\u0026#34;repo\u0026#34;].as_string() \u0026lt;\u0026lt; std::endl; /* Output: ChingCdesu \u0026#39;s homepage: https://github.com/ChingCdesu MistEO \u0026#39;s homepage: https://github.com/MistEO */ for (auto\u0026amp;\u0026amp; [name, homepage] : value[\u0026#34;author\u0026#34;].as_object()) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#39;s homepage: \u0026#34; \u0026lt;\u0026lt; homepage.as_string() \u0026lt;\u0026lt; std::endl; } // Output: abc std::string str = (std::string)value[\u0026#34;str\u0026#34;]; // As also, you can use `value[\u0026#34;str\u0026#34;].as_string()` std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; // Output: 3.141600 double num = value[\u0026#34;num\u0026#34;].as_double(); // As also, you can use `(double)value[\u0026#34;num\u0026#34;]` std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; // Output: not found std::string str_get = value.get(\u0026#34;maybe_exists\u0026#34;, \u0026#34;not found\u0026#34;); std::cout \u0026lt;\u0026lt; str_get \u0026lt;\u0026lt; std::endl; /* Output: 1 2 3 */ // It\u0026#39;s const! for (const auto\u0026amp; ele : value.at(\u0026#34;list\u0026#34;).as_array()) { int x = (int)ele; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } } 解析 Json5 /*** * from sample/json5_parse.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json5.hpp\u0026#34; void parsing() { std::string content = R\u0026#34;( // 这是一段json5格式的信息 { 名字: \u0026#34;MistEO\u0026#34;, /* key的引号可省略 */ 😊: \u0026#39;😄\u0026#39;, // emoji为key thanks: \u0026#39;ありがとう\u0026#39;, /* 单引号也可以表示字符串 */ \\u006Bey: [\u0026#39;value\u0026#39;,], // 普通字符和转义可以混用 inf: +Infinity, nan: NaN, // 数字可以以\u0026#34;+\u0026#34;开头 fractional: .3, integer: 42., // 小数点作为起始/结尾 byte_max: 0xff, // 十六进制数 light_speed: +3e8, // 科学计数法 } )\u0026#34;; auto ret = json::parse5(content); if (!ret) { std::cerr \u0026lt;\u0026lt; \u0026#34;Parsing failed\u0026#34; \u0026lt;\u0026lt; std::endl; return; } auto value = ret.value(); // As also, you can use rvalues, like // `auto value = std::move(ret).value();` // Output: MistEO std::cout \u0026lt;\u0026lt; value[\u0026#34;名字\u0026#34;] \u0026lt;\u0026lt; std::endl; // Output: value std::string str = (std::string)value[\u0026#34;key\u0026#34;][0]; std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; // for more json::value usage, please refer to sample.cpp } 生成 /*** * from sample/sample.cpp ***/ #include \u0026lt;iostream\u0026gt; #include \u0026#34;json.hpp\u0026#34; void generating() { json::value root; root[\u0026#34;hello\u0026#34;] = \u0026#34;meojson\u0026#34;; root[\u0026#34;Pi\u0026#34;] = 3.1416; root[\u0026#34;arr\u0026#34;] = json::array{ \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; }; root[\u0026#34;obj\u0026#34;] = json::object{ {\u0026#34;obj_key1\u0026#34;, \u0026#34;aaa\u0026#34;}, {\u0026#34;obj_key2\u0026#34;, 123}, {\u0026#34;obj_key3\u0026#34;, true} }; root[\u0026#34;obj\u0026#34;].object_emplace(\u0026#34;key4\u0026#34;, json::object{ { \u0026#34;key4 child\u0026#34;, \u0026#34;lol\u0026#34; } }); root[\u0026#34;obj_another\u0026#34;][\u0026#34;child\u0026#34;][\u0026#34;grand\u0026#34;] = \u0026#34;i am grand\u0026#34;; std::vector\u0026lt;int\u0026gt; vec = { 1, 2, 3, 4, 5 }; root[\u0026#34;arr from vec\u0026#34;] = json::array(vec); root[\u0026#34;arr from vec\u0026#34;].array_emplace(6); std::set\u0026lt;std::string\u0026gt; set = { \u0026#34;a\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;cc\u0026#34; }; root[\u0026#34;arr from set\u0026#34;] = json::array(set); std::map\u0026lt;std::string, int\u0026gt; map; map.emplace(\u0026#34;key1\u0026#34;, 1); map.emplace(\u0026#34;key2\u0026#34;, 2); root[\u0026#34;obj from map\u0026#34;] = json::object(map); std::cout \u0026lt;\u0026lt; root.format() \u0026lt;\u0026lt; std::endl; } ","date":"2022-01-04T17:38:16Z","permalink":"https://okokfun.github.io/post/c++/json%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Json的使用"},{"content":" 文件夹创建 在项目根目录创建Dependencies,然后在Dependencies创建include目录 在Dependencies中创建Libs 把头文件和库文件放到对目录\n项目头文件添加 然后用Visual Studio打开项目，找到 红色圈中的功能条\n再点击最下边的属性\n定位到常规，然后再编辑附加包含目录，添加一条新item为$(SolutionDir)Dependencies\\include\\\n其中 $(SolutionDir)为项目根目录，Dependencies\\include\\为头文件目录\n至此第三方库的头文件已经添加完成\n项目库文件添加 点击链接器，常规，附加库目录，添加一条$(SolutionDir)Dependencies\\Libs\\GLFW,\n然后点击输入，附加依赖项，写入要使用的库文件名，点击确定，第三方库已被添加到项目中\nEnd.\n","date":"2022-01-04T17:36:44Z","permalink":"https://okokfun.github.io/post/c++/visual-studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","title":"Visual_Studio_2022添加第三方库"},{"content":" 安装 cmake是自动化项目编译工具，可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。\n下载地址👉Download | CMake， 建议二进制安装。\nwin:\nhttps://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-windows-x86_64.zip ubuntu:\nsudo apt install cmake wget https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-linux-x86_64.tar.gz centos:\nsudo yum install cmake arch:\nsudo pacman -S cmake 编写CMakeLists.txt 单文件单目录CMakeLists.txt编写 # 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo1) # 指定编译后文件名 set(OUTPUTNAME demo1) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(. DIR_SRCS) # 编译文件 add_executable(${OUTPUTNAME} ${DIR_SRCS}) 此文件加编写完毕后，创建一个build文件夹，cd进去，执行cmake ..，会生成Makefile文件，再然后执行make编译，最终生成项目文件。\n多文件单目录CMakeLists.txt编写 和demo1相同\n# 指定cmake版本 cmake_minimum_required(VERSION 3.22) # 工程名 project(demo2) # 指定编译后文件名 set(OUTPUTNAME demo2) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 指定源文件夹 aux_source_directory(. DIR_SRCS) # 编译文件 add_executable(${OUTPUTNAME} ${DIR_SRCS}) 多文件多文件夹CMakeLists.txt编写 每一个项目都要建一个CMakeLists.txt，并且每一个文件夹都要有一个CMakeLists.txt文件\n项目根目录的CMakeLists.txt\n# 指定cmake版本 cmake_minimum_required (VERSION 3.22) # 项目信息 project (Demo3) # 指定编译后文件名 set(OUTPUTNAME demo3) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 指定编译参数 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 添加 math 子目录 add_subdirectory(math) # 指定生成目标 add_executable(${OUTPUTNAME} ${DIR_SRCS}) # 添加链接库 target_link_libraries(${OUTPUTNAME} MathFunctions) 项目其他目录的CMakeLists.txt\n# 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 库文件CMakeLists.txt编写 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 库文件安装CMakeLists.txt编写 在指定的库源文件目录添加：\n# 指定 MathFunctions 库的安装路径 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) demo会被放到bin，*.h会被放到/usr/local/include\n# 指定安装路径 install (TARGETS Demo DESTINATION bin) install (FILES \u0026#34;${PROJECT_BINARY_DIR}/config.h\u0026#34; DESTINATION include) 库文件指定输出路径与编译后的工程目录 库文件输出目录设置\n# 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 把库文件的输出路径设置为lib set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) # 生成链接库,动态库 # 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS}) add_library (MathFunctions SHARED ${DIR_LIB_SRCS}) 项目工程目录设置\ncmake_minimum_required(VERSION 3.22) project(abstract_factory_pattern) set(OUTPUTNAME test) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20\u0026#34;) # 声明库文件目录 include_directories(${PROJECT_SOURCE_DIR}/mylib) set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) # 设置可执行文件输出目录为bin aux_source_directory(. DIR_SRCS) add_executable(${OUTPUTNAME} ${DIR_SRCS}) target_link_libraries(${OUTPUTNAME} Mylib) # 链接mylib目录下的Mylib库 ","date":"2022-01-03T16:24:52Z","permalink":"https://okokfun.github.io/post/c++/cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ecmakelists-txt%E7%9A%84%E7%BC%96%E5%86%99/","title":"Cmake的安装与CMakeLists.txt的编写"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n适用场景:\n当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。\n观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。\n当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n订阅列表是动态的， 因此订阅者可随时加入或离开该列表。\n/** * Observer Design Pattern * * Intent: Lets you define a subscription mechanism to notify multiple objects * about any events that happen to the object they\u0026#39;re observing. * * Note that there\u0026#39;s a lot of different terms with similar meaning associated * with this pattern. Just remember that the Subject is also called the * Publisher and the Observer is often called the Subscriber and vice versa. * Also the verbs \u0026#34;observe\u0026#34;, \u0026#34;listen\u0026#34; or \u0026#34;track\u0026#34; usually mean the same thing. */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; class IObserver { public: virtual ~IObserver(){}; virtual void Update(const std::string \u0026amp;message_from_subject) = 0; }; class ISubject { public: virtual ~ISubject(){}; virtual void Attach(IObserver *observer) = 0; virtual void Detach(IObserver *observer) = 0; virtual void Notify() = 0; }; /** * The Subject owns some important state and notifies observers when the state * changes. */ class Subject : public ISubject { public: virtual ~Subject() { std::cout \u0026lt;\u0026lt; \u0026#34;Goodbye, I was the Subject.\\n\u0026#34;; } /** * The subscription management methods. */ void Attach(IObserver *observer) override { list_observer_.push_back(observer); } void Detach(IObserver *observer) override { list_observer_.remove(observer); } void Notify() override { std::list\u0026lt;IObserver *\u0026gt;::iterator iterator = list_observer_.begin(); HowManyObserver(); while (iterator != list_observer_.end()) { (*iterator)-\u0026gt;Update(message_); ++iterator; } } void CreateMessage(std::string message = \u0026#34;Empty\u0026#34;) { this-\u0026gt;message_ = message; Notify(); } void HowManyObserver() { std::cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; list_observer_.size() \u0026lt;\u0026lt; \u0026#34; observers in the list.\\n\u0026#34;; } /** * Usually, the subscription logic is only a fraction of what a Subject can * really do. Subjects commonly hold some important business logic, that * triggers a notification method whenever something important is about to * happen (or after it). */ void SomeBusinessLogic() { this-\u0026gt;message_ = \u0026#34;change message message\u0026#34;; Notify(); std::cout \u0026lt;\u0026lt; \u0026#34;I\u0026#39;m about to do some thing important\\n\u0026#34;; } private: std::list\u0026lt;IObserver *\u0026gt; list_observer_; std::string message_; }; class Observer : public IObserver { public: Observer(Subject \u0026amp;subject) : subject_(subject) { this-\u0026gt;subject_.Attach(this); std::cout \u0026lt;\u0026lt; \u0026#34;Hi, I\u0026#39;m the Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; ++Observer::static_number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;.\\n\u0026#34;; this-\u0026gt;number_ = Observer::static_number_; } virtual ~Observer() { std::cout \u0026lt;\u0026lt; \u0026#34;Goodbye, I was the Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;.\\n\u0026#34;; } void Update(const std::string \u0026amp;message_from_subject) override { message_from_subject_ = message_from_subject; PrintInfo(); } void RemoveMeFromTheList() { subject_.Detach(this); std::cout \u0026lt;\u0026lt; \u0026#34;Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34; removed from the list.\\n\u0026#34;; } void PrintInfo() { std::cout \u0026lt;\u0026lt; \u0026#34;Observer \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;number_ \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;: a new message is available --\u0026gt; \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;message_from_subject_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: std::string message_from_subject_; Subject \u0026amp;subject_; static int static_number_; int number_; }; int Observer::static_number_ = 0; void ClientCode() { Subject *subject = new Subject; Observer *observer1 = new Observer(*subject); Observer *observer2 = new Observer(*subject); Observer *observer3 = new Observer(*subject); Observer *observer4; Observer *observer5; subject-\u0026gt;CreateMessage(\u0026#34;Hello World! :D\u0026#34;); observer3-\u0026gt;RemoveMeFromTheList(); subject-\u0026gt;CreateMessage(\u0026#34;The weather is hot today! :p\u0026#34;); observer4 = new Observer(*subject); observer2-\u0026gt;RemoveMeFromTheList(); observer5 = new Observer(*subject); subject-\u0026gt;CreateMessage(\u0026#34;My new car is great! ;)\u0026#34;); observer5-\u0026gt;RemoveMeFromTheList(); observer4-\u0026gt;RemoveMeFromTheList(); observer1-\u0026gt;RemoveMeFromTheList(); delete observer5; delete observer4; delete observer3; delete observer2; delete observer1; delete subject; } int main() { ClientCode(); return 0; } 访问者模式 问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n适用场景:\n如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。\n可使用访问者模式来清理辅助行为的业务逻辑。\n该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。\n当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。\n/** * The Visitor Interface declares a set of visiting methods that correspond to * component classes. The signature of a visiting method allows the visitor to * identify the exact class of the component that it\u0026#39;s dealing with. */ class ConcreteComponentA; class ConcreteComponentB; class Visitor { public: virtual void VisitConcreteComponentA(const ConcreteComponentA *element) const = 0; virtual void VisitConcreteComponentB(const ConcreteComponentB *element) const = 0; }; /** * The Component interface declares an `accept` method that should take the base * visitor interface as an argument. */ class Component { public: virtual ~Component() {} virtual void Accept(Visitor *visitor) const = 0; }; /** * Each Concrete Component must implement the `Accept` method in such a way that * it calls the visitor\u0026#39;s method corresponding to the component\u0026#39;s class. */ class ConcreteComponentA : public Component { /** * Note that we\u0026#39;re calling `visitConcreteComponentA`, which matches the * current class name. This way we let the visitor know the class of the * component it works with. */ public: void Accept(Visitor *visitor) const override { visitor-\u0026gt;VisitConcreteComponentA(this); } /** * Concrete Components may have special methods that don\u0026#39;t exist in their base * class or interface. The Visitor is still able to use these methods since * it\u0026#39;s aware of the component\u0026#39;s concrete class. */ std::string ExclusiveMethodOfConcreteComponentA() const { return \u0026#34;A\u0026#34;; } }; class ConcreteComponentB : public Component { /** * Same here: visitConcreteComponentB =\u0026gt; ConcreteComponentB */ public: void Accept(Visitor *visitor) const override { visitor-\u0026gt;VisitConcreteComponentB(this); } std::string SpecialMethodOfConcreteComponentB() const { return \u0026#34;B\u0026#34;; } }; /** * Concrete Visitors implement several versions of the same algorithm, which can * work with all concrete component classes. * * You can experience the biggest benefit of the Visitor pattern when using it * with a complex object structure, such as a Composite tree. In this case, it * might be helpful to store some intermediate state of the algorithm while * executing visitor\u0026#39;s methods over various objects of the structure. */ class ConcreteVisitor1 : public Visitor { public: void VisitConcreteComponentA(const ConcreteComponentA *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;ExclusiveMethodOfConcreteComponentA() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor1\\n\u0026#34;; } void VisitConcreteComponentB(const ConcreteComponentB *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;SpecialMethodOfConcreteComponentB() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor1\\n\u0026#34;; } }; class ConcreteVisitor2 : public Visitor { public: void VisitConcreteComponentA(const ConcreteComponentA *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;ExclusiveMethodOfConcreteComponentA() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor2\\n\u0026#34;; } void VisitConcreteComponentB(const ConcreteComponentB *element) const override { std::cout \u0026lt;\u0026lt; element-\u0026gt;SpecialMethodOfConcreteComponentB() \u0026lt;\u0026lt; \u0026#34; + ConcreteVisitor2\\n\u0026#34;; } }; /** * The client code can run visitor operations over any set of elements without * figuring out their concrete classes. The accept operation directs a call to * the appropriate operation in the visitor object. */ void ClientCode(std::array\u0026lt;const Component *, 2\u0026gt; components, Visitor *visitor) { // ... for (const Component *comp : components) { comp-\u0026gt;Accept(visitor); } // ... } int main() { std::array\u0026lt;const Component *, 2\u0026gt; components = {new ConcreteComponentA, new ConcreteComponentB}; std::cout \u0026lt;\u0026lt; \u0026#34;The client code works with all visitors via the base Visitor interface:\\n\u0026#34;; ConcreteVisitor1 *visitor1 = new ConcreteVisitor1; ClientCode(components, visitor1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;It allows the same client code to work with different types of visitors:\\n\u0026#34;; ConcreteVisitor2 *visitor2 = new ConcreteVisitor2; ClientCode(components, visitor2); for (const Component *comp : components) { delete comp; } delete visitor1; delete visitor2; return 0; } 责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n适合应用场景:\n当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。\n当必须按顺序执行多个处理者时， 可以使用该模式。\n无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。\n如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。\n/** * The Handler interface declares a method for building the chain of handlers. * It also declares a method for executing a request. */ class Handler { public: virtual Handler *SetNext(Handler *handler) = 0; virtual std::string Handle(std::string request) = 0; }; /** * The default chaining behavior can be implemented inside a base handler class. */ class AbstractHandler : public Handler { /** * @var Handler */ private: Handler *next_handler_; public: AbstractHandler() : next_handler_(nullptr) { } Handler *SetNext(Handler *handler) override { this-\u0026gt;next_handler_ = handler; // Returning a handler from here will let us link handlers in a convenient // way like this: // $monkey-\u0026gt;setNext($squirrel)-\u0026gt;setNext($dog); return handler; } std::string Handle(std::string request) override { if (this-\u0026gt;next_handler_) { return this-\u0026gt;next_handler_-\u0026gt;Handle(request); } return {}; } }; /** * All Concrete Handlers either handle a request or pass it to the next handler * in the chain. */ class MonkeyHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;Banana\u0026#34;) { return \u0026#34;Monkey: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; class SquirrelHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;Nut\u0026#34;) { return \u0026#34;Squirrel: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; class DogHandler : public AbstractHandler { public: std::string Handle(std::string request) override { if (request == \u0026#34;MeatBall\u0026#34;) { return \u0026#34;Dog: I\u0026#39;ll eat the \u0026#34; + request + \u0026#34;.\\n\u0026#34;; } else { return AbstractHandler::Handle(request); } } }; /** * The client code is usually suited to work with a single handler. In most * cases, it is not even aware that the handler is part of a chain. */ void ClientCode(Handler \u0026amp;handler) { std::vector\u0026lt;std::string\u0026gt; food = {\u0026#34;Nut\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cup of coffee\u0026#34;}; for (const std::string \u0026amp;f : food) { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Who wants a \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;?\\n\u0026#34;; const std::string result = handler.Handle(f); if (!result.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; result; } else { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34; was left untouched.\\n\u0026#34;; } } } /** * The other part of the client code constructs the actual chain. */ int main() { MonkeyHandler *monkey = new MonkeyHandler; SquirrelHandler *squirrel = new SquirrelHandler; DogHandler *dog = new DogHandler; monkey-\u0026gt;SetNext(squirrel)-\u0026gt;SetNext(dog); /** * The client should be able to send a request to any handler, not just the * first one in the chain. */ std::cout \u0026lt;\u0026lt; \u0026#34;Chain: Monkey \u0026gt; Squirrel \u0026gt; Dog\\n\\n\u0026#34;; ClientCode(*monkey); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Subchain: Squirrel \u0026gt; Dog\\n\\n\u0026#34;; ClientCode(*squirrel); delete monkey; delete squirrel; delete dog; return 0; } 命令模式 命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n适合应用场景:\n如果你需要通过操作来参数化对象， 可使用命令模式。\n命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。\n举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。\n如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。\n如果你想要实现操作回滚功能， 可使用命令模式。\n尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。\n为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。\n这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。\n其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。\n/** * The Command interface declares a method for executing a command. */ class Command { public: virtual ~Command() { } virtual void Execute() const = 0; }; /** * Some commands can implement simple operations on their own. */ class SimpleCommand : public Command { private: std::string pay_load_; public: explicit SimpleCommand(std::string pay_load) : pay_load_(pay_load) { } void Execute() const override { std::cout \u0026lt;\u0026lt; \u0026#34;SimpleCommand: See, I can do simple things like printing (\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;pay_load_ \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; } }; /** * The Receiver classes contain some important business logic. They know how to * perform all kinds of operations, associated with carrying out a request. In * fact, any class may serve as a Receiver. */ class Receiver { public: void DoSomething(const std::string \u0026amp;a) { std::cout \u0026lt;\u0026lt; \u0026#34;Receiver: Working on (\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;.)\\n\u0026#34;; } void DoSomethingElse(const std::string \u0026amp;b) { std::cout \u0026lt;\u0026lt; \u0026#34;Receiver: Also working on (\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;.)\\n\u0026#34;; } }; /** * However, some commands can delegate more complex operations to other objects, * called \u0026#34;receivers.\u0026#34; */ class ComplexCommand : public Command { /** * @var Receiver */ private: Receiver *receiver_; /** * Context data, required for launching the receiver\u0026#39;s methods. */ std::string a_; std::string b_; /** * Complex commands can accept one or several receiver objects along with any * context data via the constructor. */ public: ComplexCommand(Receiver *receiver, std::string a, std::string b) : receiver_(receiver), a_(a), b_(b) { } /** * Commands can delegate to any methods of a receiver. */ void Execute() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ComplexCommand: Complex stuff should be done by a receiver object.\\n\u0026#34;; this-\u0026gt;receiver_-\u0026gt;DoSomething(this-\u0026gt;a_); this-\u0026gt;receiver_-\u0026gt;DoSomethingElse(this-\u0026gt;b_); } }; /** * The Invoker is associated with one or several commands. It sends a request to * the command. */ class Invoker { /** * @var Command */ private: Command *on_start_; /** * @var Command */ Command *on_finish_; /** * Initialize commands. */ public: ~Invoker() { delete on_start_; delete on_finish_; } void SetOnStart(Command *command) { this-\u0026gt;on_start_ = command; } void SetOnFinish(Command *command) { this-\u0026gt;on_finish_ = command; } /** * The Invoker does not depend on concrete command or receiver classes. The * Invoker passes a request to a receiver indirectly, by executing a command. */ void DoSomethingImportant() { std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: Does anybody want something done before I begin?\\n\u0026#34;; if (this-\u0026gt;on_start_) { this-\u0026gt;on_start_-\u0026gt;Execute(); } std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: ...doing something really important...\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Invoker: Does anybody want something done after I finish?\\n\u0026#34;; if (this-\u0026gt;on_finish_) { this-\u0026gt;on_finish_-\u0026gt;Execute(); } } }; /** * The client code can parameterize an invoker with any commands. */ int main() { Invoker *invoker = new Invoker; invoker-\u0026gt;SetOnStart(new SimpleCommand(\u0026#34;Say Hi!\u0026#34;)); Receiver *receiver = new Receiver; invoker-\u0026gt;SetOnFinish(new ComplexCommand(receiver, \u0026#34;Send email\u0026#34;, \u0026#34;Save report\u0026#34;)); invoker-\u0026gt;DoSomethingImportant(); delete invoker; delete receiver; return 0; } 迭代器模式 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n适合应用场景:\n当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。\n使用该模式可以减少程序中重复的遍历代码。\n重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。\n如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。\n/** * Iterator Design Pattern * * Intent: Lets you traverse elements of a collection without exposing its * underlying representation (list, stack, tree, etc.). */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; /** * C++ has its own implementation of iterator that works with a different * generics containers defined by the standard library. */ template \u0026lt;typename T, typename U\u0026gt; class Iterator { public: typedef typename std::vector\u0026lt;T\u0026gt;::iterator iter_type; Iterator(U *p_data, bool reverse = false) : m_p_data_(p_data) { m_it_ = m_p_data_-\u0026gt;m_data_.begin(); } void First() { m_it_ = m_p_data_-\u0026gt;m_data_.begin(); } void Next() { m_it_++; } bool IsDone() { return (m_it_ == m_p_data_-\u0026gt;m_data_.end()); } iter_type Current() { return m_it_; } private: U *m_p_data_; iter_type m_it_; }; /** * Generic Collections/Containers provides one or several methods for retrieving * fresh iterator instances, compatible with the collection class. */ template \u0026lt;class T\u0026gt; class Container { friend class Iterator\u0026lt;T, Container\u0026gt;; public: void Add(T a) { m_data_.push_back(a); } Iterator\u0026lt;T, Container\u0026gt; *CreateIterator() { return new Iterator\u0026lt;T, Container\u0026gt;(this); } private: std::vector\u0026lt;T\u0026gt; m_data_; }; class Data { public: Data(int a = 0) : m_data_(a) {} void set_data(int a) { m_data_ = a; } int data() { return m_data_; } private: int m_data_; }; /** * The client code may or may not know about the Concrete Iterator or Collection * classes, for this implementation the container is generic so you can used * with an int or with a custom class. */ void ClientCode() { std::cout \u0026lt;\u0026lt; \u0026#34;________________Iterator with int______________________________________\u0026#34; \u0026lt;\u0026lt; std::endl; Container\u0026lt;int\u0026gt; cont; for (int i = 0; i \u0026lt; 10; i++) { cont.Add(i); } Iterator\u0026lt;int, Container\u0026lt;int\u0026gt;\u0026gt; *it = cont.CreateIterator(); for (it-\u0026gt;First(); !it-\u0026gt;IsDone(); it-\u0026gt;Next()) { std::cout \u0026lt;\u0026lt; *it-\u0026gt;Current() \u0026lt;\u0026lt; std::endl; } Container\u0026lt;Data\u0026gt; cont2; Data a(100), b(1000), c(10000); cont2.Add(a); cont2.Add(b); cont2.Add(c); std::cout \u0026lt;\u0026lt; \u0026#34;________________Iterator with custom Class______________________________\u0026#34; \u0026lt;\u0026lt; std::endl; Iterator\u0026lt;Data, Container\u0026lt;Data\u0026gt;\u0026gt; *it2 = cont2.CreateIterator(); for (it2-\u0026gt;First(); !it2-\u0026gt;IsDone(); it2-\u0026gt;Next()) { std::cout \u0026lt;\u0026lt; it2-\u0026gt;Current()-\u0026gt;data() \u0026lt;\u0026lt; std::endl; } delete it; delete it2; } int main() { ClientCode(); return 0; } 中介者模式 中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n适合应用场景:\n当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。\n当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。\n如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; /** * The Mediator interface declares a method used by components to notify the * mediator about various events. The Mediator may react to these events and * pass the execution to other components. */ class BaseComponent; class Mediator { public: virtual void Notify(BaseComponent *sender, std::string event) const = 0; }; /** * The Base Component provides the basic functionality of storing a mediator\u0026#39;s * instance inside component objects. */ class BaseComponent { protected: Mediator *mediator_; public: BaseComponent(Mediator *mediator = nullptr) : mediator_(mediator) { } void set_mediator(Mediator *mediator) { this-\u0026gt;mediator_ = mediator; } }; /** * Concrete Components implement various functionality. They don\u0026#39;t depend on * other components. They also don\u0026#39;t depend on any concrete mediator classes. */ class Component1 : public BaseComponent { public: void DoA() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 1 does A.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;A\u0026#34;); } void DoB() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 1 does B.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;B\u0026#34;); } }; class Component2 : public BaseComponent { public: void DoC() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 2 does C.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;C\u0026#34;); } void DoD() { std::cout \u0026lt;\u0026lt; \u0026#34;Component 2 does D.\\n\u0026#34;; this-\u0026gt;mediator_-\u0026gt;Notify(this, \u0026#34;D\u0026#34;); } }; /** * Concrete Mediators implement cooperative behavior by coordinating several * components. */ class ConcreteMediator : public Mediator { private: Component1 *component1_; Component2 *component2_; public: ConcreteMediator(Component1 *c1, Component2 *c2) : component1_(c1), component2_(c2) { this-\u0026gt;component1_-\u0026gt;set_mediator(this); this-\u0026gt;component2_-\u0026gt;set_mediator(this); } void Notify(BaseComponent *sender, std::string event) const override { if (event == \u0026#34;A\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;Mediator reacts on A and triggers following operations:\\n\u0026#34;; this-\u0026gt;component2_-\u0026gt;DoC(); } if (event == \u0026#34;D\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;Mediator reacts on D and triggers following operations:\\n\u0026#34;; this-\u0026gt;component1_-\u0026gt;DoB(); this-\u0026gt;component2_-\u0026gt;DoC(); } } }; /** * The client code. */ void ClientCode() { Component1 *c1 = new Component1; Component2 *c2 = new Component2; ConcreteMediator *mediator = new ConcreteMediator(c1, c2); std::cout \u0026lt;\u0026lt; \u0026#34;Client triggers operation A.\\n\u0026#34;; c1-\u0026gt;DoA(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client triggers operation D.\\n\u0026#34;; c2-\u0026gt;DoD(); delete c1; delete c2; delete mediator; } int main() { ClientCode(); return 0; } 备忘录模式 备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n适合应用场景：\n当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。\n当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。\n/** * The Memento interface provides a way to retrieve the memento\u0026#39;s metadata, such * as creation date or name. However, it doesn\u0026#39;t expose the Originator\u0026#39;s state. */ class Memento { public: virtual std::string GetName() const = 0; virtual std::string date() const = 0; virtual std::string state() const = 0; }; /** * The Concrete Memento contains the infrastructure for storing the Originator\u0026#39;s * state. */ class ConcreteMemento : public Memento { private: std::string state_; std::string date_; public: ConcreteMemento(std::string state) : state_(state) { this-\u0026gt;state_ = state; std::time_t now = std::time(0); this-\u0026gt;date_ = std::ctime(\u0026amp;now); } /** * The Originator uses this method when restoring its state. */ std::string state() const override { return this-\u0026gt;state_; } /** * The rest of the methods are used by the Caretaker to display metadata. */ std::string GetName() const override { return this-\u0026gt;date_ + \u0026#34; / (\u0026#34; + this-\u0026gt;state_.substr(0, 9) + \u0026#34;...)\u0026#34;; } std::string date() const override { return this-\u0026gt;date_; } }; /** * The Originator holds some important state that may change over time. It also * defines a method for saving the state inside a memento and another method for * restoring the state from it. */ class Originator { /** * @var string For the sake of simplicity, the originator\u0026#39;s state is stored * inside a single variable. */ private: std::string state_; std::string GenerateRandomString(int length = 10) { const char alphanum[] = \u0026#34;0123456789\u0026#34; \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; int stringLength = sizeof(alphanum) - 1; std::string random_string; for (int i = 0; i \u0026lt; length; i++) { random_string += alphanum[std::rand() % stringLength]; } return random_string; } public: Originator(std::string state) : state_(state) { std::cout \u0026lt;\u0026lt; \u0026#34;Originator: My initial state is: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /** * The Originator\u0026#39;s business logic may affect its internal state. Therefore, * the client should backup the state before launching methods of the business * logic via the save() method. */ void DoSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Originator: I\u0026#39;m doing something important.\\n\u0026#34;; this-\u0026gt;state_ = this-\u0026gt;GenerateRandomString(30); std::cout \u0026lt;\u0026lt; \u0026#34;Originator: and my state has changed to: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /** * Saves the current state inside a memento. */ Memento *Save() { return new ConcreteMemento(this-\u0026gt;state_); } /** * Restores the Originator\u0026#39;s state from a memento object. */ void Restore(Memento *memento) { this-\u0026gt;state_ = memento-\u0026gt;state(); std::cout \u0026lt;\u0026lt; \u0026#34;Originator: My state has changed to: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;state_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; /** * The Caretaker doesn\u0026#39;t depend on the Concrete Memento class. Therefore, it * doesn\u0026#39;t have access to the originator\u0026#39;s state, stored inside the memento. It * works with all mementos via the base Memento interface. */ class Caretaker { /** * @var Memento[] */ private: std::vector\u0026lt;Memento *\u0026gt; mementos_; /** * @var Originator */ Originator *originator_; public: Caretaker(Originator *originator) : originator_(originator) { this-\u0026gt;originator_ = originator; } void Backup() { std::cout \u0026lt;\u0026lt; \u0026#34;\\nCaretaker: Saving Originator\u0026#39;s state...\\n\u0026#34;; this-\u0026gt;mementos_.push_back(this-\u0026gt;originator_-\u0026gt;Save()); } void Undo() { if (!this-\u0026gt;mementos_.size()) { return; } Memento *memento = this-\u0026gt;mementos_.back(); this-\u0026gt;mementos_.pop_back(); std::cout \u0026lt;\u0026lt; \u0026#34;Caretaker: Restoring state to: \u0026#34; \u0026lt;\u0026lt; memento-\u0026gt;GetName() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; try { this-\u0026gt;originator_-\u0026gt;Restore(memento); } catch (...) { this-\u0026gt;Undo(); } } void ShowHistory() const { std::cout \u0026lt;\u0026lt; \u0026#34;Caretaker: Here\u0026#39;s the list of mementos:\\n\u0026#34;; for (Memento *memento : this-\u0026gt;mementos_) { std::cout \u0026lt;\u0026lt; memento-\u0026gt;GetName() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } }; /** * Client code. */ void ClientCode() { Originator *originator = new Originator(\u0026#34;Super-duper-super-puper-super.\u0026#34;); Caretaker *caretaker = new Caretaker(originator); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); caretaker-\u0026gt;Backup(); originator-\u0026gt;DoSomething(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; caretaker-\u0026gt;ShowHistory(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Now, let\u0026#39;s rollback!\\n\\n\u0026#34;; caretaker-\u0026gt;Undo(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Once more!\\n\\n\u0026#34;; caretaker-\u0026gt;Undo(); delete originator; delete caretaker; } int main() { std::srand(static_cast\u0026lt;unsigned int\u0026gt;(std::time(NULL))); ClientCode(); return 0; } 状态模式 状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n适合应用场景:\n如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。\n如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。\n当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; /** * The base State class declares methods that all Concrete State should * implement and also provides a backreference to the Context object, associated * with the State. This backreference can be used by States to transition the * Context to another State. */ class Context; class State { /** * @var Context */ protected: Context *context_; public: virtual ~State() { } void set_context(Context *context) { this-\u0026gt;context_ = context; } virtual void Handle1() = 0; virtual void Handle2() = 0; }; /** * The Context defines the interface of interest to clients. It also maintains a * reference to an instance of a State subclass, which represents the current * state of the Context. */ class Context { /** * @var State A reference to the current state of the Context. */ private: State *state_; public: Context(State *state) : state_(nullptr) { this-\u0026gt;TransitionTo(state); } ~Context() { delete state_; } /** * The Context allows changing the State object at runtime. */ void TransitionTo(State *state) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Transition to \u0026#34; \u0026lt;\u0026lt; typeid(*state).name() \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; if (this-\u0026gt;state_ != nullptr) delete this-\u0026gt;state_; this-\u0026gt;state_ = state; this-\u0026gt;state_-\u0026gt;set_context(this); } /** * The Context delegates part of its behavior to the current State object. */ void Request1() { this-\u0026gt;state_-\u0026gt;Handle1(); } void Request2() { this-\u0026gt;state_-\u0026gt;Handle2(); } }; /** * Concrete States implement various behaviors, associated with a state of the * Context. */ class ConcreteStateA : public State { public: void Handle1() override; void Handle2() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA handles request2.\\n\u0026#34;; } }; class ConcreteStateB : public State { public: void Handle1() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB handles request1.\\n\u0026#34;; } void Handle2() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB handles request2.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateB wants to change the state of the context.\\n\u0026#34;; this-\u0026gt;context_-\u0026gt;TransitionTo(new ConcreteStateA); } }; void ConcreteStateA::Handle1() { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA handles request1.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteStateA wants to change the state of the context.\\n\u0026#34;; this-\u0026gt;context_-\u0026gt;TransitionTo(new ConcreteStateB); } /** * The client code. */ void ClientCode() { Context *context = new Context(new ConcreteStateA); context-\u0026gt;Request1(); context-\u0026gt;Request2(); delete context; } int main() { ClientCode(); return 0; } 策略模式 策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n适合应用场景:\n当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。\n当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。\n如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。\n当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。\n/** * The Strategy interface declares operations common to all supported versions * of some algorithm. * * The Context uses this interface to call the algorithm defined by Concrete * Strategies. */ class Strategy { public: virtual ~Strategy() {} virtual std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const = 0; }; /** * The Context defines the interface of interest to clients. */ class Context { /** * @var Strategy The Context maintains a reference to one of the Strategy * objects. The Context does not know the concrete class of a strategy. It * should work with all strategies via the Strategy interface. */ private: Strategy *strategy_; /** * Usually, the Context accepts a strategy through the constructor, but also * provides a setter to change it at runtime. */ public: Context(Strategy *strategy = nullptr) : strategy_(strategy) { } ~Context() { delete this-\u0026gt;strategy_; } /** * Usually, the Context allows replacing a Strategy object at runtime. */ void set_strategy(Strategy *strategy) { delete this-\u0026gt;strategy_; this-\u0026gt;strategy_ = strategy; } /** * The Context delegates some work to the Strategy object instead of * implementing +multiple versions of the algorithm on its own. */ void DoSomeBusinessLogic() const { // ... std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = this-\u0026gt;strategy_-\u0026gt;DoAlgorithm(std::vector\u0026lt;std::string\u0026gt;{\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34;}); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // ... } }; /** * Concrete Strategies implement the algorithm while following the base Strategy * interface. The interface makes them interchangeable in the Context. */ class ConcreteStrategyA : public Strategy { public: std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const override { std::string result; std::for_each(std::begin(data), std::end(data), [\u0026amp;result](const std::string \u0026amp;letter) { result += letter; }); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string DoAlgorithm(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;data) const override { std::string result; std::for_each(std::begin(data), std::end(data), [\u0026amp;result](const std::string \u0026amp;letter) { result += letter; }); std::sort(std::begin(result), std::end(result)); for (int i = 0; i \u0026lt; result.size() / 2; i++) { std::swap(result[i], result[result.size() - i - 1]); } return result; } }; /** * The client code picks a concrete strategy and passes it to the context. The * client should be aware of the differences between strategies in order to make * the right choice. */ void ClientCode() { Context *context = new Context(new ConcreteStrategyA); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context-\u0026gt;DoSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context-\u0026gt;set_strategy(new ConcreteStrategyB); context-\u0026gt;DoSomeBusinessLogic(); delete context; } int main() { ClientCode(); return 0; } 模板方法模式 模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n适合应用场景:\n当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。\n当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。\n/** * The Abstract Class defines a template method that contains a skeleton of some * algorithm, composed of calls to (usually) abstract primitive operations. * * Concrete subclasses should implement these operations, but leave the template * method itself intact. */ class AbstractClass { /** * The template method defines the skeleton of an algorithm. */ public: void TemplateMethod() const { this-\u0026gt;BaseOperation1(); this-\u0026gt;RequiredOperations1(); this-\u0026gt;BaseOperation2(); this-\u0026gt;Hook1(); this-\u0026gt;RequiredOperation2(); this-\u0026gt;BaseOperation3(); this-\u0026gt;Hook2(); } /** * These operations already have implementations. */ protected: void BaseOperation1() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: I am doing the bulk of the work\\n\u0026#34;; } void BaseOperation2() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I let subclasses override some operations\\n\u0026#34;; } void BaseOperation3() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I am doing the bulk of the work anyway\\n\u0026#34;; } /** * These operations have to be implemented in subclasses. */ virtual void RequiredOperations1() const = 0; virtual void RequiredOperation2() const = 0; /** * These are \u0026#34;hooks.\u0026#34; Subclasses may override them, but it\u0026#39;s not mandatory * since the hooks already have default (but empty) implementation. Hooks * provide additional extension points in some crucial places of the * algorithm. */ virtual void Hook1() const {} virtual void Hook2() const {} }; /** * Concrete classes have to implement all abstract operations of the base class. * They can also override some operations with a default implementation. */ class ConcreteClass1 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation2\\n\u0026#34;; } }; /** * Usually, concrete classes override only a fraction of base class\u0026#39; operations. */ class ConcreteClass2 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation2\\n\u0026#34;; } void Hook1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Overridden Hook1\\n\u0026#34;; } }; /** * The client code calls the template method to execute the algorithm. Client * code does not have to know the concrete class of an object it works with, as * long as it works with objects through the interface of their base class. */ void ClientCode(AbstractClass *class_) { // ... class_-\u0026gt;TemplateMethod(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass1 *concreteClass1 = new ConcreteClass1; ClientCode(concreteClass1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass2 *concreteClass2 = new ConcreteClass2; ClientCode(concreteClass2); delete concreteClass1; delete concreteClass2; return 0; } ","date":"2022-01-03T15:48:22Z","permalink":"https://okokfun.github.io/post/c++/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-行为模式"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n代理模式 解释\n对真正要被访问的产品或类加以控制，并可以进行一些控制，把访问产品与代理进行映射，访问代理就相当于访问产品\n适用场景：\n使用代理模式的方式多种多样， 我们来看看最常见的几种。\n延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。\n访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n代理可仅在客户端凭据满足要求时将请求传递给服务对象。\n本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。\n记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。\n代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。\n智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。\n代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。\nclass Subject { public: virtual void Request() const = 0; }; /** * The RealSubject contains some core business logic. Usually, RealSubjects are * capable of doing some useful work which may also be very slow or sensitive - * e.g. correcting input data. A Proxy can solve these issues without any * changes to the RealSubject\u0026#39;s code. */ class RealSubject : public Subject { public: void Request() const override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\\n\u0026#34;; } }; /** * The Proxy has an interface identical to the RealSubject. */ class Proxy : public Subject { /** * @var RealSubject */ private: RealSubject *real_subject_; bool CheckAccess() const { // Some real checks should go here. std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Checking access prior to firing a real request.\\n\u0026#34;; return true; } void LogAccess() const { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Logging the time of request.\\n\u0026#34;; } /** * The Proxy maintains a reference to an object of the RealSubject class. It * can be either lazy-loaded or passed to the Proxy by the client. */ public: Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) { } ~Proxy() { delete real_subject_; } /** * The most common applications of the Proxy pattern are lazy loading, * caching, controlling the access, logging, etc. A Proxy can perform one of * these things and then, depending on the result, pass the execution to the * same method in a linked RealSubject object. */ void Request() const override { if (this-\u0026gt;CheckAccess()) { this-\u0026gt;real_subject_-\u0026gt;Request(); this-\u0026gt;LogAccess(); } } }; /** * The client code is supposed to work with all objects (both subjects and * proxies) via the Subject interface in order to support both real subjects and * proxies. In real life, however, clients mostly work with their real subjects * directly. In this case, to implement the pattern more easily, you can extend * your proxy from the real subject\u0026#39;s class. */ void ClientCode(const Subject \u0026amp;subject) { // ... subject.Request(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the client code with a real subject:\\n\u0026#34;; RealSubject *real_subject = new RealSubject; ClientCode(*real_subject); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the same client code with a proxy:\\n\u0026#34;; Proxy *proxy = new Proxy(real_subject); ClientCode(*proxy); delete real_subject; delete proxy; return 0; } 适配器模式 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n适用场景：\n当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。\n如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。\n将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。\nclass Target { public: virtual ~Target() = default; virtual std::string Request() const { return \u0026#34;Target: The default target\u0026#39;s behavior.\u0026#34;; } }; /** * The Adaptee contains some useful behavior, but its interface is incompatible * with the existing client code. The Adaptee needs some adaptation before the * client code can use it. */ class Adaptee { public: std::string SpecificRequest() const { return \u0026#34;.eetpadA eht fo roivaheb laicepS\u0026#34;; } }; /** * The Adapter makes the Adaptee\u0026#39;s interface compatible with the Target\u0026#39;s * interface. */ class Adapter : public Target { private: Adaptee *adaptee_; public: Adapter(Adaptee *adaptee) : adaptee_(adaptee) {} std::string Request() const override { std::string to_reverse = this-\u0026gt;adaptee_-\u0026gt;SpecificRequest(); std::reverse(to_reverse.begin(), to_reverse.end()); return \u0026#34;Adapter: (TRANSLATED) \u0026#34; + to_reverse; } }; /** * The client code supports all classes that follow the Target interface. */ void ClientCode(const Target *target) { std::cout \u0026lt;\u0026lt; target-\u0026gt;Request(); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: I can work just fine with the Target objects:\\n\u0026#34;; Target *target = new Target; ClientCode(target); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; Adaptee *adaptee = new Adaptee; std::cout \u0026lt;\u0026lt; \u0026#34;Client: The Adaptee class has a weird interface. See, I don\u0026#39;t understand it:\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Adaptee: \u0026#34; \u0026lt;\u0026lt; adaptee-\u0026gt;SpecificRequest(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: But I can work with it via the Adapter:\\n\u0026#34;; Adapter *adapter = new Adapter(adaptee); ClientCode(adapter); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete target; delete adaptee; delete adapter; return 0; } 桥接模式 桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n适用场景：\n如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。\n类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。\n桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。\n如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。\n如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。\n顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。\nclass Implementation { public: virtual ~Implementation() {} virtual std::string OperationImplementation() const = 0; }; /** * Each Concrete Implementation corresponds to a specific platform and * implements the Implementation interface using that platform\u0026#39;s API. */ class ConcreteImplementationA : public Implementation { public: std::string OperationImplementation() const override { return \u0026#34;ConcreteImplementationA: Here\u0026#39;s the result on the platform A.\\n\u0026#34;; } }; class ConcreteImplementationB : public Implementation { public: std::string OperationImplementation() const override { return \u0026#34;ConcreteImplementationB: Here\u0026#39;s the result on the platform B.\\n\u0026#34;; } }; /** * The Abstraction defines the interface for the \u0026#34;control\u0026#34; part of the two class * hierarchies. It maintains a reference to an object of the Implementation * hierarchy and delegates all of the real work to this object. */ class Abstraction { /** * @var Implementation */ protected: Implementation* implementation_; public: Abstraction(Implementation* implementation) : implementation_(implementation) { } virtual ~Abstraction() { } virtual std::string Operation() const { return \u0026#34;Abstraction: Base operation with:\\n\u0026#34; + this-\u0026gt;implementation_-\u0026gt;OperationImplementation(); } }; /** * You can extend the Abstraction without changing the Implementation classes. */ class ExtendedAbstraction : public Abstraction { public: ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) { } std::string Operation() const override { return \u0026#34;ExtendedAbstraction: Extended operation with:\\n\u0026#34; + this-\u0026gt;implementation_-\u0026gt;OperationImplementation(); } }; /** * Except for the initialization phase, where an Abstraction object gets linked * with a specific Implementation object, the client code should only depend on * the Abstraction class. This way the client code can support any abstraction- * implementation combination. */ void ClientCode(const Abstraction\u0026amp; abstraction) { // ... std::cout \u0026lt;\u0026lt; abstraction.Operation(); // ... } /** * The client code should be able to work with any pre-configured abstraction- * implementation combination. */ int main() { Implementation* implementation = new ConcreteImplementationA; Abstraction* abstraction = new Abstraction(implementation); ClientCode(*abstraction); std::cout \u0026lt;\u0026lt; std::endl; delete implementation; delete abstraction; implementation = new ConcreteImplementationB; abstraction = new ExtendedAbstraction(implementation); ClientCode(*abstraction); delete implementation; delete abstraction; return 0; } 组合模式 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n适用场景\n如果你需要实现树状对象结构， 可以使用组合模式。\n组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。\n如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。\n组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; /** * The base Component class declares common operations for both simple and * complex objects of a composition. */ class Component { /** * @var Component */ protected: Component *parent_; /** * Optionally, the base Component can declare an interface for setting and * accessing a parent of the component in a tree structure. It can also * provide some default implementation for these methods. */ public: virtual ~Component() {} void SetParent(Component *parent) { this-\u0026gt;parent_ = parent; } Component *GetParent() const { return this-\u0026gt;parent_; } /** * In some cases, it would be beneficial to define the child-management * operations right in the base Component class. This way, you won\u0026#39;t need to * expose any concrete component classes to the client code, even during the * object tree assembly. The downside is that these methods will be empty for * the leaf-level components. */ virtual void Add(Component *component) {} virtual void Remove(Component *component) {} /** * You can provide a method that lets the client code figure out whether a * component can bear children. */ virtual bool IsComposite() const { return false; } /** * The base Component may implement some default behavior or leave it to * concrete classes (by declaring the method containing the behavior as * \u0026#34;abstract\u0026#34;). */ virtual std::string Operation() const = 0; }; /** * The Leaf class represents the end objects of a composition. A leaf can\u0026#39;t have * any children. * * Usually, it\u0026#39;s the Leaf objects that do the actual work, whereas Composite * objects only delegate to their sub-components. */ class Leaf : public Component { public: std::string Operation() const override { return \u0026#34;Leaf\u0026#34;; } }; /** * The Composite class represents the complex components that may have children. * Usually, the Composite objects delegate the actual work to their children and * then \u0026#34;sum-up\u0026#34; the result. */ class Composite : public Component { /** * @var \\SplObjectStorage */ protected: std::list\u0026lt;Component *\u0026gt; children_; public: /** * A composite object can add or remove other components (both simple or * complex) to or from its child list. */ void Add(Component *component) override { this-\u0026gt;children_.push_back(component); component-\u0026gt;SetParent(this); } /** * Have in mind that this method removes the pointer to the list but doesn\u0026#39;t * frees the * memory, you should do it manually or better use smart pointers. */ void Remove(Component *component) override { children_.remove(component); component-\u0026gt;SetParent(nullptr); } bool IsComposite() const override { return true; } /** * The Composite executes its primary logic in a particular way. It traverses * recursively through all its children, collecting and summing their results. * Since the composite\u0026#39;s children pass these calls to their children and so * forth, the whole object tree is traversed as a result. */ std::string Operation() const override { std::string result; for (const Component *c : children_) { if (c == children_.back()) { result += c-\u0026gt;Operation(); } else { result += c-\u0026gt;Operation() + \u0026#34;+\u0026#34;; } } return \u0026#34;Branch(\u0026#34; + result + \u0026#34;)\u0026#34;; } }; /** * The client code works with all of the components via the base interface. */ void ClientCode(Component *component) { // ... std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component-\u0026gt;Operation(); // ... } /** * Thanks to the fact that the child-management operations are declared in the * base Component class, the client code can work with any component, simple or * complex, without depending on their concrete classes. */ void ClientCode2(Component *component1, Component *component2) { // ... if (component1-\u0026gt;IsComposite()) { component1-\u0026gt;Add(component2); } std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component1-\u0026gt;Operation(); // ... } /** * This way the client code can support the simple leaf components... */ int main() { Component *simple = new Leaf; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I\u0026#39;ve got a simple component:\\n\u0026#34;; ClientCode(simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; /** * ...as well as the complex composites. */ Component *tree = new Composite; Component *branch1 = new Composite; Component *leaf_1 = new Leaf; Component *leaf_2 = new Leaf; Component *leaf_3 = new Leaf; branch1-\u0026gt;Add(leaf_1); branch1-\u0026gt;Add(leaf_2); Component *branch2 = new Composite; branch2-\u0026gt;Add(leaf_3); tree-\u0026gt;Add(branch1); tree-\u0026gt;Add(branch2); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Now I\u0026#39;ve got a composite tree:\\n\u0026#34;; ClientCode(tree); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I don\u0026#39;t need to check the components classes even when managing the tree:\\n\u0026#34;; ClientCode2(tree, simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete simple; delete tree; delete branch1; delete branch2; delete leaf_1; delete leaf_2; delete leaf_3; return 0; } 装饰模式 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n适用场景：\n如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。\n如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n许多编程语言使用 final 最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。\n/** * The base Component interface defines operations that can be altered by * decorators. */ class Component { public: virtual ~Component() {} virtual std::string Operation() const = 0; }; /** * Concrete Components provide default implementations of the operations. There * might be several variations of these classes. */ class ConcreteComponent : public Component { public: std::string Operation() const override { return \u0026#34;ConcreteComponent\u0026#34;; } }; /** * The base Decorator class follows the same interface as the other components. * The primary purpose of this class is to define the wrapping interface for all * concrete decorators. The default implementation of the wrapping code might * include a field for storing a wrapped component and the means to initialize * it. */ class Decorator : public Component { /** * @var Component */ protected: Component* component_; public: Decorator(Component* component) : component_(component) { } /** * The Decorator delegates all work to the wrapped component. */ std::string Operation() const override { return this-\u0026gt;component_-\u0026gt;Operation(); } }; /** * Concrete Decorators call the wrapped object and alter its result in some way. */ class ConcreteDecoratorA : public Decorator { /** * Decorators may call parent implementation of the operation, instead of * calling the wrapped object directly. This approach simplifies extension of * decorator classes. */ public: ConcreteDecoratorA(Component* component) : Decorator(component) { } std::string Operation() const override { return \u0026#34;ConcreteDecoratorA(\u0026#34; + Decorator::Operation() + \u0026#34;)\u0026#34;; } }; /** * Decorators can execute their behavior either before or after the call to a * wrapped object. */ class ConcreteDecoratorB : public Decorator { public: ConcreteDecoratorB(Component* component) : Decorator(component) { } std::string Operation() const override { return \u0026#34;ConcreteDecoratorB(\u0026#34; + Decorator::Operation() + \u0026#34;)\u0026#34;; } }; /** * The client code works with all objects using the Component interface. This * way it can stay independent of the concrete classes of components it works * with. */ void ClientCode(Component* component) { // ... std::cout \u0026lt;\u0026lt; \u0026#34;RESULT: \u0026#34; \u0026lt;\u0026lt; component-\u0026gt;Operation(); // ... } int main() { /** * This way the client code can support both simple components... */ Component* simple = new ConcreteComponent; std::cout \u0026lt;\u0026lt; \u0026#34;Client: I\u0026#39;ve got a simple component:\\n\u0026#34;; ClientCode(simple); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; /** * ...as well as decorated ones. * * Note how decorators can wrap not only simple components but the other * decorators as well. */ Component* decorator1 = new ConcreteDecoratorA(simple); Component* decorator2 = new ConcreteDecoratorB(decorator1); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Now I\u0026#39;ve got a decorated component:\\n\u0026#34;; ClientCode(decorator2); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete simple; delete decorator1; delete decorator2; return 0; } 外观模式 外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。\n适用场景:\n如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。\n如果需要将子系统组织为多层结构， 可以使用外观。\n创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。\n让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与中介者模式非常相似。\n/** * The Subsystem can accept requests either from the facade or client directly. * In any case, to the Subsystem, the Facade is yet another client, and it\u0026#39;s not * a part of the Subsystem. */ class Subsystem1 { public: std::string Operation1() const { return \u0026#34;Subsystem1: Ready!\\n\u0026#34;; } // ... std::string OperationN() const { return \u0026#34;Subsystem1: Go!\\n\u0026#34;; } }; /** * Some facades can work with multiple subsystems at the same time. */ class Subsystem2 { public: std::string Operation1() const { return \u0026#34;Subsystem2: Get ready!\\n\u0026#34;; } // ... std::string OperationZ() const { return \u0026#34;Subsystem2: Fire!\\n\u0026#34;; } }; /** * The Facade class provides a simple interface to the complex logic of one or * several subsystems. The Facade delegates the client requests to the * appropriate objects within the subsystem. The Facade is also responsible for * managing their lifecycle. All of this shields the client from the undesired * complexity of the subsystem. */ class Facade { protected: Subsystem1 *subsystem1_; Subsystem2 *subsystem2_; /** * Depending on your application\u0026#39;s needs, you can provide the Facade with * existing subsystem objects or force the Facade to create them on its own. */ public: /** * In this case we will delegate the memory ownership to Facade Class */ Facade( Subsystem1 *subsystem1 = nullptr, Subsystem2 *subsystem2 = nullptr) { this-\u0026gt;subsystem1_ = subsystem1 ?: new Subsystem1; this-\u0026gt;subsystem2_ = subsystem2 ?: new Subsystem2; } ~Facade() { delete subsystem1_; delete subsystem2_; } /** * The Facade\u0026#39;s methods are convenient shortcuts to the sophisticated * functionality of the subsystems. However, clients get only to a fraction of * a subsystem\u0026#39;s capabilities. */ std::string Operation() { std::string result = \u0026#34;Facade initializes subsystems:\\n\u0026#34;; result += this-\u0026gt;subsystem1_-\u0026gt;Operation1(); result += this-\u0026gt;subsystem2_-\u0026gt;Operation1(); result += \u0026#34;Facade orders subsystems to perform the action:\\n\u0026#34;; result += this-\u0026gt;subsystem1_-\u0026gt;OperationN(); result += this-\u0026gt;subsystem2_-\u0026gt;OperationZ(); return result; } }; /** * The client code works with complex subsystems through a simple interface * provided by the Facade. When a facade manages the lifecycle of the subsystem, * the client might not even know about the existence of the subsystem. This * approach lets you keep the complexity under control. */ void ClientCode(Facade *facade) { // ... std::cout \u0026lt;\u0026lt; facade-\u0026gt;Operation(); // ... } /** * The client code may have some of the subsystem\u0026#39;s objects already created. In * this case, it might be worthwhile to initialize the Facade with these objects * instead of letting the Facade create new instances. */ int main() { Subsystem1 *subsystem1 = new Subsystem1; Subsystem2 *subsystem2 = new Subsystem2; Facade *facade = new Facade(subsystem1, subsystem2); ClientCode(facade); delete facade; return 0; } 享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n适用场景:\n仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：\n程序需要生成数量巨大的相似对象 这将耗尽目标设备的所有内存 对象中包含可抽取且能在多个对象间共享的重复状态。 /** * Flyweight Design Pattern * * Intent: Lets you fit more objects into the available amount of RAM by sharing * common parts of state between multiple objects, instead of keeping all of the * data in each object. */ struct SharedState { std::string brand_; std::string model_; std::string color_; SharedState(const std::string \u0026amp;brand, const std::string \u0026amp;model, const std::string \u0026amp;color) : brand_(brand), model_(model), color_(color) { } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const SharedState \u0026amp;ss) { return os \u0026lt;\u0026lt; \u0026#34;[ \u0026#34; \u0026lt;\u0026lt; ss.brand_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; ss.model_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; ss.color_ \u0026lt;\u0026lt; \u0026#34; ]\u0026#34;; } }; struct UniqueState { std::string owner_; std::string plates_; UniqueState(const std::string \u0026amp;owner, const std::string \u0026amp;plates) : owner_(owner), plates_(plates) { } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const UniqueState \u0026amp;us) { return os \u0026lt;\u0026lt; \u0026#34;[ \u0026#34; \u0026lt;\u0026lt; us.owner_ \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; us.plates_ \u0026lt;\u0026lt; \u0026#34; ]\u0026#34;; } }; /** * The Flyweight stores a common portion of the state (also called intrinsic * state) that belongs to multiple real business entities. The Flyweight accepts * the rest of the state (extrinsic state, unique for each entity) via its * method parameters. */ class Flyweight { private: SharedState *shared_state_; public: Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state)) { } Flyweight(const Flyweight \u0026amp;other) : shared_state_(new SharedState(*other.shared_state_)) { } ~Flyweight() { delete shared_state_; } SharedState *shared_state() const { return shared_state_; } void Operation(const UniqueState \u0026amp;unique_state) const { std::cout \u0026lt;\u0026lt; \u0026#34;Flyweight: Displaying shared (\u0026#34; \u0026lt;\u0026lt; *shared_state_ \u0026lt;\u0026lt; \u0026#34;) and unique (\u0026#34; \u0026lt;\u0026lt; unique_state \u0026lt;\u0026lt; \u0026#34;) state.\\n\u0026#34;; } }; /** * The Flyweight Factory creates and manages the Flyweight objects. It ensures * that flyweights are shared correctly. When the client requests a flyweight, * the factory either returns an existing instance or creates a new one, if it * doesn\u0026#39;t exist yet. */ class FlyweightFactory { /** * @var Flyweight[] */ private: std::unordered_map\u0026lt;std::string, Flyweight\u0026gt; flyweights_; /** * Returns a Flyweight\u0026#39;s string hash for a given state. */ std::string GetKey(const SharedState \u0026amp;ss) const { return ss.brand_ + \u0026#34;_\u0026#34; + ss.model_ + \u0026#34;_\u0026#34; + ss.color_; } public: FlyweightFactory(std::initializer_list\u0026lt;SharedState\u0026gt; share_states) { for (const SharedState \u0026amp;ss : share_states) { this-\u0026gt;flyweights_.insert(std::make_pair\u0026lt;std::string, Flyweight\u0026gt;(this-\u0026gt;GetKey(ss), Flyweight(\u0026amp;ss))); } } /** * Returns an existing Flyweight with a given state or creates a new one. */ Flyweight GetFlyweight(const SharedState \u0026amp;shared_state) { std::string key = this-\u0026gt;GetKey(shared_state); if (this-\u0026gt;flyweights_.find(key) == this-\u0026gt;flyweights_.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;FlyweightFactory: Can\u0026#39;t find a flyweight, creating new one.\\n\u0026#34;; this-\u0026gt;flyweights_.insert(std::make_pair(key, Flyweight(\u0026amp;shared_state))); } else { std::cout \u0026lt;\u0026lt; \u0026#34;FlyweightFactory: Reusing existing flyweight.\\n\u0026#34;; } return this-\u0026gt;flyweights_.at(key); } void ListFlyweights() const { size_t count = this-\u0026gt;flyweights_.size(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nFlyweightFactory: I have \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; flyweights:\\n\u0026#34;; for (std::pair\u0026lt;std::string, Flyweight\u0026gt; pair : this-\u0026gt;flyweights_) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } }; // ... void AddCarToPoliceDatabase( FlyweightFactory \u0026amp;ff, const std::string \u0026amp;plates, const std::string \u0026amp;owner, const std::string \u0026amp;brand, const std::string \u0026amp;model, const std::string \u0026amp;color) { std::cout \u0026lt;\u0026lt; \u0026#34;\\nClient: Adding a car to database.\\n\u0026#34;; const Flyweight \u0026amp;flyweight = ff.GetFlyweight({brand, model, color}); // The client code either stores or calculates extrinsic state and passes it // to the flyweight\u0026#39;s methods. flyweight.Operation({owner, plates}); } /** * The client code usually creates a bunch of pre-populated flyweights in the * initialization stage of the application. */ int main() { FlyweightFactory *factory = new FlyweightFactory({{\u0026#34;Chevrolet\u0026#34;, \u0026#34;Camaro2018\u0026#34;, \u0026#34;pink\u0026#34;}, {\u0026#34;Mercedes Benz\u0026#34;, \u0026#34;C300\u0026#34;, \u0026#34;black\u0026#34;}, {\u0026#34;Mercedes Benz\u0026#34;, \u0026#34;C500\u0026#34;, \u0026#34;red\u0026#34;}, {\u0026#34;BMW\u0026#34;, \u0026#34;M5\u0026#34;, \u0026#34;red\u0026#34;}, {\u0026#34;BMW\u0026#34;, \u0026#34;X6\u0026#34;, \u0026#34;white\u0026#34;}}); factory-\u0026gt;ListFlyweights(); AddCarToPoliceDatabase(*factory, \u0026#34;CL234IR\u0026#34;, \u0026#34;James Doe\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;M5\u0026#34;, \u0026#34;red\u0026#34;); AddCarToPoliceDatabase(*factory, \u0026#34;CL234IR\u0026#34;, \u0026#34;James Doe\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;X1\u0026#34;, \u0026#34;red\u0026#34;); factory-\u0026gt;ListFlyweights(); delete factory; return 0; } ","date":"2022-01-03T15:07:58Z","permalink":"https://okokfun.github.io/post/c++/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-结构型模式"},{"content":" 推荐看👉 OI Wiki\n数据结构：数据结构是为算法服务而设计的。 算法：充分且合理利用计算机资源处理数据而诞生。\n数据结构部分 一. 数据结构的存储方式有两种 1.顺序存储(数组,内存连续) 2.链式存储(链表,内存不连续,依靠节点的指针指向下一个节点) 常见的数据结构有：\n数组(array),链表(LinkedList),\n双向链表(doubly-linked-list),\n树：\n二叉树(Binary tree),\n二叉查找树(Binary Search Tree),平衡二叉树(AVL),\n2-3-4树\n红黑树(Red Black Tree), B树, B+树, B*树, AA-树\ntreap树, k-d树, 伸展树(Splay Tree)\n最小生成树(Minimum Spanning Tree)\n图(graph),\n栈(stack), 堆(heap),队列(queue),\n散列表(hash), 位图(bitmap),\n字典(map)\n二 常见数据结构实现 1.链表 链表(LinkedList) 避免数组插入和删除的线性开销,我们需要允许表可以不连续存储,防止数据大量移动\n链表的设计 设计成一个链表节点至少包含两部分：\n数据部和指针部\n数据部为我们要存储的数据,指针部为指向下一个链表节点\ntypedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 单向链表 typedef struct ListElmt_ { void *data; struct ListElmt_ *next; } ListElmt; 例子 /*1ist.h*/ #ifndef LIST_H #define LIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for linked list elements. */ typedef struct ListElnt_ { void *data: struct ListElnt *next; } ListElmt; /* Define a structure for linked lists, */ typedef struct List_ { int size: int (*match()const void *keyl, const void *key2); void (*destroy)(void *data); ListElmt *head; ListElmt *tail; } List; /* Public Interface*/ void list_init(List *list, void (*destroy)(void *data)); // 初始化一个链表以便于进行后续操作 void list_destroy(List *list);\tint list_ins_next(List *list, ListEInt *element, const void *data); int list_rem_next(List *list, ListElnt *element, void **data); #define list_size(list()(list)-\u0026gt;size) #define list_head(list()(list)-\u0026gt;head) #define list_tail(1ist()(1ist)-\u0026gt;tail) #define list_is_head(list, element()(element)= (list)-\u0026gt;head ? 1: 0) #define list_is_tail(element()(element)-\u0026gt;next NULL ? 1:0) #define list_data(element()(element)-\u0026gt;data) #define list_next(element()(element)-\u0026gt;next) #endif /* list.c*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /*list init */ void list_init(List *list, void (*destroy)(void *data)) { /* Initialize the list. */ list-\u0026gt;size = 0; list-\u0026gt;destroy = destroy; list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; } /*listdestroy*/ void list_destroy(List *list) { void* data; /* Remove each element.*/ while (list_size(list) \u0026gt; 0) { if (0 == list_rem_next(list, NULL, (void **)\u0026amp;data) \u0026amp;\u0026amp; NULL != list-\u0026gt;destroy){ /* Call a user-defined function to free dynanically allocated data, */ list-\u0026gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precaution. */ memset(list, 0, sizeof(List)); } /*list_ins_next*/ int list_ins_next(List *list, ListElmt *element,const void *data) { ListElmt*\tnew_element; /*Allocate storage for the element. */ if(NULL == (new_element-(ListElmt*)malloc(sizeof(ListElmt)))) return -1; /* Insert the element into the list. */ new_element-\u0026gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list. */ if (list_size(list)==0) list-\u0026gt;tail = new _element; new_element-\u0026gt;next = list-\u0026gt;head; list-\u0026gt;head=new_element; } else { /* Handle insertion somewhere other than at the head. */ if(element-\u0026gt;next == NULL) list-\u0026gt;tail = new_element; new_element-\u0026gt;next = element-\u0026gt;next; element-\u0026gt;next = new_element; } /*Adjust the size of the list to account for the inserted element. */ list-\u0026gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt\t*old_element; /*Do not allow removal from an empty list.*/ if (list_size(list) == 0) return -1; /* Remove the element from the list. */ if (element == NULL) { /* Handle removal from the head of the list, */ *data = list-\u0026gt;head-\u0026gt;data; old_element = list-\u0026gt;head; list-\u0026gt;head = list-\u0026gt;head-\u0026gt;next; if (list_size(list) == 1) list-\u0026gt;tail = NULL; } else { /* Handle removal from somewhere other than the head. */ if (element—\u0026gt;next == NULL) return -1; *data = element-\u0026gt;next-\u0026gt;data; old_element = element-\u0026gt;next; element-\u0026gt;next = element-\u0026gt;next-\u0026gt;next; if (element-\u0026gt;next = NULL) list-\u0026gt;tail = element; } /* Free the storage allocated by the abstract datatype. */ free(old_element); /*Adjust the size of the list to account for the removed element.*/ 1ist—\u0026gt;size--; return 0; } 双向链表 typedef struct DListEImt_ { void *data; struct DListEImt_ *prev; struct DListEImt_ *next; } DListEImt; 例子 /*dlist h */ #ifndef DLIST_H #define DLIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for doubly-linked list elements. */ typedef struct DListEImt_ { void *data; struct DListEImt_ *prev; struct DListEImt_ *next; } DListEImt; /*Define structure for doubly-linked lists. */ typedef struct Dlist_ { int size; int (*match)(const void*key1, const void *key2); void (*destroy)(void *data); DListEImt *head; DListEImt *tail; }DList; /* Public Interface */ void dlist_init(DList *list, void (*destroy)(void *data)); void dlist_destroy(DList *list); int dlist_ins_next(DList *list, DListEImt *element const void *data); int dlist_ins_prev(DList *list, DListEImt *element, const void *data); int dlist_remove(DList *list, DListEImt *element, void **data); #define dlist_size(list)\t((list)-\u0026gt;size) #define dlist_tail(list)\t((list)-\u0026gt;tail) #define dlist_is_head(element)\t((element)-\u0026gt;prev == NULL ? 1: 0) #define dlist_is_tail(element)\t((element)-\u0026gt;next == NULL ? 1: 0) #define dlist_data(element)\t((element)-\u0026gt;data) #define diist_next(element)\t((element)-\u0026gt;next) #define dlist_prev(element)\t(element )-\u0026gt;prev) /*d]主st.C*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include dlist . h /* dlist init */ void dlist_init(DList *list, void (*destroy)(void *data)) { /* Initialize the list. */ list-\u0026gt;size = 0; list-\u0026gt;destory = destroy; list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; } /* dlist_destory */ void dlist_destroy (DList *list) { void *data /* Remove each element. */ while (dlist_size(list) \u0026gt; 0) { if (dlist_remove(list, dlist_tail(list), (void**)adata)==0 \u0026amp;\u0026amp; list-\u0026gt;destory != NULL) { /* Call a user-defined function to free dynamically allocated data. */ list-\u0026gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precaution. */ memset(list, 0, sizeof(DList)); } int dlist_ins_next(DList *list, DListElmt *element, const void *data) { DListElmt *new_element; /* Do not allow a NUll element unless the list is empty. */ if (element == NULL \u0026amp;\u0026amp; dlist_size(list) != 0) return -1; /* Allocate storage for the element. */ if ((new_element = (DListElmt *)malloc(sizeof(DListElmt)))== NULL) return -1: /* Insert the new_element into the list. */ new_element-\u0026gt;data = (void *)data; if (dlist size(list) == 0) { /* Handle insertion when the list is empty. */ list-\u0026gt;head = new_element; list-\u0026gt;head-\u0026gt;prev = NULL; list-\u0026gt;head-\u0026gt;next = NULL; list-\u0026gt;tail = new_element; } else { /* Handle insertion when the list is not empty. */ new_element-\u0026gt;next = element-\u0026gt;next; new_element-\u0026gt;prev = element; if(element-\u0026gt;next == NULL) list-\u0026gt;tail = new_element; else element-\u0026gt;next-\u0026gt;prev = new_element; element-\u0026gt;next = new_element; } /* Adjust the size of the list to account for the inserted element. */ list-\u0026gt;size++; return 0; } /* dlist ins_ prev */ int dlist_ins_prev(DList *list, DListElmt *element, const void *data) { DListElmt *new_element; /* Do not allow a NULL element unless the list is empty. */ if (element == NULL \u0026amp;\u0026amp; dlist_size(list) != 0) return -1; /* Allocate storage to be managed by the abstract datatype. */ if(new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL) return - 1; /* Insert the new_element into the list */ new_element-\u0026gt;data =(void *)data; if (dlist_size(list)== 0) { /* Handle insertion when the list is empty. */ list-\u0026gt;head = new_element; list-\u0026gt;head-\u0026gt;prev = NULL; list-\u0026gt;head-\u0026gt;next = NULL; list-\u0026gt;tail = new_element; } else { /* Handle inserton when the list is not empty. */ new_element = element; new_element-\u0026gt;prev = element-\u0026gt;prev; if (element-\u0026gt;prev == NULL) list-\u0026gt;head = new_element; else element-\u0026gt;prev-\u0026gt;next = new_element; element-\u0026gt;prev = new_element; } /* Adjust the size of the list to account for the new_element. */ list-\u0026gt;size++; return 0; } /* d1ist_remove */ int dlist_remove(DList *list, DListElmt. *element, void s*data) { /* Do not allow a NULL element or removal from an empty list. */ if (element == NULL || dlist_size(list) == 0) return -1: /* remove the element from the list. */ *data s element -\u0026gt;data; if (element == list-\u0026gt;head) { /* Handle removal from the head of the list. */ list-\u0026gt;head = element-\u0026gt;next; if (list-\u0026gt;head == NULL) list-\u0026gt;tail = NULL; else element-\u0026gt;next-\u0026gt;prev = NULL; } else { /* Handle removal from other than the head of the list. */ element-\u0026gt;prev-\u0026gt;next = element-\u0026gt;next; if (element-\u0026gt;next == NULL) list-\u0026gt;tail = elenent-\u0026gt;prev; else element-\u0026gt;next-\u0026gt;prev = element-\u0026gt;prev; } /* Free the storage allocated by the abstract datatype. */ free(element); /* Adjust the size of the list to account for the removed element */ list-\u0026gt;size--; return 0; } 循环链表 typedef struct ClistElmt_ { void *data; struct ClistElmt_ *next; }ClistElmt; 例子 /* clist .h */ #ifndef CLIST_H #define CLIST_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for circular list elements .*/ typedef struct CListElmt { void * data; struct CListElmt * next; } CListElmt; /* Definea structure for circular lists .*/ typedef struct CList_ { int size; int (*match)(constvoid * key1, const void * key2); void (*destroy)(void* data); CListElmt *head; }CList; /* Public Interface */ void clist_init(CList* list,void ( *destroy)( void* data)); void clist_destroy(CList* list); int clist_ins_next (CList* list,CListElmt * element,const void *data); int clist_rem_next (CList* list,CListElmt * element,void **data); #defineclist _size(list)((list)-\u0026gt;size) #defineclist head (list)(()-\u0026gt;head) #defineclist data (element)((element)-\u0026gt;data) #defineclist _next(element)((element)-\u0026gt;next) #endif /* clist .c */ #include \u0026lt;stdlib.h \u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;clist.h\u0026#34; /* clist init */ void clist_init(CList* list,void ( *destroy)( void* data)) { /* Initialize the list .*/ list-\u0026gt;size = 0; list-\u0026gt;destroy = destroy ; list-\u0026gt;head = NULL; } /* clist destroy */ void clist_destroy (CList* list) { void *data; /* Remove each element .*/ while (clist_size(list) \u0026gt; 0) { if (clist_remnext (list,list-\u0026gt;head, (void **)\u0026amp;data)== 0 \u0026amp;\u0026amp; list-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data .*/ list-\u0026gt;destroy(data); } } /* No operations are allowed now ,but clear the structure as a precaution .*/ memset (list, 0, sizeof(CList)); } /* clist ins next */ int clist_insnext (CList* list,CListElmt * element,const void * data) { CListElmt* new_element; /*Allocate storage for the element .*/ if ((new_element = (CListElmt* )malloc(sizeof(CListElmt))) == NULL) return -1; /* Insert the element into the list .*/ new_element-\u0026gt;data = (void *)data; if (clist_size(list) == 0) { /* Handle insertion when the list empty .*/ new_element-\u0026gt;next = new_element; list-\u0026gt;head = new_element; } else { /* Handle insertion when the list is not empty .*/ new_element-\u0026gt;next = element-\u0026gt;next; element-\u0026gt;next = new_element; } /* Adjust the size of the list to account for the inserted element .*/ list-\u0026gt;size++; return 0 ; } /* clist_rem_next */ int clist_rem_next(CList* list, CListElmt *element,void **data) { CListElmt * old_element; /* Do not allow removal from an empty list . */ if (clist_size(list) == 0) return -1; /* Remove the element from the list . */ *data = element-\u0026gt;next-\u0026gt;data; if (element-\u0026gt;next == element) { /* Handle removing the last element . */ old_element = element-\u0026gt;next; list-\u0026gt;headNULL; } else { /* Handle removing other than the last element . */ old_element = element-\u0026gt;next; element-\u0026gt;next = element-\u0026gt;next-\u0026gt;next; if (old_element == clist_head(list)) list-\u0026gt;head = old_element-\u0026gt;next; } /* Free the storage allocated by the abstract datatype . */ free(old_element); /* Adjust the size of the list to account for the removed element . */ 1ist-\u0026gt;size--; return 0; } 2.栈和队列 栈和队列是另一种数据的存储方式。\n用于检索数据的常用数据结构称为栈,栈的检索顺序和存储元素相反\n栈: 按照后进先出的顺序存储和检索数据的高效数据结构, 它检索数据的顺序和存储数据相反。\n队列：按照先进先出的顺序存储和检索数据的高效数据结构, 它按照存储元素的顺序检索元素。\n栈例子 /* stack .h*/ #ifndef STACK_H #define STACK_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement stacks as linked lists .*/ typedef List Stack; /*Public Interface */ #define stack_init list_init #define stack_destroy list_destroy int stack_push(Stack* stack,const void * data); int stack_pop(Stack* stack,void ** data); #define stack_peek(stack)\t((stack)-\u0026gt;head == NULL ? NULL : (stack)-\u0026gt;head-\u0026gt;data) #define stack_size list_size #endif /* Stack.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;Stack.h\u0026#34; /* stack_push */ int stack_push(Stack* stack,const void * data) { /* push the data onto the stack. */ return list_ins_next(stack, NULL, data); } /* stack_pop */ int stack_pop(Stack* stack,void ** data) { /* Pop the data off the stack. */ return list_rem_next(stack, NULL, data); } 队列例子 /* queue . h */ #ifndef QUEUE_H #define QUEUE_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement queues as linked lists . */ typedef List Queue ; /* Public Interface */ #define queue_init list_init #define queue_destroy list_destroy int queue_enqueue (Queue * queue, const void* data ); int queue_dequeue (Queue * queue, void **data); #define queue_peek(queue()(queue)-\u0026gt;head == NULL ? NULL : (queue)-\u0026gt;head-\u0026gt;data) #define queue_size list_size #endif /* queue.c */ #include \u0026lt;stdlib\u0026gt;h \u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;queue.h\u0026#34; /* queue_enqueue */ int queue_enqueue (Queue* queue, const void* data) { /* Enqueue the data . */ return list_ins_next(queue, list_tail(queue), data); } /* queue_dequeue */ int queue_dequeue(Queue* queue, void** data) { /* Dequeue the data . */ return list_rem_next(queue, NULL, data); } 队列示例：事件处理 遵循实时事件发生的顺序执行。\n/* events.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;event.h\u0026#34; #include \u0026#34;events.h\u0026#34; #include \u0026#34;queue.h\u0026#34; /* receive_event */ int receive_event(Queue *events, const Event *event) { Event* new_event; /* Allocate space for the event. */ if(NULL == (new_event = (Event*)(sizeof(Event)))) return -1; /* Make a copy of the event and enqueue it. */ memcpy(new_event, event, sizeof(Event)); if(queue_enqueue(events, new_event) != 0) return -1; return 0; } /* process_event */ int process_event(Queue *events, int (*dispatch)(Event* event)) { Event* event; if(0 == queue_size(events)) /* Return that there are no events to dispatch. */ return -1; else { if(0 != queue_deququq(events, (void **)\u0026amp;event)) /* Return that an event could not be retrived. */ return -1; else { /* Call a user-defined fintion to dispatch the event. */ dispatch(event); free(event); } } return 0; } 3.集合 集合定义：集合是相关联成员的无序组合,且每个成员在集合中只出现一次\n例子 /* set.h */ #ifndef SET_H #define SET_H #include \u0026lt;Stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Implement sets as linked lists. */ typedef List Set; /* Public Interface */ void set_init(Set *set, int (*match)(const void *keyl, const void *key2), void (*destory)(void *data)); int set_insert(Set *set, const void *data); int set_remcve(Set *set, void **data); int set_union(Set *setu, const Set *setl, const Set *set2); int set_intersection(Set*seti, const Set *seta, const Set *set2); int set_difference(Set *setd, const Set *setl, const Set *set2); int set_is_memeber(const Set *set, const void *data); int set_is_subset(const Set *setl, const Set *set2); int set_is_equal(const Set *setl, const Set *set2); #define set_size(set()(set) osize) #define set_destroy list_destroy #endif /* set.c */ #include \u0026lt;Stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;set.h\u0026#34; /* set_init */ void set_init(Set *set, int (*match)(const void *keyl, const void *key2), void (*destory)(void *data)) { /* Initialize the set. */ list_init(set, destory); set-\u0026gt;match = match; } /* set_insert */ int set_insert(Set *set, const void *data) { /* Do not allow the insertion of duplicates. */ if (set_in_number(set, data)) return 1; /* Insert the data. */ return list_ins_tail(set, list_tail(set), data); } /* set_remove. */ int set_remove(Set* set, void **data) { ListE1mt *member, *prev; /* Find the member to remove.*/ prev = NULL; for (member = list_head(set); member != NULL; member = list_next(member)) { if list_data(member))) break; prev = member; } /* Return if the member was not found.*/ if (member == NULL) return -1 ; /* Remove the member. */ return list_rem_next(set, prev, data); } /* set_union */ int set_unicn(Set *setu, const Set *setl, const Set *set2) { ListE1mt *member; void *data; /* Initialize the set for the union. */ set_init(setu, set1-\u0026gt;match, NULL); /* Insert the members of the first set. */ for (member = list_head(setl); member != NULL; member = list_next(member)) { data = list_data(member); if (list_ins_next(setu, list_tail(setu), data) != 0) { set_destroy(setu); return -1; } } /* Insert the members of the second set. */ for (member = list_head(set2); member != NULL; member = list_next(member)) { if (set_is_member(setl, list_data(member))) { /* Do not allow the insertion of duplicates. */ continue; } else { data = list_data(member); if (list_ins_next(setu, list_tail(setu), data) != 0) { set_destroy(setu); return -1; } } } return 0; } /* set_intersection */ int set_intersection(Set *seti, const Set *setl, const Set *set2) { ListElmt *member; void *data; /* Initialize the set for the intersection. */ set_init(set1, set1-\u0026gt;match, NULL); /* Insert the members present in both sets- */ for (member = list_head(set1); member != NULL; member = list_next(member)) { if (set_is_member(set2, list_data(member))) { data = list_data(member); if (list_ins_next(seti, list_tail(seti), data) != 0) { set_destroy(seti); return -1; } } } return 0; } /* set_difference */ int set_difference(Set *setd, const Set *seti, const Set *set2) { ListElmt *member; void *data; /* Initialize the set for the difference. */ $et_init(setd, set1-Mnatch, NULL); /* Insert the members from setl not in set2 */ for (member = list_head(setl); member != NULL; member = list_next(member)) { if (lset_is_member(set2, list_data(member))) { data = list_data(member); if (list_ins_next(setd, list_tail(setd), data) != 0) { set_destroy(setd); return -1; } } } return 0; } /* set_ls_member */ int set_is_member(const Set *set const void *data) { ListElmt *member; /* Determine if the data is a member of the set. */ for (member = list_head(set); member != NULL; member = list_next(member)) { if (set-\u0026gt;match(dataj listdata(member))) return 1; } return o; } /* set_is_subset */ int set_is_subset(const Set *setl, const Set *set2) { ListElmt\t*member; /* Do a quick test to rule out some cases. */ if (set_size(setl) \u0026gt; set_size(set2)) return 0; /* Determine if setl is a subset of set2, */ for (member = list_head(set1); member != NULL; member = list_next(member)) { if(!list_is_member(set2, list_data(member))) return 0; } return 1; } /* setis_equal */ int set_is_equal(const Set *setl, const Set *set2) { /* Do a quick test to rule out some cases. */ if (set_size(setl) != set_size(set2)) return 0; /* Sets of the same size are equal if they are subsets, */ return set_is_subset(set1, set2); } Set示例：集合覆盖 集合覆盖是一种优化求解问题, 对很多组合数学和资源选择问题给出了漂亮的抽象模型\n/* cover,c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;cover.h” #include \u0026#34;list\u0026#39;h\u0026#34; #include \u0026#34;set.h\u0026#34; /* cover */ int cover(Set *members\u0026gt; Set 率subsets, Set *covering) { Set intersection; KSet *subset; ListElflit *member, *max_member; void *data; int max_size; /* Initialize the covering» */ set_init(covering, subsets-\u0026gt;match, NULL); /* Continue while there are noncovered members and candidate subsets. */ while (set_size(members) \u0026gt; 0 \u0026amp;\u0026amp; set_size(subset) \u0026gt; 0) { /* Find the subset that covers the most members.*/ max_size = 0; for (member = list_head(subsets); member != NULL; member = list_next(member)) { if (set-intersectionC(\u0026amp;intersection, \u0026amp;((KSet *)list_data(member))-\u0026gt;set, members) != 0) { return -1; } if (set_size(\u0026amp;inteisection) \u0026gt; max_size) { max_member = member; max_size = set_size(\u0026amp;intersection); } set_destroy(\u0026amp;intersection); } /* A covering is not possible if there was no intersection♦ */ if (max_size == 0) return 1; /* Insert the selected subset into the covering» */ subset = (KSet *)list_data(max_nember); if (set_insert(coverings, subset) != 0) return -1; /* Remove each covered member -from the set of noncovered members. */ for (member = list_head(\u0026amp;((KSet *)list_data(max_member))-\u0026gt;set); member != NULL; member = list_next(member)) { data = list_data(member); if(set_remove(members, (void*)\u0026amp;data) == 0 \u0026amp;\u0026amp; members-\u0026gt;destory != NULL) members-\u0026gt;destory(data); } /* Remove the subset from the set of cnadidate subsets. */ if(set_remove(subsets, (void**)\u0026amp;subset) != 0) return -1; } /* No covering is possible if there are still noncoverd member */ if(set_size(members) \u0026gt; 0) return -1; return 0; } 4.哈希表 哈希表是一种最有效的检索方法：散列。\n从根本上来说,一个哈希表包含一个数组, 通过特殊的索引值(键)来访问数组中的元素,哈希表的主要思想是通过一个哈希函 数,在所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与 键相对应的哈希编码或哈希值。键的数据类型可能多种多样,但哈希值的类型只能是整型。\n链式哈希表 将数据存储在 桶 (bucket)中的哈希表。每个 “桶” 都是都是一个链表; 且链表的 容量能够随着冲突的增加而增大。\n解决哈希表冲突 如果想插入表中的元素数量远大于桶数量,那么即使是在一个均匀散列过的程中,表的性能会迅速降低。这种情况下桶会变得越来越深。因此我们要注意一个哈希表的负载因子。\n其定义为：\n​\tα = n/m\n​\tn为表中的元素数量,m是桶中的数量(数组元素数量)。\n​\t在均匀散列情况下,链式哈希表的负载因子告诉我们表中桶能装元素的最大值\n选择哈希函数 这是哈希算法的核心问题：将键随机地分散到表中,使冲突最小化。因此,选择一 个能够实现这一过程的哈希函数尤为重要。\n其定义为：\n​\th(k) = x\n​\tk为要被映射的值,h()为哈希函数,x为哈希表的位置\n例子 /* chtbl.h */ #ifndef CHTBL_H #define CHTBL_H #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;list.h\u0026#34; /* Define a structure for chained hash table. */ typedef struct CHTBL_ { int buckets; int (*h)(const void* key); int (*match)(const void* key1, const void *key2); int size; List* table; } CHTbl; /* Public interface */ int chtbl_init(CHTbl* htbl, int buckets, int (*h)(const void* key), int (*match)(const void* key1, const void *key2), void (*destory)(void* data)); void chtbl_destory(CHTbl *htbl); int chtbl_insert(CHTbl *htbl, const void *data); int chtbl_remove(CHTbl *htbl, void **data); int chtbl_lookup(CHTbl *htbl, void **data); #define chtbl_size(htbl()(chtbl)-\u0026gt;size) #endif /*chtbl.c*/ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;list.h\u0026#34; #include \u0026#34;chtbl.h\u0026#34; /* chtbl_init */ int chtbl_init(CHTbl* htbl, int buckets, int (*h)(const void* key), int (*match)(const void* key1, const void *key2), void (*destory)(void* data)) { int i; /* Allocate space for the hash table.*/ if ((htbl-\u0026gt;table = (List *)malloc(buckets * sizeof(List))) == NULL) return -1; /* Initialize the buckets. */ htbl-\u0026gt;buckets = buckets; for(i = 0; i \u0026lt; htbl-\u0026gt;buckets; i++) list_init(\u0026amp;htbl-\u0026gt;table[i], destroy); /* Encapsulate the functions. */ htbl-\u0026gt;h = h htbl-\u0026gt;match match; htbl-\u0026gt;destroy = destroy; /* Initialize the number of elements in the table. */ htbl-\u0026gt;size = o; return 0; } /* chtbl_destroy */ void chtbl_destory(CHTbl *htbl) { /* Destroy each bucket. */ for (int i = O; i \u0026lt; htbl-\u0026gt;buckets; i++) { list_destroy (\u0026amp;htbl -\u0026gt;tableßl) ; } /*Free the storage allocated for the hash table. */ free(htbl-\u0026gt;table); /* No operations are allowed now, but clear the structure as a precaution.*/ memset(htbl, 0, sizeof(CHTbl)); } /* chtbl insert */ int chtbl_insert(CHTbl *htbl, const void *data) { void* temp; int bucket, retval; /* Do nothing if the data is already in the table. */ temp = (void *)data; if(chtbl_lookup(htbl, \u0026amp;temp) == 0) return 1 ; /* Hash the key. */ bucket = htbl-\u0026gt;h(data) % htbl-\u0026gt;buckets; /* Insert the data into the bucket. */ if (0 == (retval = list_ins_next(\u0026amp;htbl-\u0026gt;table[bucket], NULL, data))) htbl-\u0026gt;size++; return retval; } /* chtbl remove */ int chtb1_remove(CHTbl* htbl, void **data) { ListEImt*\telement, *prev; int bucket; /* Hash the key. */ bucket = htbl-\u0026gt;h(*data) % htbl-\u0026gt;buckets; /* Search fcy the data in the bucket. */ prev = NULL; for (element = list_head(\u0026amp;htbl-\u0026gt;table[bucket]); element != NULL; element = list_next(element)) { if (htbl-\u0026gt;match(*data, list_data(element))) { /* Remove the data from the bucket. */ if(0 == list_rem_next(\u0026amp;htbl-\u0026gt;table[bucket], prev, data)) { htbl-\u0026gt;size--; return 0; } else return -1; } prev = element; } /* Return that the data was not found. */ return -1; } /* chtbl lookup */ int chtbl_lookup(CHTbl *htbl, void **data) { ListE1mt *element; int bucket; /* Hash the key.*/ bucket = htbl-\u0026gt;h(*data) % htbl-\u0026gt;buckets; /* Search for the data in the bucket.*/ for(element = list_head(\u0026amp;htbl-\u0026gt;table[bucket]); element = list_next(eleemnt)) { if(htbl-\u0026gt;match(*data, list_data(element))) { /* Pass back the data from the table. */ *data = list_data(element); return 0; } } /* Return that the was not found. */ return -1; } 开地址哈希表 将数据存储在表本身中,而不是桶中的哈希表。它通过各种探查方法来避免冲突问题。\n例子 /* ohtbl.h */ #ifndef OHTBL_H #define OHTBL_H #incluge\u0026lt;stdlib.h\u0026gt; /*Define astructure for open-addressed hash tables.*/ typedef struct OHTbl_ { int positions; void* vacateds int (*h1)(const void*key); int (*h2)(const void*key); int (*match)(const void*key1,const void*key2); int (*destroy)(void*data); int sizes; void **table; }OHTbl; /*Public Interface*/ int ohtbl_init(oHTbl*htbl,int positions,int{*hi)(const void*key),int (*h2)(const void*key),int (*match)(const void*key1, const void*key2); void (*destroy)(void*data)); void ohtbl_destroy(OHTbl*htbl); int ohtbl_insert(OHTbl*htbl,const void*data); int ohtbl_remove(OHTbl*htbl,void**data); int ohtbl_lookup(const OHTbl *htbl,void **data); #define ohtbl_size(htbl()(htbl)-\u0026gt;size) #endif /* ohtbl.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;ohtbl.h\u0026#34; /*Reserveasentinelmemoxy address for vacated elements.*/ static char vacated; /*ohtb_linit*/ int ohtb_linit(oHTbl*htbl,int positions,int (*h1)(const void*key),int (*h2)(const void*key),int (*match)(const void*key1,const void*key2),void (*destroy)(voi*data)) { int i; /*Allocate space for the hash table.*/ if ((htbl-\u0026gt;table= (void**)malloc(positions*sizeof(void*)))==NULL) return -1; /*Initializeeachposition、*/ htbl-\u0026gt;positicns = pasitions; for (i=0; i\u0026lt; htbl-\u0026gt;positions；i++) htbl-\u0026gt;table[i] = NULL; /*Set the vacated member tothe sentinel memory address reserved for this,*/ htbl-\u0026gt;vacated= \u0026amp;vacated; /*Encapsulate the functions.*/ htbl-\u0026gt;h1 = h1; htbl-\u0026gt;h2 = h2; htbl-match = match; htbl-\u0026gt;destroy = destroy; /*Initialize the number of elements in the table.*/ htbl-\u0026gt;size = 0; return 0; } /*ohtbl_destroy*/ vold ohtbl_destroy(OHTbl*htbl) { int i; if(htbl-\u0026gt;destroy != NULL) { /*Calla user-defined function to free dynamically allocated data.*/ for(i = 0; i \u0026lt; htbl-\u0026gt;positions; i++) { if(htbl-\u0026gt;table[i] != NULL \u0026amp;\u0026amp; htbl-\u0026gt;table[i] != htbl-\u0026gt;vacated) htbl-\u0026gt;destroy(htbl-\u0026gt;table[i]); } } /*Free the storage allocated for the hash table，*/ free(htbl-\u0026gt;table); /*No operations are allowed nowybut clear the structure asaprecautlon.*/ memset(htbl, 0, sizeof(OHTbl)); } /*ohtblinsert*/ int ohtb_linsert(OHTbl*htbl，constvoid *data) { void* temp; int position, i; /*Do not exceed the number of positions in the table.*/ if (htbl-\u0026gt;size == htbl-\u0026gt;positions) return -1; /*Do nothing ifthe data is already in the table.*/ temp= (void*)data; if (ohtbl_fookup(htbl, \u0026amp;temp) == 0) return 1; /*Use double hashing to hash the key.*/ for (i=0; i \u0026lt; htbl-\u0026gt;positions; i++) { position = (htbl-\u0026gt;h1(data) + (i * htbl-\u0026gt;h2(data))) % htbl-\u0026gt;positions; if (htbl-\u0026gt;table[position] == NULL || htbl-\u0026gt;table[position] == htbl-\u0026gt;vacated) { /* Insert the data into the table.*/ htbl-\u0026gt;table[position] = (void*)data; htbl-\u0026gt;size++; return 0 } } /* Return that the hash funtions were selected incorrectly. */ return -1; } /*ohtbl_remove */ int ohtbl_remove(OHTbl *htbl，void**data) { int position, i; /*Use touble hashingtohashthekey.*/ for (i=0; i \u0026lt; htbl-\u0026gt;positions; i++) { position = (htbl-\u0026gt;h1(*data) + (i * htbl-\u0026gt;h2(*data))) % htbl-\u0026gt;positions; } if (htbl-\u0026gt;table[position] == NULL) { /* Returnthat the data was not found，*/ return -1； } else if (htbl-\u0026gt;table[position]==htbl-\u0026gt;vacated) { /*Seaxch beyond vacated pasitions.*/ continue; } else if (htbl-\u0026gt;match(htbl-\u0026gt;table[position],*data)) { /* Pass back the data from the table，*/ *data = htbl-\u0026gt;table[position]; htbl-\u0026gt;table[positian] = htbl-\u0026gt;vacated; htbl-\u0026gt;size--; return 0; } /*Return that the data wasnot found，*/ return -1; } /* ohtbI_lookup */ int ohtbl_lcokup(const OHTbl *htbl, void **data) { int positiong, i; /* Use double hashing to hash the key.*/ for (i = O; i \u0026lt; htbl-\u0026gt;positions; i++) { positicn = (htb1-\u0026gt;hz(*data) + (i * htb1-\u0026gt;h2(*data))) % htb1-\u0026gt;positions; if (htbl-\u0026gt;table[position] == NULL) { /* Return that the data was not found.*/ return -1; } else if(htbl-\u0026gt;match(htbl-\u0026gt;table[position], *data)) { /* Pass back the data from the table. */ *data = htbl-\u0026gt;table[positipon]; return 0; } } /* Return that the data was not found. */ return -1; } 5.树 树的定义： 在计算机科学中，树由称之为节点的元素按照层次结构方式组织而成。层次最顶端为根(root)。与根相连的为子节点，通常子节点也有自己的子节点。二叉树是分支因子为2的树。二叉搜索树是专门用于查找的树。\n二叉树 二叉树的一个节点包含三部分：一个数据部和两个左右指针部\n树的遍历算法 先序遍历：根(root)，左，右\n中层遍历：左，根(root)，右\n后序遍历：左，右，根(root)\n层序遍历：根(root), 一层一层遍历到叶子\n树的平衡 树的平衡是指对于给定数量的节点，保证树的高度尽可能短的过程。这意味着在结点加入下一层之前必须保证本层结点满额。也就是说树的叶子都在倒数两层，且倒数第二层叶子是满的，则称这棵树是平衡的。最后一层叶子结点靠左，则称这棵树是左平衡的。\n二叉树的接口定义： /* bitree.h */ #ifndef BITREE_H #define BITREE_H #include \u0026lt;stdlib.h\u0026gt; /* Define a structure for binary tree nodes.*/ typedef struct BiTreeNode_ { void *data; struct BiTreeNode *left; struct BiTreeNode_*right; }BiTreeNode; /* Defmne a structure for binary trees.*/ typedef struct BiTree_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); BiTreeNode *root; }BiTree; /* Public Interface */ void bitree_init(BiTree *tree, void (*destroy)(void *data)); void bitree_destroy(BiTree *tree); int bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data); int bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data); void bitree_rem_left(BiTree *tree, BiTreeNode *node); void bitree_rem_right(BiTree *tree,BiTreeNode *node); int bitree_merge(BiTree *merge, BiTree *left,BiTree *right,const void *data); #define bitree_size(tree)\t((tree)-\u0026gt;size) #define bitree root(tree)\t((tree)-\u0026gt;root)) #define bitxee_is_eob(node)\t((node) == NULL) #define bitree_is_leaf(node) ((node)-\u0026gt;left == NULL \u0026amp;\u0026amp; (node)-\u0026gt;right == NULL) #define bitree_data(node) ((node)-\u0026gt;data) #define bitree left(node) ((node)-\u0026gt;left) #define bitree_right(node) ((node)-\u0026gt;right) #edif /* bitree.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;bitree.h\u0026#34; /*bitree init*/ void bitree_init(BiTree *tree, void (*destroy)(void *data)) { /* Initialize the binary tree.*/ tree-\u0026gt;size = 0; tree-\u0026gt;destroy = destroy; tree-\u0026gt;root = NULL; } /* bitree_destroy*/ void bitree_destroy(BiTree *tree) { /* Remove all the nodes from the tree.*/ bitree_rem_left(tree, NULL); /* No operations are aIlowed now, but clear the structure as a precaution. */ memset(tree, 0, sizeof(BiTree); } /* bitree ins left */ int bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data) { BiTreeNode new_node, **position; /* Determine where to insert the node.*/ if (node == NULL) { /* Allow insertion at the root only in an empty tree.*/ if (bitree_size(tree) \u0026gt; 0) return -1; position = \u0026amp;tree-\u0026gt;root; } else { /* Normally allow insertion only at the end of a branch.*/ if (bitree_left(node) != NULL) return -1; position = \u0026amp;node-\u0026gt;left; } /* Allocate storage for the node.*/ if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNcde))) == NULL) return -1; /* Insert the node into the tree.*/ new_node-\u0026gt;data = (void *)data; new_node-\u0026gt;ieft = NULL; new_node-\u0026gt;right = NULL; *position = new_node; /* Adjust the size of the tree to account for the inserted node.*/ tree-\u0026gt;size++; return 0; } /* bitree_ins_right */ int bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data) { BiTreeNode *new_node, **position; /* Determine where to insert the node.*/ if (node == NULL) { /* Allow insertion at the root only in an empty tree.*/ if (bitree_size(tree) \u0026gt; 0) return -1; position = \u0026amp;tree-\u0026gt;root; } else { /* Normally allow insertion only at the end of a branch. */ if (bitree_right(node) != NULL) return -1; position = \u0026amp;node-\u0026gt;right; } /* Allocate storage for the node.*/ if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNode))) == NULL) return -1; /* Insert the node into the tree.*/ new_node-\u0026gt;data = (void *)data; new_node-\u0026gt;left = NULL; new_node-\u0026gt;right = NULL; *position = new_node; /* Adjust the size of the tree to account for the inserted node.*/ tree-\u0026gt;size++; return 0; } /* bitree_rem_left */ void bitree_rem_left(BiTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow removal from an empty tree.*/ if (bitree_size(tree) == 0) return; /*Determine where to remove nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;node-\u0026gt;left; /*Remove the nodes.*/ if (*position != NULL) { bitree_rem_left(tree, *position); bitree_rem_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data.*/ tree-\u0026gt;destroy((*position-\u0026gt;data); } free(*position); *position = NULL; /* Adjust the size of the tree to account for the removed node.*/ tree-\u0026gt;size--; } return; } /* bitree_rem_right */ void bitree_rem_right(BiTzee *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow removal from an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to remove nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;node-\u0026gt;right; /* Remove the nodes.*/ if (*position != NULL) { bitree_rem_left(txee,*position); bitree_rem_right(tree,*position); if (tree-\u0026gt;destroy != NULL) { /* CalI a user-defined function to free dynamically allocated data.*/ tree-\u0026gt;destroy((*position)-\u0026gt;data); } free(*position); *position = NULL; /* Adjust the size of the tree to account for the removed node.*/ tree-\u0026gt;size--; } return; } /* bitree_merge*/ int bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data) { /* Initialize the merged tree.*/ bitree_init(merge, left-\u0026gt;destroy); /* Insert the data for the root node of the merged tree.*/ if (bitree_ins_left(merge, NULL, data) != 0) { bitree_destroy(merge); return -1; } /* Merge the two binary trees into a single binary tree.*/ bitree_root(merge)-\u0026gt;left = bitree_root(left); bitree_root(merge)-\u0026gt;right = bitree_root(right); /* Adjust the size of the new binary tree.*/ merge-\u0026gt;size = merge-\u0026gt;size + bitree_size(left) + bitree_size(right); /* Do not let the original trees access the merged nodes.*/ left-\u0026gt;root = NULL; left-\u0026gt;size = 0; right-\u0026gt;root = NULL; right-\u0026gt;size = 0; return 0; } 二叉搜索树 定义： 二叉搜索树是有二叉树组成的专用于查找和搜索目的的一种数据结构。\n数据插入遵循：比根节点(root)大的数插入根右边，比根节点小的数插入左边。\n数据搜索遵循：要查询的值比根(root)大的数向右子节点查，比根节点小向左节点查。\n不允许有重复值出现\n二叉搜素树应尽量保持平衡，但比较困难。非平衡树会造成搜索的节点数量过多，最多O(n)\n二叉搜索树要保持平衡最好的方法是\nAVL树 其定义为：\nAVL树每个节点都保持了一个平衡因子。\n插入结点时AVL树需要自我调整。\n平衡因子：结点的右子树高度-左子树高度，其值为+1, 0，-1。\n+1：代表树是左倾斜的\n-1：代表树是右倾斜的\n平衡因子改变：\n插入新的结点会造成平衡因子改变，因此这棵树需要重新平衡，我们称这种平衡为AVL树的旋转\nAVL树旋转方法：\nLL(left-left)，LR(left-right)，RR(right-right)，RL(right-left)\navl树旋转有一个更简单的方法:\n把这颗树抽象成一棵自然界的树，节点的平衡因子不是-1，0，+1时，RR和LL的节点小于-1或大于+1时树的树梢向下落一层；\nRL和LR的节点小于-1或大于+1时是因为不平衡的子节点引起的，找到不平衡的子节点重复LL或RR的过程，不平衡子节点旋转之后父节点重复LL或RR.\n接口定义： /* bistree.h */ #ifndef BISTREE_H #define BISTREE_R #include \u0026#34;bitree.h\u0026#34; /* Define balance factors for AVL trees. */ #define AVL_LFT_HEAVY 1 #define AVL_BALANCED 0 #deftne AVERGT_HEAVY -1 /* Define a structure for nodes in AVL trees. */ typedef struct AvlNode_ { void *data; int hidden; int factor; }Av1Node; /* Implement binary search trees as binary trees. */ typedef BiTree BisTree; /* Public Interface */ void bistree_init(Bistree *tree, int (*compare)(const void *key1, const void *key2), void (*destroy)(void *data)); void bistree_destroy(BisTree *tree); int bistree_insert(BisTree *tree, const void *data); int bistree_remove(BisTree *tree, const void *data); int bistree_lookup(BisTree *tree, void **data); #define bistree_size(tree) ((txee) -\u0026gt;size) #endif /* bistree.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;bistree.h\u0026#34; static void destroy_right(BisTree *tree, BiTreeNode *node); /* rotate_left */ static void rotate_left(BiTreeNode **node) { BiTreeNode *left, *grandchild; left = bitree_left(*node); if (((AvlNode *)bitree_data(left))-\u0026gt;factor == AVL_LFT_HEAVY) { /* Perform an LL rotation. */ bitree_left(*node) = bitree_right(left); bitree_right(left) = *node; ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; *node = left; } else { /* Perform an LR rotation. */ grandchild = bitree_right(left); bitree_right(left) = bitree_left(grandchild); bitree_left(grandchild) = left; bitree_left(*node) = bitree_right(grandchild); bitree_right(grandchild) = *node; switch (((AvlNode *)bitree_data(left))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_RGT_HEAVY; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_BALANCED; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(left))-\u0026gt;factor = AVL_LFT_HEAVY; break; } ((AvlNode *)bitree_data(grandchild))-\u0026gt;factor = AVL_BALANCED; *node = grandchild; } } /* rotate_right */ static void rotate_right(BiTreeNode **node) { BiTreeNode *right, *grandchild; right = bitree_right(*node); if (((AvlNode *)bitree_data(right))-\u0026gt;factor == AVL_RGT_HEAVY) { /* Perform an RR rotation. */ bitree_right(*node) = bitree_right(right); bitree_left(right) = *node; ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED; *node = right; } else { /* Perform an RL rotation. */ grandchild = bitree_left(right); bitree_right(right) = bitree_right(grandchild); bitree_right(grandchild) = right; bitree_right(*node) = bitree_left(grandchild); bitree_left(grandchild) = *node; switch (((AvlNode *)bitree_data(grandchild))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_RGT_HEAVY; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_LFT_HEAVY; ((AvlNode *)bitree_data(right))-\u0026gt;factor = AVL_BALANCED ; break; } ((AvlNode *)bitree_data(grandchild))-\u0026gt;factor = AVL_BALANCED; *node = grandchild; } } /* destroy_left */ static void destroy_left(BisTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow destruction of an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to destroy nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;tree-\u0026gt;left; /* Destroy the nodes. */ if (*position != NULL) { destroy_left(tree, *position); destroy_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data. */ tree-\u0026gt;destory(((AvlNode *)(*position)-\u0026gt;data)-\u0026gt;data); } /* Free the AVL data in the node, then free the node itself. */ free((*position)-\u0026gt;data); free(*position); *position = NULL; /* Adjust the size of the tree to account for the destroyed node. */ tree-\u0026gt;size--; } } /* destroy_right */ static void destroy_right(BisTree *tree, BiTreeNode *node) { BiTreeNode **position; /* Do not allow destruction of an empty tree. */ if (bitree_size(tree) == 0) return; /* Determine where to destroy nodes.*/ if (node == NULL) position = \u0026amp;tree-\u0026gt;root; else position = \u0026amp;tree-\u0026gt;right; /* Destroy the nodes. */ if (*position != NULL) { destroy_left(tree, *position); destroy_right(tree, *position); if (tree-\u0026gt;destroy != NULL) { /* Call a user-defined function to free dynamically allocated data. */ tree-\u0026gt;destory(((AvlNode *)(*position)-\u0026gt;data)-\u0026gt;data); } /* Free the AVL data in the node, then free the node itself. */ free((*position)-\u0026gt;data); free(*position); *position = NULL; /* Adjust the size of the tree to account for the destroyed node. */ tree-\u0026gt;size--; } } /* insert */ static int insert(BisTree *tree, BiTreeNode **node, const void *data, int *balanced) { AvlNode *avl_data; int cmpval, retval; /* Insert the data into the tree. */ if (bitree_is_eob(*node)) { /* Handle insertion into an empty tree.*/ if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl data-\u0026gt;factor = AVL_BALANCED; avi data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; return bitree_ins_left(tree, *node, avl_data); } else { /* Handle insertion into a tree that is not empty. */ cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(*node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left. */ if (bitree_is_eob(bitree_left(*node))) { if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl_data-\u0026gt;factor = AVL_BALANCED; avl_data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; if (bitree_ins_left(tree, *node, avl_data) != 0) return -1; *balance = 0; } else { if ((retval = insert(tree, \u0026amp;bitree_left(*node), data, balanced)) != 0) return retval; } /* Ensure that the tree remains balanced. */ if (!(*balanced)) { switch (((AvlNode *)bitree_data(*node))-\u0026gt;factor) { case AVL_LFT_HEAVY: rotate_left(node) ; *balanced = 1; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_LFT_HEAVY; break; case AVL_RGT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; *balanced = 1; break; } } } /* if (cmpval \u0026lt; 0) */ else if (cmpval \u0026gt; 0) { /* move to the right. */ if (bitree_is_eob(bitree_right(*node))) { if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1; avl_data-\u0026gt;factor = AVL_BALANCED; avl_data-\u0026gt;hidden = 0; avl_data-\u0026gt;data = (void *)data; if (bitree_ins_right(tree, *node, avl_data) != 0) return -1; *balance = 0; } else { if ((retval = insert(tree, \u0026amp;bitree_right(*node), data, balanced)) != 0) return retval; } /* Ensure that the tree remains balanced. */ if (!(*balanced)) { switch (((AvlNode *)bitree_data(*node))-\u0026gt;factor) { case AVL_LFT_HEAVY: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_BALANCED; *balanced = 1; break; case AVL_BALANCED: ((AvlNode *)bitree_data(*node))-\u0026gt;factor = AVL_RGT_HEAVY; break; case AVL_RGT_HEAVY: rotate_right(node) ; *balanced = 1; break; } } /* if (cmpval) \u0026gt; 0 */ else { /* Handle finding a copy of the data. */ if (!((Av1Node *)bitree_data(*node))-\u0026gt;hodden) { /* Do nothing since the data is in the tree and not hidden. */ return 1; } else { /* Insert the new data and mark it as not hidden. */ if (tree-\u0026gt;destroy != NULL) { /* Destroy the hidden data since it is being replaced. */ tree-\u0026gt;destory(((Av1Node *)bitree_data(*node))-\u0026gt;data); } ((Av1Node *)bitree_data(*node))-\u0026gt;data = (void *)data; ((Av1Node *)bitree_data(*node))-\u0026gt;hidden = 0; /* Do not rebalance because the tree structure is unchanged. */ *balanced = 1; } } } } return 0; } /* hide */ static int hide(BisTree *tree, BiTreeNode *node, const void *data) { int cmpval, retval; if (bitree_is_eob(node)) { /* Return that the data was not found. */ return -1; } cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left.*/ retval = hide(tree, bitree_left(node), data); } else if (cmpval \u0026gt; 0) { /* Move to the right.*/ retval = hide(tree, bitree_right(node), data); } else { /* Mark the node as hidden. */ ((AvLNode *)bitree_data(node))-\u0026gt;hidden = 1; retvaL = 0; } return retval; } /* lookup */ static int lookup(BisTree *tree, BiTreeNode *node, void *data) { int cmpval, retval; if (bitree_is_eob(node)) { /* Return that the data was not found. */ return -1; } cmpval = tree-\u0026gt;compare(data, ((AvlNode *)bitree_data(node))-\u0026gt;data); if (cmpval \u0026lt; 0) { /* Move to the left.*/ retval = lookup(tree, bitree_left(node), data); } else if (cmpval \u0026gt; 0) { /* Move to the right.*/ retval = lookup(tree, bitree_right(node), data); } else { if(!((AvlNode *)bitree_data(node))-\u0026lt;hidden) { /* Pass back the data from the tree. */ *data = ((AvlNode *)bitree_data(node))-\u0026gt;data; retval = 0; } else { /* Return that the data was not found. */ return -1; } } return retval; } /* bistree_init */ void bistree_init(BisTree *tree, int (*cpmpare)(void *keyl, const void *key2), void (*destory)(*data)) { /* Initialize the tree. */ bitree_init(tree, destory); tree-\u0026gt;compare = compare; } /* bistree_destroy */ void bistree_destroy(BisTree *tree) { /* Destroy all nodes in the tree. */ destory_left(tree, NULL); /* No operations are allowed now, but clear the structure as a precaution. */ memset(tree, 0, sizeof(BisTree)); } /* bistree_insert */ int bistree_insert(BisTree *tree, const void *data) { int balanced = O; return insert(tree, \u0026amp;bitree_rot(tree), data, \u0026amp;balanced); } /* bitree_remove */ int bitree_remove(BisTree *tree, const void *data) { return hide(tree, bitree_root(tree), data); } /* bistree_lookup */ int bistree_lookup(BisTree *tree, void *data) { return lookup(tree, bitree_root(tree), data); } 红黑树（R-B树） 定义： 红黑树 为妥协的AVL树，平衡要求没AVL树严格，因此适用范围比AVL树多\n红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。待插入结点默认为红色结点，插入时按照二分插入。\n性质1. 结点是红色或黑色。\n性质2. 根结点是黑色。\n性质3. 所有叶子都是黑色。（叶子是NIL结点）\n性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）\n性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。\nR_B树的插入旋转法 RR或LL，刚插入的结点的父节点是红色，叔叔结点也是红色，那么父节点和叔叔变为黑色，祖父结点变为红色\n刚插入的结点的父节点是红色，叔叔结点是黑色，那么父节点和叔叔结点需要左旋或右旋，然后原父结点变为黑色，叔叔结点变为红色。\nLR或RL，刚插入结点父结点是红色，叔叔结点也是红色，那么父节点和叔叔结点变为黑色，祖父结点变为红色，\n刚插入结点父结点是红色，叔叔结点为黑色，那么刚插入结点和父节点需要左旋或右旋，再次执行RR或LL步骤。\nR_B树的删除旋转法： ​\tR_B树的删除为红黑树最复杂部分\n1、红黑树删除的情形\n​\t一、从树中删除节点X（以寻找后继节点的方式进行删除）\n​\t情况①：如果X没有孩子，且如果X是红色，直接删除X；如果X是黑色，则以X为当前节点进行旋转调色，最后删掉X\n​\t情况②：如果X只有一个孩子C，交换X和C的数值，再对新X进行删除。根据红黑树特性，此时X不可能为红色，因为红色节点要么没有孩子，要么有两个黑孩子。此时以新X为当前节点进行情况①的判断\n​\t情况③：如果X有两个孩子，则从后继中找到最小节点D，交换X和D的数值，再对新X进行删除。此时以新X为当前节点进行情况①或②的判断\n​\t二、旋转调色（N=旋转调色的当前节点[等于情况①中的X]，P=N的父亲，W=N的兄弟，Nf=N的远侄子，Nn=N的近侄子）\n​\t情况1：N是根或者N是红色，则：直接将N设为黑色\n​\t情况2：N不是根且N是黑色，且W为红色，则：将W设为黑色，P设为红色，对P进行旋转(N为P的左子时进行左旋，N为P的右子时进行右旋)，将情况转化为情况1、2、3、4、5\n​\t情况3：N不是根且N是黑色，且W为黑色，且W的左右子均为黑色，则：将W设为红色，将P设为当前节点进行旋转调色，将情况转化为情况1、2、3、4、5\n​\t情况4：N不是根且N是黑色，且W为黑色，且Nf为黑色，Nn为红色，则：交换W与Nn的颜色，并对W进行旋转(N为P的左子进行右旋，N为P的右子进行左旋)，旋转后N的新兄弟W有一个红色WR，则转换为情况5\n​\t情况5：N不是根且N是黑色，且W为黑色，且Nf为红色，Nn为黑色，则：将W设为P的颜色，P和Nf设为黑色，并对P进行旋转(N为P的左子进行左旋，N为P的右子进行右旋)，N设为根\nB树，B+树，B*树 当数据量非常大时，二叉树已经不能满足需求，如果还用二叉树那么树的深度过大，一个节点存储多个数据就应运而生了。\n定义：\nB树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件：\n每个节点最多只有m个子节点。\n每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。\n如果根不是叶节点，则根至少有两个子节点。\n具有k个子节点的非叶节点包含k -1个键。\n所有叶子都出现在同一水平，没有任何信息（高度一致）。\n此树的一个节点最多有4个结点，一个节点最多有三个值，\n插入如删除方法：B树插入与删除\nB+树\n在B树的基础上增加了数据遍历优点，想要遍历整个树的数据只要把叶子节点便完毕就行，因为B+树的叶子节点数据是整棵树数据，非叶子节点是叶子节点索引。\nB*树\nB*树在B+树的基础上增加了非叶子结点之间链表相联系。\n2-3-4树 2-3-4树是4阶B树，2-3-4树插入与删除\ntreap树 所谓的Treap树堆其实就是树 + 堆。树是二叉查找树BST，堆是二叉堆，大根堆小根堆都可以。\n树堆既是一棵二叉查找树，也是一个二叉堆。但是这两种数据结构貌似还是矛盾的存在，如果是二叉查找树，就不能是一个堆，如果是一个堆，那么必然不是二叉查找树。\n所以树堆用了一个很巧妙的方式解决这个问题：给每个键值一个随机附加的优先级，让键值满足二叉查找树的结构，让优先级满足二叉堆的结构。\ntreap树的详解，插入与删除\nk-d树 k-d树常用来作空间划分及近邻搜索，是二叉空间划分树的一个特例。\nK-D TREE算法原理及实现\n最小生成树(Minimum Spanning Tree) 对于有n个顶点的连通图，生成树有n-1条边，若边数小于此数就不可能将各顶点连通，如果边的数量多于n-1条边，必定会产生回路。\n最小生成树(Minimum Spanning Tree理解\n6.堆和优先队列 在许多问题中，当对数据集进行频繁的插入和删除操作时，往往需要快速确定最大或最小的元素。处理这个问题的方法之一，就是使用一个已排好序的数据集，通过这种方法，最大或最小的元素总是处在数据集的头部（这取决于使用升序还是降序排列）。然而将数据集一遍又一遍地进行排序的代价是非常高的。并且许多情况下，将元素排序并不是超越的目的，最终我们可能在真正要做的工作之外做了很多其他工作，想要快速的找到最大或最小的元素，只需要让元素储存在可以找到它的位置上就行。堆和优先队列，就是一种处理这种问题的有效方法。\n本章内容包括：\n堆： 它是一种树形组织，使我们能够迅速确定包含最大值的结点。维持一棵树的代价低于维持一个有序数据集。同样，我们可以确定通过堆快速地找到包含最小值的元素。\n优先队列 它是一个从堆自然衍生而来的数据结构。在优先队列中，数据保存在一个堆中，这样我们能够迅速确定下一个最高优先级的结点。所谓元素的“优先级”在不同的问题中有不同的意义。\n队和优先队列的一些应用：\n排序：堆排序 任务调度 任务调度会告诉操作系统接下来哪个进程将在CPU上运行。操作系统会不断调整进 程的优先级，用优先队列来存储进程是相对比较高效的方法，因为它可以确保下一 个将在CPU中运行的进程的优先级是最高的。\n包褰分拣（见本章相关章节） 快递公司通常用包裹分拣法来确定包裹递送的优先级。当扫描包裹时，高优先级的 包裹将作为急快件投递出去。而非急快件将作为较低优先级的包裹投递出去。计算 机系统通常使用优先队列来保证最高优先级的包在系统中运行最顺畅，因为这种方 法十分高效。\n霍夫曼编码 这是一种数据压缩方法，它使用霍夫曼树为数据符号分配编码（见第14章）。向出 现频率较高的符号分配较短的编码,向出现频率较低的符号分配较长的编码。霍夫 曼树是由较小的二叉树两两合并构成。由于每次都必须合并键值最小的二叉树，因 此每次合并的两棵树都是从一个优先队列中取出的。\n负载均衡 它用来维护管理一系列处理类似任务的服务。当连接请求到达时，优先队列可以确定哪 个服务器能够最好地处理到达的任务。\n优先队列的描述:\n优先队列将数据按照优先级顺序排列。一个优先队列由许多有序的元素构成，所以优先级最高的元素可以有效而快速地确定,例如，我们看一组用来做负载均衡的服务器，时时观察它们的使用情况。当连接请求到达时，优先队列可以告知当前哪个服务器是处理 此连接请求的最佳服务器。在这种情况下，最空闲的服务器获取的优先级最高，因为它 可以最好地处理服务请求。\n","date":"2022-01-01T19:32:29Z","permalink":"https://okokfun.github.io/post/c++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":" 推荐看👉 OI Wiki\n算法部分 位图(bitmap) 通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。\n位图BitMap\n字典(map) 字典有什么特点呢?\n字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情况下取出这些信息. 使用数组的方式: [18, \u0026ldquo;Coderwhy\u0026rdquo;, 1.88]. 可以通过下标值取出信息. 使用字典的方式: {\u0026ldquo;age\u0026rdquo; : 18, \u0026ldquo;name\u0026rdquo; : \u0026ldquo;Coderwhy\u0026rdquo;, \u0026ldquo;height\u0026rdquo;: 1.88}. 可以通过key取出value 字典(map)的详细解释\nkmp算法 kmp算法也就是字符串匹配算法。\n比如： 在string str = \u0026ldquo;abcababcba\u0026quot;中匹配 string str2 = \u0026ldquo;ababc\u0026ldquo;字符串\n最长公共前后缀：要匹配的字符串生成的数组\n从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计\n0\ta\n0\ta\tb\n1\ta\tb\ta\n2\ta\tb\ta\tb\n0\ta\tb\ta\tb\tc\n得出的公共前后缀为\n0 0 1 2 0 然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为\n-1 0 0 1 2 kmp匹配过程\nabcababcba\nababc\n如果匹配到不相等元素，则通过next数组(P)决定next数组移动的位置，例如上图next数组(P)下标为2的元素与T字符串不相等，则看一下P数组下标2的next数组的值为0，则把next数组下标为0的位置移动到不匹配的地方\n如果next数组的值为-1则next数组整体右移，或找到T字符串与子字符串第一个元素(如果找到的话)，然后把P移动到此位置(T的剩余的元素大于等于子字符串元素个数)；\n代码\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 计算最长公共前后缀 void prefix_table(char pattern[], int prefix[], int n) { prefix[0] = 0; int len = 0; int i = 1; while (i \u0026lt; n) { if (pattern[i] == pattern[len]) { len++; prefix[i] = len; i++; } else { if (len \u0026gt; 0) { len = prefix[len - 1]; } else { prefix[i] = len; i++; } } } } // 计算next数组 void move_prefix_table(int table[], int n) { for (int i = n - 1; i \u0026gt; 0; --i) { table[i] = table[i - 1]; } table[0] = -1; } // kmp算法 void kmp_search(char text[], char pattern[]) { int n = strlen(pattern); int m = strlen(text); int *prefix = new int[n]; prefix_table(pattern, prefix, n); move_prefix_table(prefix, n); int i = 0; int j = 0; while (i \u0026lt; m) { if (j == n - 1 \u0026amp;\u0026amp; text[i] == pattern[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;Found pattern at \u0026#34; \u0026lt;\u0026lt; i - j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; j = prefix[j]; } if (text[i] == pattern[j]) { i++; j++; } else { j = prefix[j]; if (j == -1) { i++; j++; } } } delete[] prefix; } int main(void) { char pattern[] = \u0026#34;ABABCABAA\u0026#34;; char text[] = \u0026#34;ABABABCABAABABABAAB\u0026#34;; kmp_search(text, pattern); return 0; } 双指针 同向双指针 判断一个链表是否有环\n创建两个指针ptr1,ptr2,两个指针同时指向链表头结点。ptr1每次向后移动一个结点，ptr2每次移动2个结点，如果链表有环他们会指向同一个结点\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ bool samecircle(Node head) { // write your code here Node ptr2 = head; Node ptr2 = head; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 return true; } return false; } }; 判断环长\n第一次相遇代表有环，第二次相遇代表两个指针发生了套环，所以：\n环长 = 速度差 * 移动次数\n判断入环点\n慢指针ptr1每次走一步，所以走的距离是：\nd1 = D + X * (S1 + S2) + S1\n快指针ptr2走的距离是：\nd2 = D + N * (S1 + S2) + S1\n快指针速度是慢指针2倍。 即：\n2 * d1 = d2\n整理后的公式为\nD = (n - 2X - 1)(S1 + S2) + S2\n假设n - 2X -1的值为0，则D = S2;，那么我们就可以在首次相遇点的时候，定义一个指针指向链表的起点，一个指针指向首次相遇点，然后两个指针每次前进1步，当两个指针相遇的时候就是链表的入环点。\n例子：\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ Node find_node(Node head) { // write your code here Node ptr1 = head; Node ptr2 = head; Node ptr3 = nullptr; Node ptr4 = nullptr; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 ptr3 = head; ptr4 = ptr1; break; } if (ptr3 != nullptr \u0026amp;\u0026amp; != ptr4 != nullptr) { while(ptr3 != ptr4) { ptr3 = ptr3.next; ptr4 = ptr4.next; } return ptr4; } return nullptr; } }; 相向双指针 二分法 又称折半搜索，期望时间复杂度为O(log2n)，最差为O(log2(n + 1)) 二分法前提是数据已经有序\n在A[0] \u0026hellip; A[n]中搜索K。\n步骤： \\1. 令low = 0， high = n - 1，初始的查找区域为[low， high]. \\2. 取low和high的中间值mid = (low+high)/2。 \\3. 如果A[mid] = K，则返回mid, 如果不等，则重新确定查找区间。 \\4. 当low \u0026gt; high 时，则表示区间已经失效，如果还未找到，则表示数组中不包含K的值，返回-1。\ntemplate\u0026lt;class T\u0026gt; int binary_search(vector\u0026lt;T\u0026gt; \u0026amp;A, T K) { int low = 0; int high = A.size() - 1; while( low \u0026lt; high ) { int mid = (low + high)/2; if( A[mid] \u0026lt; K ) low = mid + 1; else if( A[mid] \u0026gt; k ) high = mid - 1; else return mid; } return -1; /*返回-1表示数组不存在K的值*/ } 二分答案 二分答案与二分查找 其实是不一样的\n二分答案: 即对你要求的答案进行二分 二分查找: 对一个已知的有序数据集上进行二分的查找\n基础算法·二分答案 - Potassium - 博客园 (cnblogs.com)\n分治法 分治分治，即分而治之。分治，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……直接说就是将一个难以直接解决的大问题，分割成一些规模比较小的相同的小问题，以便各个击破，分而治之。\n分治法所能解决的问题一般具有以下几个特征：\n\\1) 该问题的规模缩小到一定的程度就可以容易地解决\n\\2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。\n\\3) 利用该问题分解出的子问题的解可以合并为该问题的解；\n\\4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\n第一条: 特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；\n第二条: 特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、\n第三条: 特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。\n第四条: 特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。\n经典问题:\n二分查找\n棋盘覆盖\n汉诺塔问题\n归并排序/合并排序\n快速排序\n宽度优先搜索(BFS) 它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。\n基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。\n广度优先搜索原理与实践 - huansky - 博客园 (cnblogs.com)\nprivate Map\u0026lt;String, Boolean\u0026gt; status = new HashMap\u0026lt;String, Boolean\u0026gt;(); private Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); public void BFSSearch(String startPoint) { //1.把起始点放入queue； queue.add(startPoint); status.put(startPoint, false); bfsLoop(); } private void bfsLoop() { while(!queue.isEmpty()) { // 1) 从queue中取出队列头的点；更新状态为已经遍历。 String currentQueueHeader = queue.poll(); //出队 status.put(currentQueueHeader, true); System.out.println(currentQueueHeader); // 2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。 List\u0026lt;String\u0026gt; neighborPoints = graph.get(currentQueueHeader); for (String poinit : neighborPoints) { if (!status.getOrDefault(poinit, false)) { //未被遍历 if (queue.contains(poinit)) continue; queue.add(poinit); status.put(poinit, false); } } } } 拓扑排序法 拓扑排序指的是将有向无环图（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。 算法：拓扑排序 - 子烁爱学习 - 博客园 (cnblogs.com)\n拓扑排序算法及C语言实现 (biancheng.net)\n深度优先搜索/回溯法 (DFS) 深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。\n/** * DFS核心伪代码 * 前置条件是visit数组全部设置成false * @param n 当前开始搜索的节点 * @param d 当前到达的深度，也即是路径长度 * @return 是否有解 */ bool DFS(Node n, int d){ if (isEnd(n, d)){//路径长度为返回true，表示此次搜索有解 return true; } for (Node nextNode in n){//遍历跟节点n相邻的节点nextNode， if (!visit[nextNode]){//未访问过的节点才能继续搜索 //例如搜索到V1了，那么V1要设置成已访问 visit[nextNode] = true; //接下来要从V1开始继续访问了，路径长度当然要加 if (DFS(nextNode, d+1)){//如果搜索出有解 //例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解 return true; } //重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中 visit[nextNode] = false; } //到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。 } return false;//本次搜索无解 } 动态规划 它将问题分成小问题，并先着手解决这些小问题\n背包型DP 假设有三种商品，分别是小汽车1吨，卡车3吨，起重机4吨.价格分别是：3000，4000，6000。\n现在只能卖总共4吨的商品，怎么卖商品售价最高？\n所有的组合为：\n组合 价值 无 0 小汽车 3000 卡车 4000 起重机 6000 小汽车和起重机 重量过大 小汽车和卡车 7000 卡车和起重机 重量过大 小汽车,卡车，起重机 重量过大 可以看到随着商品种类增加组合也在飞速增长，时间复杂度为O(2^n),太慢了\n动态规划算法可以用网格描述\n填充这些表格最后就是背包问题的解法。\n当在小汽车一行时，其他种类的商品选不了，所以都是3000\n当加入卡车时1-2吨放不下3吨的卡车，3吨可以放下卡车，所以为4000，4吨可以放下一个卡车和一个小汽车，共7000\n加入起重机时，1-2背包只能装小汽车，3吨可以装一辆卡车，4吨可以装起重机，但是价格低于7000所以不选起重机的价格，定位卡车加小汽车，价格为7000.\n坐标型DP 又被称为网格型动态规划\n一个网格有m行n列，一个小动物从(0, 0)出发，每一步可以向下或向右走一步，最总到达(m - 1, n - 1)处\n最简单的动态规划类型 给定一个序列或者网格 需要找到序列中某个/些子序列或网格中的某条路径 某种性质最大/最小 计数 存在性 动态规划方程 f[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，f[i][j] 中下标 i , j 表示以格子( i , j )为结尾的满足条件的路径的性质 最大值/最小值 个数 存在性 坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质 D2-坐标型动态规划\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid==null||obstacleGrid.length==0){ return 0; } int [] [] dp = new int[obstacleGrid.length][obstacleGrid[0].length]; for(int i=0;i\u0026lt;obstacleGrid.length;i++){ for(int j=0;j\u0026lt;obstacleGrid[i].length;j++){ if(obstacleGrid[i][j]==1){//有障碍 dp[i][j]=0; continue; }else{ if(i == 0 \u0026amp;\u0026amp; j == 0) dp[i][j]=1;//没有障碍起点 else if(i==0) dp[i][j]=dp[i][j-1];//在第一行,上一题在没有障碍情况下默认是1,但是有障碍就取决于该行前面是否有障碍了 else if(j==0) dp[i][j]=dp[i-1][j];//第一列,没有障碍默认是1,有障碍就取决于该列前面是否有障碍了 else{ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } } } return dp[obstacleGrid.length-1][obstacleGrid[0].length-1]; } } 序列型DP D3-序列型动态规划\n双序列型DP D7-双序列型动态规划\n划分型DP 常见类型：\n1. 给定长度为N的序列或字符串，要求划分成若干段 - 段数不限，或指定K段 - 每一段满足一定的性质 2. 做法 - 类似于序列型动态规划，但是通常要加上段数信息 - 一般用`f[i][j]`记录前i个元素（元素0~i-1）分成 j 段的性质，如最小代价 D4 划分型动态规划\n记忆化搜索 记忆化搜索 - OI Wiki (oi-wiki.org)\n区间型DP D6-区间型动态规划\n状态压缩DP 状压 DP - OI Wiki (oi-wiki.org)\n博弈型DP D4-博弈型动态规划\n匹配型DP 数位 DP 数位 DP - OI Wiki (oi-wiki.org)\n树形DP 树形 DP - OI Wiki (oi-wiki.org)\n插头 DP 插头 DP - OI Wiki (oi-wiki.org)\n概率 DP 概率 DP - OI Wiki (oi-wiki.org)\n动态 DP 动态 DP - OI Wiki (oi-wiki.org)\n排序算法 排序简介 - OI Wiki (oi-wiki.org)\n外排序算法 排序之外部排序 - Judy518 - 博客园 (cnblogs.com)\n快速排序算法 快速排序 - OI Wiki (oi-wiki.org)\n欧拉路径 什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。\n欧拉路径详解 - TEoS - 博客园 (cnblogs.com)\n模拟法 模拟算法（C++）_1只小弛的博客-CSDN博客_c++模拟\nC++算法：模拟 - 无咕 - 博客园 (cnblogs.com)\n扫描线算法 扫描线是一种用于求矩阵面积并或者周长并的算法，可以使用 线段树 来优化。假设给定了平面上若干个可能相交的矩阵，需要求出它们的面积并（面积之和减去相交部分）或者周长并（外轮廓的长度）。我们可以虚拟出一条按顺序扫描整个平面的线段，通过对平行或垂直于 [Math Processing Error]x 轴的线段进行处理得到答案。\n扫描线 - Ling_Lover - 博客园 (cnblogs.com)\n枚举法 枚举法 - Huise.J - 博客园 (cnblogs.com)\n最短路径 看完就懂了！一篇搞定图论最短路径问题 - thousfeet - 博客园 (cnblogs.com)\n贪心法 贪心算法原理及其应用 - vcjmhg - 博客园 (cnblogs.com)\n最小生成树 最小生成树 - SeanOcean - 博客园 (cnblogs.com)\n狄克斯特拉算法 Dijkstra算法(一)之 C语言详解 - 如果天空不死 - 博客园 (cnblogs.com)\n近似算法 算法课堂笔记6—近似算法 - f91og - 博客园 (cnblogs.com)\n高精度计算 高精度计算\nLRU算法 缓存淘汰算法\n长期不被使用的数据，在未来被用到的几率也不大。如果缓存到达了预设值就要删除一些内容，给新的内容腾位置\n如何实现LRU算法？ - murphy_gb - 博客园 (cnblogs.com)\nA星寻路算法 A星寻路算法 - szmtjs10 - 博客园 (cnblogs.com)\nA星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com)\nA-Star（A*）寻路算法原理与实现 - 知乎 (zhihu.com)\n","date":"2022-01-01T19:32:29Z","permalink":"https://okokfun.github.io/post/%E7%AE%97%E6%B3%95/","title":"算法"},{"content":" 推荐看👉常用设计模式有哪些？ (refactoringguru.cn)\n设计模式描述：\n用特定的套路解决现实问题，每一个设计模式对应一个法子\n分类 根据意图或目的分类\n创建型模式: 提供创建对象机制，增加已有的代码灵活性和可复用性 结构型模式: 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 行为模式: 负责对象间的高效沟通和职责委派。 创建型模式 simple_factory_pattern(简单工厂) Factory Method(工厂方法) 在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n要解决的问题：\n当增加一个新类，和其他类低耦合\n解决方案:\n增加一个子类的抽象类，所有的子类继承于抽象类，并且写父类的实现\n#include \u0026lt;iostream\u0026gt; class product { public: virtual ~product() {} }; class phone : public product { public: phone() { std::cout \u0026lt;\u0026lt; \u0026#34;make phone\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class tv : public product { public: tv() { std::cout \u0026lt;\u0026lt; \u0026#34;make tv\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class factory { public: virtual ~factory() {} virtual product* make_product() = 0; }; class phone_factory : public factory { public: virtual product* make_product() { return new phone(); } }; class tv_factory : public factory { public: virtual product* make_product() { return new tv(); } }; int main() { factory* factory1 = new phone_factory(); product* product1 = factory1-\u0026gt;make_product(); factory* factory2 = new tv_factory(); product* product2 = factory2-\u0026gt;make_product(); delete factory1; delete product1; delete factory2; delete product2; return 0; } Abstract Factory(抽象工厂模式) 随着业务的发展，更多的类需要创建，比如美国工厂，欧洲工厂，亚洲工厂，南美工厂，每个地区工厂又需要创建各自的产品\n问题：\n每个地区生产的产品拥有一个风格，不同地区的产品混杂一起对顾客不友好\n保持核心代码不修改。\n解决：\n首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如phone、 tv）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 phone接口； 所有风格的咖啡桌都实现 tv接口， 以此类推。\n#include \u0026lt;iostream\u0026gt; // 食草动物. class herbivore { public: virtual ~herbivore() {} }; // 食肉动物. class carnivore { public: virtual ~carnivore() {} virtual void eat(herbivore* h) = 0; }; // 角马. class wildebeest : public herbivore { }; // 野牛. class bison : public herbivore { }; // 狮子. class lion : public carnivore { public: void eat(herbivore*) { std::cout \u0026lt;\u0026lt; \u0026#34;lion eat wildebeest\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 狼. class wolf : public carnivore { public: void eat(herbivore*) { std::cout \u0026lt;\u0026lt; \u0026#34;wolf eat bison\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂. class factory { public: virtual ~factory() {} // 创建食草动物. virtual herbivore* create_herbivore() = 0; // 创建食肉动物. virtual carnivore* create_carnivore() = 0; }; // 非洲工厂. class africa_factory : public factory { public: virtual herbivore* create_herbivore() { return new wildebeest(); } virtual carnivore* create_carnivore() { return new lion(); } }; // 美洲工厂. class america_factory : public factory { public: virtual herbivore* create_herbivore() { return new bison(); } virtual carnivore* create_carnivore() { return new wolf(); } }; // 动物世界（客户端）. class animal_world { public: animal_world(factory* f) { _herbivore = f-\u0026gt;create_herbivore(); _carnivore = f-\u0026gt;create_carnivore(); } void start() { _carnivore-\u0026gt;eat(_herbivore); } private: herbivore* _herbivore; carnivore* _carnivore; }; int main() { factory* factory1 = new africa_factory(); animal_world* world1 = new animal_world(factory1); world1-\u0026gt;start(); factory* factory2 = new america_factory(); animal_world* world2 = new animal_world(factory2); world2-\u0026gt;start(); delete factory1; delete world1; delete factory2; delete world2; return 0; } singletonton_pattern(单例模式) 保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n问题：\n同时解决了两个问题, 但违反了单一职责原则\n解决：\n将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n#include \u0026lt;iostream\u0026gt; class singleton { public: singleton() = default; singleton(const singleton\u0026amp;) = delete; singleton\u0026amp; operator=(const singleton\u0026amp;) = delete; static singleton\u0026amp; get_instance() { static singleton s; return s; } void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { singleton::get_instance().print(); singleton::get_instance().print(); return 0; } prototype_pattern(原型模式) 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n问题：\n如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。\n不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。\n直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。\n解决：\n原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。\n所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。\n支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。\n其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。\n可以类比有丝分裂：由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // #include \u0026lt;vector\u0026gt; class resume { public: resume() {} virtual ~resume() {} virtual resume* clone() { return nullptr; } virtual void set(char*) {} virtual void show() {} protected: char* _name = nullptr; }; class resume_a : public resume { public: resume_a(const char* str) { if (str == nullptr) { _name = new char[1]; _name[0] = \u0026#39;\\0\u0026#39;; } else { _name = new char[strlen(str) + 1]; strcpy(_name, str); } } ~resume_a() { if (_name != nullptr) { delete [] _name; _name = nullptr; } } resume_a(const resume_a\u0026amp; other) { if (_name != nullptr) { delete [] _name; _name = nullptr; } _name = new char[strlen(other._name) + 1]; strcpy(_name, other._name); } virtual resume_a* clone() { return new resume_a(*this); } virtual void show() { std::cout \u0026lt;\u0026lt; \u0026#34;resume_a name: \u0026#34; \u0026lt;\u0026lt; _name \u0026lt;\u0026lt; std::endl; } }; int main() { resume* r1 = new resume_a(\u0026#34;A\u0026#34;); resume* r2 = r1-\u0026gt;clone(); r1-\u0026gt;show(); delete r1; r2-\u0026gt;show(); delete r2; return 0; } builder_pattern(生成器模式) 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n问题：\n假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。 例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？\n最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。\n另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。 通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。\n解决：\n生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。 该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。\n当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。\n在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。\n例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。 主管 你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。\n严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。\n此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 产品. class product { public: void add(const std::string\u0026amp; product_name) { _product_name_vec.emplace_back(product_name); } void show() { for (auto\u0026amp; name : _product_name_vec) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } } private: std::vector\u0026lt;std::string\u0026gt; _product_name_vec; }; // 抽象建造者. class builder { public: virtual ~builder() {} virtual void build_ricenoodles() = 0; virtual void build_cooldish() = 0; virtual void build_drink() = 0; virtual product* get_product() = 0; }; // 建造者A. class builder_a : public builder { public: builder_a() { _product = new product; } ~builder_a() { delete _product; } virtual void build_ricenoodles() { _product-\u0026gt;add(\u0026#34;ricenoodles a\u0026#34;); } virtual void build_cooldish() { _product-\u0026gt;add(\u0026#34;cooldish a\u0026#34;); } virtual void build_drink() { _product-\u0026gt;add(\u0026#34;drink a\u0026#34;); } virtual product* get_product() { return _product; } private: product* _product; }; // 导演. class director { public: void construct(builder* b) { b-\u0026gt;build_ricenoodles(); b-\u0026gt;build_cooldish(); b-\u0026gt;build_drink(); } }; int main() { director* d = new director(); builder* b = new builder_a(); d-\u0026gt;construct(b); product* p = b-\u0026gt;get_product(); p-\u0026gt;show(); delete b; delete d; return 0; } ","date":"2021-12-27T13:48:06Z","permalink":"https://okokfun.github.io/post/c++/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"C++设计模式-创建型模式"},{"content":" GDB是是 Linux 平台下最常用的一款程序调试器，通常服务于终端下，无GUI。Linux下很多IDE的调试能力源于GDB调试器\n1. Linux下安装二进制版GDB调试器 centos下命令：\nsudo yum -y install gdb Ubuntu下安装命令：\nsudo apt -y install gdb 2. 源码安装下载： sudo wget https://ftp.gnu.org/gnu/gdb/gdb-13.2.tar.xz 解压：\ntar -zxvf gdb-13.2.tar.xz 进入源码目录安装：\n./configure make sudo make install 3. 调试准备 GDB supports the following languages (in alphabetical order):\nAda Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust 只是为了调试代码需要在编译时加入：-g参数，关掉编译器优化参数：-O0，打开所有 warning：-Wall 4. GDB的启动与退出 启动gdb调试 gdb 可执行程序文件名\n(gdb) gdb app 退出调试\nquit = q (gdb) q 命令行传参:show args 设置的时机: 启动gdb之后, 在应用程序启动之前\n(gdb) set args 参数1 参数2 …. … 查看设置的命令行参数\n(gdb) show args 例子： 非gdb调试命令行传参\nargc 参数总个数，argv[0] == ./app， argv[1] == \u0026#34;11\u0026#34; argv[2] == \u0026#34;22\u0026#34; argv[3] == \u0026#34;33\u0026#34; argv[4] == \u0026#34;44\u0026#34; argv[5] == \u0026#34;55\u0026#34; ./app 11 22 33 44 55 使用 gdb 调试\ngdb app (gdb) set args 11 22 33 44 55 查看设置的命令行参数\n(gdb) show args Argument list to give program being debugged when it is started is \u0026#34;11 22 33 44 55\u0026#34;. gdb 中启动程序 run: 缩写为 r,停在第一个断点的位置，如果没有设置断点，程序就执行完了 start: 启动程序，阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令\n例子：\n\u0026gt;# 两种方式 # 方式1: run == r (gdb) run (如果有断点会停在断点处) # 方式2: start (会停在main函数处) (gdb) start 继续运行：\n# quit == q (gdb) qui 5. 查看代码 查看代码的命令叫做 list 可以缩写为 l，此命令可以通过行号，函数名查看，也可以查看不同文件的信息\n如果不切换文件会停在main函数所在文件\n当前文件 从第一行开始显示 (gdb) l 默认只显示10行内容，上下文 (gdb) l 行号 显示这个函数的上下文内容, 默认显示10行 (gdb) l 函数名 切换文件 切到指定文件行号处，默认显示10行 (gdb) l 文件名:行号 切到指定文件函数处，默认显示10行 (gdb) l 文件名:函数名 设置默认显示的行数 # 以下两个命令中的 listsize 都可以写成 list (gdb) set listsize 行数 # 查看当前list一次显示的行数 (gdb) show listsize 6.断点操作 设置断点 断点设置有两个方式：常规断点：程序只要运行到这个位置就会被阻塞\n条件断点：条件被满足了程序才会在断点处阻塞。\n当前文件： # 在当前文件的某一行上设置断点 # break == b (gdb) b 行号 (gdb) b 函数名\t# 停止在函数的第一行 非当前文件： # 在非当前文件的某一行上设置断点 (gdb) b 文件名:行号 (gdb) b 文件名:函数名\t# 停止在函数的第一行 设置条件断点 # 必须要满足某个条件, 程序才会停在这个断点的位置上 # 通常情况下, 在循环中条件断点用的比较多 (gdb) b 行数 if 变量名==某个值 查看断点 # 查看设置的断点信息 (gdb) i b #info break # 举例 (gdb) i b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400cb5 in main() at test.cpp:12 2 breakpoint keep y 0x0000000000400cbd in main() at test.cpp:13 3 breakpoint keep y 0x0000000000400cec in main() at test.cpp:18 4 breakpoint keep y 0x00000000004009a5 in insertionSort(int*, int) at insert.cpp:8 5 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 6 breakpoint keep y 0x00000000004009e5 in insertionSort(int*, int) at insert.cpp:16 需要关注的点：\nNum: 断点的编号，删除断点或者设置断点状态的时候都需要使用 Enb: 当前断点的状态，y 表示断点可用，n 表示断点不可用 What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上 删除断点 # 需要 info b 查看断点的信息, 第一列就是编号 (gdb) d 断点的编号1 \u0026amp;#091;断点编号2 ...] # 举例: (gdb) d 1 # 删除第1个断点 (gdb) d 2 4 6 # 删除第2,4,6个断点 # 删除一个范围, 断点编号 num1 - numN 是一个连续区间 (gdb) d num1-numN # 举例, 删除第1到第5个断点 (gdb) d 1-5 设置断点状态 断点无效化 dis 断点编号 dis 断点1编号-断点n编号 断点无效化例子：\n# 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep y 0x0000000000400d7d in main() at test.cpp:30 # 设置第2, 第4 个断点无效 (gdb) dis 2 4 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep y 0x0000000000400d7d in main() at test.cpp:30 # 设置 第5,6,7,8个 断点无效 (gdb) dis 5-8 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 让无效的断点生效 # enable == ena # 设置某一个或者某几个断点有效 (gdb) ena 断点1的编号 \u0026amp;#091;断点2的编号 ...] # 设置某个区间断点有效 (gdb) ena 断点1编号-断点n编号 有效化例子：\n# 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep n 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep n 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 # 设置第2, 第4个断点有效 (gdb) ena 2 4 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep n 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep n 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep n 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 # 设置第5,6,7个断点有效 (gdb) ena 5-7 # 查看断点信息 (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400cce in main() at test.cpp:14 4 breakpoint keep y 0x0000000000400cdd in main() at test.cpp:16 5 breakpoint keep y 0x0000000000400d46 in main() at test.cpp:23 6 breakpoint keep y 0x0000000000400d4e in main() at test.cpp:25 7 breakpoint keep y 0x0000000000400d6e in main() at test.cpp:28 8 breakpoint keep n 0x0000000000400d7d in main() at test.cpp:30 7.调试命令 继续运行 gdb # cont = continue (gdb) cont = continue 手动打印信息 当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。\n打印变量值 print 命令的语法格式如下:\n# print == p (gdb) p 变量名 # 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表 (gdb) p/fmt 变量名 例子：\n# 举例 (gdb) p i # 10进制 $5 = 3 (gdb) p/x i # 16进制 $6 = 0x3 (gdb) p/o i # 8进制 $7 = 03 打印变量类型 查看某个变量的类型\n(gdb) ptype 变量名 例子：\n# 打印变量类型 (gdb) ptype i type = int (gdb) ptype array\u0026amp;#091;i] type = int (gdb) ptype array type = int \u0026amp;#091;12] 自动打印信息 设置变量名自动显示 频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式\n# 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示) (gdb) display 变量名 # 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令 (gdb) display/fmt 变量名 查看自动显示列表 # info == i (gdb) info display Auto-display expressions now in effect: Num Enb Expression 1: y i 2: y array\u0026amp;#091;i] 3: y /x array\u0026amp;#091;i] 在展示出的信息中，每个列的含义如下:\nNum : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号 Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。 Expression ：被自动打印值的变量或表达式的名字。 取消自动显示 对于不需要再打印值的变量或表达式，可以将其删除或者禁用。\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) undisplay num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) undisplay num1-numN (gdb) delete display num \u0026amp;#091;num1 ...] (gdb) delete display num1-numN\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 例子：\n# 查看显示列表 (gdb) info display Auto-display expressions now in effect: Num Enb Expression 1: y i 2: y array\u0026amp;#091;i] 3: y /x array\u0026amp;#091;i] # 删除变量显示, 需要使用 info display 得到的变量/表达式编号 (gdb) undisplay 1 2 # 查看显示列表, 只剩下一个了 (gdb) i display Auto-display expressions now in effect: Num Enb Expression 3: y /x array\u0026amp;#091;i] 禁用自动显示列表中处于激活状态下的变量或表达式\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) disable display num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) disable display num1-numN 当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令\n# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个 (gdb) enable display num \u0026amp;#091;num1 ...] # num1 - numN 表示一个范围 (gdb) disable display num1-numN 单步调试 当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:\nstep step 命令可以缩写为 s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。\n# 从当前代码行位置, 一次调试当前行下的每一行代码 # step == s # 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部 (gdb) step finish 作用：跳出函数体，函数体内不能有有效断点\n# 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体 (gdb) finish next 作用：和step相似，但不会进入函数体内部\n# next == n # 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部 (gdb) next until until作用：直接跳出某个循环体 循环体内部不能有有效的断点，必须要在循环体的开始 / 结束行执行该命令\n(gdb) until 设置变量值 set var 变量名=值\n设置某个变量的值\n","date":"2021-12-26T16:46:38Z","permalink":"https://okokfun.github.io/post/c++/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","title":"gdb代码调试工具"},{"content":"\n1.点击home,再点击配置，然后填写nas的ip地址即可 ","date":"2021-12-26T13:43:29Z","permalink":"https://okokfun.github.io/post/nas/%E4%BB%8Eportainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/","title":"从Portainer点击端口号进入容器服务方法"},{"content":" 1. 安装完第三方插件后，再安装docker与portainer 2. 点击Opem Portainer创建管理账号 3. 然后创建一个容器网络 ","date":"2021-12-26T13:42:29Z","permalink":"https://okokfun.github.io/post/nas/openmediavault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8Egui%E5%B7%A5%E5%85%B7portainer/","title":"OpenMediaVault中docker与工具portainer"},{"content":" OpenMediaVault 国内软件源镜像服务器\n清华大学镜像 https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/ 北京外国语大学镜像 https://mirrors.bfsu.edu.cn/OpenMediaVault/ OMV 5\n一、编辑 sources.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list\u0026#39; 3. 编辑配置文件\nsudo nano /etc/apt/sources.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free 二、编辑 openmediavault-kernel-backports.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list.d/openmediavault-kernel-backports.list /etc/apt/sources.list.d/openmediavault-kernel-backports.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault-kernel-backports.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault-kernel-backports.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian buster-backports main contrib non-free 三、编辑 openmediavault.list 1. 备份配置文件 sudo cp /etc/apt/sources.list.d/openmediavault.list /etc/apt/sources.list.d/openmediavault.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/public/ usul main 四、编辑 omvextras.list\n1. 备份配置文件 sudo cp /etc/apt/sources.list.d/omvextras.list /etc/apt/sources.list.d/omvextras.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/omvextras.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/omvextras.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers usul main deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable deb http://linux.teamviewer.com/deb stable main 五. 刷新软件源 sudo apt update ","date":"2021-12-26T13:42:29Z","permalink":"https://okokfun.github.io/post/nas/openmediavault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/","title":"OpenMediaVault软件源修改"},{"content":" OpenMediaVault（omv）是开源的nas系统，本博客尽量采用开源的代码和软件\n1. 镜像下载 下载地址\nhttps://sourceforge.net/projects/openmediavault/files/latest/download 2. 刻录或虚拟机安装 可以用etcher软件刻录镜像\n安装 omv-extras 启用 OMV 5 社区插件支持 3. 安装依赖的工具 sudo apt --yes --no-install-recommends install dirmngr gnupg 4. 下载最新的omv-extras 安装包 地址：https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 下载命令：sudo wget https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 5. 安装 sudo dpkg -i openmediavault-omvextrasorg_5.6.2_all.deb 6. 安装完开启docker扩展源 7. Docker修改镜像源并在OMV 中的安装和使用 Docker 设置国内镜像服务器\n第一步 创建 docker 配置文件目录 sudo mkdir /etc/docker 第二步 创建 daemon.json 配置文件 sudo touch /etc/docker/daemon.json 第三步 编辑配置文件 sudo nano /etc/docker/daemon.json 在编辑器中粘贴以下内容: { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.baidubce.com\u0026#34; ] } 第四步 重启 docker 服务 sudo systemctl daemon-reload sudo systemctl restart docker 检查设置是否生效\nsudo docker info 如果生效返回的信息类似下面这样\nRegistry Mirrors: https://hub-mirror.c.163.com/ ","date":"2021-12-26T13:39:29Z","permalink":"https://okokfun.github.io/post/nas/openmediavault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/","title":"OpenMediaVault安装与初步设置"},{"content":" 要创建的容器有：\nMariadb: 关系型数据库，mysql的开源版本\rAdminer：开源的数据库管理软件\rGitea：开源的私人代码版本管理器\rFlarum：开源的论坛\rWordPress：开源的博客软件\rNextCloud：开源的私人网盘软件\r1.在一个分区上创建我们需要的文件夹存放配置文件 2.在终端拉取上面的各个镜像文件 1.flarum docker pull mondedie/flarum:latest\r2.wordpress docker pull wordpress\r3.adminer docker pull adminer\r4.mariadb docker pull mariadb\r5.gitea docker pull gitea/gitea\r6.nextcloud docker pull nextcloud\r3.创建各个容器 按顺序应该创建数据库软件与数据库管理软件 1.mariadb容器创建参考 container_name: mariadb\renvironment:\r- PUID=1000\r- PGID=1000\r- MYSQL_ROOT_PASSWORD=1\r- TZ=Asia/Shanghai\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/mariadb/config:/config\rports:\r- 3306:3306\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r2.adminer创建参考 container_name: adminer\renvironment:\r- ADMINER_DEFAULT_SERVER=mariadb\rports:\r- 8080:8080\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.flarum创建参考 3.1在映射的flarum根目录创建docker-compose.yaml version: \u0026quot;3\u0026quot;\rservices:\rflarum:\rimage: mondedie/flarum:stable\rcontainer_name: flarum\renv_file:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/flarum.env\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/assets:/flarum/app/public/assets\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/extensions:/flarum/app/extensions\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/nginx:/etc/nginx/flarum\r- /mnt/docker/flarum/storage/logs:/flarum/app/storage/logs\rports:\r- 8081:8888\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.2再创建flarum.env DEBUG=false\rFORUM_URL=http://192.168.1.105:8081\r# Database configuration\rDB_HOST=mariadb\rDB_NAME=flarum\rDB_USER=flarum\rDB_PASS=123456789\rDB_PREF=flarum_\rDB_PORT=3306\r# User admin flarum (environment variable for first installation)\r# /!\\ admin password must contain at least 8 characters /!\\\rFLARUM_ADMIN_USER=admin\rFLARUM_ADMIN_PASS=123456789\rFLARUM_ADMIN_MAIL=txt1994s@163.com\rFLARUM_TITLE=txt1994的论坛\r登录adminer,然后创建数据库\nDB_HOST=mariadb (地址)\rDB_NAME=flarum (数据库)\rDB_USER=flarum （用户）\rDB_PASS=123456789（密码）\r然后运行命令：\ndocker-compose up -d flarum\r安装中文插件\n=Beta 14\ndocker exec -ti flarum extension require ffans/lang-simplified-chinese\n安装emoji表情插件 docker exec -ti flarum extension require clarkwinkelmann/flarum-ext-emojionearea\n安装显示帖子阅读次数 docker exec -ti flarum extension require michaelbelgium/flarum-discussion-views\n安装flarum媒体增强插件 docker exec -ti flarum extension require fof/formatting\n表格支持插件\ndocker exec -ti flarum extension require askvortsov/flarum-markdown-tables\n代码高亮\ndocker exec -ti flarum extension require therealsujitk/flarum-ext-hljs\n4.gitea创建参考 container_name: gitea\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/gitea/data:/data\rports:\r- \u0026quot;3000:3000\u0026quot;\r- \u0026quot;2222:22\u0026quot;\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建数据库：\r- MYSQL_ROOT_PASSWORD=1\r- MYSQL_DATABASE=gitea\r- MYSQL_USER=gitea\r- MYSQL_PASSWORD=123456789\r5.wordpress创建参考 container_name: wordpress\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/wordpress/html:/var/www/html\rports:\r- 8082:80\renvironment:\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建好数据库：\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\r6.nextcloud创建参考 container_name: nextcloud\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/nextcloud/html:/var/www/html\rports:\r- 8083:80 networks:\r- mynet restart: always\r创建好数据库：\renvironment:\r- MYSQL_PASSWORD=123456789\r- MYSQL_DATABASE=nextcloud\r- MYSQL_USER=nextcloud\r- MYSQL_HOST=mariadb ","date":"2021-12-26T13:41:29+08:00","permalink":"https://okokfun.github.io/post/nas/openmediavault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/","title":"OpenMediaVault创建容器"},{"content":" 开源 C++ 库列表 \u0026lt; cpp‎ | links\n此页面的目的是构建开源 C++ 库的比较列表，使得人们在需要特定功能的实现时，不必浪费时间在网上（ DuckDuckGo 、谷歌、必应等）搜索。\n若你知道可能对其他人有用的库，请在此添加到它的链接。能包含进来的库没有限制，但是必须能便捷地下载库的源码。\n以“原态”提供此页面——希望这有用，但不提供任何担保。过时、误导或错误的链接可能出现于此。若你注意到这些错误，则改正它会很有意义。\n包管理器 Package manager Description build2 一个开源的 (MIT)、跨平台的构建工具链，旨在为开发和打包 C/C++ 项目时提供如 Rust Cargo 一样的便利性。 cget Cmake 包检索工具，可用于下载并安装 Cmake 包。 cmodule 非侵入式 CMake 依赖管理。 conan 去中心化、开源 (MIT) 的 C/C++ 包管理器。 CPM.cmake 一段可以为 CMake 加入依赖管理功能的 CMake 脚本。它是作为 CMake 的 FetchContent 模块的一个简单包装构建的。该模块加入了版本控制、缓存、简单 API 等功能。 hunter 一个 CMake 驱动的跨平台包管理器，服务于 C/C++ 项目。 spack 一个超级计算机、Linux、macOS 平台的包管理器。它使得安装科学软件变得简单。非绑定于某一特定语言。 teaport 一个受 cocoapods 启发的依赖管理器。 vcpkg 一个 Windows、Linux、macOS 平台的 C++ 包管理器。 库 音频 库名 简述 协议 配置手段 Aquila Aquila 是一个开源、跨平台的 C++11 DSP 库。 MIT 许可 CMake Essentia 开源库，音频和音乐分析、描述和合成工具 (MIR) (源码) Affero GPLv3 FFTW 离散傅里叶变换 (DFT) 计算库 (SSE/SSE2/AVX/Altivec/ARM Neon)。 (源码) GPL-2.0 CMake KFR 快速、现代、C++17、开源并且跨平台的 DSP/DFT 框架。支持音频重采样、 FIR/IIR 滤波器、二阶滤波器, (SSE, AVX, AVX-512, ARM NEON)。 (源码) GPL-2.0 CMake soundtouch SoundTouch 是一个开源、跨平台的音频处理库，用于更改音频流或音频文件的速度、音调和播放速率。 (源码) LGPL-2.1 Makefile 音频指纹 库名 简述 协议 配置手段 chromaprint (源码) MIT 许可, LGPL 2.1 CMake libmusicbrainz (源码) LGPL-2.1 CMake libofa MusicIP 开源音频指纹库 APL makefile 格式 库名 简述 协议 配置手段 audiofile LGPL-2.1 makefile flac Open Source, BSD 许可, GPL 许可 libsndfile LGPL v2.0 or v3.0 标签 库名 简述 协议 配置手段 id3lib LGPL v2 taglib (源码) LGPL 和 MPL v1.1 CD 库名 简述 协议 配置手段 libkcompactdisc CD 接口库 GPL v2.0 CMake 性能测试 库名 简述 协议 配置手段 benchmark Apache2.0 许可 CMake Celero Apache 许可 CMake gperftools “谷歌性能工具”包含高性能、多线程的 malloc 实现加上评测堆分配和 CPU 利用的工具。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License configure plf::nanotimer 用于性能评测的最低开销、跨平台的简单定时器类。 zlib 许可 通信 库名 简述 协议 配置手段 ACE 异步网络、多路分离、报文发送 Apache Thrift Apache Thrift 软件框架，用于规模可变的跨语言服务开发，将软件栈与代码生成引擎结合，构建有效而无缝地在 C++ 、 Java 、 Python 、 PHP 、 Ruby 、 Erlang 、 Perl 、 Haskell 、 C# 、 Cocoa 、 JavaScript 、 Node.js 、 Smalltalk 、 Ocaml 、 Delphi 及其他语言间工作的服务。 Boost.Asio 异步及同步网络、定时器、序列 I/O BSL-1.0 Boost.Beast 建立于 Boost.Asio 顶上的 HTTP 及 WebSocket 库 BSL-1.0 Breep 基于事件、高层、点对点库，允许用户直接发送和接收对象。 European Union Public License 1.1 CMake C++ REST SDK 异步 HTTP 客户端及监听器、异步 Stream 、 URI 、 JSON MIT 许可 CMake cpp-netlib cpp-netlib ： C++ 网络库 BSL-1.0 CMake cpr 现代 C++ HTTP 请求库 MIT 许可 CMake Crow BSD-3-Clause CMake curlpp CURL 库的 C++ 包装 DumaisLib MIT 许可 Makefile EasyHttp 跨平台的 HTTP 客户端库，专注于可用性和速度，支持 http 响应缓存及更多 MIT 许可 CMake eCAL 高性能进程间通信 Apache2.0 许可 CMake fineftp-server MIT 许可 CMake gRPC gsoap XML 数据绑定、快速 WSDL/SOAP/XML 网络服务、 WS 安全、 JSON/XML-RPC RESTful 服务的 C/C++ 开发工具套 HTTPP 简单、生产就绪的构建在 Boost 上的 HTTP 服务器，及构建在 libcurl 上的客户端。 BSD 2-Clause \u0026ldquo;Simplified\u0026rdquo; License CMake, Makefile IXWebSocket 无依赖的开源 WebSocket + HTTP 库，支持 SSL 和逐条消息 deflate 的 WebSocket 扩展。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake, Makefile KCP 快速可靠的 ARQ 协议，帮助应用减少网络延迟。 MIT 许可 CMake libashttp 异步 HTTP 客户端库 GNU Lesser General Public License v3.0 libnavajo CeCILL-C FREE SOFTWARE LICENSE AGREEMENT CMake libtins 网络包装制作及嗅探库 nanomsg netif BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake nghttp2 HTTP/2 C 库及工具（服务器、客户端、代理和评测工具） MIT 许可 CMake, configure ngrest 快速而简易的利用 JSON 的 RESTful 网络服务框架 Apache2.0 许可 CMake nng omniORB 最快速、完整而可移植的 CORBA ORB 在 C++ 中的实现 OpenDDS DDS 实现 Paho MQTT CMake PcapPlusPlus 多平台 C++ 网络嗅探和包装分析及制作框架 POCO 网络：加密、 HTTP ； ZIP 文件 rest_rpc 现代、简单、易用的 rpc 框架 CMake restbed 设计以嵌入到宽范围的应用中的 C++ 为框架。 许可协议 CMake restc-cpp 将痛苦从自 C++ 访问 JSON API 带走。 HTTP 客户端，原生 C++ 类到/自 JSON 的序列化，通过 boost::asio coroutines 携程的异步 IO 。 C++14 。 MIT 许可 CMake restful_mapper 于 C++ 中消费 RESTful JSON API 的 ORM CMake, Makefile seastar 用C++11实现的高性能异步编程框架。 Apache2.0 许可 CMake, etc. Silicon 快速而稳健的 Web APIs MIT 许可 CMake sockpp 简单的现代 C++ 套接库 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake Simple C++ REST library 在你的 C++ 应用中创建 REST API 的非常简单且自成文档的库 stream-client 轻量、唯头文件的、基于 Boost 的客户端 socket/connector/socket pool/resolver Apache2.0 许可 CMake tacopie C++11 TCP 库 MIT 许可 CMake TAO CORBA taox11 基于 C++11 的 CORBA 实现 MIT 许可 Unicomm 异步网络、高层 TCP 交互框架 uvw 现代 C++ 书写的 libuv MIT 许可 CMake wvstreams GPL 许可 zeromq 快速消息队列 并发 库名 简述 协议 配置手段 BlockingCollection C++11 线程安全汇集类，模仿 .Net BlockingCollection。 Boost.Atomic BSL-1.0 Boost.Compute （非官方） OpenCL 的仿 STL 算法及数据结构 BSL-1.0 Boost.Context BSL-1.0 Boost.Interprocess BSL-1.0 Boost.Lockfree BSL-1.0 Boost.MPI BSL-1.0 Boost.Thread BSL-1.0 Cpp-Taskflow 带任务依赖的快速 C++ 并行编程 hipSYCL BSD-2-Clause License CMake HPX 任何规模的并行和分布式应用的通用 C++ 运行时系统 Intel TBB KOKKOS C++ 中的编程模型，用于书写高性能的便携 HPC 应用 libopenmpi libsimdpp MutexGear The MutexGear Library License configure, MSVC OpenMP RaftLib 类似并发行动者的 C++ 流 SObjectizer 通过行动者和出版订阅模型，简化开发并发和事件驱动应用的 C++ 中的小型框架。 subprocess Taskflow Thrust CUDA 的仿 STL 算法及数据结构 VexCL OpenCL 和 CUDA 的 C++ 表达式模板库 ViennaCL 带 OpenMP 、 CUDA 及 OpenCL 后端的线性代数及算法 Xenium 配置 库名 简述 协议 配置手段 Boost.Program_options BSL-1.0 gconfmm libconfig libconfini INI 分析器 XML 库名 简述 协议 配置手段 ai-xml GPDS gSOAP XML 数据绑定 libxml++ pugixml tinyxml tinyxml2 另一 TinyXML ，建设中。 Xerces JSON 库名 简述 协议 配置手段 ArduinoJson ArduinoJson CAJUN jansson Jansson 是编码、解码及操纵 JSON 数据的 C 库。 jeayeson 非常健全的（唯头文件） C++14 JSON 库 jios JSON 输入输出流 (JSON Input Output Streams) MIT 许可 CMake JOST JSON Voorhees C++ 的杀手 JSON json Niels Lohmann JSON json-cpp json11 json11 是 C++11 的轻量 JSON 库，提供 JSON 分析及序列化。 JsonBox jsoncons JSON 与类 JSON 数据结构的唯头文件库，含 JSON Pointer 、 JSON Patch 、 JSONPath 、 CSV 、 MessagePack 、 CBOR 、 BSON 、 UBJSON。 jsoncpp jsonme\u0026ndash; libjson minijson C++ 无 DOM 且免分配的 JSON 分析及序列化 nosjob qjson rapidjson simdjson 每秒解析 GB 级别的 JSON struct_mapping ThorsSerializer JSON/YAML Input Output Streams MIT 许可 Makefile ujson µjson 是小型的 C++11、UTF-8 JSON 库 zoolib meojson json简单库，作者MistEo MIT许可 Cmake, Makefile YAML 库名 简述 协议 配置手段 yaml-cpp TOML 库名 简述 协议 配置手段 toml++ toml11 基于 C++11 的 TOML 解析库 HOCON 库名 简述 协议 配置手段 cpp-hocon Pupplet 开发的 HOCON 格式的 C++ 实现。 CSS 库名 简述 协议 配置手段 mycss CSS 解析器 容器 库名 简述 协议 配置手段 Boost.Bimap BSL-1.0 Boost.Container BSL-1.0 Boost.Fusion BSL-1.0 Boost.Heap BSL-1.0 Boost.Pointer Container BSL-1.0 Boost.Tuple BSL-1.0 Boost.Variant BSL-1.0 cpp-btree btree_map 、 btree_set 、 btree_multimap 、 btree_multiset 。 DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 eggs::variant Eggs.Variant 是 C++11/14 的泛型、线程安全、有区别的联合体。值得注意的是它有很好的 constexpr 支持。 Frozen constexpr 完美基于哈希的冻结集合与映射（ Apache 2.0 ）。 Immer Boost License CMake plf::colony 无序的“类背包”容器，在高度修改场景中性能优于 std:: 容器，同时维护指向未被擦除元素的合法指针，无关乎插入或擦除。 plf::list std::list 实现，为缓存友好牺牲范围切割，导致更快的插入、擦除和迭代。 plf::stack std::stack 容器适配器的随意访问替换容器，在栈环境中有优于 std::vector 和 std::deque 的性能。 ring_span Guy Davidson 与 Arthur O\u0026rsquo;Dwyer 的 ring_span ——即环状缓冲区视图的简化实现。 strict_variant 快速而决不空的 variant ，目标 C++11 。阻止许多不想要的隐式转换。 TdhLists Ygg 高性能容器和数据结构，例如红黑树、区间数和区间映射的侵入式 C++11 实现。 密码学 库名 简述 协议 配置手段 Botan crypto++ gnutls openssl TomCrypt 数据库 库名 简述 协议 配置手段 redis-plus-plus 用C++ 11编写的Redis客户端, 支持Redis Sentinel，Redis Cluster，管道，事务，发布订阅，连接池以及类似于STL的接口 cpp-redis C++11 轻量的 Redis 客户端：异步、线程安全、无依赖、管道化、多平台。 OTL DTL libpqxx lmdb++ LMDB 嵌入式 B+ 树数据库的 C++11 包装。 mongocxx MongoDB 的 C++11 驱动库 mysql++ ODB - C++ Object-Relational Mapping (ORM) Pgfe - PostGres FrontEnd 现代 C++ 客户端 API 到 PostgreSQL QUINCE: QUeries IN C++ Expressions (ORM+EDSL) QxOrm - C++ Qt Object-Relational Mapping (ORM) SOCI sqlpp11 SQLAPI++ EasyQtSql 轻量唯头文件 C++11 库，用 QtSql 快速便捷地进行 SQL 查询 LevelDB 谷歌开发的、能够处理十亿级别规模 Key-Value 型数据持久性存储的C++ 程序库。 嵌入语言绑定 库名 简述 协议 配置手段 ChaiScript ExprTk lua sol2 AngelScript 类似 C++ 的脚本语言。 mozjs muparser PythonQt ScriptCaller 允许程序员调用 Ruby 脚本的唯头文件库。 v8pp 将 C++ 函数和类绑定到 V8 JavaScript引擎中。 嵌入式/实时 库名 简述 协议 配置手段 QP/C++ RTOS 内核，双重 GPL ETL - Embedded Template Library C++03 ，为少资源平台裁剪的可移植模板库 distortos 微控制器的面向对象 C++ RTOS µcuREST 微控制器的 C++11 REST/JSON 服务器框架 文件元数据 库名 简述 协议 配置手段 libkexiv2 exiv2 exempi rarian 金融计算 库名 简述 协议 配置手段 QuantLib - Quantitative finance library DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 游戏引擎架构 库名 简述 协议 配置手段 EntityX Anax EntityPlus EnTT BOX2D 物理引擎 通用多媒体 库名 简述 协议 配置手段 SFML (Simple and Fast Multimedia Library) SDL (Simple DirectMedia Layer) 对音频、键盘、鼠标、操纵杆及图形硬件，经由平台上图形 API （通常为 OpenGL 或 Direct3D ）的跨平台低层访问（ zlib 许可） SIGIL (Sound, Input, and Graphics Integration Library) 文本、形状、输入、音频及 2D 图像的难以置信地简单的跨平台极简库 Cinder openFrameworks 通用 库名 简述 协议 配置手段 Boost 大量通用库的汇集 Boost 许可 GSL Guideline Support Library 实现，为 Bjarne Stroustrup, Herb Sutter 和 Co 在《 C++ 核心方针》中推荐 BDE 来自 Bloomberg L.P. 的 Bloomberg Development Environment 核心库 Apache 许可 Dlib 网络、线程、图形用户界面、数据结构、线性代数、机器学习、 XML 及文本分析、数值优化、贝叶斯网络和大量其他任务 Boost 许可 JUCE 扩展性的成熟跨平台 C++ 工具套 GPL 许可 Loki 设计模式 Reason xml 、 xpath 、正则表达式、线程、接头、 http 、 sql 、日期时间、流、编码与解码、文件系统、压缩 GPL 许可 yomm2 C++17 的开放式多方法 Boost 许可 Folly Facebook 开源库。设计带有构思中的实践性和效率设计的 C++11 组件库。 Abseil Google 设计以补足 C++ 标准库的开源 C++ 库代码汇集。 cxxomfort C++ 特性逆向移植（ C++11 到 C++03 及 C++1y 提案到 C++11/C++03 ）。 libsourcey 高速网络化和多媒体编码的跨平台 C++11 库。 HTTP 、 WebSockets 、 TURN 、 STUN 、 Symple 及更多…… OnPosix 在 POSIX 平台上提供各种抽象（例如线程、网络化、日志、 IPC 等）的 C++ 库。 Ultimate++ 跨平台的迅速应用开发框架 CAF C++ Actor Framework (CAF) 是开源的 C++11 行动者模型实现，特性为轻量而快速的行动者实现、消息的模式匹配、网络不可见消息传递及更多 BSD 许可 cpp-mmf 对 POSIX 或 Windows 封装映射到内存文件的 C++98 库 CommonPP 多用途库，强调在项目中得出度规。 BSD Better Enums 反射性枚举（枚举到字符、迭代等），带 constexpr 支持。 BSD Smart Enum 给你的枚举 \u0026ldquo;to_string\u0026rdquo; 、 \u0026ldquo;from_string\u0026rdquo; 和更多。 Boost 许可 nytl 通用的 C++17 唯头文件模板库。 Boost 许可 SaferCPlusPlus SaferCPlusPlus - 不安全的 C++ 原始工具的安全兼容替换品，包括指针、 int 和 std::vector。 Boost 许可 fcppt Freundlich 的 C++ 工具套 (fcppt) 是聚焦于通过提供更好的类型和函数式编程改进 C++ 代码的库汇集。 bitfield.h 位域结构设施，比基础语言设施更可移植/灵活。 composite_op.h 基础类数据成员自省，繁琐且常常不可重入，但有时有用。 Abstract Intrusive Containers 比 boost::intrusive 更灵活，但非 STL 兼容。 Yato 现代 C++ (14/17) 的跨平台 STL 风格及 STL 兼容库，实现容器、范围、迭代器、类型特性和其他工具；行动者系统；类型安全配置接口 Apache-2.0 Kangaru C++11 与 C++14 的依赖注入容器 MIT 许可 yaal 算法、汇集、任意精度计算、泛型 DSL 文法驱动分析器及更多 CC BY-ND-NC 4.0 CMake gsl-lite C++98 、 C++11 及后续版本的 ISO C++ Guideline 支持库 (GSL) 的单文件唯头文件版本。 nonstd-lite *-lite 仓库的亲属，将 C++11 后特性移植到古代 C++ 环境的迁移路径。 units 编译时唯头文件的量纲分析及单位转换库，建立于 C++14 而无依赖。 GPS 库名 简述 协议 配置手段 gpsd 图形用户界面 库名 简述 协议 配置手段 Dear ImGui 高度优化的不膨胀的图形用户界面库。 FLTK nana 用现代 C++ 风格的 GUI 编程（ Boost 许可） nanogui 最小化的跨平台器件库，适用于 OpenGL 3.x 或更高版本 WxWidgets OWLNext 对 OWL 的，用于在 Windows 上以标准 C++ 书写 GUI 应用的现代更新 tiny file dialogs 单个 C C++ 跨平台文件（无初始化、无 main 循环、 6 种形态的函数调用） CopperSpice 库名 简述 协议 配置手段 CopperSpice CopperSpice 是用于开发跨平台软件应用的 C++ 库集合。它在 LGPL V2.1 许可下发布。它使用现代理念的 C++ 并与 STL 无缝结合。 CopperSpice 派生自 Qt 框架。 CsSignal 独立的 C++ 具线程信号/槽库 CsString 独立的 C++ 具 Unicode 字符串库 libGuarded 独立的 C++ 多线程库，用于管理对共享数据的访问 GTK+ 库名 简述 协议 配置手段 glibmm gtkmm goocanvasmm libglademm libgnomecanvasmm webkitgtk flowcanvas evince Qt 库名 简述 协议 配置手段 Qt qwtplot3d qwt5 技术应用到 Qt Widgets libdbusmenu-qt QuickQanava 直接在 Qt/QML 应用中画图的 C++14 库；项目主页： http://www.qanava.org QuickProperties QObject/QtObject 属性编辑的 C++/QML 库；项目主页： http://www.qanava.org 图形 库名 简述 协议 配置手段 cairomm nux pangomm nanovg 基于openGL/DX/metal的2d绘图库。 bgfx 非常强大的跨平台图形渲染库，支持平台包括 Windows Mac Linux iOS Android Web，渲染后端包括 DX, opengl, metal webgl等。 图像 库名 简述 协议 配置手段 gegl stb.image Adobe/boost GIL 高层通用库，聚焦于 2D 图像上操作的算法。非常有限定 I/O 选项。 GraphicsMagick 读、写、操纵 88 种主要格式的图像。于 2002 年分化自 ImageMagick Skia Graphics Engine Google 从 2005 年起的图形库，用于 Chrome 、 Chrome OS 、 Android 还有 Firefox 和 Sublime Text enwiki:Skia_Graphics_Engine Anti-Grain Evolution 跨平台 2D 光栅化及绘图引擎 打点 库名 简述 协议 配置手段 plotutils 格式 库名 简述 协议 配置手段 libraw openexr qimageblitz imagemagick djvulibre poppler SVG++ 3D 图形 库名 简述 协议 配置手段 Vulkan OpenGL bgfx 跨平台、不知图形 API 、“带来你自己的引擎/框架”风格的制图库。 Ogre3D Diligent Engine 现代跨平台低层 3D 图形库。 GLEW OpenGL 功能加载 GLAD 可定制的轻量库，用于加载 OpenGL 功能 Epoxy GLEM 的现代后继者。在 GL 环境的一些种类间抽象，这使得有时比使用 GLEW 更加单。自 2015 起为 GTK+ 项目所用。 GLFW OpenGL 窗口管理器 GLM 制图用的唯头文件 C++ 数学库 hlsl++ 使用 hlsl 语法的唯头文件 C++ 渲染库。支持 SSE 和 NEON assimp 3D 模型加载 VTK Magnum 游戏和数据可视化的轻量模块化的 C++11/C++14 图形中间件 Irrlicht Horde3D Visionaray C++ 光束追踪模板库 Open CASCADE 3D CAD/CAM/CAE 应用的 SDK OpenSceneGraph 图像处理 库名 简述 协议 配置手段 opencv dlib ITK OTB 国际化 库名 简述 协议 配置手段 IBM ICU gettext spirit-po 快速的唯头文件库，分析 po 文件，并提供类似 GNU libintl 的接口。基于 boost::spirit 。 记录 库名 简述 协议 配置手段 Log4cpp 用于灵活地记录到文件、系统日志、 IDSA 或其他目标的 C++ 类库 (LGPL) Log4cplus 日志 API ，提供日志管理及配置上的线程安全、灵活且有任意粒度的控制。 spdlog 超快的唯头文件 C++ 日志库 plog C++ 的可移植且简单的日志，少于 1000 行代码 (MPL2) Boost.Log glog Google 日志库 log4cxx Apache log4cxx 是 Apache log4j 后的 C++ 模式化记录框架 Pantheios 诊断日志 API 库，提供类型安全、效率、泛型和可扩展性的结合 Backward 打印漂亮的 Python 风格栈追踪，带颜色和源代码片段，特别是在崩溃时（ MIT 许可）。 数学 库名 简述 协议 配置手段 stats++ 先进、广泛的统计软件：数据收集及预处理、统计、机器学习及优化，拥有开放的 C++ 源码。 StatsLib 统计分布函数的模板化唯头文件库。 alglib ArrayFire High Performance Computation Library GNU MP bignum C++ interface BigNumber 创建和计算任意长度整数的 C++ 类 Boost.Multiprecision Boost.Math.Special Functions and Statistical Distributions Boost.Random NTL - A Library for doing Number Theory cpp-measures 处理物理度量的唯头文件 C++11 库 G+Smo 等几何分析的跨平台库 C++ Matrix 高性能且精确（例如极端情况）的矩阵数学库，带表达式模板算术运算符 Exact floating-point arithmetic library RPNX Uniform Smooth Noise N 维均匀分布的平滑噪声函数，以 C++ 实现。 数值计算 库名 简述 协议 配置手段 LibBF 由 Bellard 开发的任意精度数值计算库，拥有一个将圆周率计算到数十亿位的示例程序 线性代数 库名 简述 协议 配置手段 Boost.uBLAS Eigen Armadillo Blitz++ IT++ Dlib - linear algebra tools Blaze ETL DecompLib 唯头文件的 C++11 库，分解向量为正定加权基向量的集合。 优化 库名 简述 协议 配置手段 OptimLib 非线性函数数值优化方法的 C++11 库。 图论 库名 简述 协议 配置手段 Boost.Graph LEMON OGDF - Open Graph Drawing Framework NGraph - a simple (Network) Graph library in C++ GTpo C++14 泛型图拓扑库，带 Protocol Buffer 序列化；项目主页： http://www.qanava.org 数的类库 库名 简述 协议 配置手段 cln Universal 通用数算术的 C++ 模板库，取代 IEEE 浮点（ MIT 许可） 人工智能 库名 简述 协议 配置手段 stats++ liblinear Dlib 机器学习工具 MLPACK 机器学习包 Shogun 大规模机器学习工具箱 FANN 快速人工神经网络库 TensorFlow 面向所有人的开源机器学习框架 Paddle 并行化分布式深度学习库 DLDT OpenVINO™工具包-深度学习部署工具包 TensorRT 用于在 NVIDIA GPU 和深度学习加速器上进行高性能推理的 C++ 库 NCNN 腾讯开发的、针对移动平台进行了优化的高性能神经网络推理框架 OpenPose 实时多人关键点检测库，用于身体，面部，手和脚的检测 ANNetGPGPU 基于GPU（CUDA）的人工神经网络库。 btsk 游戏行为树入门套件。 Evolving Objects 基于模板的 C++ 演化计算库，可帮助您快速随意地编写自己的随机优化算法。 frugally-deep 仅头文件的库，用于在 C++ 中使用Keras模型。 Genann 简单神经网络库。 Recast/Detour 导航网格生成器和浏览器，主要用于游戏。 CNTK 微软认知工具包（CNTK），一种开源的深度学习工具包。 tiny-dnn 基于 C++11 的唯头文件、无依赖的深度学习框架。 Veles 用于快速深度学习应用程序开发的分布式平台。 Kaldi 语音识别工具包。 计算几何 库名 简述 协议 配置手段 CGAL 计算几何算法库 Wykobi 计算几何库 PCL 点云库 自动化理论 库名 简述 协议 配置手段 yasmine - C++11 UML state machine framework 元编程 库名 简述 协议 配置手段 Boost.MPL 原初元编程库，目标为 C++03 ，慢 Boost.Hana 类型与值的新元编程库 Boost.Mp11 Boost.CallableTraits Metal 使用饿元函数， 100% SFINAE 友好 Brigand 使用饿元函数，为最佳性能优化 Meta 使用饿元函数，在 metal 和 brigand 之间，相对于性能妥协 Boost.Metaparse 编译时分析器库，从编译时字符串产生类型、值和元函数 Boost.Proto 构建基于表达式模板的 EDSLs 的库 CoMeta 轻量、唯头文件的 C++14 元编程库 visit_struct 小规模反射库，提供 C++11 的结构体观察器。自容纳， 100-200 行代码，取决于如何计算。 PDF 库名 简述 协议 配置手段 HARU PoDoFo JagPDF 物理与模拟 库名 简述 协议 配置手段 ReactPhysics3D 进行 3D 模拟与游戏的 C++ 物理引擎 ProjectCHRONO 开源多物理模拟引擎 Bullet 游戏、视觉效果、机器人及加固学习的物理模拟 序列化 库名 简述 协议 配置手段 Boost.Serialization libs11n sweet_persist protobuf gSOAP 准确的 XML 序列化 ai-xml 通过添加单个最小的函数到类，在 XML 间序列化及反序列化。在底层使用 libxml++ 。 C++ XML objects YAS (Yet Another Serialization) yaml-cpp cereal (C++11 serialization) jios (JSON serialization) ThorsSerializer (JSON/YAML Input Output Streams) cppcodec 唯头文件库，编码/解码 base64 、 base32 和十六进制，有一致而灵活的 API （ MIT 许可） iguana (universal serialization engine) rpnx-serial 能（反）序列化如 std::map 、 std::vector 等类型的库 二进制序列化 库名 简述 协议 配置手段 UBjsonCpp 基于 C++14 的高性能 UBJson 读写库 binn 旨在紧凑，快速且易于使用的二进制序列化库，自身是同名格式的实现。 bson-cxx BSON 格式的 C++ 实现。 排序 库名 简述 协议 配置手段 Timsort 模板化的稳定排序函数，对于逆序或半排序的数据，性能优于基于快速排序的算法，包括 std::sort 。 (MIT) 终端 库名 简述 协议 配置手段 cwidget replxx readline 和 libedit 的替换品，支持 UTF-8 、语法高亮和提示。 测试 库名 简述 协议 配置手段 Boost.Test cppunit Google Test Catch2 doctest 单元测试和 TDD 使用的最轻量的特性丰富的 C++ 单头文件测试框架 lest 现代的 C++11 原生的单文件唯头文件的轻量单元测试、 TDD 和 BDD 框架（包含 C++98 变体）。 liblittletest 可移植，单个唯头文件的测试框架 ELFspy 杜绝假象和间谍的测试 - 仅 Linux xtd.tunit Windows 、 macOS 、 Linux 、 iOS 和 Android 上的现代 C++17 单元测试库。官方网站 bandit C++11 的对人类友好单元测试 文本 编码 库名 简述 协议 配置手段 uchardet 实现猜字符串编码的功能,和python里的uchardet功能基本一样。 win-iconv Linux 和 Mac 上的字符集编码转换库 iconv 的 Windows 实现，基于 Win32 字符集转换 API 实现。 格式化 库名 简述 协议 配置手段 fmt printf 不好用，ostream 也不好用，format 好用 分析 库名 简述 协议 配置手段 PEGTL 分析表达式文法的模板库 BNFlite 仅单个头文件的轻量文法分析器库 搜索 库名 简述 协议 配置手段 clucene xapian Step Ukkonen 的构建后缀树在线算法， Manber 的构建后缀数组算法。 模板引擎 库名 简述 协议 配置手段 inja 现代 C++ 的模板引擎 版本控制 库名 简述 协议 配置手段 LibGit2 版本控制系统 Git 的核心库。 cpp-semver 语义化版本号的 C++ 操作库。 视频 库名 简述 协议 配置手段 crystalhd mjpegtools libmatroska libVLC gstreamermm Web 库名 简述 协议 配置手段 libmusicbrainz5 liblastfm libkcddb Chromium Embedded QtWebApp Java Servlets 所启发的 HTTP(s) Server ，以 C++ 实现 Wt Tufão libhttpserver cpp-jwt oatpp 用于创建高性能网络服务的轻量零依赖框架 ","date":"2021-12-26T13:23:02+08:00","permalink":"https://okokfun.github.io/post/openlib-c/","title":"OpenLib-c++"},{"content":" Arch安装 一.准备工作 1.1下载镜像 地址：\n清华：https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/ 163:https://mirrors.163.com/archlinux/iso/latest/ 中科大：https://mirrors.ustc.edu.cn/archlinux/iso/latest/ 上海交通：https://mirror.sjtu.edu.cn/archlinux/iso/latest/ 北大：https://mirrors.pku.edu.cn/archlinux/iso/latest/ 本文是Arch官方文档的再次梳理版\nhttps://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 安装方法有很多种比如脚本，实体机，虚拟机\n本文采用虚拟机+SSH安装+UEFI，SSH方便复制命令\n二.安装 1.键盘布局,默认为us，不需要更改 2.验证引导模式 ls /sys/firmware/efi/efivars 结果无错误切有目录则是UEFI，反之是BIOS引导\n3.连接网络 ip link 用 ping 检查网络连接\nping archlinux.org 4.更新系统时间 timedatectl set-ntp true 可用 timedatectl status 检查服务状态\n5.建立硬盘分区 cfdisk比fdisk配置简单许多，因此本文采用cfdisk\ncfdisk -l cfdisk UEFI采用GPT分区，一般情况下需要创建\n挂载点 分区 分区类型 建议大小 /mnt/boot 或 /mnt/efi /dev/efi_system_partition（efi 系统分区） EFI 系统分区 至少 260 MiB [SWAP] /dev/swap_partition（交换空间分区） Linux swap (交换空间) 大于 512 MiB /mnt /dev/root_partition（根分区） Linux x86-64 根目录 (/) 剩余空间 文件系统 创建命令 工具 Archiso [1] 内核文档 [2] 说明 Btrfs mkfs.btrfs(8) btrfs-progs 是 btrfs.html 可靠性 VFAT mkfs.fat(8) dosfstools 是 vfat.html exFAT mkexfatfs(8) exfat-utils 是 N/A (FUSE-based) F2FS mkfs.f2fs(8) f2fs-tools 是 f2fs.html 基于闪存的设备 ext3 mke2fs(8) e2fsprogs 是 (base) ext3.html ext4 mke2fs(8) e2fsprogs 是 (base) ext4.txt HFS mkfs.hfsplus(8) hfsprogsAUR 否 hfs.html macOS (8.x-10.12.x) 文件系统 JFS mkfs.jfs(8) jfsutils 是 (base) jfs.txt NILFS2 mkfs.nilfs2(8) nilfs-utils 是 nilfs2.html NTFS mkfs.ntfs(8) ntfs-3g 是 N/A (FUSE-based) Windows 文件系统 Reiser4 mkfs.reiser4(8) reiser4progsAUR 否 ReiserFS mkfs.reiserfs(8) reiserfsprogs 是 (base) UDF mkfs.udf(8) udftools Optional udf.html XFS mkfs.xfs(8) xfsprogs 是 (base) xfs.txt xfs-delayed-logging-design.html xfs-self-describing-metadata.html ZFS zfs-linuxAUR 否 N/A (OpenZFS 移植) 本文创建俩分区：根分区和ESP分区，ESP分区300M，根分区剩余全部空间\n6.格式化上边创建的分区 mkfs.ext4 /dev/sda2 //根分区 mkfs.vfat /dev/sda1\t//ESP分区 7.挂载格式化后的分区 挂载有先后顺序， 先挂载根（root）分区（到 /mnt），再挂载引导（boot）分区（到 /mnt/boot 或 /mnt/efi ， 否则您可能遇到安装完成后无法启动系统的问题\nmount /dev/sda2 /mnt mkdir /mnt/efi mount /dev/sda1 /mnt/efi 8.更换软件源 curl -L -o /etc/pacman.d/mirrorlist \u0026#34;https://www.archlinux.org/mirrorlist/?country=CN\u0026#34; 编辑/etc/pacman.d/mirrorlist，反注释其中一个或多个链接\n本文采用中科大和清华源\nvim /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 9.安装系统到磁盘 基础包：\npacstrap /mnt base base-devel linux linux-firmware #base-devel在AUR包的安装是必须的 功能性软件 :\npacstrap /mnt vim nano ctags wget clang clangd gcc g++ cmake make git networkmanager dhcpcd iwd sudo bash-completion openssh #一个有线所需 一个无线所需 一个编辑器 一个提权工具 一个补全工具 iwd也需要dhcpcd 10.配置系统 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab 11.切换到新系统 arch-chroot /mnt 三.设置时区 本地时区配置\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 生成 /etc/adjtime\nhwclock --systohc --utc 本地化： 明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。\n需在这两个文件设置：locale.gen 与 locale.conf。\n编辑 /etc/locale.gen，然后取消掉 en_US.UTF-8 UTF-8，zh_CN.UTF-8 UTF-8 和其他需要的 地区 前的注释（#）。\n接着执行 locale-gen 以生成 locale 信息：\nlocale-gen 编辑： /etc/locale.conf\necho \u0026#39;LANG=en_US.UTF-8\u0026#39; \u0026gt; /etc/locale.conf 四.配置主机名 编辑/etc/hostname，写入myhostname 默认为archlinux\necho \u0026#34;archlinux\u0026#34; \u0026gt;\u0026gt; /etc/hostname 五.配置hosts 编辑/etc/hosts，把myhostname改为你自己的主机名\n127.0.0.1 localhost ::1 localhost 127.0.1.1 archlinux.localdomain archlinux 六.引导系统 1）Grub引导Windows或其他Linux pacman -S os-prober 2)\t主板支持UEFI引导 |安装微码 pacman -S intel-ucode #Intel pacman -S amd-ucode #AMD 2.1)\t下载grub安装时所必需的文件 pacman -S grub efibootmgr 2.2)\t安装grub grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB 编辑/etc/default/grub 文件，去掉GRUB_CMDLINE_LINUX_DEFAULT一行中最后的 quiet 参数，同时把 log level 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错。同时加入 nowatchdog 参数，这可以显著提高开关机速度\n2.3)\t更新grub grub-mkconfig -o /boot/grub/grub.cfg 七.\t用户设置 vim /etc/hostname #输入主机名，只能输入字母 passwd root #设置root密码 useradd -m -g users -G wheel -s /bin/bash username #添加用户 passwd username #设置用户密码 vim /etc/sudoers #为用户添加sudo权限 反注释%wheel ALL=(ALL) ALL #如果想在输入密码时显示星号，可以追加Defaults env_reset,pwfeedback 八.设置默认编辑器 ln -f /usr/bin/vim /usr/bin/vi 九.安装网络驱动 1）wifi pacman -S netctl iw wpa_supplicant dialog networkmanager pacman -S broadcom-wl #博通无线网卡驱动 2）有线连接dhcp pacman -S dhcp dhcpcd 十.退出chroot并重启 # 退出chroot exit # 卸载 /mnt umount -R /mnt # 重启电脑 reboot 注意 运行reboot命令后，请拔掉U盘 使用ssh或其他Linux发行版本安装的用户请在新系统中配置好ssh环境，重启后可以直接ssh连接（需要安装net-tools软件包，不然无法运行ifconfig命令）\n配置系统 （一）网络配置 1）Wi-Fi 最新版的arch可能没有wifi-menu命令\nsudo wifi-menu 2）dhcp 有线连接\nsudo systemctl enable --now dhcpcd 3) timezone 设置系统时区\nsudo timedatectl set-timezone Asia/Shanghai 4) set-ntp 网络时间同步\nsudo timedatectl set-ntp true 查看时间状态\ntimedatectl status 5) /etc/skel/.bashrc 编辑用户配置文件.bashrc以在终端显示文件夹，以颜色\ncd /etc/skel/ ls -la vim .bashrc 在PS1之前添加如下文本\nexport EDITOR=vim alias ls=\u0026#39;ls --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; [ ! -e ~/.dircolors ] \u0026amp;\u0026amp; eval $(dircolors -p \u0026gt; ~/.dircolors) [ -e /bin/dircolors ] \u0026amp;\u0026amp; eval $(dircolors -b \u0026gt; ~/.dircolors) 覆盖家目录的文件\ncp -a . ~ （二）安装驱动 1）显卡驱动 运行lspci | grep VGA查看显卡型号 按照自己的显卡型号安装相应驱动\n显卡 驱动名称 Intel xf86-video-intel vulkan-intel mesa NVIDIA nvidia nvidia-utils nvidia-settings opencl-nvidia lib32-opencl-nvidia lib32-nvidia-utils 开源NVIDIA(不推荐) xf86-video-nouveau AMD xf86-video-amdgpu xf86-video-ati mesa vulkan-radeom FBI Warning 千万不要安装nouveau，千万不要安装nouveau，千万不要安装nouveau！重要的事情说三遍。如果你不怕电脑莫名卡死，当我没说。（doge） ps：博主受过nouveau的折磨\n2）触摸板驱动 sudo pacman -S xf86-input-synaptics //笔记本,外置触摸 3）安装声卡驱动 pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups （三）安装桌面（以gnome桌面为例） 安装x窗口系统\n#安装英文字体 sudo pacman -S ttf-dejavu ttf-droid ttf-hack ttf-fonts-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-ubuntu-font-family #安装中文字体 sudo pacman -S ttf-hannom noto-fonts noto-fonts-extra noto-fonts-cjk noto-fonts-emoji adobe-source-code-oro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-serif-cn-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts wqy-zenhei wqy-microhei sudo vim /etc/locale.conf #将语言改成中文 # 将英语注释掉，添加以下内容LANG=zh_CN.UTF-8 locale-gen sudo pacman -S xorg #安装x窗口系统 安装kde桌面\nsudo pacman -S plasma-meta plasma-nm konsole dolphin kde-connect firefox #简洁的kde桌面 sudo pacman -S plasma plasma-nm kde-applications #kde全家桶 sudo systemctl enable sddm #启动sddm服务 sudo systemctl enable NetworkManager #启动网络管理器 sudo reboot重启 安装gnome桌面\npacman -S gnome gnome-extra gdm#(gdb是登陆管理器) systemctl enable gdm.service reboot 开启字体渲染引擎\nvim /etc/profile.d/freetype2.sh 去掉 #export FREETYPE_PROPERTIES=\u0026quot;truetype:interpreter-version=40\u0026quot; 的 # 号\n清空无用缓存和语言\npacman -Scc （四）安装AUR包软件管理 git clone https://aur.archlinux.org/paru.git 打包工具\nsudo vim /etc/makepkg.conf 取消注释#MAKEFLAGS=\u0026quot;-j$(nproc)\u0026quot;\nmakepkg -si 此时paru已经被安装了\n修改paru排序的相关性，倒序\nvim /etc/paru.conf # 取消注释#BottomUp （五）Arch Linux Gnome桌面环境管理extensions Gnome桌面管理extensions是内置的，但主题较少，在archwiki可以用-theme搜索到想要的主题 然后用：\nsudo pacman -S 主题名 （六）Gnome应用启动器 要使用Gnome启动器要先安装connector,此文件在AUR里，所以要使用paru安装 https://extensions.gnome.org\nparu chrome-gnome-shell 安装dash to dock blur my shell\nArcMenu\nVitals\nJust Perfection\n（七）输入法安装 fcitx5\nsudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-material-color 环境变量与故障处理,wps和firefox无法正确输入 编辑~/.pam_environment\nGTK_IM_MODULE DEFAULT=fcitx QT_IM_MODULE DEFAULT=fcitx XMODIFIERS DEFAULT=@im=fcitx 主题安装\nsudo pacman -S fcitx5-nord 输入法联想与准确度\nfcitx5-config-qt配置工具选择Input Method下Pinyin,选择Enable Cloud Pinyin，字库(Cloud Pinyin)来自Baidu。 离线字库Dictionaries 加入清华的源需要编辑/etc/pacman.conf [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 更新数据库\nsudo pacman -Syy 安装拼音联想词库\nsudo pacman -S archlinuxcn-keyring fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki 键盘布局配置 编辑：\n/etc/vconsole.conf KEYMAP=de-latin1 ","date":"2021-12-24T19:34:05+08:00","permalink":"https://okokfun.github.io/post/c++/arch%E5%AE%89%E8%A3%85/","title":"Arch安装"},{"content":" C++线程池 任务类 #pragma once #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; // 定义任务结构体 using callback = void (*)(void *); struct Task { Task() { this-\u0026gt;function = nullptr; this-\u0026gt;arg = nullptr; } Task(callback f, void *arg) { this-\u0026gt;function = f; this-\u0026gt;arg = arg; } callback function; void *arg; }; class TaskQueue { public: TaskQueue(); ~TaskQueue(); // 添加任务 void addTask(Task task); void addTask(callback f, void *arg); // 取出一个任务 Task getTask(); // 判断队列任务是否为空 inline bool empty() { return m_taskQ.empty(); } // 当前任务个数 inline int gettaskNumber() { return m_taskQ.size(); } private: std::queue\u0026lt;Task\u0026gt; m_taskQ; std::mutex m_mutex; }; #include \u0026#34;TaskQueue.h\u0026#34; #include \u0026lt;mutex\u0026gt; void TaskQueue::addTask(Task task) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); m_taskQ.push(task); } void TaskQueue::addTask(callback f, void *arg) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); m_taskQ.push(Task(f, arg)); } Task TaskQueue::getTask() { Task task; if (!m_taskQ.empty()) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); task = m_taskQ.front(); m_taskQ.pop(); } return task; } TaskQueue::TaskQueue() {} TaskQueue::~TaskQueue() {} 线程池类 #pragma once #include \u0026#34;TaskQueue.h\u0026#34; #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; class ThreadPool { public: // 创建线程池并初始化 ThreadPool(int min, int max); // 给线程池添加任务 void addTask(Task task); // 获取线程池中工作的线程的个数 int getBusyNumber(); // 获取线程池中活着的线程的个数 int getAliveNumber(); // static ThreadPool *instance(); // static ThreadPool \u0026amp;Instance(); // 销毁线程池 ~ThreadPool(); ThreadPool(); private: ////////////////////// // 工作的线程(消费者线程)任务函数 static void *worker(void *arg); // 管理者线程任务函数 static void *manager(void *arg); private: // 任务队列 TaskQueue *taskQ; int minNum; // 最小线程数量 int maxNum; // 最大线程数量 int busyNum; // 忙的线程的个数 int liveNum; // 存活的线程的个数 std::atomic_int exitNum; // 要销毁的线程个数 std::condition_variable m_notEmpty; std::mutex m_mutex; static const int NUMBER = 2; int shutdown; // 是不是要销毁线程池, 销毁为1, 不销毁为0 }; #include \u0026#34;ThreadPool.h\u0026#34; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // 创建线程池并初始化 ThreadPool::ThreadPool(int min, int max) { do { taskQ = new TaskQueue; if (nullptr == taskQ) { std::cout \u0026lt;\u0026lt; \u0026#34;malloc taskQ fail...\u0026#34; \u0026lt;\u0026lt; std::endl; break; } minNum = min; maxNum = max; busyNum = 0; liveNum = min; // 和最小个数相等 exitNum = 0; shutdown = false; // 管理者线程 std::thread manager_thread(manager, this); std::cout \u0026lt;\u0026lt; \u0026#34;manager_thread created id: \u0026#34; \u0026lt;\u0026lt; manager_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; manager_thread.detach(); // 工作者线程 for (int i = 0; i \u0026lt; min; ++i) { std::thread worker_thread(worker, this); std::cout \u0026lt;\u0026lt; \u0026#34;worker_thread created \u0026#34; \u0026lt;\u0026lt; worker_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker_thread.detach(); } return; } while (0); // 释放资源 if (taskQ) { delete taskQ; taskQ = nullptr; } } ThreadPool::~ThreadPool() { // 关闭线程池 shutdown = true; // 唤醒阻塞的线程 for (int i = 0; i \u0026lt; liveNum; ++i) { m_notEmpty.notify_all(); } // 释放堆内存 if (taskQ) { delete taskQ; taskQ = nullptr; } } void ThreadPool::addTask(Task task) { if (shutdown) { return; } // 添加任务 taskQ-\u0026gt;addTask(task); // 唤醒一个工作者线程 m_notEmpty.notify_one(); } int ThreadPool::getBusyNumber() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); int busyNum_1 = this-\u0026gt;busyNum; return busyNum_1; } int ThreadPool::getAliveNumber() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(m_mutex); int aliveNum = this-\u0026gt;liveNum; return aliveNum; } void *ThreadPool::worker(void *arg) { ThreadPool *pool = static_cast\u0026lt;ThreadPool *\u0026gt;(arg); while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(pool-\u0026gt;m_mutex); // 当前任务队列是否为空 if (pool-\u0026gt;taskQ-\u0026gt;gettaskNumber() == 0 \u0026amp;\u0026amp; !pool-\u0026gt;shutdown) { // 阻塞工作线程 pool-\u0026gt;m_notEmpty.wait(lk, [\u0026amp;] { return pool-\u0026gt;exitNum || pool-\u0026gt;shutdown || !pool-\u0026gt;taskQ-\u0026gt;empty(); }); } lk.unlock(); // 判断线程池是否被关闭了 if (pool-\u0026gt;shutdown || pool-\u0026gt;exitNum \u0026gt; 0) { pool-\u0026gt;exitNum--; std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; exiting...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; break; } // 从任务队列中取出一个任务 auto task = std::move(pool-\u0026gt;taskQ-\u0026gt;getTask()); // 解锁 lk.lock(); pool-\u0026gt;busyNum++; lk.unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; start working...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 消费任务 task.function(task.arg); delete task.arg; task.arg = nullptr; lk.lock(); pool-\u0026gt;busyNum--; lk.unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; end working...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return nullptr; } void *ThreadPool::manager(void *arg) { ThreadPool *pool = static_cast\u0026lt;ThreadPool *\u0026gt;(arg); while (!pool-\u0026gt;shutdown) { // 每隔3s检测一次 std::this_thread::sleep_for(std::chrono::seconds(1)); std::unique_lock\u0026lt;std::mutex\u0026gt; lk(pool-\u0026gt;m_mutex); // 取出线程池中任务的数量和当前线程的数量 int queueSize = pool-\u0026gt;taskQ-\u0026gt;gettaskNumber(); // 取出忙的线程的数量 int busyNum = pool-\u0026gt;busyNum; int liveNum = pool-\u0026gt;liveNum; lk.unlock(); // 添加线程 // 任务的个数\u0026gt;存活的线程个数 \u0026amp;\u0026amp; 存活的线程数\u0026lt;最大线程数 if (queueSize \u0026gt; liveNum \u0026amp;\u0026amp; liveNum \u0026lt; pool-\u0026gt;maxNum) { lk.lock(); int counter = 0; for (int i = 0; i \u0026lt; pool-\u0026gt;maxNum \u0026amp;\u0026amp; counter \u0026lt; NUMBER \u0026amp;\u0026amp; pool-\u0026gt;liveNum \u0026lt; pool-\u0026gt;maxNum; ++i) { std::thread worker_thread(worker, pool); std::cout \u0026lt;\u0026lt; \u0026#34;worker_thread created \u0026#34; \u0026lt;\u0026lt; worker_thread.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; worker_thread.detach(); pool-\u0026gt;liveNum++; counter++; } lk.unlock(); } // 销毁线程 // 忙的线程*2 \u0026lt; 存活的线程数 \u0026amp;\u0026amp; 存活的线程\u0026gt;最小线程数 if (busyNum * 2 \u0026lt; liveNum \u0026amp;\u0026amp; liveNum \u0026gt; pool-\u0026gt;minNum) { pool-\u0026gt;exitNum = NUMBER; // 让工作的线程自杀 for (int i = 0; i \u0026lt; NUMBER; ++i) { pool-\u0026gt;m_notEmpty.notify_one(); } } } std::cout \u0026lt;\u0026lt; \u0026#34;manager_thread exiting...\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return nullptr; } 测试 /************************************************************************* \u0026gt; File Name: main.cpp \u0026gt; Author: txt1994 \u0026gt; Mail: txt1994s@163.com \u0026gt; Created Time: Mon 08 Nov 2021 05:58:32 PM CST ************************************************************************/ #include \u0026#34;ThreadPool.h\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;utility\u0026gt; void taskFunc(void *arg) { int num = *(int *)arg; std::cout \u0026lt;\u0026lt; \u0026#34;thread id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; number = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::this_thread::sleep_for(std::chrono::seconds(1)); } int main(void) { // 初始化线程池 ThreadPool *pool = new ThreadPool(4, 10); for (int i = 0; i \u0026lt; 100; ++i) { int *num = new int; *num = i + 100; Task task; task.arg = num; task.function = taskFunc; pool-\u0026gt;addTask(task); } std::this_thread::sleep_for(std::chrono::seconds(30)); delete pool; return 0; } ","date":"2021-12-24T17:01:29+08:00","permalink":"https://okokfun.github.io/post/c++/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"C++线程池"}]