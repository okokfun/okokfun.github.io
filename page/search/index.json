[{"content":" 文件下载链接 https://github.com/txt1994/keil_plugs 本人收集的Keil插件，当然也可用于其他软件\n1.AStyle 下载链接:\nhttps://sourceforge.net/projects/astyle/files 1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令： -n !E --style=google -s4 对多个文件格式化，但需要在同一个文件夹，命令：\n-n \u0026#34;$E*.c\u0026#34; \u0026#34;$E*.h\u0026#34; --style=google -p -s4 -S -f -xW -w -xw -R 2.FileComments 2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令： !E 3.DateTime 3.1 DateTime可以识别当前日期和时间，用的不多，命令： 当前日期：\n!E ~E ^E 当前时间：\n!E ~E ^E T 4.FunctionComment 4.1 FunctionComment可以提供函数快速添加注释，命令： !E ~E 把这些插件添加到keil中，打开keil，依次点击Tools-\u0026gt;Customize Tools Menu,此时页面是这样的： 把上述的插件添加进去，Command是插件路径，Arguments是使用插件时的参数，可以根据需要自行定制\n添加插件的快捷键：点击keil页面的小扳手，找到Shortcut Keys,把下拉框拉到刚才添加的插件处，右边是添加快键键的地方，添加后可以使用了\n","date":"2023-07-11T13:55:45+08:00","permalink":"https://okokfun.github.io/post/keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/","title":"适用于Keil的插件合集"},{"content":" 文章emoji支持\nnpm install hexo-filter-github-emojis --save 文章加密访问插件\nnpm install hexo-blog-encrypt --save 使用方法\n将 \u0026ldquo;password\u0026rdquo; 字段添加到您文章信息头就像这样. --- title: Hello World tags: - 作为日记加密 date: 2016-03-30 21:12:21 password: mikemessi abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. --- password下边几行可加可不加。\n编辑_config.yml 加入下列几行\n# Security encrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码, 请点击本文字. tags: - {name: tagName, password: 密码A} - {name: tagName, password: 密码B} wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 卸载对应的插件把install换为un\n","date":"2022-01-28T14:14:03+08:00","permalink":"https://okokfun.github.io/post/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/","title":"本人使用的hexo插件列表"},{"content":" 安乐死是对人最后的仁慈，让人可以有尊严和最后无痛苦的离开这个世界，当然前提是有病痛且无法医治，比如物理学家霍金的 肌萎缩性脊髓侧索硬化症（ALS）。\n","date":"2022-01-24T13:37:38+08:00","permalink":"https://okokfun.github.io/post/me/","title":"Me"},{"content":" 数据库介绍 什么是数据库?\n​\t数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.\n​\t举个例子来说明这个问题：每个人都有很多亲戚和朋友，为了保持与他们的联系，\n​\t我们常常用一个笔记本将他们的姓名、地址、电话等信息都记录下来，\n​\t这样要査谁的电话或地址就很方便了。\n​\t这个“通讯录”就是一个最简单的“数据库”，每个人的姓名、地址、电话等信息就是这个数据库中的“数据”。\n​\t我们可以在笔记本这个“数据库”中添加新朋友的个人信息，也可以由于某个朋友的电话变动而修改他的电话号码这个“数据”。\n​\t不过说到底，我们使用笔记本这个“数据库”还是为了能随时査到某位亲戚或朋友的地址、邮编或电话号码这些“数据”。\n数据库是干什么用的?\n存储和管理数据,便于程序开发.\noracle简介:\nOracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。\nOracle公司成立与1977年，总部位于美国加州；\nOracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。\nOracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。\n2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。\n2008年1月16日 sun公司收购了mysql 。\n2009年4月20日 oracle收购了sun 。\n常见的数据库有哪些？\noracle公司的oracle数据库\nIBM公司的DB2数据库\nInformix公司的Informix数据库\nsysbase公司的sysbase数据库\nMicrosoft公司的SQL Server\noracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）\nMongoDB数据库\nMariadb数据库 (由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发,MariaDB名称来自Michael Widenius的女儿Maria的名字)\nSQLite (设计目标是嵌入式)\n1 Oracle的体系结构 Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。\n1.1 表空间和数据文件 逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。\n物理概念：数据文件，在磁盘上（/home/oracle_11/app/oradata/orcl目录中的.DBF文件）；\n​ 一个表空间包含一个或者多个数据文件。\n1.2 段、区、块 段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。\n图请看讲义部分。\n1.3 DBA 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。从时间开销上看：安装占用6%，创建和配置占用12%，装载和存档数据占6%, 软件维护占6%，管理数据库系统占55%，可见，管理数据库系统占用了大部分的时间开销。\n1.4 如何启动数据库服务 Windows启动oracle数据库服务：\n启动服务：services.msc，找到下列两个服务，并启动。\nOracleServiceORCL： oracle数据库服务系统\nhome1TNSListene： 监听服务，用于远程连接的侦听\n注意：若把数据库默认设置为自启动，则开机时间会延长。\nLinux启动oracle数据库服务步骤(oracle数据库系统安装到linux系统上)\n​\t1. 执行sqlplus / as sysdba或sqlplus sys/sys as sysdba进入到命令行界面\n​\t2. 执行startup启动数据库服务\n​\t3. 执行exit退出sqlplus命令行界面\n​\t4. 执行lsnrctl start启动监听服务\n注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。\n1.5 如何登陆数据库服务 在本机登陆：\n普通用户身份登陆\nsqlplus ↙ 用户名 ↙\t密码 ↙\nsqlplus 用户名/密码，如sqlplus scott/tiger\n以管理员身份登陆 sqlplus / as sysdba（此处不用输入密码，在安装的时候已经输入密码） sqlplus sys/sys as sysdba 通过网络使用客户端远程登陆 远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。\n注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。\nD:\\oracle\\app\\HGUANG\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora，下面是经过Net Manager进行配置后得到的一个文件内容：\n客户端安装完成之后进行远程登陆之前最好先进行测试：\n首先测试网络是否是通的： ping IP ， 然后tnsping IP 或者 tnsping oracle_orcl。\n普通用户登陆\nsqlplus 用户名/密码@连接字符串，如sqlplus scott/tiger@oracle_orcl\n管理员用户登陆\nsqlplus sys/sys@oracle_orcl as sysdba 此外：还可以执行： sqlplus scott/tiger@//IP地址/实例名 进行登陆。\n使用scott用户或者sys用户登陆完之后，可以使用show user测试一下，如果显示用户名就表明已经登陆成功了，或者是执行select * from tab;进行一次查询, 有结果显示就表名已经登陆成功了.\n解锁用户：alter user scott account unlock (管理员身份登陆，给scott用户解锁。用户默认锁定)\n锁定用户：alter user scott account lock，（必须用管理员用户登陆）\n修改用户密码：alter user scott identified by 新密码 (管理员身份登陆，给scott用户修改密码)\n查看当前语言环境：select userenv('language') from dual;\n1.6 贯穿这门课程的方案 请看oracle讲义。\nscott用户的emp表, dept表和salgrade表.\n2基本的SQL select语句 2.1 sqlplus的基本操作 显示当前用户： show user;\n查看当前用户下的表：select * from tab;\n​\ttab:\t数据字典（记录数据库和应用程序源数据的目录），包含当前用户下的表。\n查看员工表的结构：desc emp;\n设置行宽：set linesize 120;\n设置页面：set pagesize 100;\n​\t或者将上述两行写入如下两个配置文件，可永久设置：\nC:\\app\\Administrator\\product\\11.2.0\\client_1\\sqlplus\\admin\\glogin.sql\nC:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\sqlplus\\admin\\glogin.sql\n设置员工名列宽：col ename for a20\t(a表示字符串)\n设置薪水列为4位数子：col sal for 9999\t(一个9表示一位数字)\n2.2 基本的select语句 Select语句的整体形式：\nSELECT col1, col2… FROM table_name WHERE condition GROUP BY col… HAVING condtion ORDER BY col… 其语法格式为：\nSELECT *|{[DISTINCT] *column|*expression [*alias],\u0026hellip;} FROM *table;\n案例\n1查询所有员工的所有记录\nSELECT * FROM emp; SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno FROM emp; 说明：尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)\n2 查询员工号、姓名、薪水\nSELECT empno, ename, sal FROM emp; 3 查询员工号、姓名、薪水和年薪\nSELECT empno, ename, sal, sal*12 FROM emp; 说明：select语句中可以使用表达式\n注意：在执行sql语句的时候，执行 / 会执行上一次执行的语句。\n若在写sql语句的时候, 写错了, 可以使用c（change）命令来修改. 默认, 光标闪烁位置指向上一条SQL语句的第一行。输入 2 则定位到第二行。\nc /错误关键字/正确关键字 ↙\n使用“/”来执行修改过的SQL语句\n例如：错误输入:\n`select empno, ename, sal, sal * 12\n​\tform emp`; （“from”书写错误，该错误位于整条SQL语句的第二行）\n（1） 输入：2↙ 终端提示：2* from emp\n（2） 输入：c /form/from ↙\t终端提示：2* from emp (意为改正后的sql语句样子)\n（3） 输入：/↙\n也可以使用ed(或者edit)命令来修改\ned ↙弹出系统默认的文本编辑器，(如记事本)\n修改、保存、退出、执行“/”。\n使用edit打开文件编辑sql语句:\n如果sql语句很长, 可以分行编写或者用ed命令打开一个文件,\n然后在文件中编写sql语句, 注意, sql语句末尾不要加; , 然后换行加上/表示结束.\n若想将显示结果保存到文件中:\nspool命令:\nspool d:\\result.txt; select * from emp; spool off; 使用别名：\n别名：as\n案例：查询员工号，姓名，月薪，年薪\nSELECT empno AS \u0026#34;员工号\u0026#34;, ename \u0026#34;姓名\u0026#34;, sal 月薪, sal*12 年薪 FROM emp; 说明：关键字as写与不写没有区别； \u0026ldquo;\u0026ldquo;有与没有取决于别名中是否有空格，建议在用别名的时候加上\u0026rdquo;\u0026quot;。\nDISTINCT\u0026mdash;à重复记录只取一次\n案例：\nSELECT deptno FROM emp; SELECT DISTINCT deptno FROM emp; SELECT job FROM emp; SELECT DISTINCT job FROM emp; SELECT DISTINCT deptno, job FROM emp; 说明: DISTINCT的作用范围不是距离它最近的列, 而是后面的所有的列。\n2.3 SQL语句使用注意事项 SQL 语言大小写不敏感。\nsql语句对关键字的大小写不敏感, 如SELECT和select一样, 但是对于内容敏感。\nSQL可以写在一行或者多行\n关键字不能被缩写也不能分行\n各子句一般要分行写。\n使用缩进提高语句的可读性\n2.4 算数运算 + - * / 乘除的优先级高于加减\n优先级相同时, 按照从左至右运算\n可以使用括号改变优先级\n查询: 员工号、姓名、月薪、年薪、奖金、年收入。\nSELECT deptno, ename, sal, sal*12, comm, comm+sal*12 FROM emp; ​\t结果不正确, 没有奖金的员工, 年收入不正确。\n说明： 在程序开发过程中, 数据是核心. 程序再正确也没有用, 必须保证数据不能丢, 且正确, 对于上面的结果, 有对有错的情况是最危险的.\n解决这个问题需要正确认识NULL值。\n2.5 NULL值 NULL值问题：\n包含NULL值的表达式都为空.\nNULL不等于NULL\nselect * from emp where NULL=NULL; 查不到任何记录。\n解决：滤空函数：nvl(a, b) 如果a为NULL，返回b；\n所以：使用sal * 12 + nvl(comm, 0) 表示年收入。\n在SQL中, 判断一值是否等于NULL不用“=” 和“!=”而使用is和is not 查询奖金为NULL的员工信息：\nselect * from emp where comm = NULL; (SQL中不使用==)\n​\t应该使用：select * from emp where comm is NULL;\n查询奖金不为NULL的员工信息：\nselect * from emp where comm is not NULL;\n总结: 空值是无效的, 未指定的, 未知的或不可预知的值, 空值不是空格或者0.\n2.6 连接符 ​\t在oracle中使用 || 连接字符串\n例如：\nSELECT ename || \u0026#39; is a \u0026#39; || job FROM emp; 若要显示hello world字符串应该怎么办呢?\noracle中语法规定：select后面必须接from关键字，所有需要有一个表名用来满足oracle的SQL99语法规定，为此定义了一个伪表dual。\nSELECT concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;) FROM dual; 若要连接三个字符串呢？\nSELECT concat(concat(\u0026#39;hello \u0026#39;, \u0026#39;world\u0026#39;), \u0026#39; i love you\u0026#39;) FROM dual; 注意：concat函数只支持两个参数，不支持三个参数形式。\n​\t也可以使用||连接三个以上的字符串：\nSELECT \u0026#39;hello \u0026#39; || \u0026#39;world \u0026#39; || \u0026#39;i love you\u0026#39; FROM dual; 说明：使用||比concat函数要灵活，其实||就是用来替换concat函数的。\n2.7 SQL和sqlplus 我们已经学习使用了select，应该知道还有update、delete、insert、create…\n同时，我们学习了ed、c、set、col、desc….\nSQL是语言，关键字不能缩写。\nsqlplus是oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。\nSQL\n一种语言\nANSI 标准\n关键字不能缩写\n使用语句控制数据库中的表的定义信息和表中的数据\nSQL*Plus\n一种环境\nOracle 的特性之一\n关键字可以缩写\n命令不能改变数据库中的数据的值\n集中运行\n3 过滤和排序数据 3.1 where条件过滤 在where条件中使用的列的值对大小写是敏感的, 如是字符串需要用单引号引起来, 如KING和king是不同的字符串。\n如select * from emp where ename= 'KiNg '；未选定行\nselect * from emp where ename= 'KING '； 正确\n说明： 对于列的值来说，大小写是敏感的。\n​ [未选定行]不是发生了错误，而是查不到记录。\n3.1.1 日期格式 查询入职日期为1981年11月17日的员工\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 会报错，ORA-01861: 文字与格式字符串不匹配。\n首先查询一下emp使用的日期格式：\nSELECT * FROM emp; 使用sysdate函数获取当前系统的日期：\nSELECT sysdate FROM dual; 查询得出格式为： DD-MON-RR\n应该使用当前系统指定的日期格式来查询：\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 如何获取当前系统的日期格式?\nSELECT * FROM v$nls_parameters; 若格式不太好看，可以执行col parameter for a30设置列的宽度。\n如何修改日期格式?\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd \u0026#39;; 查看修改结果：\nSELECT * FROM v$nls_parameters; 验证：再次查询emp表：\nSELECT * FROM emp WHERE hiredate= \u0026#39;1981-11-17 \u0026#39;; 修改日期格式到秒\nalter session SET NLS_DATE_FORMAT = \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;; 执行select sysdate from dual;验证修改结果.\n将日期格式改回默认设置\nalter session SET NLS_DATE_FORMAT = \u0026#39;DD-MON-RR\u0026#39;; 说明:\n字符和日期要包含在单引号中。\n字符大小写敏感, 日期格式敏感。\n默认的日期格式是DD-MON-RR\n3.1.2 比较运算 l 普通比较运算符：\n= 等于(不是==)\t\u0026gt; 大于\n\u0026gt;= 大于等于\t\u0026lt; 小于\n\u0026lt;= 小于等于\t\u0026lt;\u0026gt;\t不等于(也可以是!=)\n案例:\n1 查询薪水不等于1250的员工信息\nSELECT * FROM emp WHERE sal \u0026lt;\u0026gt; 1250; SELECT * FROM emp WHERE sal != 1250; between…and:介于两值之间,闭区间,包含两边的值.\n案例:\n查询工资在1000-2000之间的员工：\nSELECT * FROM emp WHERE sal \u0026gt;=1000 AND sal\u0026lt;=2000; SELECT * FROM emp WHERE sal BETWEEN 1000 AND 2000; ​\t注意：1.包含边界 2. 小值在前，大值在后。 (对于日期也是如此)\n2 查询81年2月至82年2月(不含2月)入职的员工信息：\nSELECT * FROM emp WHERE hiredate BETWEEN \u0026#39;1-2月-81\u0026#39; AND \u0026#39;30-1月-82\u0026#39;; in：在集合中, not in 不在集合中\n案例\n查询部门号为10和20的员工信息： SELECT * FROM emp WHERE deptno=10 OR deptno=20; SELECT * FROM emp WHERE deptno IN (10, 20); 查询部门号不是10和20的员工(除了10和20以外的部门) SELECT * FROM emp WHERE deptno NOT IN (10, 20); 使用比较运算符该怎么写呢？\rSELECT * FROM emp WHERE deptno!=10 AND deptno!=20; 如果是 ….. not in (10, 20, NULL) 可不可以呢?\n☆NULL空值:如果结果中含有NULL,不能使用not in 操作符,但可以使用in操作符。\r课后思考为什么???\r因为: not in (10, 20, NULL)相当于:\ndeptno!=10 and deptno!=20 and deptno!=NULL包含NULL的表达式都为空.\nlike：模糊查询\n%匹配任意多个字符, _匹配一个字符, 使用escape表示转义字符\n案例:\n查询名字以S开头的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;S% \u0026#39;; (注意：S小写、大写不同)\n查询名字是4个字的员工\nSELECT * FROM emp WHERE ename LIKE \u0026#39;_ _ _ _\u0026#39;; 增加测试例子：向表中插入员工：\ninsert into emp(empno, ename, sal, deptno) values(1001, \u0026#39; TOM_ABC \u0026#39;, 3000, 10); 查询名字中包含_的员工：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;% _ % \u0026#39;; 查不到记录.\n转义字符：\nSELECT * FROM emp WHERE ename LIKE \u0026#39;%\\_% \u0026#39; escape \u0026#39;\\\u0026#39;; 转义单引号本身使用两个单引号来完成转义\nSELECT \u0026#39;hello \u0026#39;\u0026#39; world\u0026#39; FROM dual; 3.1.3 逻辑运算 逻辑运算符\nAND\t逻辑并\nOR 逻辑或\nNOT\t逻辑非\n如果…..where 表达式1 and/or 表达式2;\n…..where 表达式2 and/or 表达式1;\t这两句SQL语句功能一样吗？效率一样吗？\n※SQL优化：\nSQL在解析where的时候，是从右至左解析的。\n所以： and时应该将易假的值放在右侧;\nor时应该将易真的值放在右侧.\r这样的话可以提高效率.\n案例:\n查询部门为30且工种为SALESMAN的员工 SELECT * FROM emp WHERE deptno=30 AND job=\u0026#39;SALESMAN\u0026#39;; 查询部门为10或者工资大于2000的员工 SELECT * FROM emp WHERE deptno=10 OR sal\u0026gt;2000; 查询工种不是MANAGER或者PRISIDENT的员工 SELECT * FROM emp WHERE job!=\u0026#39;MANAGER\u0026#39; AND job!=\u0026#39;PRISIDENT\u0026#39;; SELECT * FROM emp WHERE job NOT IN (\u0026#39;MANAGER\u0026#39;, \u0026#39;PRESIDENT\u0026#39;); 3.1.4 order by 排序 使用 ORDER BY 子句排序\nASC（ascend）: 升序。默认采用升序方式。\nDESC（descend）: 降序\nORDER BY子句在SELECT语句的最末尾, 是对select查询的最后的结果进行排序.\n案例:\n查询emp表, 按照入职日期先后排序 SELECT * FROM emp ORDER BY hiredate; 查询员工信息, 按月薪排序 SELECT * FROM emp ORDER BY sal; # ---从小到大排序, 默认方式.\tSELECT * FROM emp ORDER BY sal desc; # ---从大到小排序 order by 之后可以跟那些内容呢？\norder by + 列名, 序号, 表达式, 别名,\n注意：语法要求order by子句应放在select的结尾。\n案例:\n查询员工信息, 按月薪排序\u0026mdash;-à使用列名排序的情况 SELECT * FROM emp ORDER BY sal; 按照工资进行排序\u0026ndash;à使用序号进行排序的情况 SELECT ename, sal, sal*12, FROM emp ORDER BY 2 desc; 序号: 按照select后面列名出现的先后顺序, ename→1, sal→2, sal*12→3\n按照员工的年薪进行排序\u0026mdash;-à使用表达式排序的情况 SELECT ename, sal, sal*12 FROM emp ORDER BY sal * 12 desc; 按照员工的年薪进行排序\u0026mdash;-à使用别名进行排序的情况 SELECT ename, sal, sal*12 \u0026#34;年薪\u0026#34; FROM emp ORDER BY \u0026#34;年薪\u0026#34; desc; 按照两列或者多列进行排序\n案例:\n按照部门和工资进行排序 SELECT * FROM emp ORDER BY deptno, sal; order by后有多列时, 列名之间用逗号隔分, order by会同时作用于多列。上例的运行结果会在同一部门内升序, 部门间再升序。\nSELECT * FROM emp ORDER BY deptno, sal desc; 注意: desc只作用于最近的一列, 两列都要降序排, 则需要两个desc。即：\nSELECT * FROM emp ORDER BY deptno desc, sal desc; 查询员工信息, 按奖金由高到低排序： SELECT * FROM emp ORDER BY comm desc; 结果前面的值为NULL, 数据在后面, 如果是一个100页的报表，这样显示肯定不\n正确。较为人性化的显示应该将空值放在最后, 即：\nSELECT * FROM emp ORDER BY comm DESC nulls last; (注意：是 nulls 而不是null)\n排序的规则\n可以按照select语句中的列名排序\n可以按照别名排序\n可以按照表达式排序,如order by sal*12+nvl(comm, 0)\n可以按照select语句中的列名的顺序值(序号)排序\n如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推\ndesc和asc只作用于最近的一列.\n4 单行函数 单行函数:只对一行进行变换, 产生一个结果。函数可以没有参数, 但必须要有返回值。如：concat、nvl\n操作数据对象\n接受参数返回一个结果\n只对一行进行变换\n每行返回一个结果\n可以转换数据类型\n可以嵌套\n参数可以是一列或一个值\n4.1 字符函数 操作对象是字符串。\n大致可分为两大类: 一类是大小写控制函数, 主要有lower、upper、initcap:\n案例:\n大小写转换lower和upper, 首字母大写initcap函数测试\nSELECT lower(\u0026#39;HeLlo, WORld\u0026#39;) 转小写, upper(\u0026#39;HellO, woRld\u0026#39;) 转大写, initcap(\u0026#39;hello, world\u0026#39;) 首字母大写 FROM dual; 另一类是字符控制函数: 有CONCAT、SUBSTR、LENGTH/LENGTHB、INSTR、LPAD | RPAD、TRIM、REPLACE\nsubstr(a, b)：在字符串a中，从第b位开始取(计数从1开始)，取到结尾\n案例:\n从helloworld字符串中的第3位开始后面的所有字符\nselect substr('helloworld', 3) from dual; \u0026mdash;à得到lloworld\nsubstr(a, b, c)：从a中，第b位开始，向右取c位。\n案例:\n从hello world字符串中, 从第3位开始取连续取5个字符\nSELECT substr(\u0026#39;helloworld\u0026#39;, 3, 5) FROM dual; length:字符数, lengthb:字节数：\n案例:\nSELECT length(\u0026#39;hello world\u0026#39;) 字符数, lengthb(\u0026#39;hello world\u0026#39;) 字节数 FROM dual; SELECT length(\u0026#39;哈喽我的\u0026#39;) 字符数, lengthb(\u0026#39;哈喽我的\u0026#39;) 字节数 FROM dual; 注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,\n这两个函数对于普通字符串没有什么区别.\ninstr: 在母串中查找子串, 找到返回下标, 计数从1开始, 没有返回0\n案例\n查找hello world字符串中, llo子串首次出现的下标位置\nSELECT instr(\u0026#39;hello world\u0026#39;, \u0026#39;llo\u0026#39;), instr(\u0026#39;hello world\u0026#39;, \u0026#39;www\u0026#39;) FROM dual; 注意: 下标是从1开始的.\nlpad：左填充，\n参1: 待填充的字符串，\n参2: 填充后字符串的总长度(字节)，\n参3: 填充什么\nrpad: 右填充, 参数同lpad.\n案例\nselect lpad('abcd', 10, '*') 左, rpad('abcd', 10, '#') 右 from dual; 结果显示: ******abcd abcd######\nselect lpad('abcd', 15, '你')左填充, rpad('abcd', 16, '我') 右填充 from dual; 结果显示: 你你你你你abcd abcd我我我我我我\n注意: lpad(\u0026lsquo;abcd\u0026rsquo;, 15, \u0026lsquo;你\u0026rsquo;)由于abcd本身占4个字节, 需要填充11个字节才能\n够15个字节, 但是一个汉字占两个字节, 所以填充了1个空格+5个汉字.\ntrim:去掉前后指定的字符(不去掉中间的)\n案例\n去掉\u0026rsquo; hello world \u0026lsquo;两端的空格\nSELECT trim(\u0026#39; hello world \u0026#39;) FROM dual; 去掉Hello worldH字符串前后的H字符\nSELECT trim(\u0026#39;H\u0026#39; FROM \u0026#39;Hello worldH\u0026#39;) FROM dual; replace:替换\n案例\n将hello world字符串中的l替换成*\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;*\u0026#39;) FROM dual; 删除字符串\u0026rsquo;hello world\u0026rsquo;中的字符\u0026rsquo;l\u0026rsquo;\nSELECT replace(\u0026#39;hello world\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;\u0026#39;) FROM dual; 4.2 数值函数 ROUND: 四舍五入\nROUND(45.926, 2)\t45.93\nTRUNC:\t截断\nTRUNC(45.926, 2)\t45.92\nMOD: 求余\nMOD(1600, 300)\t100\n案例: round(45.926, 2) :2表达的含义是小数点向右保留两位并四舍五入，第二个参数如果是0可以省略.\nSELECT round(45.926, 2), round(45.926, 1), round(45.926, 0) , round(45.926), round(45.926, -1) , round(45.926, -2) FROM dual; trunc函数, 正数表示小数点之后, 负数表示小数点之前的位数, 0可以不写. SELECT trunc(45.926, 2), trunc(45.926, 1), trunc(45.926, 0), trunc(45.926), trunc(45.926, -1) , trunc(45.926, -2) FROM dual; mod函数: 求余数 select mod(1600, 600) from dual; \u0026ndash;à结果为100\nceil函数:向上取整 floor函数:向下取整\nselect ceil(19.23), floor(19.23) from dual;\n4.3 时间函数 在Oracle中日期型的数据，既有日期部分，也有时间部分.\n案例:\nselect sysdate from dual; 这里没有时间部分，因为系统默认的格式中不显示时间\nselect to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual; 显示日期到秒\nselect to_char(sysdate, 'day') from dual ; 可以显示当前日期星期几\n日期加、减数字得到的结果仍为日期。单位：天\n显示 昨天、今天、明天\nSELECT (sysdate-1) 昨天, (sysdate) 今天, (sysdate + 1) 明天 FROM dual; SELECT to_char(sysdate-1, \u0026#39;yyyy-mm-dd\u0026#39;) 昨天, to_char(sysdate, \u0026#39;yyyy-mm-dd\u0026#39;) 今天, to_char(sysdate+1, \u0026#39;yyyy-mm-dd\u0026#39;) 明天 FROM dual; à转换日期格式; 既然一个日期型的数据加上或者减去一个数字得到的结果仍为日期，两个日期相减，得到的就是相差的天数。\n计算员工的工龄, 显示从入职以来的总天数, 星期数, 总月数, 总年数\nSELECT ename, hiredate, (sysdate - hiredate) 天, (sysdate - hiredate)/7 星期, (sysdate - hiredate)/30 月, (sysdate - hiredate)/365 年 FROM emp; 日期和日期可以相减表示相隔多少天, 但是不允许相加, 两个日期相加没有意义, 日期只能和数字相加\u0026mdash;-à类似于两个指针相加没有意义一样.\n​\tselect sysdate+hiredate from emp; 报错: ORA-00975: 不允许日期 + 日期\n4.4 日期函数 上面求取员工工龄的结果不精确，如果想将其算准确，可以使用日期函数来做。\nmonths_between\n两个日期值相差的月数(精确值)\nSELECT ename, hiredate, (sysdate-hiredate)/30 一, months_between(sysdate, hiredate) 二 FROM emp; months_between函数更精确, 在表示月份差的时候要使用months_between函数.\nadd_months\n在某个日期值上，加上多少的月，正数向后计算，负数向前计算。\n计算95个月以后是哪年、哪月、那天：\nselect add_months(sysdate, 95) 哪一天 from dual;\n结果是: 2025/10/11\nlast_day\n日期所在月的最后一天, 要么30, 31或者28\nSELECT last_day(sysdate) FROM dual; 上个月的最后一天\nSELECT last_day(add_months(sysdate, -1)) FROM dual; 下一个月的最后一天\nSELECT last_day(add_months(sysdate, 1)) FROM dual; next_day:指定日期的下一个日期\n从当前时间算起, 下一个星期一的日期\nSELECT next_day(sysdate, \u0026#39;星期一\u0026#39;) FROM dual; 从特定日期得到之后的第一个星期几的日期\nSELECT next_day(to_date(\u0026#39;2017-11-11\u0026#39;, \u0026#39;yyyy-mm-dd\u0026#39;), \u0026#39;星期三\u0026#39;) FROM dual; round、trunc 对日期型数据进行四舍五入和截断\nSELECT round(sysdate, \u0026#39;month\u0026#39;), round(sysdate, \u0026#39;year\u0026#39;) FROM dual; SELECT trunc (sysdate, \u0026#39;month\u0026#39;), trunc(sysdate, \u0026#39;year\u0026#39;) FROM dual; 4.5 转换函数 在不同的数据类型之间完成转换, 如将\u0026quot;123\u0026quot;转换为123, 有隐式转换和显示转换之分。\n隐式转换(由oracle数据库来完成)\nSELECT * FROM emp WHERE hiredate = \u0026#39;17-11月-81\u0026#39;; 若是显示转换:\nSELECT * FROM emp WHERE to_char(hiredate, \u0026#39;DD-MON-RR\u0026#39;) = \u0026#39;17-11月-81\u0026#39;; 或者\nSELECT * FROM emp WHERE hiredate = to_date(\u0026#39;17-11月-81\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;); 显示转换(通过转换函数来完成)\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss\u0026#39;) FROM dual; 注意: 隐式转换，前提条件是：被转换的对象是可以转换的。（ABC→625 可以吗？）\n显示转换：借助to_char(数据，格式)、to_number、to_date函数来完成转换。\n​\n格式 说明 举例 YYYY Full year in numbers 2011 YEAR Year spelled out(年的英文全称) twenty eleven MM Two-digit value of month 月份（两位数字） 04 MONTH Full name of the month（月的全称） 4月 DY Three-letter abbreviation of the day of the week(星期几) 星期一 DAY Full name of the day of the week 星期一 DD Numeric day of the month 02 如果隐式转换和显示转换都可以使用，应该首选哪个呢？\n注意：如果隐式、显示都可以使用，应该首选显示，这样可以省去oracle的解析过程。\n练习：在屏幕上显示如下字符串：\n2015-05-11 16:17:06 今天是 星期一\nSELECT to_char(sysdate, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; 说明: 在固定的格式里加入自定义的格式，是可以的，必须要加””。\n反向操作：已知字符串'2015-05-11 15:17:06 今天是 星期一\u0026rsquo;转化成日期.\n使用to_date函数将字符串转换成date类型\nSELECT to_date(\u0026#39;2015-05-11 15:17:06 今天是 星期一\u0026#39;, \u0026#39;yyyy-mm-dd hh24:mi:ss \u0026#34;今天是\u0026#34; day\u0026#39;) FROM dual; 案例:\n查询员工的薪水: 使用2位小数, 本地货币代码, 千位符 SELECT to_char(sal, \u0026#39;L9,999.99\u0026#39;) FROM emp; 特别注意:\u0026lsquo;L9,999.99\u0026rsquo;之间没有空格\n将￥2,975.00转化成数字： SELECT to_number(\u0026#39;￥2,975.00\u0026#39;, \u0026#39;L9,999.99\u0026#39;) 转成数字 FROM dual; 4.6 通用函数(了解) 这些函数适用于任何数据类型，同时也适用于空值：\nNVL (expr1, expr2)\nNVL2 (expr1, expr2, expr3)\nNULLIF (expr1, expr2)\nCOALESCE (expr1, expr2, \u0026hellip;, exprn)\nnvl2:是nvl函数的增强版。\tnvl2(a, b, c) 当a = null 返回 c, 否则返回b\n使用nvl2求员工的年收入：\nSELECT empno, ename, sal, sal*12, sal * 12 + nvl2(comm, comm, 0) 年薪 FROM emp; nullif: nullif(a, b) 当 a = b 时返回null, 不相等的时候返回a值。\nselect nullif('hello', 'hello') from dual; 返回空\nselect nullif('hello', 'world') from dual; 返回hello\nselect ename, nullif(comm, null) from emp;\ncoalesce:coalesce(a, b, c, …, n) 从左向右找参数中第一个不为空的值。\nSELECT comm, sal, coalesce(comm, sal) 结果值 FROM emp; 4.7 条件表达式 例子：老板打算给员工涨工资, 要求：\n总裁(PRESIDENT)涨1000, 经理(MANAGER)涨800, 其他人涨400. 请将涨前, 涨后的薪水列出。\n涨后的薪水是根据job来判断的\n思路：\tif 是总裁(\u0026lsquo;PRESIDENT\u0026rsquo;) then + 1000\nelse if 是经理(\u0026#39;MANAGER\u0026#39;) then + 800 else + 400\t但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode\ncase:是一个表达式，其语法为：\nCASE *expr WHEN *comparison_expr1 THEN *return_expr1 [WHEN *comparison_expr2 THEN *return_expr2 WHEN *comparison_exprn THEN *return_exprn ELSE *else_expr] END SQL\u0026gt;SELECT ename, job, sal 涨前薪水, CASE job WHEN \u0026#39;PRESIDENT\u0026#39; THEN sal+1000 WHEN \u0026#39;MANAGER\u0026#39; THEN sal+800 ELSE sal + 400 END 涨后薪水 FROM emp; 注意语法：when then 与下一个when then以及end之间没有“,”分割符, 可以将when当成if.\ndecode：是一个函数，其语法为：\nDECODE(*col|expression, search1, result1\n[*, search2, result2,...,]\r[*, default])\r除第一个和最后一个参数之外，中间的参数都是成对呈现的 (参1, 条件, 值, 条件, 值, …, 条件, 值, 尾参)\nSELECT ename, job, sal 涨前薪水, decode(job, \u0026#39;PRESIDENT\u0026#39;, sal + 1000, \u0026#39;MANAGER\u0026#39;, sal + 800, sal + 400) AS 涨后薪水 FROM emp; 5 分组函数 5.1分组函数 多行函数也叫组函数，本章学习目标:\n了解组函数。\n描述组函数的用途。\n使用GROUP BY 子句数据分组。\n使用HAVING 子句过滤分组结果集。\n分组函数作用于一组数据，并对一组数据返回一个值\n常用的有5个函数: avg、count、max、min、sum操作的是一组数据，返回一个结果。\n案例\n求员工的工资总额 SELECT sum(sal) FROM emp; 求员工人数 SELECT count(*) FROM emp; 平均工资 SELECT sum(sal)/count(*) 方式一, avg(sal) 方式二 FROM emp; 方式一和方式二结果一样, 当有空值得时候结果有可能不一样。如：奖金。\n求员工的平均奖金 SELECT sum(comm)/count(*) 方式一, sum(comm)/count(comm) 方式二, avg(comm) 方式三 FROM emp; 结果：方式一结果不同，方式二 和 方式三结果一样。\n说明: avg(comm)是求comm有值的几个的平均值, 跟方式二是相同的.\nNULL空值：组函数都有自动滤空功能(忽略空值)，所以：\nselect count(*), count(comm) from emp; 执行结果不相同。\n说明: count(comm)返回不为空的comm的总个数\n如何屏蔽组函数的滤空功能?\nSELECT count(*), count(nvl(comm, 0)) FROM emp; 但是实际应用中, 结果为14和结果为4都有可能对，看问题本身是否要求统计空值。\n5 count函数\n求emp表的部门总个数, 如果要求不重复的个数, 使用distinct。\nSELECT count(distinct deptno) FROM emp; 求emp表中的工种的总个数\nSELECT count(distinct job) FROM emp; 5.2 分组数据 分组数据使用group by关键字.\n按照group by 后给定的表达式，将from后面的table进行分组。针对每一组，使用组函数, 即先分组, 再分组统计.\n案例\n查询“部门”的平均工资： 分析: 结合select * from emp order by deptno; 结果分析分组\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno; 上SQL语句可以抽象成：select a, 组函数(x) from 表 group by a; 这样的格式。\r如果select a, b, 组函数(x) …… group by 应该怎么写？\n注意: 在select列表中所有没有包含在组函数中的列, 都必须在group by的后面出现.所以上面的问题应该写成group by a, b; 没有b就会出错, 不会执行sql语句。但, 反之可以。group by a，b，c; c可以不出现在select语句中。\ngroup by后面有多列的情况：\n查询部门内部不同职位的平均工资: SELECT deptno, job, avg(sal) FROM emp GROUP BY deptno, job ORDER BY 1; 分析该SQL的作用：\n因为`deptno, job` 两列没有在组函数里面，所以必须同时在group by后面。\r该SQL的语义:按部门, 不同的职位统计平均工资。先按第一列分组, 如果第一列相同, 再按第二列分组, 所以查询结果中，同一部门中没有重复的职位。\n关于分组函数常见的问题:\n在select后面出现的列, 该列没有出现在分组函数中, 但是未出现在group by子句中. 如: select deptno, job, avg(sal) from emp group by deptno;\n\u0026mdash;-job未出现在group by子句中\n报错: ORA-00979: 不是 GROUP BY 表达式.\nselect count(*) from emp; 分析: count是分组函数, 但是select后面没有其他列, 所以不必非出现group by子句,\n该sql语句意思是统计emp表中员工总数;\n当然: `select count(*) from emp group by deptno; 也对, 但是查询出来的结果并不知道是\n哪个组的总数.\n5.3 Having 使用 HAVING 过滤分组:\n行已经被分组。\n使用了组函数。\n满足HAVING 子句中条件的分组将被显示。\n其语法：\nSELECT\tcolumn, group_function\nFROM\ttable\n[WHERE\tcondition]\n[GROUP BY\tgroup_by_expression]\n[HAVING\tgroup_condition]\n[ORDER BY\tcolumn];\n查询平均薪水大于2000的部门 ：\n分析：该问题实际上是在分组的基础上过滤分组。\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal)\u0026gt;2000; 注意：having后面不能使用别名, 可以使用函数\n​\n特别注意: 不能在 WHERE 子句中使用组函数.\n可以在 HAVING 子句中使用组函数。\n从功能上讲，where和having都是将满足条件的结果进行过滤。但是差别是where子句中不能使用组函数, 所以上句中的having不可以使用where代替。\r求10号部门的平均工资：\n分析：在上一条的基础上，having deptno=10;\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING deptno=10; 使用where也可以做这件事\nSELECT deptno, avg(sal) FROM emp WHERE deptno=10 GROUP BY deptno; 在子句中没有使用组函数的情况下，where、having都可以，应该怎么选择？\nSQL优化： 尽量采用where。\n如果有分组的话，where是先过滤再分组，而having是先分组再过滤。当数据量庞大如1亿条，where优势明显。\n6 多表查询 理论基础：——笛卡尔集\n笛卡尔集的行数 = table1的行数 x table2的行数\n笛卡尔集的列数 = table1的列数 + table2的列数\n在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。\n多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。\n根据连接条件的不同可以划分为：等值链接、不等值链接、外链接、自连接\nOracle 连接:\nEquijoin：等值连接\nNon-equijoin：不等值连接\nOuter join：外连接\nSelf join：自连接\nSQL: 1999\nCross joins\nNatural joins\nUsing clause\nFull or two sided outer joins\n6.1 等值连接： ​\t从概念上，区分等值连接和不等值连接非常简单，只需要辨别where子句后面的条件，是“=”为等值连接。不是“=”为不等值连接。\n查询员工信息：员工号 姓名 月薪和部门名称\n​\t分析：这个问题涉及emp(员工号，姓名，月薪) 和dept(部门名称)两张表 ——即为多表查询。\n​\t通常在进行多表查询的时，会给表起一个别名，使用“别名.列名”的方式来获取数据，直接使用“表名.列名”语法上是允许的，但是实际很少这样用。\n如果：select e.empno, e.ename, e.sal, e.deptno, d.dname, d.deptno from emp e, dept d; 直接得到的是笛卡尔全集。其中有错误结果。所以应该加 where 条件进行过滤.\nSELECT e.empno, e.ename, e.sal, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno; 如果有N个表，where后面的条件至少应该有N-1个, 才会不产生笛卡尔积.\n6.2 不等值连接： 将上面的问题稍微调整下，查询员工信息：员工号 姓名 月薪 和 薪水级别(salgrade表)\nSELECT * FROM salgrade; 看到员工总的薪水级别，共有5级，员工的薪水级别应该满足 \u0026gt;=当前级别的下限，\u0026lt;=该级别的上限：\n过滤子句应该：\twhere e.sal \u0026gt;= s.losal and e.sal \u0026lt;= s.hisal;\nSELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal \u0026gt;= s.losal AND e.sal \u0026lt;= s.hisal; 更好的写法应该使用between…and:\nSELECT s.grade, e.empno, e.ename, e.sal, e.job FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ORDER BY 1; 6.3 外链接： l 按部门统计员工人数，显示： 部门号 部门名称 人数\n分析:\n​\t人数：一定是在emp表中，使用count()函数统计emp表中任一非空列均可。\n​\t部门名称：在dept表dname中, 直接读取即可。\n​\t部门号：任意，两张表都有, 两个表的联系是deptno.\n所以:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno=d.deptno GROUP BY d.deptno, d.dname; 注意：由于使用了组函数count()，所以组函数外的d.deptno和d.dname必须放到group by后。\n得到查询结果，但是select * from dept发现40号部门没有显示出来，原因是40号部门没有员工，where没满足。结果不对，40号部门没有员工，应该在40号部门位置显示0。\n我们希望： 在最后的结果中，包含某些对于where条件来说不成立的记录 （外链接的作用）\nl 左外链接：当 where e.deptno=d.deptno 不成立的时候，=左边所表示的信息，仍然被包含。\n​\t写法：与叫法相反：where e.deptno=d.deptno(+)\nl 右外链接：当 where e.deptno=d.deptno 不成立的时候，=右边所表示的信息，仍然被包含。\n​\t写法：依然与叫法相反：where e.deptno(+)=d.deptno\n以上我们希望将没有员工的部门仍然包含到查询的结果当中。因此应该使用外链接的语法。\n写法1:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE e.deptno(+)=d.deptno GROUP BY d.deptno, d.dname; 写法2:\nSELECT d.deptno 部门号, d.dname 部门名称, count(e.empno) 人数 FROM emp e, dept d WHERE d.deptno = e.deptno(+) GROUP BY d.deptno, d.dname; 这样就可以将40号部门包含到整个查询结果中。人数是0\n注意：不能使用count(e.*), 应该是某个表的具体的列.\n思考: 能否使用count(), count()与count(e.empno)有什么不同???\n6.4 自连接： 核心，通过表的别名，将同一张表视为多张表。\n例如: 查询员工信息：xxx的老板是 yyy\n分析：执行select * from emp; 发现，员工的老板也在员工表之中，是一张表。要完成多表查询我们可以假设，有两张表，一张表e(emp)只存员工、另一张表b(boss)只存员工的老板。—— from e, b;\n老板和员工之间的关系应该是：where e.mgr=b.empno (即:员工表的老板 = 老板表的员工)\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || b.ename FROM emp e, emp b WHERE e.mgr=b.empno; 执行, 发现结果正确了, 但是KING没有显示出来. KING的老板是他自己. 应该怎么显示呢?\n使用外连接:\nSELECT e.ename || \u0026#39; 的老板是 \u0026#39; || nvl(b.ename, \u0026#39;他自己\u0026#39; ) FROM emp e, emp b WHERE e.mgr=b.empno(+); 使用concat函数应该怎么做呢??\nSELECT concat(e.ename, concat(\u0026#39; 的老板是 \u0026#39;, nvl(b.ename, \u0026#39;他自己\u0026#39; ))) FROM emp e, emp b WHERE e.mgr = b.empno(+); 7 子查询 子查询语法很简单，就是select 语句的嵌套使用, 即sql嵌套sql。\n查询工资比SCOTT高的员工信息.\n分析：两步即可完成\r查出SCOTT的工资 SELECT ename, sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;; # 结果为3000 查询比3000高的员工 SELECT * FROM emp WHERE sal\u0026gt;3000; 通过两步可以将问题结果得到。子查询，可以将两步合成一步。\n——子查询解决的问题：问题本身不能一步求解的情况。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE ename=\u0026#39;SCOTT\u0026#39;); 子查询语法格式：\nSELECT *select_list FROM *table WHERE *expr operator (SELECT *select_list FROM *table); 本章学习目标:\n描述子查询可以解决的问题\n定义子查询(子查询的语法)\n列出子查询的类型。\n书写单行子查询和多行子查询。\n7.1 定义子查询 需要注意的问题 合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩 进)\n小括号( )\n主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可\n可以在主查询的where、select、having、from后都可以放置子查询\n不可以在主查询的group by后面放置子查询 (SQL语句的语法规范)\n强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)\n一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外\n一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by\n单行子查询只能使用单行操作符；多行子查询只能使用多行操作符\n子查询中的null值\n7.2 主、子查询在不同表间进行。 查询部门名称是“SALES”的员工信息\n主查询：查询员工信息。select * from emp;\n子查询：负责根据部门名称(在dept表中)得到部门号。\nSELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;; SELECT * FROM emp WHERE deptno= (SELECT deptno FROM dept WHERE dname=\u0026#39;SALES\u0026#39;); 主查询, 查询的是员工表emp, 子查询, 查询的是部门表dept。是两张不同的表。\r将该问题使用“多表查询”解决\nSELECT e.* FROM emp e, dept d WHERE e.deptno=d.deptno AND d.dname=\u0026#39;SALES\u0026#39;; 两种方式哪种好呢？\nSQL优化: 理论上，既可以使用子查询，也可以使用多表查询，尽量使用“多表查询”。子查询有2次from, 与数据库服务的交互多.\n不同数据库处理数据的方式不尽相同，如Oracle数据库中，子查询地位比较重要，做了深入的优化。有可能实际看到结果是子查询快于多表查询。\n7.3 在主查询的where select having from 放置子查询 子查询可以放在select后，但，要求该子查询必须是单行子查询：(该子查询本身只返回一条记录，2+叫多行子查询)\nSELECT empno, ename, (SELECT dname FROM dept) 部门 FROM emp; 注意：SQL中没有where是不可以的，那样是多行子查询。\u0026ndash;但这是不符合实际情况的.\n应该:\nSELECT empno, ename, (SELECT dname FROM dept WHERE deptno = 10) 部门 FROM emp WHERE deptno = 10; 进一步理解查询语句，实际上是在表或集合中通过列名来得到行数据，子查询如果是多行，select无法做到这一点。\n在 having 后 和 where 类似。但需注意在where后面不能使用组函数。\n在having后面使用子查询的例子:\n查询部门平均工资高于30号部门平均工资的部门和平均工资\nSELECT deptno, avg(sal) FROM emp GROUP BY deptno HAVING avg(sal) \u0026gt; (SELECT avg(sal) FROM emp WHERE deptno = 30); 7.4 在from后面放置的子查询(***) 表, 代表一个数据集合、查询结果(SQL)语句本身也代表一个集合, 把查询结果看成一个表.\n查询员工的姓名、薪水和年薪：\n说明：该问题不用子查询也可以完成。但如果是一道填空题：\rselect * from ___________________\n因为显示的告诉了，要使用select *, 所以只能:\nSELECT * FROM (SELECT ename, sal, sal*12 年薪 FROM emp); 将select 语句放置到from后面，表示将select语句的结果，当成表来看待. 这种查询方式在Oracle语句中使用比较频繁.\n7.5 单行子查询只能使用单行操作符；多行子查询只能使用多行操作符 7.5.1单行子查询： 单行子查询就是该条子查询执行结束时, 只返回一条记录(一行数据)。\n使用单行操作符:\n=、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=\n单行子查询:\n单行子查询, 只能使用单行操作符\n在一个主查询中可以有多个子查询。\n子查询里面可以嵌套多层子查询。\n子查询也可以使用组函数。子查询也是查询语句，适用于前面所有知识。\n案例:\n查询emp表部门编号为10且高于本部门的平均工资的员工信息 SELECT * FROM emp WHERE sal\u0026gt; (SELECT avg(sal) FROM emp WHERE deptno=10) AND deptno=10; 查询emp表中与SMITH职位相同的员工信息 SELECT * FROM emp WHERE job = (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询薪水低于本公司的平均薪水且职位与SMITH职位相同的所有员工信息 SELECT * FROM emp WHERE sal\u0026lt; (SELECT avg(sal) FROM emp) AND job= (SELECT job FROM emp WHERE ename=\u0026#39;SMITH\u0026#39;); 查询emp表中最低工资员工和最高工资员工的信息 SELECT * FROM emp WHERE sal= (SELECT max(sal) FROM emp) OR sal= (SELECT min(sal) FROM emp); 5 思考??,下列sql语句正确吗?\nSELECT * FROM emp WHERE sal= (SELECT min(sal) FROM emp GROUP BY deptno); 注意: =、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、\u0026lt;\u0026gt;或者!=是单行操作符, 而后面的子查询会返回多条记录,所以会报错, 要解决这个问题要使用多行子查询.\n7.5.2多行子查询： 子查询返回2条记录以上就叫多行。\n多行操作符有：\nIN\t等于列表中的任意一个\nANY\t和子查询返回的任意一个值比较\nALL\t和子查询返回的所有值比较\nIN(表示在集合中)：\n解决上面的那个问题?\nSELECT * FROM emp WHERE sal IN (SELECT min(sal) FROM emp GROUP BY deptno); 查询部门名称为SALES和ACCOUNTING的员工信息。\n分析：部门名称在dept表中，员工信息在emp表中,子查询应先去dept表中将SALES和ACCOUNTING的部门号得到，交给主查询得员工信息.\nSELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept WHERE dname IN (\u0026#39;SALES\u0026#39;, \u0026#39;ACCOUNTING\u0026#39;)); 也可以使用多表查询来解决该问题：\rSELECT e.* FROM emp e, dept d WHERE e.deptno = d.deptno AND (d.dname = \u0026#39;SALES\u0026#39; OR d.dname = \u0026#39;ACCOUNTING\u0026#39;); 红色语句也可以用 d.dname in ('SALES ', 'ACCOUNTING ')\n这种解决方式，注意使用()来控制优先级。 如果查询不是这两个部门的员工，只要把in → not in就可以了，注意不能含有空值。\nANY(表示和集合中的任意一个值比较)：\n查询薪水比30号部门任意一个员工高的员工信息：\n分析：首先查出30号部门的员工薪水的集合，然后\u0026gt;它就得到了该员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT sal FROM emp WHERE deptno=30); # 正确吗？ 这样是错的，子句返回多行结果。而‘\u0026gt;’是单行操作符。——应该将‘\u0026gt;’替换成‘\u0026gt; any’\n实际上\u0026gt;集合的任意一个值，就是大于集合的最小值。\nSELECT * FROM emp WHERE sal \u0026gt; any (SELECT sal FROM emp WHERE deptno=30); 若将这条语句改写成单行子查询应该怎么写呢？\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT min(sal) FROM emp WHERE deptno=30); ALL(表示和集合中的所有值比较)：\n查询薪水比30号部门所有员工高的员工信息。\nSELECT * FROM emp WHERE sal \u0026gt; ALL (SELECT sal FROM emp WHERE deptno=30); 同样，将该题改写成单行子句查询：\nSELECT * FROM emp WHERE sal \u0026gt; (SELECT max(sal) FROM emp WHERE deptno=30); 对于any 和 all 来说，究竟取最大值还是取最小值，不一定。将上面的两个例子中的“高”换成“低”，any和all就各自取相反的值了。\n子查询中null 判断一个值等于、不等于空，不能使用=和!=号，而应该使用is 和 not。\n如果集合中有NULL值，不能使用not in。如： not in (10， 20， NULL)，但是可以使用in。为什么呢？\n先看一个例子：\n查询不是老板的员工信息：\n分析：不是老板就是树上的叶子节点。在emp表中有列mgr，该列表示该员工的老板的员工号是多少。那么，如果一个员工的员工号在这列中，那么说明这员工是老板，如果不在，说明他不是老板。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp); 但是运行没有结果，因为有NULL\n查询是老板的员工信息：只需要将not去掉。\nSELECT * FROM emp WHERE empno IN (SELECT mgr FROM emp ); 还是我们之前null的结论：in (10, 20, null) 可以，not in (10, 20, null) 不可以\nselect * from emp where deptno in (10, 20, null);\u0026mdash;\u0026ndash;可以\nSELECT * FROM emp WHERE deptno NOT IN (10, 20, null);# -----不可以 例如：a not in(10, 20, NULL) 等价于 (a != 10) and (a != 20) and (a != NULL)\n因为, not in操作符等价于 !=All，最后一个表达式为假，整体假;\n而a in (10, 20, NULL)等价于(a = 10) or (a = 20) or (a = null)只要有一个为真即为真。\nin 操作符等价于 = Any SELECT * FROM emp WHERE deptno = any(10, 20, null);\t# 等价于 SELECT * FROM emp WHERE deptno IN (10, 20, null); 继续，查询不是老板的员工信息, 只要将空值去掉即可。\nSELECT * FROM emp WHERE empno NOT IN (SELECT mgr FROM emp WHERE mgr is NOT null); 注意: not in 后面的结合中不能有null\n一般不在子查询中使用order by 一般情况下，子查询使用order by或是不使用order by对主查询来说没有什么意义。子查询的结果给主查询当成集合来使用，所以没有必要将子查询order by。\n但，在Top-N分析问题中，必须使用order by\n一般先执行子查询，再执行主查询 含有子查询的SQL语句执行的顺序是，先子后主。\n但，相关子查询例外.\n8 集合运算 l 查询部门号是10和20的员工信息?\t有三种方法\nSELECT * FROM emp WHERE deptno in(10, 20); SELECT * FROM emp WHERE deptno=10 OR deptno=20; n 集合运算：\nSELECT * FROM emp WHERE deptno=10;\t# 加上 SELECT * FROM emp WHERE deptno=20; 集合运算所操作的对象是两个或者多个集合，而不再是表中的列(select一直在操作表中的列)\n8.1 集合运算符 集合运算的操作符。A∩B、A∪ B、A - B\nSELECT * FROM emp WHERE deptno=10 UNION SELECT * FROM emp WHERE deptno=20; union和union all的区别: union会去掉重复的, 而union all会全部显示\n注意：这是一条SQL语句。\n8.2 集合运算需要注意的问题： 参与运算的各个集合必须列数相同，且对应每个列的类型一致。\n采用第一个集合的表头作为最终使用的表头.\n可以使用括号()先执行后面的语句。\n问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出：\n分析SQL执行结果。\n第一部分数据是按照deptno和job进行分组；select 查询deptno、job、sum(sal)\n第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal)\n第三部分数据不按照任何条件分组，即group by null；select 查询sum(sal)\n所以，整体查询结果应该= group by deptno,job + group by deptno + group by null\n按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!\nSELECT deptno, job, sum(sal) FROM emp GROUP BY deptno,job UNION SELECT deptno, to_char(null), sum(sal) FROM emp GROUP BY deptno UNION SELECT to_number(null), to_char(null), sum(sal) FROM emp; 交集和差集与并集类似，也要注意以上三点。只不过算法不同而已。\n需要注意:集合运算的性能一般较差.\nSQL的执行时间：\n`set timing on/off`\t默认是off 9 数据处理 SQL语言的类型： 数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵 语言)，就是指代：insert、update、delete、select这四个操作。\nDDL语句。(Data Definition Language 数据定义语言)。 如：truncate table(截断/清空 一张表)\ncreate table(表)、create view(视图)、create index(索引)、create sequence(序列)、 create synonym(同义词)、alter table、drop table。 DCL语句。DCL（Data Control Language数据控制语言）如：\ncommit(提交)、rollback(回滚)\n插入数据insert： l 使用 INSERT 语句向表中插入数据。其语法为：\nINSERT INTO\t*table [(column [, column\u0026hellip;])]\nVALUES\t(value [, value\u0026hellip;]);\nl 如果：values后面的值，涵盖了表中的所有列，那么table的列名可以省略不写。\ndesc emp; 查看员工表的结构，得到所有的列名。\ninsert into emp values (1001, \u0026#39;Tom\u0026#39;, \u0026#39;Engineer\u0026#39;, 7839, sysdate, 5000, 200, 10 ); insert into emp values (1005, \u0026#39;Bone\u0026#39;, \u0026#39;Raphealy\u0026#39;, 7829, to_date(\u0026#39;17-12月-82\u0026#39;, \u0026#39;DD-MON-RR\u0026#39;), NULL, 300, 20); l 如果:插入的时候没有插入所有的列, 就必须显式的写出这些列的名字。\ninsert into emp(empno, ename, sal, deptno) values(1002, \u0026#39;Marry\u0026#39;, 6000, 20); 注意：字符串和日期都应该使用 \u0026rsquo; \u0026lsquo;号引用起来.\nl 没有写出的列自动填NULL, 这种方式称之为“隐式插入空值”。\nl 显示插入空值: insert into emp(empno, ename, sal) values(1003, \u0026lsquo;Jim\u0026rsquo;, null);\n“\u0026amp;” 地址符： l 在insert语句中使用\u0026amp;可以让用户输入值:\ninsert into emp(empno, ename, sal, deptno) values(\u0026amp;empno, \u0026amp;ename, \u0026amp;sal, \u0026amp;deptno); 理论上“\u0026amp;”后面的变量名任意，习惯上一般与前面的列名相同，赋值的时候清楚在给谁赋值。\n当再次需要插入新员工的时候直接输入“/”就可以继续输入新员工的值, /表示重复刚刚执行过的sql语句.\nl 可以在DML的任意一个语句中输入“\u0026amp;”,\nSELECT empno, ename, sal, \u0026amp;t FROM emp ; 执行时，会提示你输入要查询的列名。当输入不同的列名时，显示不同的执行结果。\nselect * from \u0026amp;t; 修改t的值，可以查看不同表。\n总结: \u0026amp;类似于c语言中的宏替换, 只是进行简单的字符串替换操作, 但是select关键字不能用\u0026amp;指代. 如 \u0026amp;t * from emp; 而from, 表名, where 是可以用\u0026amp;指代的, 如: select * \u0026amp;t emp; select * from \u0026amp;t; select * from emp \u0026amp;t sal\u0026gt;2000;但是通常情况都是替换值.\n批处理： 一次插入多条数据, 使用一个新创建的表用来测试.\n创建一张与emp完全相同的表，用于测试。\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; SELECT * FROM tab; SELECT * FROM emp10; desc emp10; 一次性将emp表中所有10号部门的员工, 放到新表emp10中来。\ninsert into emp10SELECT * FROM emp WHERE deptno=10; 一次性将emp表中的指定列插入到表emp10中。\n注意：insert的列名, 要和select的列名一致\rinsert into emp10(empno, ename, sal, deptno); SELECT empno, ename, sal, deptno FROM emp WHERE deptno=10; 注意没有values关键字了, 但列名必须一一对应.\n总结: 子查询可以出现在DML的任何语句中.\n更新数据update 格式: update 表名 set col=值 where condtion\n对于更新操作来说，一般会有一个“where”条件，如果没有这限制条件，更新的就是整张表。\nUPDATE emp10 SET sal=4000, comm=300 WHERE ename = \u0026#39;CLARK\u0026#39;; 注意：若没有where限定，会将所有的员工的sal都设置成4000，comm设置成300；\n能否将某一列的值设置为null呢?\nUPDATE emp10 SET comm = null WHERE empno=1000; # ----可以 能否在查询的时候where条件中指定列的值为null吗?\nSELECT * FROM emp WHERE comm = null; # ----不可以 10 删除数据delete 格式: delete from 表名 where condtion\ndelete FROM emp10 WHERE empno=7782; 注意: 如不加\u0026quot;where\u0026quot;会将整张表的数据删除。\n“from”关键字在Oracle中可以省略不写，但MySQL中不可以;\r但在使用的时候建议还是加上from.\ndelete 和 truncate的区别： delete 逐条删除表“内容”，truncate 先摧毁表再重建。\n(由于delete使用频繁，Oracle对delete优化后delete快于truncate)\ndelete 是DML语句，truncate 是DDL语句。\nDML语句可以闪回(flashback)，DDL语句不可以闪回。\n（闪回： 做错了一个操作并且commit了，对应的撤销行为。了解）\n由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。\n（同样是由于Oracle对delete进行了优化，让delete不产生碎片）。\n两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动\ndelete不会释放空间，truncate 会释放空间\n用delete删除一张10M的表，空间不会释放。而truncate会。所以当确定表不再\n使用，应truncate\ndelete可以回滚rollback, truncate不可以回滚rollback。 delete和truncate的时效性 【做实验sql.sql】：验证delete和truncate的时效性。\t终端里@c:\\sql.sql\t可以执行脚本sql.sql\n语句执行时间记录开关：set timing on/off\r回显开关：set feedback on/off\r【测试步骤】：\t1. 关闭开关：\tSQL\u0026gt; set timing off;\tSQL\u0026gt; set feedback off; 2. 使用脚本创建表：\tSQL\u0026gt; @c:\\sql.sql 3. 打开时间开关：\tSQL\u0026gt; `set timing on; ` 4. 使用delete删除表内容：\tSQL\u0026gt; `delete from testdelete; ` 5. 删除表：\tSQL\u0026gt;`drop table testdelete purge;` 6. 关闭时间开关：\tSQL\u0026gt; `set timing off;` 7. 使用脚本创建表：\tSQL\u0026gt; `@c:\\sql.sql ` 8. 打开时间开关：\tSQL\u0026gt; `set timing on; `\r9. 使用truncate删除表内容：\tSQL\u0026gt; `truncate table testdelete;` 事务 联想现实生活中的银行转账业务, 从A账户把钱转给B账户.\n数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。\nn 数据库事务由以下的部分组成:\nØ 一个或多个DML 语句\nØ 一个 DDL(Data Definition Language – 数据定义语言) 语句\nØ 一个 DCL(Data Control Language – 数据控制语言) 语句\n事务的特点：要么都成功，要么都失败。\n事务的特性 l 事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。\n原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n一致性 (Consistency)：几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致。\n隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。\n持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。\n事务的起始标志：oracle中自动开启事务，以DML语句为开启标志。\n执行一个增删改查语句, 只要没有提交commit和回滚rollback, 操作都在一个事务中.\n事务的结束标志: 提交、回滚都是事务的结束标志。\n提交:\nØ 显示提交: commit\nØ 隐式提交\n有DDL语句，如：create table除了创建表之外还会隐式提交Create 之前所有没有提交的DML语句。\n正常退出(exit / quit) u 回滚:\nØ 显示回滚: rollback\nØ 隐式回滚: 掉电、宕机、非正常退出。\n控制事务 l 保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。\n【示例】：1. create table testsp ( tid number, tname varchar2(20)); DDL语句会隐式commit之前操作.\n2. `set feedback on; ` 打开回显\r3. `insert into testsp values(1, 'Tom');`\r4. `insert into testsp values(2, 'Mary');`\r5. `savepoint aaa;`\r6. `insert into testsp values(3, 'Moke');`\t故意将“Mike”错写成“Moke”。\r7. `select * from testsp; `\t三条数据都显示出来。\r8.` rollback to savepoint aaa;`\t回滚到保存点aaa\r9. `select * from testsp;` 发现表中的数据保存到第二条操作结束的位置\r需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。\nsavepoint主要用于在事务上下文中声明一个中间标记, 将一个长事务分隔为多个较小的部分, 和我们编写文档时, 习惯性保存一下一样, 都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一但commit之后，所有的savepoint将失效。\n隔离级别 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n脏读: 对于两个事物T1, T2, T1读取了已经被T2更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的\n不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.\n幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.\n​\nSQL99定义4中隔离级别：\nRead Uncommitted\t读未提交数据。\nRead Commited\t读已提交数据。\t（Oracle默认）\nRepeatable Read\t可重复读。\t（MySQL默认）\nSerializable\t序列化、串行化。 （查询也要等前一个事务结束）\nOracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。\nRead Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。\n11 创建和管理表 常见的数据库对象 数据库的对象: 经常使用的数据库对象有 表、视图、索引、序列、同义词等.\n表\t基本的数据存储集合，由行和列组成。\n视图\t从表中抽出的逻辑上相关的数据集合。\n序列\t提供有规律的数值。\n索引\t提高查询的效率\n同义词\t给对象起别名\n表的基本操作 基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：\n必须以字母开头\n必须在 1–30 个字符之间\n必须只能包含 A–Z, a–z, 0–9, _, $, 和 #\n必须不能和用户定义的其他对象重名\n必须不能是Oracle 的保留字\nOracle默认存储是都存为大写\n数据库名只能是1~8位, datalink可以是128位, 和其他一些特殊字符\n创建表 创建一张表必须具备：1. Create Table的权限 2. 存储空间。我们使用的scott/hr用户都具备这两点。\ncreate table test1 (tid number, tname varchar2(20), hiredate date default sysdate); default的作用是, 当向表中插入数据的时候, 没有指定时间的时候, 使用默认值sysdate。insert into test1(tid, tname) values(11, 'wangwu');\n插入时没有指定Hiredate列，取当前时间。\n创建表时， 列所使用的数据类型：\nrowid：行地址 ——伪列\nSELECT rowid, empno, deptno FROM emp; 看到该列存储的是一系列的地址(指针), 创建索引用.\n分析，之前我们使用过的创建表的语句：\ncreate table emp10 ASSELECT * FROM emp WHERE 1=2; 在这条语句中，“where 1=2”一定为假。所以是不能select到结果的，但是将这条子查询放到Create语句中，可以完成拷贝表结构的效果。最终emp10和emp有相同的结构。\n如果, “where”给定的是一个有效的条件, 就会在创建表的同时拷贝数据。如:\ncreate table emp20 ASSELECT * FROM emp WHERE deptno=20; 这样emp20在创建之初就有5条数据。\n创建一张表，要求包含：员工号 姓名 月薪 年薪 年收入 部门名称\n分析：[员工号 姓名 月薪 年薪 年收入]在emp表中, 部门名称在dept表中, 两个表是通过deptno部门编号联系起来的.\n根据要求，涉及emp和dept两张表(至少有一个where条件)，并且要使用表达式来计算年收入和年薪。\ncreate table empincome AS ↓SELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 必须要给表达式取别名(语法要求) 由于此时的“where”条件是有效的条件，就会在创建表的同时拷贝数据。\n创建“视图”的语法与上边表的语法、顺序几乎完全一样，只是将“table”→“view”即可。\n修改表 ALTER TABLE\n追加一列: 向test1表中加入新列 image 类型是blob\nalter table test1 add image blob; desc test1; 修改一列: 将tname列的大小有20→40.\nalter table test1 modify tname varchar2(40); 删除一列: 将刚加入的新列image删除.\nalter table test1 drop column image; 重命名一列: 将列tname重命名为username.\nalter table test1 rename column tname to username;\t注意: 若是修改表的字段的长度, 若是增加长度没有问题, 若是减少字段的长度, 有可能会报错.\n删除表 当表被删除：\n数据和结构都被删除\n所有正在运行的相关事物被提交\n所有相关索引被删除\nDROP TABLE 语句不能回滚，但是可以闪回\nselect * from tab; 查看当前用户下有哪些表, 拷贝保存表名。\ndrop table testsp; 将测试保存点的表删除。\nselect * from tab; 再次查询跟刚刚保存的表名比对，少了testsp，但多了另外一张命名复杂的表。\nOracle的回收站：\n查看回收站：show recyclebin (sqlplus 命令)那个复杂的命名即是testsp在回收站中的名字。 select * from testsp; 这样是不能访问的。\nselect * from \u0026ldquo;BIN$+vu2thd8TiaX5pA3GKHsng==$0\u0026rdquo; 要使用“回收站中的名字”\n清空回收站：purge recyclebin\ndrop table test1 purge 表示直接删除表，不经过回收站。\n将表从回收站里恢复，涉及“闪回”的知识，作为了解性知识点。\n将表从回收站闪回\nflashback table t2 to before drop; 清空回收站\npurge recyclebin; 注意：并不是所有的用户都有“回收站”，对于没有回收站的用户（管理员）来说，删除操作是不可逆的.\n重命名表 rename test1 to test8;\tTruncate Table：DDL语句\t——注意：不能回滚(rollback)\n约束： 约束的种类 Not Null\t非空约束\n例如：人的名字，不允许为空。\rUnique\t唯一性约束\n例如：电子邮件地址，不可以重复。\rPrimary Key\t主键约束\n通过这个列的值可以唯一的确认一行记录，主键约束隐含Not null + Unique\rForeign Key\t外键约束\n​\n例如：部门表dept和员工表emp，不应该存在不属于任何一个部门的员工。用来约束两张表的关系。\n注意：如果父表的记录被子表引用的话，父表的记录默认不能删除。解决方法：\n1）\t先将子表的内容删除，然后在删除父表。\r2）\t将子表外键一列设置为NULL值，断开引用关系，然后删除父表。\r无论哪种方法，都要在两个表进行操作。所以定义外键时，可以通过references指定如下参数：\nON DELETE CASCADE：当删除父表时，如发现父表内容被子表引用，级联删除子表引用记录。\nON DELETE SET NULL：当发现上述情况，先把子表中对应外键值置空，再删除父表。\n多数情况下，使用SET NULL方法，防止子表列被删除，数据出错。\nCheck检查性约束\n如：教室中所有人的性别；工作后薪水满足的条件。\r新建一个测试表: test7\ncreate table test7 (tid number, tname varchar2(20), gender varchar(6) check (gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)),\tsal number check (sal \u0026gt; 0)\t); 说明:\ncheck (gender in (\u0026lsquo;男\u0026rsquo;, \u0026lsquo;女\u0026rsquo;)) 检查插入的性别是不是‘男’或‘女’（单引号）。\ncheck (sal \u0026gt; 0)\t检查薪水必须是一个正数。\r测试: insert into test7 values(1, 'Tom', '男', 1000); 没有问题.\n如果插入: insert into test7 values(2, \u0026lsquo;Mary\u0026rsquo;, \u0026lsquo;啊\u0026rsquo;, 2000); 会报错.\nORA-02290：违反检查约束条件SCOTT.SYS_C005523, gender的值只能取’男’或者’女’.\n其中的“SYS_C005523”是约束的名字，由于在定义约束时没有显式指定，系统默认给起了这样一个名称。所以我们建议，创建约束的时候，自定义一个见名知意的约束名。\nconstraint: 使用该关键字，来给约束起别名。\n约束举例 【约束举例】：\ncreate table student ( sid number constraint student_PK primary key, # --学生Id主键约束 sname varchar2(20) constraint student_name_notnull not null, # --学生姓名非空约束 email varchar2(20) constraint student_email_unique unique\t# --学生邮件唯一约束 constraint student_email_notnull not null,\t# --同时邮件可再设非空，没有, age number constraint student_age_min check(age \u0026gt; 10),\t# --学生年龄设置check约束 gender varchar2(6) constraint gender_female_or_male check(gender in (\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;)), deptno number constraint student_FK references dept (deptno) ON DELETE SET NULL ); 在定义学生deptno列的时候，引用部门表的部门号一列作为外键，同时使用references设置级联操作\n——当删除dept表的deptno的时候，将student表的deptno置空。\r查看student表各列的约束\ndesc student; student的建表语句:\nSELECT dbms_metadata.get_ddl(\u0026#39;TABLE\u0026#39;, \u0026#39;STUDENT\u0026#39;) FROM dual; 测试用例：\ninsert into student values(1, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 20, \u0026#39;男\u0026#39;, 10); # 正确插入表数据。 insert into student values(2, \u0026#39;Tom\u0026#39;, \u0026#39;tom@126.com\u0026#39;, 15, \u0026#39;男\u0026#39;, 10); 违反student_email_unique约束。\rinsert into student values(3, \u0026#39;Tom3\u0026#39;, \u0026#39;tom3@126.com\u0026#39;, 14, \u0026#39;男\u0026#39;,100 ); 违反完整约束条件 (SCOTT.STUDENT_FK) - 未找到父项关键字\r问题：是不是父表的所有列，都可以设置为子表的外键？作外键有要求吗？\n外键：必须是父表的主键.\r查看指定表（如student）的约束, 注意表名必须大写。\nSELECT constraint_name, constraint_Type, search_condition FROM user_constraints WHERE table_name=\u0026#39;STUDENT\u0026#39;; 12 其它数据库对象 视图： 视图是一种常见数据库对象, 它是从表中抽出的逻辑上相关的数据集合。\n所以：1. 视图基于表。2. 视图是逻辑概念。3. 视图本身没有数据。\n创建视图 创建语法与创建表类似，只需要将table → view即可:\ncreate view empincomeview ASSELECT e.empno, e.ename, e.sal, e.sal*12 annualsal, e.sal*12+nvl(comm, 0) income, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno; 出错提示：权限不足。因为创建视图需要“create view”的权限。默认scott用户没有该种权限。加之！\r添加步骤：\n使用管理员登陆：sqlplus / as sysdba\n给scott用户增加权限\ngrant create view to scott; 执行“/”可成功创建视图empincomeview.\n视图的操作和表的操作完全一样.\nSELECT * FROM empincomeview; 视图的优点： 视图的优点\n简化复杂查询: 原来分组、多表、子查询等可以用一条select * from xxxview代替,视图可以看做是表的复杂的SQL一种封装。\n限制数据访问: 只看视图的结构和数据是无法清楚视图是怎样得来的。可以限制数据的访问。例如：银行项目，所谓的各个“表”都是“视图”，并有可能只是“只读视图”\n注意：1. 视图不能提高性能 2. 不建议通过视图对表进行修改。\n创建视图细节： 使用下面的语法格式创建视图：\nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view\n[(alias[, alias]\u0026hellip;)]\nAS subquery\n[WITH CHECK OPTION [CONSTRAINT constraint]]\n[WITH READ ONLY [CONSTRAINT constraint]];\n视图只能创建、删除、替换。（不能修改，修改即替换replace）\n如：刚刚创建的empincomeview，其他语句不变，将create一行改写成：\ncreate # 视图不存在则创建、存在则替换。 OR replace view empincomeview AS select…… from…..where….. WITH read only; # 可以将视图设为只读视图。 别名: 可以写在子查询select各个列的后面，也可以写在视图的名字后面。\nwith read only 表示该视图为只读视图。\nwith check option\t了解即可， 举例：\ncreate view testview ASSELECT * FROM emp WHERE deptno=10 WITH check option; insert into testview values(******, 10); 不建议向视图插入，但可以做。向视图插入10号员工。\ninsert into testview values(******, 20); 因为创建视图时加了“with check option”，所以失败。\n视图中使用DML的规定：\n一：\n当视图定义中包含以下元素之一时不能使用delete:\n组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n二：\n当视图定义中包含以下元素之一时不能使用update :\r组函数\nGROUP BY子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n三：\n当视图定义中包含以下元素之一时不能使用insert :\r组函数\nGROUP BY 子句\nDISTINCT 关键字\nROWNUM 伪列\n列的定义为表达式\n表中非空的列在视图定义中未包括\n总结一句话：不通过视图做insert、update、delete操作。因为视图提供的目的就是为了简化查询。\n删除视图:\ndrop view testview; \u0026mdash;\u0026mdash;à不加“purge”关键字。\n序列： 可以理解成数组：默认，从[1]开始，长度[20]\t[1, 2, 3, 4, 5, 6, …, 20]\t在内存中。\n由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。\n序列的使用： 初始状态下：指针指向1前面的位置。欲取出第一个值，应该将向后移动。每取出一个值指针都向后移。\n常常用序列来指定表中的主键。\n创建序列：create sequence myseq 来创建一个序列。\n​\n创建序列：\nCREATE SEQUENCE sequence [INCREMENT BY n] [START WITH n] [{MAXVALUE n | NOMAXVALUE}] [{MINVALUE n | NOMINVALUE}] [{CYCLE | NOCYCLE}] [{CACHE n | NOCACHE}]; NOCACHE表示没有缓存，一次不产生20个，而只产生一个。\n创建序列 创建序列、表，以备后续测试使用：\n`create sequence myseq;` 按默认属性创建一个序列。\rcreate table tableA (tid number, tname varchar2(20)); tid作为主键，准备使用序列来向表中插入值。\n序列的属性： 每个序列都有两个属性, nextval和currval.\nNextVal 必须在CurrVal之前被指定。因为初始状态下，CurrVal指向1前面的位置，无值\n对于新创建的序列使用select myseq.currval from dual; 得到出错。\n但select myseq.nextval from dual; 可以得到序列的第一值1.\n此时再执行select myseq.currval from dual; currval的值也得到1\n使用序列给tableA表创建主键tid：\ninsert into tableA values(myseq.nextval, ‘aaa’) 只有nextval取完会向后移动，使用currval不会移动。\rinsert into tableA values(myseq.nextval, ‘bbb’) 继续使用nextval向表中添加主键tid\rinsert into tableA values(myseq.nextval, \u0026amp;name) 可以使用“\u0026amp;”和“/”来指定名字。\rSELECT * FROM tableA; 由于前面测试currval和nextval关系时调用过nextval，所以tableA的tid起始从2开始。\n查询序列的属性：``select * from user_sequences; user_sequences`为数据字典视图。\n修改序列：\n必须是序列的拥有者或对序列有 ALTER 权限\n只有将来的序列值会被改变\n改变序列的初始值只能通过删除序列之后重建序列的方法实现\n删除序列：drop sequence myseq; 使用序列需要注意的地方: 应首先执行nextval, 之后才能使用currval的值, 刚刚创建的序列不能直接使用currval的值.\n使用序列需要注意的问题： 序列是公有对象，所以多张表同时使用序列，会造成主键不连续。\t如：[1, 2, 3, 4, 5, …, 20] tableA:\t1\t2\t4\ntableB:\t3\t5\tA、B表有可能主键不连续。\n回滚也可能造成主键不连续。\t如：多次调用insert操作使用序列创建主键。但是当执行了rollback后再次使用insert借助序列创建主键的时候，nextval不会随着回滚操作回退。\n掉电等原因，也可能造成不连续。由于代表序列的数组保存在内存中，断电的时候内存的内容丢失。恢复供电时候，序列直接从21开始。\n索引： 索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）\n一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中\n索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度\n索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引\n在删除一个表时, 所有基于该表的索引会自动被删除\n通过指针加速 Oracle 服务器的查询速度\n通过快速定位数据的方法，减少磁盘 I/O\n上图中：\nemp表中保存数据，其中包含部门号列。有10号部门，有20部门员工\n当 select * from emp where deptno=10 的时候。由于10号部门员工不连续，没规律。\n为了提高访问速度，可以在数据库中，依照rowid给deptno列建立索引\ncreate index myindex ON emp(deptno); 这样就建立了“索引表”可以通过rowid保存的行地址快速的找到表中数据。即使表中数据不连续。\r建立了索引以后，如果再执行select语句的时候，会先检查表上是否有索引表。如果有，可以通过有规律的rowid找到连续的数据。\nOracle的数据库中，索引有 B树索引（默认）和 位图索引两种。\n使用create index 索引表名 on 表名（列名1， 列名2…）;来创建索引表。由数据库自动进行维护。\n使用主键查询数据最快速，因为主键本身就是“索引”，所以检索比较快。\n索引使用的场景：\n以下情况可以创建索引:\n列中数据值分布范围很广\n列经常在 WHERE 子句或连接条件中出现\n表经常被访问而且数据量很大, 访问的数据大概占数据总量的2%到4%\n下列情况不要创建索引:\n表很小\n列不经常作为连接条件或出现在WHERE子句中\n查询的数据大于2%到4%\n表经常更新\n删除索引: drop index myindex;\nsynonym同义词： 就是指表的别名。\n如：scott用户想访问hr用户下的表employees。默认是不能访问的。需要hr用户为scott用户授权.\n`sqplus hr/11\t或 conn hr/11`（已登录界面， 切换登陆）\rgrant select ON employees to scott; hr用户为scott用户开放了employees表的查询权限。\n这时scott用户就可以使用select语句，来查询hr用户下的employees表的信息了。\nSELECT count(*) FROM hr.employees; ​\t若用户名叫zhangsanfeng则zhangsanfeng.employees\nhr.employees名字过长，为了方便操作，scott用户为它重设别名:\ncreate synonym hremp for hr.employees; # 为hr.employees创建了同义词。 如有权限限制，那么切换管理员登录，给scott用户添加设置同义词权限。\nconn / as sysdba; grant create synonym to scott; SELECT count(*) FROM hremp; # 使用同义词进行表查询操作。 同义词、视图 等用法在数据保密要求较高的机构使用广泛，如银行机构。好处是既不影响对数据的操作，同时又能保证数据的安全。\nOCA\nOCP\nOCM\t认证\nSELECT rownum, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) WHERE rownum \u0026lt;=3; SELECT * FROM (SELECT rownum rn, empno, ename, sal FROM (SELECT * FROM emp ORDER BY sal desc) ) WHERE rn\u0026gt;=4 AND rn\u0026lt;=7; SELECT d.deptno, e.empno, e.ename, d.avgsal, e.sal FROM emp e, (SELECT deptno, avg(sal) avgsal FROM emp GROUP BY deptno) d WHERE e.deptno=d.deptno AND e.sal\u0026gt;d.avgsal; ","date":"2022-01-09T16:51:29+08:00","permalink":"https://okokfun.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Oracle数据库介绍"},{"content":" 1. 一些基本概念 ###1.1 Nginx初步认识\nNginx介绍\nengine x\n俄罗斯\n开源的框架\nc语言\nTengine - 淘宝基于nginx修改的\nNginx能干什么?\n作为web服务器 解析http协议 反向代理服务器 了解反向代理的概念 邮件服务器 解析邮件相关的协议: pop3/smtp/imap Nginx的优势?\n更快\n高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求 高扩展\n低耦合设计的模块组成,丰富的第三方模块支持 高可靠\n经过大批网站检验 www.sina.com.cn www.xunlei.com www.163.com 每个worker进程相对独立, 出错之后可以快速开启新的worker worker进程的个数是可以控制的 在后台干活的进程 低内存消耗\n一般情况下,10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗 2.5M内存 单机支持10万以上的并发连接\n取决于内存,10万远未封顶 热部署\nmaster和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件 最自由的BSD许可协议\nBSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布 淘宝: tengine 1.2 正向/反向代理 正向代理\n正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。\n正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径, 比如:\n学校的局域网\n单位局域网访问外部资源\n正向代理服务器是为用户服务的\n反向代理\n反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。\n客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的\n请求直接发给反向代理服务器\n反向代理服务器将请求转发给后边的web服务器\nweb服务器 N 台 反向代理服务器转发请求会轮询进行 web服务器收到请求进行处理, 得到结果\nweb服务器将处理结果发送给反向代理服务器\n反向代理服务器将拿到的结果转发给客户端\n1.3 域名和IP 什么是域名？ https://www.baidu.com https://www.jd.com https://taobao.com 什么是IP地址？ 点分十进制的字符串 11.22.34.45 域名和IP地址的关系？ 域名绑定IP 一个域名只能绑定一个IP 一个IP地址被多个域名绑定 2. Nginx 安装和配置 2.1 安装 切换到/usr/local/src目录\n下载\n官方地址: nginx: download 下载 wget http://nginx.org/download/nginx-1.19.9.tar.gz 解压 tar -zxvf nginx-1.19.9.tar.gz Nginx相关依赖: OpenSSL: http://www.openssl.org/ 密码库 使用https进行通信的时候使用 下载 git clone https://github.com.cnpmjs.org/openssl/openssl.git 安装 cd openssl ./Configure make make install ZLib下载: http://www.zlib.net/ 数据压缩 下载 wget http://zlib.net/zlib-1.2.11.tar.gz 安装: tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make sudo make install PCRE下载: http://www.pcre.org/ 解析正则表达式 下载 wget https://ftp.pcre.org/pub/pcre/pcre-8.45.tar.gz 安装 tar -zxvf pcre-8.45.tar.gz cd pcre-8.45 ./configure make sudo make install 安装\nnginx的安装\n进入nginx目录cd nginx-1.19.9\n# nginx工作时候需要依赖三个库 # 三个参数=这三个库对应的源码安装目录 # 根据自己的电脑的库安装包的位置进行指定 ./configure --with-openssl=/usr/local/src/openssl \\ --sbin-path=/usr/local/nginx/sbin/nginx \\ --with-pcre=/usr/local/src/pcre-8.45 \\ --with-zlib=/usr/local/src/zlib-1.2.11 \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/conf/nginx.pid \\ --lock-path=/usr/local/nginx/conf/nginx.lock \\ --with-http_gzip_static_module \\ --with-http_stub_status_module \\ --with-file-aio \\ --with-http_realip_module \\ --with-http_ssl_module \\ --with-ipv6 make -j2 sudo make install Nginx 相关的指令\nNginx的默认安装目录\n/usr/local/nginx conf -\u0026gt; 存储配置文件的目录 html -\u0026gt; 默认的存储网站(服务器)静态资源的目录 [图片, html, js, css] logs -\u0026gt; 存储log日志 sbin -\u0026gt; 启动nginx的可执行程序 Nginx可执行程序的路径\n/usr/local/nginx/sbin/nginx # 快速启动的方式 # 1. 将/usr/local/nginx/sbin/添加到环境变量PATH中 # 2. /usr/local/nginx/sbin/nginx创建软连接, 放到PATH对应的路径中, 比如: /usr/bin ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 启动Nginx - 需要管理器权限\n# 假设软连接已经创建完毕 sudo nginx # 启动 关闭Nginx\n# 第一种, 马上关闭 sudo nginx -s stop # 第二种, 等nginx作为当前操作之后关闭 sudo nginx -s quit 重新加载Nginx\nsudo nginx -s reload # 修改了nginx的配置文件之后, 需要执行该命令 测试是否安装成功\n知道nginx对应的主机的IP地址 - \u0026gt; 192.168.1.100 在浏览器中访问该IP地址 看到一个welcom nginx的欢迎界面 2.2 配置 Nginx配置文件的位置\n/usr/local/nginx/conf/nginx.conf Nginx配置文件的组织格式\nhttp -\u0026gt; 模块, http相关的通信设置 server模块 -\u0026gt; 每个server对应的是一台web服务器 location 模块 处理的是客户端的请求 mail -\u0026gt; 模块, 处理邮件相关的动作 常用配置项介绍\nuser nobody; # 启动之后的worker进程属于谁 - 错误提示: nginx操作xxx文件时候失败, 原因: Permission denied - 将nobody -\u0026gt; root worker_processes 1; # 设置worker进程的个数, 最大 == cpu的核数 (推荐) error_log logs/error.log; # 错误日志, /usr/local/nginx pid logs/nginx.pid; # pid文件, 里边是nginx的进程ID # nginx的事件处理 events { use epoll;\t# 多路IO转接模型使用epoll worker_connections 1024;\t// 每个工作的进程的最大连接数 } http-\u0026gt;server -\u0026gt; 每个server模块可以看做一台web服务器 server{ listen 80; # web服务器监听的端口, http协议的默认端口 server_name localhost; # 对应一个域名, 客户端通过该域名访问服务器 charset utf8; # 字符串编码 location {\t// 模块, 处理客户端的请求 } # 客户端 (浏览器), 请求: http://192.168.10.100:80/login.html # 服务器处理客户端的请求 服务器要处理的指令如何从url中提取? - 去掉协议: http - 去掉IP/域名+端口: 192.168.10.100:80 - 最后如果是文件名, 去掉该名字: login.html - 剩下的: / 服务器要处理的location指令: location / { 处理动作 } 3. Nginx的使用 3.1 部署静态网页 静态网页存储目录\n默认的存储目录:\n/usr/local/nginx/html 自己创建新的目录:\n应该在 /usr/local/nginx/ mkdir /usr/local/nginx/mydir 练习\n在Nginx服务器上进行网页部署, 实现如下访问:\n在/usr/local/nginx/创建新的目录, yundisk用来存储静态网页\n访问地址: http://192.168.80.254/login.html\nlogin.html放到什么位置?\n/ -\u0026gt; 服务器的资源根目录, /usr/local/nginx/yundisk login.htm-\u0026gt; 放到yundisk中 服务器要处理的动作\n# 对应这个请求服务器要添加一个location location 指令(/) { # 找一个静态网页 root yundisk; # 相对于/usr/local/nginx/来找 # 客户端的请求是一个目录, nginx需要找一默认显示的网页 index index.html index.htm; } # 配置之后重启nginx sudo nginx -s reload 访问地址: http://192.168.80.254/hello/reg.html\nhello是什么?\n目录 reg.html放到哪儿?\nhello目录中 如何添加location\nlocation /hello/ { root yundisk; index xx.html; } 访问地址: http://192.168.80.254/upload/ 浏览器显示upload.html\n直接访问一个目录, 得到一默认网页\nupload是一个目录, uplaod.html应该再upload目录中\nlocation /upload/ { root yundisk; index upload.html; } 3.2 反向代理和负载均衡 反向代理和负载均衡是两码事儿\n准备工作:\n需要客户端 - 1个 Window中的浏览器作为客户端 反向代理服务器 -\u0026gt; 1个 window作为反向代理服务器 web服务器 -\u0026gt; 2个 ubuntu - robin: 192.168.247.135 ubuntu - luffy : 192.168.26.250 反向代理设置\n找window上对应的nginx的配置文件 - conf/nginx.conf # 代理几台服务器就需要几个server模块 # 客户端访问的url: http://192.168.1.100/login.html server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name ubuntu.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://robin.test.com; } } # 添加一个代理模块 upstream robin.test.com { server 192.168.247.135:80; } # luffy server { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name hello.com; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定 proxy_pass http://luffy.test.com; } } # 添加一个代理模块 upstream luffy.test.com { server 192.168.26.250:80; } } 负载均衡设置\nserver { listen 80; # 客户端访问反向代理服务器, 代理服务器监听的端口 server_name localhost; # 客户端访问反向代理服务器, 需要一个域名 location / { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /hello/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } location /upload/ { # 反向代理服务器转发指令, http:// 固定的头 proxy_pass http://linux.com; } } # 添加一个代理模块 upstream linux.com { server 192.168.247.135:80 weight=1; server 192.168.26.250:80 weight=3; } ## ===================================== web服务器需要做什么? # 192.168.247.135 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } # 192.168.26.250 location / { root xxx; index xxx; } location /hello/ { root xx; index xxx; } location /upload/ { root xxx; index xx; } 课外知识导读 1. URL和URI 概念:\nURL（Uniform Resource Locator）: 统一资源定位符\n表示资源位置的字符串\n基本格式: \u0026ldquo;协议://IP地址/路径和文件名\u0026rdquo; ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt telnet://192.0.2.16:80/ URN（Uniform Resource Name）: 统一资源名称\nP2P下载中使用的磁力链接 URI（Uniform Resource Identifier）: 统一资源标识符\n是一个紧凑的字符串用来标示抽象或物理资源, URL是URI的一种 让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. http:// or ftp://。 files.hp.com tel:+1-816-555-1212 ftp://ftp.is.co.za/rfc/rfc1808.txt （also a URL） http://www.ietf.org/rfc/rfc2396.txt （also a URL） telnet://192.0.2.16:80/ （also a URL） 经验式理解:\n从包含关系上说: URI包含URL\n字符串长度上说: URL包含URI\nUIRI可以没有协议, 没有地址(IP/域名)\nURL 红色字体部分+绿色字体部分 URI 绿色字体部分 2. DNS解析过程 DNS解析的过程\n在浏览器中输入www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到www.magedu.com主机。 如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 域名解析服务器\nPod DNS+:\n首选：119.29.29.29 备选：182.254.116.116 114DNS:\n首选：114.114.114.114 备选：114.114.114.115 阿里 AliDNS:\n首选：223.5.5.5\n备选：223.6.6.6\nhosts文件\n# 存储的是域名和IP的对应关系 -windows目录: \u0026#34;C:\\Windows\\System32\\drivers\\etc\\hosts\u0026#34; 复习 redis\n是什么?\n非关系型数据库 - nosql 数据存储在内存里边 能干什么?\n提高程序效率 程序中频繁访问的数据, 可以存储到redis中 我们需要干什么?\n会安装\n掌握启动redis服务器和客户端的启动命令\n# 服务器 redis-server (配置文件名) # 客户端 redis-cli (-h redis服务器IP -p 端口) redis中支持的数据类型 - value\n键值对方式存储数据\nkey - 字符串 value 字符串 - string 列表 - list 集合 - set 排序集合 - sortedSet 哈希 - hash 关于服务器使用的配置文件的修改\nredis中持久化\nrdb aof 能够在程序中操作redis服务器\n需要使用以下函数接口 官方地址 - \u0026gt; 客户端 -\u0026gt; 选择语言 ","date":"2022-01-08T16:07:29+08:00","permalink":"https://okokfun.github.io/post/nginx%E5%AE%89%E8%A3%85/","title":"nginx安装"},{"content":" MySQL数据库API库 访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。\n可使用mysql -V 命令查看当前系统内所使用的mysql数据库版本信息。数据库版本为5.6.20版。因此，我们可从帮助手册refman-5.6-en.a4.pdf入手，了解学习MySQL C API使用的一般信息。\n从API手册23.8中可获取信息，MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数-I、-L、-l。\n从手册中可获知，函数库名为mysqlclient。\n因此我们使用命令:\nfind / -name libmysqlclient* 查找该库的路径。得到 /usr/lib64/mysql/libmysqlclient.a。 nm /usr/lib64/mysql/libmysqlclient.a命令可查看库内包含的函数。\n编写hello应用链接函数库 编写一个hello.c应用程序，链接使用该库。\n用到头文件 \u0026lt;mysql.h\u0026gt; 可使用locate mysql.h查看其目录位置/usr/include/mysql/mysql.h。\n编译引用了库的应用程序。\ngcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient 参见帮助手册refman-5.6-en.a4.pdf：23.8.4.3小节。\nMySQL API常用函数 总体印象 使用MySQL库API函数的一般步骤：\na. 初始化. MYSQL *mysql_init(MYSQL *mysql);\nb. 错误处理\tunsigned int mysql_errno(MYSQL *mysql);\rchar *mysql_error(MYSQL *mysql);\nc. 建立连接.\tMYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);\nd. 执行SQL语句\tint mysql_query(MYSQL *mysql, const char *stmt_str);\ne. 获取结果\tMYSQL_RES *mysql_store_result(MYSQL *mysql) MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);\nf. 释放内存\tvoid mysql_free_result(MYSQL_RES *result);\ng. 关闭连接\tvoid mysql_close(MYSQL *mysql);\n初始化 编写程序测试 初始化函数MYSQL *mysql_init(MYSQL *mysql)。\n其中有一种新数据类型MYSQL。可在头文件mysql.h → 263. typedef struct st_mysql {\u0026hellip;} MYSQL;找到其定义。是一个结构体。\n处理错误码的函数：unsigned int mysql_errno(MYSQL *mysql) #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); return 0; } 编译出错，原因是64位Linux环境下，动态库配置不完整。 需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：\n__gxx_personality_v0 \u0026ndash;\u0026gt; -lstdc++\t使用g++相关的环境\ndlclose/dlopen/dlsym\t\u0026ndash;\u0026gt;\t-ldl\t完成用一个程序加载其他动态库的作用。\npthread_*\t\u0026ndash;\u0026gt; -lpthread\t线程库\nmy_getsystime'/clock_gettime\u0026rsquo;\t\u0026ndash;\u0026gt; -lrt\tlibrt.so是glibc中对real-time的支持库\n使用ldd命令可以查看该可执行文件运行所依赖的库文件。\nMakefile 管理 src = $(wildcard *.c) target = $(patsubst %.c, %, $(src)) inc_path = /usr/include/mysql/ lib_path = /usr/lib64/mysql/ all: $(target) %:%.c gcc $\u0026lt; -o $@ -I$(inc_path) -L$(lib_path) -lmysqlclient -lstdc++ -lpthread -ldl -lrt clean: -rm -rf $(target) .PHONY: all clean 注意：在测试makefile时，应先使用-n参数，检查无误再执行。\n连接数据库关闭连接 // 依据proc猜想应该是一个类似于connect的函数，查看API文档发现：mysql_connect();但该函数已经过时，应该使用手册中推荐的mysql_real_connect函数取而代之。 MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag ); // 根据手册中的描述，我们可以使用基础的链接方式与MySQL数据库建立连接。 mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0 ); // 连接数据库成功。对表中数据进行访问， //\t访问结束需调用void mysql_close(MYSQL *mysql) 函数关闭连接。 // 该函数在断开连接的同时，还可以解除分配由mysql指向的连接句柄。 mysql_close(mysql); 读取数据 查询表数据 // mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。 // 是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。查询以\\0结尾的字符串。 // 如果语句中包含二进制数据，则需要调用mysql_real_query来执行查询语句。 // 函数原型：int mysql_query(MYSQL *mysql, const char *query);\t//\t成功返回0，失败返回非0 char *psql = \u0026#34;select * from emp\u0026#34;; ret = mysql_query(mysql, psql); 若执行的是UPDATE, DELETE或INSERT语句，则可通过mysql_affected_rows()获知受影响的记录数。\n若执行的是SELECT语句，查询结束后，查询结果被保存在mysql句柄中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。\n注意: mysql_query执行的SQL语句不应为语句添加终结分号（‘;’）或“\\g”。\n获取结果集 一种方式是通过mysql_store_result()将整个结果集全部取回来。另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过mysql_fetch_row()来访问每一条记录。\nMYSQL_RES *mysql_store_result(MYSQL *mysql) // 成功返回MYSQL_RES结果集指针，失败返回NULL。 // MYSQL_RES是一个结构体类型，可以从mysql.h头文件中找到该结构体的定义： mysql.h → 308. typedef struct st_mysql_res {...} MYSQL_RES; 整体获取的结果集，保存在 MYSQL_RES 结构体指针中，通过检查mysql_store_result()是否返回NULL，可检测函数执行是否成功：\nMYSQL_RES *result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} 该函数调用成功，则SQL查询的结果被保存在result中，但我们不清楚有多少条数据。所以应使用游标的方式将结果集中的数据逐条取出。\n解析结果集 通过游标一行一行fetch结果集中的数据。根据游标使用的一般特性，应使用循环结构，到达结尾或者出错，返回NULL。\n// 函数原型：MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) 成功返回下一行的MYSQL_ROW结构。 // 如果没有更多要检索的行或出现了错误，返回NULL。-----MYSQL_ROW定义在118行 select * from emp // 可以看到emp表一共有8列数据。可以循环将每行上每一列的数据显示到屏幕。 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); } MYSQL_ROW的本质是 typedef char ** MYSQL_ROW; 数据信息存储的形式如下图所示：\n从mysql.h头文件可查看MYSQL_ROW定义: 118. typedef char **MYSQL_ROW; /return data as array of string/\n// 从上图分析MYSQL_ROW为什么被定义为char**类型呢？推测mysq_fetch_row()的函数实现大致思想如下： char **mysql_fetch_row() { char **tmp = (char **) malloc(sizeof(char *) * 8); for (i = 0; i \u0026lt; 8; i++) { tmp[i] = (char *)malloc(50); } strcpy(tmp[0], \u0026#34;7369\u0026#34;); strcpy(tmp[1], \u0026#34;SMITH\u0026#34;); strcpy(tmp[2], \u0026#34;CLERK\u0026#34;); ... return tmp; } 释放结果集 结果集处理完成，应调用对应的函数释放所占用的内存。\nvoid mysql_free_result(MYSQL_RES *result); 成功释放参数传递的结果集。没有失败情况。\nmysql_free_result(result); 思考：上述实现是直接在MySQL工具中数出列数。找寻能获取列数的API函数、获取表头的API函数。\n获取列数 // 查看帮助手册可以看到，有两个函数具备获取列数的功能： unsigned int mysql_field_count(MYSQL *mysql) // 从mysql句柄中获取有多少列。 unsigned int mysql_num_fields(MYSQL_RES *result) // 从返回的结果集中获取有多少列。 // 选择任意一种方式均可以完成该功能。 int num = mysql_field_count(connect); while (row = mysql_fetch_row(result)) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); //printf(\u0026#34;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\u0026#34;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); 获取表头 // 获取表头的API函数同样有两个： MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result) // 全部获取 MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result) // 获取单个 // MYSQL_FIELD也是一个结构体类型，其内部保存了选择列表项的信息， // 其中的name成员变量就保存着列名。可从头文件mysql.h中94-116行找到其定义。 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result);\t//得到表头的结构体数组 for (i = 0; i \u0026lt; num; i++) {\t//已通过 mysql_field_count\t获取了总列数\tprintf(\u0026#34;%s\\t\u0026#34;, fields[i].name);\t//每一列的列名保存在name成员中 } printf(\u0026#34;\\n\u0026#34;); 示例程序 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; char *psql = \u0026#34;select * from emp\u0026#34;;\tMYSQL_RES *result = NULL; MYSQL_FIELD *fields = NULL; MYSQL_ROW row = NULL;\tMYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, psql); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} num = mysql_field_count(mysql); result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } mysql_free_result(result); mysql_close(mysql); return 0;\t} MySQL tools实现 依托我们所学习的MySQL基础类API函数，可以编写程序实现简单的sqlplus/mysql 工具的功能。\n思路分析 \\1. 仿照mysql工具，应在连接数据库成功之后，在一个while循环中不断的接受用户输入的SQL语句。定义char sqlbuf[1024] 存储用户输入的SQL语句。初始化该buf，并提示用户输入SQL语句。使用gets函数在循环中动态接收用户输入。\nwhile (1) { memset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;\\nYourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin); } 在mysql_query(connect, sqlbuf)之前，如果用户输入了“exit”那么程序直接结束。\n在执行完 mysql_query(connect, sqlbuf)之后，应该判别用户输入的是否为select语句。如不是select语句不需要查询结果集、处理结果集等繁复操作。\n如用户输入的是有结果集的SQL语句，将获取列数、获取结果集、获取表头、解析结果集、释放结果集等相关代码一起并入if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6))中。\n测试注意：执行SQL语句时不要在结尾加“;”\n程序实现 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; int main(void) { int i, ret = 0, num = 0; //char *psql = \u0026#34;select * from emp\u0026#34;;\tchar sqlbuf[1024]; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ret = mysql_query(mysql, \u0026#34;set names utf8\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} while (1) {\tmemset(sqlbuf, 0, sizeof(sqlbuf)); printf(\u0026#34;YourSQL\u0026gt; \u0026#34;); fgets(sqlbuf, sizeof(sqlbuf), stdin);\tif (strncmp(sqlbuf, \u0026#34;exit\u0026#34;, 4) || strncmp(sqlbuf, \u0026#34;quit\u0026#34;, 4) ) { break; } ret = mysql_query(mysql, sqlbuf); if (ret != 0) { printf(\u0026#34;mysql_query error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} if (strncmp(sqlbuf, \u0026#34;select\u0026#34;, 6) || strncmp(sqlbuf, \u0026#34;SELECT\u0026#34;, 6)) { num = mysql_field_count(mysql);\tMYSQL_RES *result = NULL; result = mysql_store_result(mysql); if (result == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_store_result error: %s\\n\u0026#34;, mysql_error(mysql)); return ret;\t} //打印表头 MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;);\t//解析结果集 MYSQL_ROW row = NULL;\t//typedef char **MYSQL_ROW;\twhile ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); }\tmysql_free_result(result);\t} else { printf(\u0026#34;\\n--- not select sql---\\n\u0026#34;); printf(\u0026#34;affected: %ld\\n\u0026#34;, (long)mysql_affected_rows(mysql)); } } mysql_close(mysql); return 0;\t} 中文问题： 修改mysql_real_connect()参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用mysql_query函数来解决该问题。\n在 while (1) 之前使用 ret = mysql_query(mysql, \u0026quot;set names utf8\u0026quot;); 来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。\n或者mysql_set_character_set(mysql, \u0026quot;utf8\u0026quot;);\n获取当前使用的字符集: const char *mysql_character_set_name(MYSQL *mysql)\n预处理类API函数： 该类函数解决问题：处理带有占位符的SQL语句。insert into table111(col1, col2, col3) values(?, ?, ?);\n这种SQL语句由两部分组成，一部分是SQL语句体模型部分，另一部分是？所匹配的值。\n性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。\n元数据（Metadata）：又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\n根据API提供的案例学习该部分内容。主要有 4 个函数：\nmysql_stmt_init()\t初始化预处理环境句柄。\t返回一个结构体指针 MYSQL_STMT *stmt\nmysql_stmt_prepare()\t向上面句柄中添加SQL语句，带有 (?,?,?) 占位符\nmysql_stmt_param_count() 求绑定变量的个数(辅助函数)， 有多少个\u0026rsquo;?\u0026lsquo;就返回多少\nmysql_stmt_bind_param()\t将?对应的实参，设置到预处理环境句柄中\nmysql_stmt_execute()\t执行预处理的SQL语句\n在不熟悉这套API函数的情况下，如何能快速的找到一个完整的案例，使用这套函数呢？分析：在以上4个过程中，哪个最重要呢？找到它，去查看API文档！发现有对应的demo程序。将该demo导入到我们的程序中，运行，观察它的作用。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define STRING_SIZE 50 #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(40),\\ col3 SMALLINT,\\ col4 TIMESTAMP)\u0026#34; #define INSERT_SAMPLE \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;init ok...\\n\u0026#34;); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34;connect ok...\\n\u0026#34;); ////////////////////////以下为demo源码//////////////////////////////// MYSQL_STMT *stmt; MYSQL_BIND bind[3]; my_ulonglong affected_rows; int param_count; short small_data; int int_data; char str_data[STRING_SIZE]; unsigned long str_length; my_bool is_null; if (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } /* Prepare an INSERT query with 3 parameters */ /* (the TIMESTAMP column is not named; the server */ /* sets it to the current date and time) */ stmt = mysql_stmt_init(mysql); if (!stmt) { fprintf(stderr, \u0026#34; mysql_stmt_init(), out of memory\\n\u0026#34;); exit(0); } if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) { fprintf(stderr, \u0026#34; mysql_stmt_prepare(), INSERT failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } fprintf(stdout, \u0026#34; prepare, INSERT successful\\n\u0026#34;); /* Get the parameter count from the statement */ param_count= mysql_stmt_param_count(stmt); fprintf(stdout, \u0026#34; total parameters in INSERT: %d\\n\u0026#34;, param_count); if (param_count != 3) /* validate parameter count */ { fprintf(stderr, \u0026#34; invalid parameter count returned by MySQL\\n\u0026#34;); exit(0); } /* Bind the data for all 3 parameters */ memset(bind, 0, sizeof(bind)); /* INTEGER PARAM */ /* This is a number type, so there is no need to specify buffer_length */ bind[0].buffer_type = MYSQL_TYPE_LONG; bind[0].buffer = (char *)\u0026amp;int_data; bind[0].is_null = 0; bind[0].length = 0; /* STRING PARAM */ bind[1].buffer_type = MYSQL_TYPE_STRING; bind[1].buffer = (char *)str_data; bind[1].buffer_length = STRING_SIZE; bind[1].is_null = 0; bind[1].length = \u0026amp;str_length; /* SMALLINT PARAM */ bind[2].buffer_type = MYSQL_TYPE_SHORT; bind[2].buffer = (char *)\u0026amp;small_data; bind[2].is_null = \u0026amp;is_null; bind[2].length = 0; /* Bind the buffers */ if (mysql_stmt_bind_param(stmt, bind)) { fprintf(stderr, \u0026#34; mysql_stmt_bind_param() failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); }\t/* Specify the data values for the first row */ int_data= 10; /* integer */ strncpy(str_data, \u0026#34;MySQL\u0026#34;, STRING_SIZE); /* string */ str_length= strlen(str_data); /* INSERT SMALLINT data as NULL */ is_null= 1; /* Execute the INSERT statement - 1*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute(), 1 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } /* Get the total number of affected rows */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 1): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Specify data values for second row, then re-execute the statement */ int_data= 1000; strncpy(str_data, \u0026#34;The most popular Open Source database\u0026#34;, STRING_SIZE); str_length= strlen(str_data); small_data= 1000; /* smallint */ is_null= 0; /* reset */ /* Execute the INSERT statement - 2*/ if (mysql_stmt_execute(stmt)) { fprintf(stderr, \u0026#34; mysql_stmt_execute, 2 failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt));\texit(0); } /* Get the total rows affected */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \u0026#34; total affected rows(insert 2): %lu\\n\u0026#34;, (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ { fprintf(stderr, \u0026#34; invalid affected rows by MySQL\\n\u0026#34;); exit(0); } /* Close the statement */ if (mysql_stmt_close(stmt)) { fprintf(stderr, \u0026#34; failed while closing the statement\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_stmt_error(stmt)); exit(0); } mysql_close(mysql); printf(\u0026#34;hello mysql...\\n\u0026#34;); return 0;\t} 注意：bind \u0026ndash;\u0026gt; mysql.h下 MYSQL_BIND结构体 bind[3]; 是一个结构体数组。有3个‘?’占位符，所以用三个结构体(数组)来对应保存信息。0-\u0026gt;第一列；1-\u0026gt;第二列；2-\u0026gt;第三列。\nmysql.h中查找 MYSQL_BIND 结构体原型。对比：select * from teat_table; 和 desc test_table; 的查询结果。\n帮助理解bind的小程序框架：\ntypedef struct xxx{ char *p1; char *p2; char *p3; } MYSQL_BIND; void saveXXXInfo(MYSQL_BIND *bind, int num) { insert into test_table valudes(bind[0].p2, bind[1].p3, bind[2].p1); } int main(void) { MYSQL_BIND bind[3]; bind[0].p1 = \u0026#34;类型1\u0026#34;;\t//第一列 bind[0].p2 = \u0026#34;10\u0026#34;; bind[0].p3 = \u0026#34;其他数据\u0026#34;; bind[1].p1 = \u0026#34;类型\u0026#34;;\t//第二列 bind[1].p2 = \u0026#34;数据\u0026#34;; bind[1].p3 = \u0026#34;描述\u0026#34;; bind[2].p1 = \u0026#34;p1p1p1\u0026#34;;\t//第三列 //第四列是时间戳，不需要用户使用?来指定，直接使用了系统时间。 bind[2].p2 = \u0026#34;数据\u0026#34;; bind[2].p3 = \u0026#34;其他限定条件\u0026#34;;\tsaveXXXInfo(bind, 3); } 日期时间类API函数 练习：熟悉上述预处理类工作模式，模拟精简一个将时间插入数据库的程序。将时间存入数据库有两种方式：\n使用SQL语句方式\n预处理环境句柄变量方式存入\n提示：\nMYSQL_TIME ts;\t// 浏览头文件 mysql_time.h 熟悉MYSQL_TIME结构体。 MYSQL_BIND bind[3]; MYSQL_STMT *stmt; // 可直接使用SQL语句提前创建表test_table2，也可以使用mysql_query函数来创建。 create table test_table2 (date_field date, time_field time, timestamp_field timestamp); char query[1024] = \u0026#34;INSERT INTO test_table2(date_field, time_field, timestamp_field) VALUES(?,?,?)\u0026#34;; stmt = mysql_stmt_init(mysql); // MYSQL_TIME 是一个结构体，使用typedef定义。位于mysql_time.h文件中。\tAPI参考：refman-5.6-en.a4.pdf手册25.2.10. 日期和时间值的C API处理\n多查询执行的C API函数 一次性执行多条SQL语句，包括select、drop、update、create等。 如：\nmysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\\ DROP TABLE test_table\u0026#34;); 文档：25.2.9. 多查询执行的C API处理。中文文档只有demo框架。查阅对应英文文档refman-5.6-en.a4.pdf。关键字Multiple 23.8.17\r注意：打桩函数——函数接口\rif (mysql_real_connect (mysql, host_name, user_name, password,\rdb_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL)\rCLIENT_MULTI_STATEMENTS：客户端通知Server，将要发送多个SQL语句。\rmysql_field_count(mysql)：影响的行数。 如：\r当select * from dept;\t执行结束，提示：“5 rows in set”\t表示影响了4行。\r当Create一张表，\t执行结束，提示：“Query OK, 0 rows affected (0.01 sec)”\r当delete一行，\t执行结束，提示：“Query OK, 1 row affected (0.00 sec)”\rmysql_field_count函数调用后会将影响的行数保存到句柄 mysql 中。\r下方是帮助文档中demo程序，它将帮助我们分析与之前掌握的API函数间的区别与联系：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; void process_result_set(MYSQL *mysql, MYSQL_RES *result) { int i, num; num = mysql_field_count(mysql); MYSQL_FIELD *fields = NULL; fields = mysql_fetch_fields(result); for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); MYSQL_ROW row = NULL; while ((row = mysql_fetch_row(result))) { for (i = 0; i \u0026lt; num; i++) { printf(\u0026#34;%10s\\t\u0026#34;, row[i]);\t} printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int ret = 0, status = 0; MYSQL_RES *result = NULL; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) { //unsigned int mysql_errno(MYSQL *mysql) ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb61\u0026#34;, 0, NULL, CLIENT_MULTI_STATEMENTS); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;mysql_init err:%d\\n\u0026#34;, ret); return ret; } /////////////////////////////以下为demo源码////////////////////////////// /* execute multiple statements */ status = mysql_query(mysql,\u0026#34;DROP TABLE IF EXISTS test_table;\\ CREATE TABLE test_table(id INT);\\ INSERT INTO test_table VALUES(10);\\ UPDATE test_table SET id=20 WHERE id=10;\\ SELECT * FROM test_table;\u0026#34;); DROP TABLE test_table if (status) { printf(\u0026#34;Could not execute statement(s)\u0026#34;); mysql_close(mysql); exit(0); } /* process each statement result */ do { /* did current statement return data? */ result = mysql_store_result(mysql); if (result)\t{ /* yes; process rows and free the result set */ process_result_set(mysql, result); mysql_free_result(result); } else /* no result set or error */ { if (mysql_field_count(mysql) == 0) { printf(\u0026#34;%lld rows affected\\n\u0026#34;, mysql_affected_rows(mysql)); } else /* some error occurred */ { printf(\u0026#34;Could not retrieve result set\\n\u0026#34;); break; }\t} /* more results? -1 = no, \u0026gt;0 = error, 0 = yes (keep looping) */ if ((status = mysql_next_result(mysql)) \u0026gt; 0) printf(\u0026#34;Could not execute statement\\n\u0026#34;); printf(\u0026#34;------------status: %d\\n\u0026#34;, status); } while (status == 0); mysql_close(mysql);\treturn 0; } process_result_set函数是文档中给我们预留的打桩函数，需要我们在使用的过程中，自己实现它。\n函数实现就是借助mysql和result两个参数打印一条sql语句查询到的结果集到屏幕。\n可以直接使用mysq_tool.c中if (strncmp(sqlbuf, \u0026quot;select\u0026quot;, 6) == 0 || strncmp(sqlbuf, \u0026quot;SELECT\u0026quot;, 6) == 0)内的代码。“获取结果集”片段可以删除。“释放结果集”片段可以删除。API示例中含有该部分内容。\n常见错误：在process_result_set函数实现中，不要使用mysql_store_result(mysql)再次获取结果集， 该result已经在API函数接口传入，直接使用参数result即可。否则会出现【段错误】。\nMySQL中的事务 测试MySQL中事务的特性。\nMySQL的事务的默认自动提交的，每执行一个sql语句都自动commit\rOracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit\r在程序中设置autocommit修改MySQL事务的属性。\nset autocommit = 0 禁止自动提交\rset autocommit = 1 开启自动提交MySQL中InnoDB引擎才支持事务默认自动提交机制。MYISAM引擎不支持。\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;mysql.h\u0026#34; #define SET_TRAN\t\u0026#34;SET AUTOCOMMIT=0\u0026#34; //手动commit\t#define UNSET_TRAN\t\u0026#34;SET AUTOCOMMIT=1\u0026#34;\t//自动commit //设置事务为手动提交 int mysql_OperationTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为手动提交 ret = mysql_query(mysql, SET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_OperationTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; }\t//设置事务为自动提交 int mysql_AutoTran(MYSQL *mysql) { //--开启事务 int ret = mysql_query(mysql, \u0026#34;start transaction\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query start err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } //--设置事务为自动提交 ret = mysql_query(mysql, UNSET_TRAN); if (ret != 0) { printf(\u0026#34;mysql_AutoTran query set err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret;\t} //执行commit，手动提交事务 int mysql_Commit(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;COMMIT\u0026#34;); if (ret != 0) { printf(\u0026#34;commit err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } //执行rollback，回滚事务\tint mysql_Rollback(MYSQL *mysql) { int ret = mysql_query(mysql, \u0026#34;ROLLBACK\u0026#34;); if (ret != 0) { printf(\u0026#34;rollback err: %s\\n\u0026#34;, mysql_error(mysql)); return ret; } return ret; } #define DROP_SAMPLE_TABLE \u0026#34;DROP TABLE IF EXISTS test_table\u0026#34; #define CREATE_SAMPLE_TABLE \u0026#34;CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(10),\\ col3 VARCHAR(10))\u0026#34; #define sql01 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(10, \u0026#39;AAA\u0026#39;, \u0026#39;A1\u0026#39;)\u0026#34; #define sql02 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(20, \u0026#39;BBB\u0026#39;, \u0026#39;B2\u0026#39;)\u0026#34; #define sql03 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(30, \u0026#39;CCC\u0026#39;, \u0026#39;C3\u0026#39;)\u0026#34; #define sql04 \u0026#34;INSERT INTO test_table(col1,col2,col3) VALUES(40, \u0026#39;DDD\u0026#39;, \u0026#39;D4\u0026#39;)\u0026#34; int main(void) { int ret = 0; MYSQL *mysql = mysql_init(NULL); mysql = mysql_real_connect(mysql, \u0026#34;localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;mydb2\u0026#34;, 0, NULL, 0); if (mysql == NULL) { ret = mysql_errno(mysql); printf(\u0026#34;func mysql_real_connect() err：%d\\n\u0026#34;, ret); return ret; } printf(\u0026#34; --- connect ok......\\n\u0026#34;);\tif (mysql_query(mysql, DROP_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; DROP TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); } if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) { fprintf(stderr, \u0026#34; CREATE TABLE failed\\n\u0026#34;); fprintf(stderr, \u0026#34; %s\\n\u0026#34;, mysql_error(mysql)); exit(0); }\tret = mysql_OperationTran(mysql); //开启事务，并修改事务属性为手动commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql01);\t//向表中插入第一行数据 ‘AAA’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret);\treturn ret; } ret = mysql_query(mysql, sql02);\t//向表中插入第二行数据 ‘BBB’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Commit(mysql); //手动提交事务 if (ret != 0) { printf(\u0026#34;mysql_Commit() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_AutoTran(mysql); // =再次= 修改事务属性为【自动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_OperationTran(mysql); // =再次= 修改事务属性为【手动】commit if (ret != 0) { printf(\u0026#34;mysql_OperationTran() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql03);\t//向表中插入第三行数据 ‘CCC’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_query(mysql, sql04);\t//向表中插入第四行数据 ‘DDD’ if (ret != 0) { printf(\u0026#34;mysql_query() err:%d\\n\u0026#34;, ret); return ret; } ret = mysql_Rollback(mysql);\t//直接rollback操作 if (ret != 0) { printf(\u0026#34;mysql_Rollback() err:%d\\n\u0026#34;, ret); return ret; } //rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。 mysql_close(mysql); return 0;\t} 对应参考API手册。中文：25.2.3.2.\t英文：23.8.7.2\n","date":"2022-01-05T20:21:29+08:00","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93api%E5%BA%93/","title":"MySQL数据库API库"},{"content":" 1 MySQL基础知识 瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。\nMySQL是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低、MySQL软件采用了双授权政策，分为社区版和企业版。\n1.1 MySQL版本及下载 MySQL数据库版本相对比较繁杂。常见的有：Community社区版、Enterprise企业版。\nMySQL Community Server 版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。\nMySQL Enterprise Edition 企业版收费的，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。\n其中Community Server 可以直接从mysql 的官网下载。但Enterprice Edition只能从Oracle edelivery上下载，而Edelivery有时会屏蔽中国IP。\nMySQL各版本区别参见：\nhttp://www.admin10000.com/Document/62.html\n下载mysql时注意区分版本细节及所应用的系统平台：linux(32/64) 、win(32/64)\n举例：\nwin版本：\nmysql-installer-community-8.0.26.0.msi版本\n​ GA 是指软件的通用版本，一般指正式发布的版本 (Generally Available (GA) Release)\n​ mysql-essential-5.1.60-win32.msi精简版，如果只需要mysql服务，就选择此版本。\n​ mysql-5.1.60-win32.msi 是完 是整版，包含安装程序和配置向导，有MySQL文档。\nmysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导\n​ mysql-5.1.60.zip 是用于windows的Mysql源码压缩包\nlinux版本\n​ 在http://www.mysql.com/downloads/网站上下载不了\n​ 在 www.oracle.com/downloads 找mysql 注册用户, 选择操作系统平台和mysql版本 进行下载\n官方文档上有关MySQL安装，介绍了3种类型及其对应安装方式来安装MySQL数据库：\nLinux supports a number of different solutions for installing MySQL. The recommended method is to use one of the distributions from Oracle. If you choose this method, there are three options available:\n(1) Installing from a generic binary package in .tar.gz format. See Section 2.2,“Installing MySQL from Generic Binaries on Unix/Linux”for more information.\n(2) Extracting and compiling MySQL from a source distribution. For detailed instructions, see Section 2.9, “Installing MySQL from Source”.\n(3) Installing using a pre-compiled RPM package. For more information on using the RPM solution, see Section 2.5.1,“Installing MySQL from RPM Packages on Linux”\n我们选用较简单的RPM 包来安装。\n1.2 下载安装包 Community Server 下载地址：https://dev.mysql.com/downloads/mysql/\nMySQL Community Server. mysql社区版，开源、免费\nMySQL Enterprise Edition. mysql企业版，非免费\nMySQL Cluster. mysql集群版，开源、免费\n2 MySQL服务器安装和启动 2.1 查询服务器上已经安装的mysql ​ 在终端提示符输入：rpm -aq | grep mysql 命令。查询结果如下显示：\nqt-mysql-4.6.2-25.el6.x86_64 mysql-connector-odbc-5.1.5r1144-7.el6.x86_64 mysql-bench-5.1.66-2.el6_3.x86_64 mysql-devel-5.1.66-2.el6_3.x86_64 libdbi-dbd-mysql-0.8.3-5.1.el6.x86_64 mysql-test-5.1.66-2.el6_3.x86_64 mysql-libs-5.1.66-2.el6_3.x86_64 mysql-5.1.66-2.el6_3.x86_64 mysql-connector-java-5.1.17-6.el6.noarch mysql-server-5.1.66-2.el6_3.x86_64 ​ 注：各机器有可能不相同，软件列表视实际情况。\n2.2 卸载旧的版本 rpm -e 软件包名 \u0026ndash;nodeps \u0026ndash;allmatches (不理会依赖关系，删除所有上一步查出来的相同的mysql)\n[root@localhost home]# rpm -e mysql-connector-odbc-3.51.26r1127-1.el5 --nodeps --allmatches [root@localhost home]# rpm -e libdbi-dbd-mysql-0.8.1a-1.2.2 --nodeps --allmatches [root@localhost home]# rpm -e mysql-server-5.0.77-3.el5 --nodeps --allmatches [root@localhost home]# rpm -aq | grep mysql [root@localhost home]# ​ 将老版本的几个文件手动删除\nrm -f /etc/my.cnf rm -rf /var/lib/mysql rm -rf /var/share/mysql rm -rf /usr/bin/mysql* 2.3 安装 解压.zip安装包\nunzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip 得到如下软件包：\nMySQL-client-advanced-5.6.20-1.el6.x86_64.rpm MySQL-devil-advanced-5.6.20-1.el6.x86_64.rpm MySQL-server-advanced-5.6.20-1.el6.x86_64.rpm MySQL-embedded-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-advanced-5.6.20-1.el6.x86_64.rpm MySQL-shared-compal-advanced-5.6.20-1.el6.x86_64.rpm MySQL-test-advanced-5.6.20-1.el6.x86_64.rpm README.txt 2.3.1 安装服务器 rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER ! You will find that password in \u0026#39;/root/.mysql_secret\u0026#39;. You must change that password on your first connect, no other statement but \u0026#39;SET PASSWORD\u0026#39; will be accepted. See the manual for the semantics of the \u0026#39;password expired\u0026#39; flag. Also, the account for the anonymous user has been removed. In addition, you can run: /usr/bin/mysql_secure_installation which will also give you the option of removing the test database. This is strongly recommended for production servers. See the manual for more instructions. Please report any problems at http://bugs.mysql.com/ The latest information about MySQL is available on the web at http://www.mysql.com Support MySQL by buying support/licenses at http://shop.mysql.com New default config file was created as /usr/my.cnf and will be used by default by the server when you start it. You may edit this file to change server settings 2.3.2 安装客户端： rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm 说明:不安装mysql-client是不能使用mysql工具登陆到mysql数据库\n​ 其他软件包选择性安装： rpm -ivh MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm\n2.4 查看mysql服务器是否已经启动 # 查看状态 systemctl status mysqld # 启动mysql systemctl start mysqld # 关闭mysql systemctl stop mysqld # 重新启动mysql systemctl restart mysqld # 开机启动mysql systemctl enable mysqld # 关闭开机启动mysql systemctl disable mysqld # 另外一种操作方式 service mysqld status 2.5 登录Mysql oracle收购Mysql后, 新版的mysql刚安装完mysql后不能直接输入mysql登录数据库, 而是设置了默认free password密码, 默认密码放在了/root/.mysql_secret文件中, 登陆后需要修改密码。\n1.查看文件寻找密码 cat /root/.mysql_secret 2.以root用户身份登陆MySQL 服务启动和关闭：\nservice mysql start service mysql stop ps -u mysql #可以查看mysql用户（安装MySQL时，系统自动创建该用户）的进程\nPID TTY TIME CMD 7586 ? 00:00:50 mysqld 守护进程 登陆服务器：\nmysql -uroot –p 密码\n输入从.mysql_secret中读到的密码登录。\n如果登录期间发生异常，无法登陆：\n使用root将mysql的后台进程kill -9 PID\n3.修改密码 mysql\u0026gt; set password=password('123456'); 将密码设置为：123456\n密码修改成后，再次登录使用：\n$mysql -uroot -p123456 即可。\n4.查看数据库 mysql\u0026gt; show databases; 5.远程root登录mysql 5.1Mysql8.0创建用户和授权 mysql8.0需要先创建用户和设置密码,然后才能授权.\n#先创建一个用户 create user \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123123\u0026#39;; #再进行授权 grant all privileges on *.* to \u0026#39;tone\u0026#39;@\u0026#39;%\u0026#39; with grant option; 5.2MySQL8.0 的远程链接 MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题.\n5.2.1登录MySQL mysql -u root -p #然后输入您的密码 5.2.2选择 mysql 数据库 use mysql; --因为 mysql 数据库中存储了用户信息的 user 表。 5.2.3在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 select host, user, authentication_string, plugin from user; --执行完上面的命令后会显示一个表格 --查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。 5.2.4授权 root 用户的所有权限并设置远程访问 GRANT ALL ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;你自己的密码\u0026#39;; 5.2.5刷新权限 --所有操作后，应执行 flush privileges; 5.2.6查看 root 用户的 host use mysql;\rselect host, user, authentication_string, plugin from user;\r--会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。\r5.3访问数据库 --输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.7 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。 --出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password. --解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. --这里采用第二种方式 ： --修改加密规则: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39; PASSWORD EXPIRE NEVER; password 为你当前密码。 --更新 root 用户密码: ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; password 为你新设置的密码。 --刷新权限: FLUSH PRIVILEGES; --OK，设置完成，再次使用 Navicat 连接数据库 6. 数据库的CURD 对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。\n6.1查看数据库 显示所有数据库 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | itcast | | itcast1 | | itcast2 | | mysql | | performance_schema | | sys | +--------------------+ 7 rows in set (0.01 sec) 显示创建数据库的语句信息 mysql\u0026gt; show create database itcast; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | itcast | CREATE DATABASE `itcast` /*!40100 DEFAULT CHARACTER SET utf8 */ | +----------+-----------------------------------------------------------------+ 1 row in set (0.00 sec) /* `itcast` 两端是反单引号, esc下的键, 使用``包含数据库的名字是区分大小写的 */ 使用数据库 /* 我们以root用户登录, 用户下有很多数据库, 需要指定, 当前使用哪一个数据库, 操作的就是那个数据库中的数据 */ mysql\u0026gt; use itcast1; Database changed mysql\u0026gt; use itcast2; Database changed 6.2创建数据库 -- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句\r-- create_specification是建库的一些选项\r-- 关键字不区分大小写\rCREATE {DATABASE} [IF NOT EXISTS] db_name\r[create_specification [, create_specification] ...]\r创建一名为itcast的数据库 mysql\u0026gt; create database itheima; /* utf8 */ 创建一个使用 latin1 字符集的数据库 mysql\u0026gt; create database itheima character set latin1; 6.3修改数据库 -- 修改字符集, 不能改名 alter database itcast character set utf8; 6.4删除数据库 drop database itcast; 7. 表的CURD 对表本身进行操作：创建，查看，修改，删除\n7.1 查看表 查看当前数据库下的数据库表\n\u0026ndash; 当前使用的数据库下的表 mysql\u0026gt; show tables;\n查看指定表的创建语句\nmysql\u0026gt; show create table 表名;\n查看表结构\nmysql\u0026gt; desc 表名;\n7.2创建表 mysql中表名区分大小写, 列名不区分大小写\n数据类型 float/double: 指定精确到小数点以后第几位, 比如: 精确到后3位 通过计算得到一个数据: 12.345678 这个数的678会被抹掉 decimal 完整的保存精度, 最少有小数后有两位 12.3 保存为: 12.30 创建表 create table 表名( 列名 text [default \u0026#39;xxx\u0026#39;], 列名 类型 [default value], 类名 类型 [default value], ...... ); 7.3修改表 修改表名\n-- oracle和mysql相同 rename table oldN to newN; 添加一个字段\n-- oracle alter table 表名 add 列名 列的类型; -- mysql alter table 表名 add column 列名 列的类型; 修改一个字段\n-- oracle alter table 表名 modify 列名 列的类型; -- mysql alter table 表名 modify column 列名 列的类型; 删除一个字段\n-- mysql和oracle相同 alter table 表名 drop column 列; -- mysql中没有对对字段的rename操作 修改表的字符集\nalter table 表名 character set utf8; 7.4 删除表 drop table 表名; -- oracle中可以这么做, mysql中不行 drop table 表名 purge 8. 表数据的CURD 插入数据\n表名后的列名什么时候可以省略? 在values(列的值, 列的值, \u0026hellip;.)中将表有的字段值都指定出来的时候, 列名可以省略 insert into 表名[(列名, 列名, ...)] values(列的值, 列的值, ....); 更新数据\nupdate 表名 set 列名=新值 where 列名=值; 删除数据\ndelete from 表名; -- 删除所有行 delete from 表名 where 列名=值; -- 删除满足条件的行 查询数据\nselect *|列名|表达式 from 表名 where 条件 group by 列名 having 条件 order by asc|desc; 练习\n创建数据库 student 表 create table student( id int, name varchar(20), chinese int, english int, math int ); 插入数据 insert into student(id,name,chinese,english,math) values(1, \u0026#39;范建\u0026#39;,80,85,90); insert into student(id,name,chinese,english,math) values(2,\u0026#39;罗况\u0026#39;,90,95,95); insert into student(id,name,chinese,english,math) values(3,\u0026#39;杜子腾\u0026#39;,80,96,96); insert into student(id,name,chinese,english,math) values(4,\u0026#39;范冰\u0026#39;,81,97,85); insert into student(id,name,chinese,english,math) values(5,\u0026#39;申晶冰\u0026#39;,85,84,90); insert into student(id,name,chinese,english,math) values(6,\u0026#39;郝丽海\u0026#39;,92,85,87); insert into student(id,name,chinese,english,math) values(7,\u0026#39;郭迪辉\u0026#39;,75,81,80); insert into student(id,name,chinese,english,math) values(8,\u0026#39;拎壶冲\u0026#39;,77,80,79); insert into student(id,name,chinese,english,math) values(9,\u0026#39;任我行\u0026#39;,95,85,85); insert into student(id,name,chinese,english,math) values(10,\u0026#39;史泰香\u0026#39;,94,85,84); 查询表中所有学生的信息。 查询表中所有学生的姓名和对应的英语成绩。 将第二步查询结果中的重复成绩过滤掉。\n在所有学生英语分数上加10分特长分。\n统计每个学生的总分。\n使用别名表示学生分数\n查询姓名为何东的学生成绩\n查询英语成绩大于90分的同学\n查询总分大于250分的所有同学\n查询英语分数在 85－95之间的同学。\n查询数学分数为84,90,91的同学。\n查询所有姓何的学生成绩。\n查询数学分\u0026gt;85，语文分\u0026gt;90的同学。\n对数学成绩排序后输出。\n对总分排序后输出，然后再按从高到低的顺序输出\n对姓何的学生成绩排序输出\n统计一个班级共有多少学生？\n统计数学成绩大于90的学生有多少个？\n统计总分大于250的人数有多少？\n统计一个班级数学总成绩？\n统计一个班级语文、英语、数学各科的总成绩\n统计一个班级语文、英语、数学的成绩总和\n求一个班级数学平均分？\n求一个班级总分平均分\n求班级最高分和最低分\n9. mysql函数的使用 9.1 日期函数 MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。\n-- 当前时间: now() == sysdate() mysql\u0026gt; select sysdate() from dual; +---------------------+ | sysdate() | +---------------------+ | 2019-12-02 09:03:42 | +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select now() from dual; +---------------------+ | now() | +---------------------+ | 2019-12-02 09:04:35 | +---------------------+ 1 row in set (0.00 sec) -- addtime(time, s) 给当前实际, 添加对应的秒数 select addtime(\u0026#39;09:04:35\u0026#39;,20) from dual; +------------------------+ | addtime(\u0026#39;09:04:35\u0026#39;,20) | +------------------------+ | 09:04:55 | +------------------------+ -- 当前日期: 年, 月, 日 mysql\u0026gt; select current_date() from dual; +----------------+ | current_date() | +----------------+ | 2019-12-02 | +----------------+ 1 row in set (0.00 sec) -- 当前时间: 时, 分, 秒 mysql\u0026gt; select current_time() from dual; +----------------+ | current_time() | +----------------+ | 09:08:10 | +----------------+ 1 row in set (0.00 sec) -- 时间戳 mysql\u0026gt; select current_timestamp() from dual; +---------------------+ | current_timestamp() | +---------------------+ | 2019-12-02 09:09:47 | +---------------------+ 1 row in set (0.00 sec) -- 将给定时间的日期取出 select date(now()) from dual; +-------------+ | date(now()) | +-------------+ | 2019-12-02 | +-------------+ 1 row in set (0.00 sec) -- date_add(), 第二个参数的type: 天: day, 月:month, 年: year mysql\u0026gt; select date_add(now(), interval 1 day) from dual; +---------------------------------+ | date_add(now(), interval 1 day) | +---------------------------------+ | 2019-12-03 09:14:57 | +---------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 month) from dual; +-----------------------------------+ | date_add(now(), interval 1 month) | +-----------------------------------+ | 2020-01-02 09:15:27 | +-----------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_add(now(), interval 1 year) from dual; +----------------------------------+ | date_add(now(), interval 1 year) | +----------------------------------+ | 2020-12-02 09:15:37 | +----------------------------------+ 1 row in set (0.00 sec) -- 计算两个日期的差值 mysql\u0026gt; select datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2019-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | 333 | +-------------------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;); +-------------------------------------------------------+ | datediff(\u0026#39;2018-12-01 09:18:06\u0026#39;, \u0026#39;2019-1-02 09:18:06\u0026#39;) | +-------------------------------------------------------+ | -32 | +-------------------------------------------------------+ 1 row in set (0.00 sec) -- 单独显示当前年, 月, 日 select year(now()) \u0026#34;年\u0026#34;, month(now()) \u0026#34;月\u0026#34;, day(now()) \u0026#34;日\u0026#34; from dual; -- 单独显示当前日期, 时间, 时间戳 -- 显示昨天, 今天, 明天 select date_sub(now(), interval 1 day), now(), date_add(now(), interval 1 day) from dual; 9.2 字符串函数 -- 字符串连接 -- mydql中可以连接多个字符串, oracle中只能连接两个字符串 mysql\u0026gt; select concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) from dual; +-------------------------------------------------+ | concat(\u0026#34;hello\u0026#34;, \u0026#34; world\u0026#34;, \u0026#34; 你好,\u0026#34;, \u0026#34;世界\u0026#34;) | +-------------------------------------------------+ | hello world 你好,世界 | +-------------------------------------------------+ -- 大小写转换 mysql\u0026gt; select ucase(\u0026#34;hello\u0026#34;), lcase(\u0026#34;WORLD\u0026#34;) from dual; +----------------+----------------+ | ucase(\u0026#34;hello\u0026#34;) | lcase(\u0026#34;WORLD\u0026#34;) | +----------------+----------------+ | HELLO | world | +----------------+----------------+ 1 row in set (0.00 sec) -- 字符串截取, 从左侧开始 mysql\u0026gt; select left(\u0026#34;hello,world\u0026#34;, 5) from dual; +------------------------+ | left(\u0026#34;hello,world\u0026#34;, 5) | +------------------------+ | hello | +------------------------+ 1 row in set (0.00 sec) -- 字符串比较 mysql\u0026gt; select strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;abc\u0026#34;, \u0026#34;bca\u0026#34;) | +----------------------+ | -1 | -- 小于 +----------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) from dual; +---------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aa\u0026#34;) | +---------------------+ | 1 | -- 大于 +---------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) from dual; +----------------------+ | strcmp(\u0026#34;aaa\u0026#34;, \u0026#34;aaa\u0026#34;) | +----------------------+ | 0 | -- 等于 +----------------------+ 1 row in set (0.00 sec) 9.3 数学函数 \u0026ndash; 向上取整 \u0026ndash; mysql ceiling(小数) \u0026ndash; oracle ceil(小数)\n-- 进制转换 mysql\u0026gt; select conv(100, 10, 16) from dual; +-------------------+ | conv(100, 10, 16) | +-------------------+ | 64 | +-------------------+ -- 保留指定的小数位数, 可以四舍五入 mysql\u0026gt; select format(12.345, 2) from dual; +-------------------+ | format(12.345, 2) | +-------------------+ | 12.35 | +-------------------+ 1 row in set (0.00 sec) -- 取集合中的最小值 mysql\u0026gt; select least(12, 1, 3, 4, 0) from dual; +-----------------------+ | least(12, 1, 3, 4, 0) | +-----------------------+ | 0 | +-----------------------+ 1 row in set (0.00 sec) -- 生成随机数 -- 生成的随机数范围: 0-1 mysql\u0026gt; select rand(now()) from dual; +--------------------+ | rand(now()) | +--------------------+ | 0.8633374812671333 | +--------------------+ 1 row in set (0.00 sec) 9.4 日期转换 -- oracle 日期格式: yyyy-mm-dd hh24:mi:ss 不区分大小写 to_char() 日期转字符串 to_date() 字符串转日期 -- mysql 日期格式: %Y-%m-%d %H:%i:%s 区分大小写 date_format() 日期转字符串 str_to_date() 字符串转日期 值 含义 秒 %S、%s 两位数字形式的秒（ 00,01, \u0026hellip;, 59） 分 %i 两位数字形式的分（ 00,01, \u0026hellip;, 59） 小时 %H 24小时制，两位数形式小时（00,01, \u0026hellip;,23） %h 12小时制，两位数形式小时（00,01, \u0026hellip;,12） %k 24小时制，数形式小时（0,1, \u0026hellip;,23） %l 12小时制，数形式小时（0,1, \u0026hellip;,12） %T 24小时制，时间形式（HH:mm:ss） %r 12小时制，时间形式（hh:mm:ss AM 或 PM） %p AM上午或PM下午 周 %W 一周中每一天的名称（Sunday,Monday, \u0026hellip;,Saturday） %a 一周中每一天名称的缩写（Sun,Mon, \u0026hellip;,Sat） %w 以数字形式标识周（0=Sunday,1=Monday, \u0026hellip;,6=Saturday） %U 数字表示周数，星期天为周中第一天 %u 数字表示周数，星期一为周中第一天 天 %d 两位数字表示月中天数（01,02, \u0026hellip;,31） %e 数字表示月中天数（1,2, \u0026hellip;,31） %D 英文后缀表示月中天数（1st,2nd,3rd \u0026hellip;） %j 以三位数字表示年中天数（001,002, \u0026hellip;,366） %M 英文月名（January,February, \u0026hellip;,December） %b 英文缩写月名（Jan,Feb, \u0026hellip;,Dec） %m 两位数字表示月份（01,02, \u0026hellip;,12） %c 数字表示月份（1,2, \u0026hellip;,12） 年 %Y 四位数字表示的年份（2015,2016\u0026hellip;） %y 两位数字表示的年份（15,16\u0026hellip;） 文字输出 %文字 直接输出文字内容 date类型装换为varchar类型\n-- date_format(日期, fmt) mysql\u0026gt; select date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) from dual; +-----------------------------------------+ | date_format(now(), \u0026#39;%Y/%m/%d %H:%i:%s\u0026#39;) | +-----------------------------------------+ | 2019/12/02 10:07:37 | +-----------------------------------------+ varchar类型转换为date类型\n-- 参数fmt的个数应该和日期字符串的形式一致 -- str_to_date(日期字符串, fmt) mysql\u0026gt; select str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) from dual; +---------------------------------------------------------+ | str_to_date(\u0026#34;2019/12/02 10:07:37\u0026#34;, \u0026#34;%Y/%m/%d %H:%i:%s\u0026#34;) | +---------------------------------------------------------+ | 2019-12-02 10:07:37 | +---------------------------------------------------------+ 1 row in set (0.00 sec) 10. 多表查询 -- 分组函数 count(); -- 求总数 avg(); -- 求平均值 sum(); -- 求和 min(); -- 最小值 max(); -- 最大值 -- having 必须出现在group by 后边, 不能写where -- where 写在 from 的后边 -- order by: 默认升序 asc, 降序 desc select 列名|表达式 as \u0026#34;别名\u0026#34; from 表名 \u0026#34;表的别名\u0026#34; where 表达式 group by 列名 having 条件 order by asc | desc -- 求两个表的笛卡尔积 cross join -- 最简单的两个表查询 select * from dept, emp; select * from dept cross join emp; 10.1 内连接 \u0026ndash; inner join 显示部门名称, 部门编号, 员工编号,和员工姓名\n-- mysql+oracle select d.deptno, d.dname, e.empno, e.ename from dept d, emp e where d.deptno=e.deptno; -- mysql+oracle -- 将表之间的逗号替换为 inner join --\u0026gt; 简写为 join -- 将 where 替换为 on select d.deptno, d.dname, e.empno, e.ename from dept d join emp e on d.deptno=e.deptno; 10.2 外连接 \u0026ndash; outer join 外连接: 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 必须使用外连接的方式, 才能够使其显示在结果集中.\n按部门统计员工人数，显示如下信息：部门号，部门名称，人数(所有部门的人数都统计)\n左外连接 \u0026ndash; left outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where d.deptno=e.deptno(+) group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: left outer join -\u0026gt; outer 可以省略 -\u0026gt; left join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from dept d left outer join emp e on d.deptno=e.deptno group by d.deptno, d.dname; 右外连接 \u0026ndash; right outer join -- oracle select d.deptno, d.dname, count(e.empno) from dept d, emp e where e.deptno(+)=d.deptno group by d.deptno, d.dname; -- mysql + oracle -- 表之间的逗号替换为: right outer join -\u0026gt; outer 可以省略 -\u0026gt; right join -- where -\u0026gt; on select d.deptno, d.dname, count(e.empno) from emp e right join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 全外连接 \u0026ndash; full outer join 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 不知道的那个表的字段不满足条件或者是左侧不满足条件或右侧表不满足条件, 需要将这些不满条件对数据全部显示到结果集中, 可以使用全外连接.\n两个表互相补充 -- 在mysql中不支持全外连接, oracle中是支持的 -- full outer join -\u0026gt; 简写: full join -- 有可能emp表给dept提供补充, 也有可能dept给emp提供补充 select d.deptno, d.dname, count(e.empno) from emp e full join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 10.3 自连接 查询员工、老板信息，显示: xxx的老板是xxx\n-- oracle select e.ename \u0026#34;员工\u0026#34;, nvl(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e, emp b where e.mgr=b.empno(+); -- mysql -- mysql 中的ifnull 等价于 oracle 中的 nvl select e.ename \u0026#34;员工\u0026#34;, ifnull(b.ename, \u0026#39;jump\u0026#39;) \u0026#34;领导\u0026#34; from emp e left join emp b on e.mgr=b.empno; 11. 表的约束 create table 表名( 列名 列的类型 default 默认值, 列名 列的类型, 列名 列的类型 ); 11.1 约束种类 mysql中常用的约束有五种:\n主键约束　primary key\n非空 + 唯一 主键自动增长　auto_increment\n给主键用的, 只有列是主键才能加这个约束 主键是数字的时候使用 唯一约束　unique\n非空约束　not null\n外键约束　foreign key\n检查约束 check (在MySQL中语法保留，但没有效果)\n11.2 约束的使用 create table persion( id int, -- 主键, 自动增长 age int, -- 非空 name varchar(20), -- 唯一 deptno int -- 外键 ); 表级别的约束 -- auto_increment只能放到列的位置 -- not null 非空只能在列上添加约束 create table persion( id int auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20), -- 唯一 deptno int, -- 外键 constraint pk_id_xxx primary key(id) , constraint un_name_xxx unique(name), constraint fk_deptno_xx foreign key(deptno) references dept(deptno) ); 列级别的约束 create table persion1( id int primary key auto_increment, -- 主键, 自动增长 age int not null, -- 非空 name varchar(20) unique, -- 唯一 deptno int references dept(deptno) -- 外键 ); 12. 事务 在mysql中事务默认是自动提交的，oracle中默认是手动提交的。\n原子性 一致性 隔离性 永久性 -- 修改事务提交方式 -- 手动提交 mysql\u0026gt; set autocommit=0; Query OK, 0 rows affected (0.00 sec) -- 提交数据 mysql\u0026gt; commit; Query OK, 0 rows affected (0.00 sec) -- 数据回滚 mysql\u0026gt; rollback; Query OK, 0 rows affected (0.00 sec) -- 自动提交 mysql\u0026gt; set autocommit=1; Query OK, 0 rows affected (0.00 sec) 13. mysql API 初始化连接环境 连接mysql的服务器 执行sql语句 查询 插入 更新 删除 创建/删除/修改数据库表 如果是插入/删除/修改数据等操作只能看到状态 成功 失败 如果sql语句是查询, 得到结果集 遍历结果集 释放资源 初始化连接环境 // 参数: NULL // 返回值: 返回函数申请的内存的地址 MYSQL *mysql_init(MYSQL *mysql) 连接mysql服务器 // 返回值: 失败-\u0026gt; NULL, 成功了-\u0026gt; 返回值和第一个参数的地址相同 MYSQL *mysql_real_connect( MYSQL *mysql, // mysql_init函数的返回值 // 本地: localhost, 远程连接:192.168.xx.xx; const char *host, // mysql服务器地址, IP/主机名 const char *user, // mysql数据用户名, root const char *passwd, // root用户的密码 const char *db, // 数据库的名字 // 如果port==0, 使用默认端口, !=0是使用指定的端口 unsigned int port, // 数据库的端口, 默认3306 const char *unix_socket, // NULL unsigned long client_flag // 0 ); 执行sql语句 // 添删查改的sql语句都是可以执行的 // 参数: // mysql: mysql_real_connect()函数的返回值 // query: sql语句, 语句的结尾不要加 ; // 返回值: 成功-\u0026gt; 0, 失败-\u0026gt;非0 int mysql_query(MYSQL *mysql, const char *query); 获取结果集 // 将结果集保存到本地内存中 // 返回值: 错误-\u0026gt;null, 成功-\u0026gt;非空 // 参数 mysql: mysql_real_connect() 返回值 // 结果集中保存了多条记录, 每条记录中有若干个字段 MYSQL_RES *mysql_store_result(MYSQL *mysql); 得到结果集的列数 unsigned int mysql_num_fields(MYSQL_RES *result) 获取表头 -\u0026gt; 列名(字段名) / mysql.h typedef struct st_mysql_field { char *name; /* Name of column */ char *org_name; /* Original column name, if an alias */ char *table; /* Table of column if column was a field */ char *org_table; /* Org table name, if table was an alias */ char *db; /* Database for table */ char *catalog; /* Catalog for table */ char *def; /* Default value (set by mysql_list_fields) */ unsigned long length; /* Width of column (create length) */ unsigned long max_length; /* Max width for selected set */ unsigned int name_length; unsigned int org_name_length; unsigned int table_length; unsigned int org_table_length; unsigned int db_length; unsigned int catalog_length; unsigned int def_length; unsigned int flags; /* Div flags */ unsigned int decimals; /* Number of decimals in field */ unsigned int charsetnr; /* Character set */ enum enum_field_types type; /* Type of field. See mysql_com.h for types */ void *extension; } MYSQL_FIELD; // 返回值 中保存了所有的字段名, 返回值是一个数组 MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result); MYSQL_FIELD *fields = mysql_fetch_fields(result); for(int i=0; i\u0026lt;num; ++i) { fields[i].name } 遍历结果集 typedef char** MYSQL_ROW; // 函数每调用一次, 从结果集中取出一条记录(行) // 参数: 结果集, mysql_store_result()返回值 // 返回值: char* row[], char**执向一个指针数组, 数组中的每一个元素都是一个字符串, 字符串就是字段值 // 不管字段原来是什么类型, 结果集中都是以字符串形式保存的 // 如果还有下一行返回非空, 没有下一行, 或者失败了返回NULL MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 资源回收 // 参数是 mysql_store_result() 函数的返回值 void mysql_free_result(MYSQL_RES *result); // 参数是: mysql_init() 函数的返回值 void mysql_close(MYSQL *mysql); 字符编码 // 获取字节编码 const char *mysql_character_set_name(MYSQL *mysql); // 设置字节编码 // csname: 编码的名字, utf8 int mysql_set_character_set(MYSQL *mysql, char *csname); 事务操作 // mode==0 -\u0026gt; 手动提交, mode1 -\u0026gt; 自动提交事务 my_bool mysql_autocommit(MYSQL *mysql, my_bool mode); my_bool mysql_commit(MYSQL *mysql); my_bool mysql_rollback(MYSQL *mysql); 打印错误信息 // 返回错误的描述 const char *mysql_error(MYSQL *mysql); // 返回错误的编号 unsigned int mysql_errno(MYSQL *mysql); 需要的头文件 #include \u0026lt;mysql.h\u0026gt; // 动态库名: libmysqlclient.so // 静态库名: libmysqlclient.a 搜索文件 find 路径 -name 文件名 locate 文件名 # centos # 切换到root下安装 yum install mlocate updatedb # 只需要做一次, 安装完成之后做 完整实例 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;mysql.h\u0026gt; int main() { MYSQL *mysql = mysql_init(NULL); if (mysql == nullptr) { printf(\u0026#34;mysql_init() failed\\n\u0026#34;); return -1; } mysql_real_connect(mysql, \u0026#34;192.168.213.128\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;zzc123\u0026#34;, \u0026#34;scott\u0026#34;, 0, NULL, 0); if (mysql == NULL) { printf(\u0026#34;mysql_real_connect() failed\\n\u0026#34;); return -1; } printf(\u0026#34;服务器连接成功!\\n\u0026#34;); printf(\u0026#34;原字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); mysql_set_character_set(mysql, \u0026#34;utf8\u0026#34;); printf(\u0026#34;现字符编码: %s\\n\u0026#34;, mysql_character_set_name(mysql)); int ret = mysql_query(mysql, \u0026#34;select * from emp\u0026#34;); if (ret != 0) { printf(\u0026#34;mysql_query(select) failed: %s\\n\u0026#34;, mysql_error(mysql)); return -1; } MYSQL_RES *res = mysql_store_result(mysql); int colNum = mysql_num_fields(res); //fields是一个结构体数组 MYSQL_FIELD *fields = mysql_fetch_fields(res); for (int i = 0; i \u0026lt; colNum; i ++) { //遍历结构体内名字字段 printf(\u0026#34;%s\\t\u0026#34;, fields[i].name); } printf(\u0026#34;\\n\u0026#34;); //读取每一行 //二级指针 MYSQL_ROW row; while ((row = mysql_fetch_row(res)) != NULL) { for (int i = 0; i \u0026lt; colNum; i ++) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); } //释放结果集 mysql_free_result(res); //设置事务手动提交 mysql_autocommit(mysql, 0); //将下面的四个操作设置为事务 //插入数据 int fl1 = mysql_query(mysql, \u0026#34;insert into dept values(11, \u0026#39;海军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl2 = mysql_query(mysql, \u0026#34;insert into dept values(12, \u0026#39;革命军\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); int fl3 = mysql_query(mysql, \u0026#34;insert into dept values(13, \u0026#39;马戏团\u0026#39;, \u0026#39;china\u0026#39;)\u0026#34;); //更新数据 int fl4 = mysql_query(mysql, \u0026#34;update dept set dname=\u0026#39;群众\u0026#39; where loc=\u0026#39;china\u0026#39;\u0026#34;); //全部成功 if (!fl1 \u0026amp;\u0026amp; !fl2 \u0026amp;\u0026amp; !fl3 \u0026amp;\u0026amp; !fl4) { //提交事务 mysql_commit(mysql); } else { //事务回滚 mysql_roolback(mysql); } //释放资源 mysql_close(mysql); return 0; } mysql和oracle区别\n结构不同\nmsyql 基于数据库\n表存储在数据库中 oracle 基于用户的\n表属于用户 mysql没有表空间, oracle有表空间\n管理员\nmysql\nroot oralce\nsys -\u0026gt; 管理员, 身份 sysdba system -\u0026gt; 管理员, 登录的时候需要使用normal身份登录 其他的普通用户 事务\noracle默认手动提交\nocci接口 (C++接口), 这个接口中是自动提交事务的 mysql中默认是自动提交\nsql语句\n外连接\noralce中可以使用 (+) mysql中必须使用 , 不支持(+) right outer join -\u0026gt; oracle也支持这种写法 left outer join mysql不支持全外连接, oracle支持的 full outer join 函数:\nnvl -\u0026gt; oralce\nifnull -\u0026gt; mysql\n日期\n字符串\n数学函数\n建表的时候的约束指定\n都有:\n主键 -\u0026gt; primary key 非空: not null 唯一性: unique 外键约束: foreign key 不同:\noralce: check, 在mysql中也有, 但是不起作用 mysql 主键自动增长: auto_increment\n需要和主键约束一起使用 删除表\noracle\ndrop talbe 表名 purge; msyql\ndrop talbe 表名; \u0026ndash;\u0026gt; 不能使用 purge 字段的修改\noralce\n列的添加 alter table 表名 add 列名 列的属性; alter table 表名 modify 列名 列的属性; mysql\n列的添加修改 alter table 表名 add column 列名 列的属性; alter table 表名 modify column 列名 列的属性; ","date":"2022-01-05T12:57:29+08:00","permalink":"https://okokfun.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Mysql数据库"},{"content":" 推荐看👉 OI Wiki\n算法部分 位图(bitmap) 通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。\n位图BitMap\n字典(map) 字典有什么特点呢?\n字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情况下取出这些信息. 使用数组的方式: [18, \u0026ldquo;Coderwhy\u0026rdquo;, 1.88]. 可以通过下标值取出信息. 使用字典的方式: {\u0026ldquo;age\u0026rdquo; : 18, \u0026ldquo;name\u0026rdquo; : \u0026ldquo;Coderwhy\u0026rdquo;, \u0026ldquo;height\u0026rdquo;: 1.88}. 可以通过key取出value 字典(map)的详细解释\nkmp算法 kmp算法也就是字符串匹配算法。\n比如： 在string str = \u0026ldquo;abcababcba\u0026quot;中匹配 string str2 = \u0026ldquo;ababc\u0026ldquo;字符串\n最长公共前后缀：要匹配的字符串生成的数组\n从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计\n0\ta\n0\ta\tb\n1\ta\tb\ta\n2\ta\tb\ta\tb\n0\ta\tb\ta\tb\tc\n得出的公共前后缀为\n0 0 1 2 0 然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为\n-1 0 0 1 2 kmp匹配过程\nabcababcba\nababc\n如果匹配到不相等元素，则通过next数组(P)决定next数组移动的位置，例如上图next数组(P)下标为2的元素与T字符串不相等，则看一下P数组下标2的next数组的值为0，则把next数组下标为0的位置移动到不匹配的地方\n如果next数组的值为-1则next数组整体右移，或找到T字符串与子字符串第一个元素(如果找到的话)，然后把P移动到此位置(T的剩余的元素大于等于子字符串元素个数)；\n代码\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 计算最长公共前后缀 void prefix_table(char pattern[], int prefix[], int n) { prefix[0] = 0; int len = 0; int i = 1; while (i \u0026lt; n) { if (pattern[i] == pattern[len]) { len++; prefix[i] = len; i++; } else { if (len \u0026gt; 0) { len = prefix[len - 1]; } else { prefix[i] = len; i++; } } } } // 计算next数组 void move_prefix_table(int table[], int n) { for (int i = n - 1; i \u0026gt; 0; --i) { table[i] = table[i - 1]; } table[0] = -1; } // kmp算法 void kmp_search(char text[], char pattern[]) { int n = strlen(pattern); int m = strlen(text); int *prefix = new int[n]; prefix_table(pattern, prefix, n); move_prefix_table(prefix, n); int i = 0; int j = 0; while (i \u0026lt; m) { if (j == n - 1 \u0026amp;\u0026amp; text[i] == pattern[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;Found pattern at \u0026#34; \u0026lt;\u0026lt; i - j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; j = prefix[j]; } if (text[i] == pattern[j]) { i++; j++; } else { j = prefix[j]; if (j == -1) { i++; j++; } } } delete[] prefix; } int main(void) { char pattern[] = \u0026#34;ABABCABAA\u0026#34;; char text[] = \u0026#34;ABABABCABAABABABAAB\u0026#34;; kmp_search(text, pattern); return 0; } 双指针 同向双指针 判断一个链表是否有环\n创建两个指针ptr1,ptr2,两个指针同时指向链表头结点。ptr1每次向后移动一个结点，ptr2每次移动2个结点，如果链表有环他们会指向同一个结点\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ bool samecircle(Node head) { // write your code here Node ptr2 = head; Node ptr2 = head; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 return true; } return false; } }; 判断环长\n第一次相遇代表有环，第二次相遇代表两个指针发生了套环，所以：\n环长 = 速度差 * 移动次数\n判断入环点\n慢指针ptr1每次走一步，所以走的距离是：\nd1 = D + X * (S1 + S2) + S1\n快指针ptr2走的距离是：\nd2 = D + N * (S1 + S2) + S1\n快指针速度是慢指针2倍。 即：\n2 * d1 = d2\n整理后的公式为\nD = (n - 2X - 1)(S1 + S2) + S2\n假设n - 2X -1的值为0，则D = S2;，那么我们就可以在首次相遇点的时候，定义一个指针指向链表的起点，一个指针指向首次相遇点，然后两个指针每次前进1步，当两个指针相遇的时候就是链表的入环点。\n例子：\nclass Solution { public: /** * @param circles: The value of 6 points on n rings * @return: Whether there are two same circles */ Node find_node(Node head) { // write your code here Node ptr1 = head; Node ptr2 = head; Node ptr3 = nullptr; Node ptr4 = nullptr; while (p1 != nullptr \u0026amp;\u0026amp; p2 != nullptr) { ptr1 = p1.next; ptr2 = p2.next.next; if (ptr1 == ptr2) // 结点相遇 ptr3 = head; ptr4 = ptr1; break; } if (ptr3 != nullptr \u0026amp;\u0026amp; != ptr4 != nullptr) { while(ptr3 != ptr4) { ptr3 = ptr3.next; ptr4 = ptr4.next; } return ptr4; } return nullptr; } }; 相向双指针 二分法 又称折半搜索，期望时间复杂度为O(log2n)，最差为O(log2(n + 1)) 二分法前提是数据已经有序\n在A[0] \u0026hellip; A[n]中搜索K。\n步骤： \\1. 令low = 0， high = n - 1，初始的查找区域为[low， high]. \\2. 取low和high的中间值mid = (low+high)/2。 \\3. 如果A[mid] = K，则返回mid, 如果不等，则重新确定查找区间。 \\4. 当low \u0026gt; high 时，则表示区间已经失效，如果还未找到，则表示数组中不包含K的值，返回-1。\ntemplate\u0026lt;class T\u0026gt; int binary_search(vector\u0026lt;T\u0026gt; \u0026amp;A, T K) { int low = 0; int high = A.size() - 1; while( low \u0026lt; high ) { int mid = (low + high)/2; if( A[mid] \u0026lt; K ) low = mid + 1; else if( A[mid] \u0026gt; k ) high = mid - 1; else return mid; } return -1; /*返回-1表示数组不存在K的值*/ } 二分答案 二分答案与二分查找 其实是不一样的\n二分答案: 即对你要求的答案进行二分 二分查找: 对一个已知的有序数据集上进行二分的查找\n基础算法·二分答案 - Potassium - 博客园 (cnblogs.com)\n分治法 分治分治，即分而治之。分治，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……直接说就是将一个难以直接解决的大问题，分割成一些规模比较小的相同的小问题，以便各个击破，分而治之。\n分治法所能解决的问题一般具有以下几个特征：\n\\1) 该问题的规模缩小到一定的程度就可以容易地解决\n\\2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。\n\\3) 利用该问题分解出的子问题的解可以合并为该问题的解；\n\\4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\n第一条: 特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；\n第二条: 特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、\n第三条: 特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。\n第四条: 特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。\n经典问题:\n二分查找\n棋盘覆盖\n汉诺塔问题\n归并排序/合并排序\n快速排序\n宽度优先搜索(BFS) 它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。\n基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。\n广度优先搜索原理与实践 - huansky - 博客园 (cnblogs.com)\nprivate Map\u0026lt;String, Boolean\u0026gt; status = new HashMap\u0026lt;String, Boolean\u0026gt;(); private Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); public void BFSSearch(String startPoint) { //1.把起始点放入queue； queue.add(startPoint); status.put(startPoint, false); bfsLoop(); } private void bfsLoop() { while(!queue.isEmpty()) { // 1) 从queue中取出队列头的点；更新状态为已经遍历。 String currentQueueHeader = queue.poll(); //出队 status.put(currentQueueHeader, true); System.out.println(currentQueueHeader); // 2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。 List\u0026lt;String\u0026gt; neighborPoints = graph.get(currentQueueHeader); for (String poinit : neighborPoints) { if (!status.getOrDefault(poinit, false)) { //未被遍历 if (queue.contains(poinit)) continue; queue.add(poinit); status.put(poinit, false); } } } } 拓扑排序法 拓扑排序指的是将有向无环图（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。 算法：拓扑排序 - 子烁爱学习 - 博客园 (cnblogs.com)\n拓扑排序算法及C语言实现 (biancheng.net)\n深度优先搜索/回溯法 (DFS) 深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。\n/** * DFS核心伪代码 * 前置条件是visit数组全部设置成false * @param n 当前开始搜索的节点 * @param d 当前到达的深度，也即是路径长度 * @return 是否有解 */ bool DFS(Node n, int d){ if (isEnd(n, d)){//路径长度为返回true，表示此次搜索有解 return true; } for (Node nextNode in n){//遍历跟节点n相邻的节点nextNode， if (!visit[nextNode]){//未访问过的节点才能继续搜索 //例如搜索到V1了，那么V1要设置成已访问 visit[nextNode] = true; //接下来要从V1开始继续访问了，路径长度当然要加 if (DFS(nextNode, d+1)){//如果搜索出有解 //例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解 return true; } //重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中 visit[nextNode] = false; } //到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。 } return false;//本次搜索无解 } 动态规划 它将问题分成小问题，并先着手解决这些小问题\n背包型DP 假设有三种商品，分别是小汽车1吨，卡车3吨，起重机4吨.价格分别是：3000，4000，6000。\n现在只能卖总共4吨的商品，怎么卖商品售价最高？\n所有的组合为：\n组合 价值 无 0 小汽车 3000 卡车 4000 起重机 6000 小汽车和起重机 重量过大 小汽车和卡车 7000 卡车和起重机 重量过大 小汽车,卡车，起重机 重量过大 可以看到随着商品种类增加组合也在飞速增长，时间复杂度为O(2^n),太慢了\n动态规划算法可以用网格描述\n填充这些表格最后就是背包问题的解法。\n当在小汽车一行时，其他种类的商品选不了，所以都是3000\n当加入卡车时1-2吨放不下3吨的卡车，3吨可以放下卡车，所以为4000，4吨可以放下一个卡车和一个小汽车，共7000\n加入起重机时，1-2背包只能装小汽车，3吨可以装一辆卡车，4吨可以装起重机，但是价格低于7000所以不选起重机的价格，定位卡车加小汽车，价格为7000.\n坐标型DP 又被称为网格型动态规划\n一个网格有m行n列，一个小动物从(0, 0)出发，每一步可以向下或向右走一步，最总到达(m - 1, n - 1)处\n最简单的动态规划类型 给定一个序列或者网格 需要找到序列中某个/些子序列或网格中的某条路径 某种性质最大/最小 计数 存在性 动态规划方程 f[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，f[i][j] 中下标 i , j 表示以格子( i , j )为结尾的满足条件的路径的性质 最大值/最小值 个数 存在性 坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质 D2-坐标型动态规划\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid==null||obstacleGrid.length==0){ return 0; } int [] [] dp = new int[obstacleGrid.length][obstacleGrid[0].length]; for(int i=0;i\u0026lt;obstacleGrid.length;i++){ for(int j=0;j\u0026lt;obstacleGrid[i].length;j++){ if(obstacleGrid[i][j]==1){//有障碍 dp[i][j]=0; continue; }else{ if(i == 0 \u0026amp;\u0026amp; j == 0) dp[i][j]=1;//没有障碍起点 else if(i==0) dp[i][j]=dp[i][j-1];//在第一行,上一题在没有障碍情况下默认是1,但是有障碍就取决于该行前面是否有障碍了 else if(j==0) dp[i][j]=dp[i-1][j];//第一列,没有障碍默认是1,有障碍就取决于该列前面是否有障碍了 else{ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } } } return dp[obstacleGrid.length-1][obstacleGrid[0].length-1]; } } 序列型DP D3-序列型动态规划\n双序列型DP D7-双序列型动态规划\n划分型DP 常见类型：\n1. 给定长度为N的序列或字符串，要求划分成若干段 - 段数不限，或指定K段 - 每一段满足一定的性质 2. 做法 - 类似于序列型动态规划，但是通常要加上段数信息 - 一般用`f[i][j]`记录前i个元素（元素0~i-1）分成 j 段的性质，如最小代价 D4 划分型动态规划\n记忆化搜索 记忆化搜索 - OI Wiki (oi-wiki.org)\n区间型DP D6-区间型动态规划\n状态压缩DP 状压 DP - OI Wiki (oi-wiki.org)\n博弈型DP D4-博弈型动态规划\n匹配型DP 数位 DP 数位 DP - OI Wiki (oi-wiki.org)\n树形DP 树形 DP - OI Wiki (oi-wiki.org)\n插头 DP 插头 DP - OI Wiki (oi-wiki.org)\n概率 DP 概率 DP - OI Wiki (oi-wiki.org)\n动态 DP 动态 DP - OI Wiki (oi-wiki.org)\n排序算法 排序简介 - OI Wiki (oi-wiki.org)\n外排序算法 排序之外部排序 - Judy518 - 博客园 (cnblogs.com)\n快速排序算法 快速排序 - OI Wiki (oi-wiki.org)\n欧拉路径 什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。\n欧拉路径详解 - TEoS - 博客园 (cnblogs.com)\n模拟法 模拟算法（C++）_1只小弛的博客-CSDN博客_c++模拟\nC++算法：模拟 - 无咕 - 博客园 (cnblogs.com)\n扫描线算法 扫描线是一种用于求矩阵面积并或者周长并的算法，可以使用 线段树 来优化。假设给定了平面上若干个可能相交的矩阵，需要求出它们的面积并（面积之和减去相交部分）或者周长并（外轮廓的长度）。我们可以虚拟出一条按顺序扫描整个平面的线段，通过对平行或垂直于 [Math Processing Error]x 轴的线段进行处理得到答案。\n扫描线 - Ling_Lover - 博客园 (cnblogs.com)\n枚举法 枚举法 - Huise.J - 博客园 (cnblogs.com)\n最短路径 看完就懂了！一篇搞定图论最短路径问题 - thousfeet - 博客园 (cnblogs.com)\n贪心法 贪心算法原理及其应用 - vcjmhg - 博客园 (cnblogs.com)\n最小生成树 最小生成树 - SeanOcean - 博客园 (cnblogs.com)\n狄克斯特拉算法 Dijkstra算法(一)之 C语言详解 - 如果天空不死 - 博客园 (cnblogs.com)\n近似算法 算法课堂笔记6—近似算法 - f91og - 博客园 (cnblogs.com)\n高精度计算 高精度计算\nLRU算法 缓存淘汰算法\n长期不被使用的数据，在未来被用到的几率也不大。如果缓存到达了预设值就要删除一些内容，给新的内容腾位置\n如何实现LRU算法？ - murphy_gb - 博客园 (cnblogs.com)\nA星寻路算法 A星寻路算法 - szmtjs10 - 博客园 (cnblogs.com)\nA星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com)\nA-Star（A*）寻路算法原理与实现 - 知乎 (zhihu.com)\n","date":"2022-01-01T19:32:29+08:00","permalink":"https://okokfun.github.io/post/%E7%AE%97%E6%B3%95/","title":"算法"},{"content":"\n1.点击home,再点击配置，然后填写nas的ip地址即可 ","date":"2021-12-26T13:43:29+08:00","permalink":"https://okokfun.github.io/post/nas/%E4%BB%8Eportainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/","title":"从Portainer点击端口号进入容器服务方法"},{"content":" 1. 安装完第三方插件后，再安装docker与portainer 2. 点击Opem Portainer创建管理账号 3. 然后创建一个容器网络 ","date":"2021-12-26T13:42:29+08:00","permalink":"https://okokfun.github.io/post/nas/openmediavault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8Egui%E5%B7%A5%E5%85%B7portainer/","title":"OpenMediaVault中docker与工具portainer"},{"content":" OpenMediaVault 国内软件源镜像服务器\n清华大学镜像 https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/ 北京外国语大学镜像 https://mirrors.bfsu.edu.cn/OpenMediaVault/ OMV 5\n一、编辑 sources.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list\u0026#39; 3. 编辑配置文件\nsudo nano /etc/apt/sources.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free 二、编辑 openmediavault-kernel-backports.list 1. 备份配置文件\nsudo cp /etc/apt/sources.list.d/openmediavault-kernel-backports.list /etc/apt/sources.list.d/openmediavault-kernel-backports.list.bak 2. 清空配置文件\nsudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault-kernel-backports.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault-kernel-backports.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian buster-backports main contrib non-free 三、编辑 openmediavault.list 1. 备份配置文件 sudo cp /etc/apt/sources.list.d/openmediavault.list /etc/apt/sources.list.d/openmediavault.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/openmediavault.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/openmediavault.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/public/ usul main 四、编辑 omvextras.list\n1. 备份配置文件 sudo cp /etc/apt/sources.list.d/omvextras.list /etc/apt/sources.list.d/omvextras.list.bak 2. 清空配置文件 sudo sh -c \u0026#39;echo \u0026gt; /etc/apt/sources.list.d/omvextras.list\u0026#39; 3. 编辑配置文件 sudo nano /etc/apt/sources.list.d/omvextras.list 复制并粘贴以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers usul main deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable deb http://linux.teamviewer.com/deb stable main 五. 刷新软件源 sudo apt update ","date":"2021-12-26T13:42:29+08:00","permalink":"https://okokfun.github.io/post/nas/openmediavault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/","title":"OpenMediaVault软件源修改"},{"content":" 要创建的容器有：\nMariadb: 关系型数据库，mysql的开源版本\rAdminer：开源的数据库管理软件\rGitea：开源的私人代码版本管理器\rFlarum：开源的论坛\rWordPress：开源的博客软件\rNextCloud：开源的私人网盘软件\r1.在一个分区上创建我们需要的文件夹存放配置文件 2.在终端拉取上面的各个镜像文件 1.flarum docker pull mondedie/flarum:latest\r2.wordpress docker pull wordpress\r3.adminer docker pull adminer\r4.mariadb docker pull mariadb\r5.gitea docker pull gitea/gitea\r6.nextcloud docker pull nextcloud\r3.创建各个容器 按顺序应该创建数据库软件与数据库管理软件 1.mariadb容器创建参考 container_name: mariadb\renvironment:\r- PUID=1000\r- PGID=1000\r- MYSQL_ROOT_PASSWORD=1\r- TZ=Asia/Shanghai\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/mariadb/config:/config\rports:\r- 3306:3306\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r2.adminer创建参考 container_name: adminer\renvironment:\r- ADMINER_DEFAULT_SERVER=mariadb\rports:\r- 8080:8080\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.flarum创建参考 3.1在映射的flarum根目录创建docker-compose.yaml version: \u0026quot;3\u0026quot;\rservices:\rflarum:\rimage: mondedie/flarum:stable\rcontainer_name: flarum\renv_file:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/flarum.env\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/assets:/flarum/app/public/assets\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/extensions:/flarum/app/extensions\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/nginx:/etc/nginx/flarum\r- /mnt/docker/flarum/storage/logs:/flarum/app/storage/logs\rports:\r- 8081:8888\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r3.2再创建flarum.env DEBUG=false\rFORUM_URL=http://192.168.1.105:8081\r# Database configuration\rDB_HOST=mariadb\rDB_NAME=flarum\rDB_USER=flarum\rDB_PASS=123456789\rDB_PREF=flarum_\rDB_PORT=3306\r# User admin flarum (environment variable for first installation)\r# /!\\ admin password must contain at least 8 characters /!\\\rFLARUM_ADMIN_USER=admin\rFLARUM_ADMIN_PASS=123456789\rFLARUM_ADMIN_MAIL=txt1994s@163.com\rFLARUM_TITLE=txt1994的论坛\r登录adminer,然后创建数据库\nDB_HOST=mariadb (地址)\rDB_NAME=flarum (数据库)\rDB_USER=flarum （用户）\rDB_PASS=123456789（密码）\r然后运行命令：\ndocker-compose up -d flarum\r安装中文插件\n=Beta 14\ndocker exec -ti flarum extension require ffans/lang-simplified-chinese\n安装emoji表情插件 docker exec -ti flarum extension require clarkwinkelmann/flarum-ext-emojionearea\n安装显示帖子阅读次数 docker exec -ti flarum extension require michaelbelgium/flarum-discussion-views\n安装flarum媒体增强插件 docker exec -ti flarum extension require fof/formatting\n表格支持插件\ndocker exec -ti flarum extension require askvortsov/flarum-markdown-tables\n代码高亮\ndocker exec -ti flarum extension require therealsujitk/flarum-ext-hljs\n4.gitea创建参考 container_name: gitea\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/gitea/data:/data\rports:\r- \u0026quot;3000:3000\u0026quot;\r- \u0026quot;2222:22\u0026quot;\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建数据库：\r- MYSQL_ROOT_PASSWORD=1\r- MYSQL_DATABASE=gitea\r- MYSQL_USER=gitea\r- MYSQL_PASSWORD=123456789\r5.wordpress创建参考 container_name: wordpress\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/wordpress/html:/var/www/html\rports:\r- 8082:80\renvironment:\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\rnetworks:\r- mynet\rrestart: always\rnetworks:\rmynet:\rexternal:\rname: mynet\r创建好数据库：\rWORDPRESS_DB_HOST: mariadb\rWORDPRESS_DB_USER: wordpress\rWORDPRESS_DB_PASSWORD: 123456789\rWORDPRESS_DB_NAME: wordpress\r6.nextcloud创建参考 container_name: nextcloud\rvolumes:\r- /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/nextcloud/html:/var/www/html\rports:\r- 8083:80 networks:\r- mynet restart: always\r创建好数据库：\renvironment:\r- MYSQL_PASSWORD=123456789\r- MYSQL_DATABASE=nextcloud\r- MYSQL_USER=nextcloud\r- MYSQL_HOST=mariadb ","date":"2021-12-26T13:41:29+08:00","permalink":"https://okokfun.github.io/post/nas/openmediavault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/","title":"OpenMediaVault创建容器"},{"content":" OpenMediaVault（omv）是开源的nas系统，本博客尽量采用开源的代码和软件\n1. 镜像下载 下载地址\nhttps://sourceforge.net/projects/openmediavault/files/latest/download 2. 刻录或虚拟机安装 可以用etcher软件刻录镜像\n安装 omv-extras 启用 OMV 5 社区插件支持 3. 安装依赖的工具 sudo apt --yes --no-install-recommends install dirmngr gnupg 4. 下载最新的omv-extras 安装包 地址：https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 下载命令：sudo wget https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb 5. 安装 sudo dpkg -i openmediavault-omvextrasorg_5.6.2_all.deb 6. 安装完开启docker扩展源 7. Docker修改镜像源并在OMV 中的安装和使用 Docker 设置国内镜像服务器\n第一步 创建 docker 配置文件目录 sudo mkdir /etc/docker 第二步 创建 daemon.json 配置文件 sudo touch /etc/docker/daemon.json 第三步 编辑配置文件 sudo nano /etc/docker/daemon.json 在编辑器中粘贴以下内容: { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.baidubce.com\u0026#34; ] } 第四步 重启 docker 服务 sudo systemctl daemon-reload sudo systemctl restart docker 检查设置是否生效\nsudo docker info 如果生效返回的信息类似下面这样\nRegistry Mirrors: https://hub-mirror.c.163.com/ ","date":"2021-12-26T13:39:29+08:00","permalink":"https://okokfun.github.io/post/nas/openmediavault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/","title":"OpenMediaVault安装与初步设置"},{"content":" 开源 C++ 库列表 \u0026lt; cpp‎ | links\n此页面的目的是构建开源 C++ 库的比较列表，使得人们在需要特定功能的实现时，不必浪费时间在网上（ DuckDuckGo 、谷歌、必应等）搜索。\n若你知道可能对其他人有用的库，请在此添加到它的链接。能包含进来的库没有限制，但是必须能便捷地下载库的源码。\n以“原态”提供此页面——希望这有用，但不提供任何担保。过时、误导或错误的链接可能出现于此。若你注意到这些错误，则改正它会很有意义。\n包管理器 Package manager Description build2 一个开源的 (MIT)、跨平台的构建工具链，旨在为开发和打包 C/C++ 项目时提供如 Rust Cargo 一样的便利性。 cget Cmake 包检索工具，可用于下载并安装 Cmake 包。 cmodule 非侵入式 CMake 依赖管理。 conan 去中心化、开源 (MIT) 的 C/C++ 包管理器。 CPM.cmake 一段可以为 CMake 加入依赖管理功能的 CMake 脚本。它是作为 CMake 的 FetchContent 模块的一个简单包装构建的。该模块加入了版本控制、缓存、简单 API 等功能。 hunter 一个 CMake 驱动的跨平台包管理器，服务于 C/C++ 项目。 spack 一个超级计算机、Linux、macOS 平台的包管理器。它使得安装科学软件变得简单。非绑定于某一特定语言。 teaport 一个受 cocoapods 启发的依赖管理器。 vcpkg 一个 Windows、Linux、macOS 平台的 C++ 包管理器。 库 音频 库名 简述 协议 配置手段 Aquila Aquila 是一个开源、跨平台的 C++11 DSP 库。 MIT 许可 CMake Essentia 开源库，音频和音乐分析、描述和合成工具 (MIR) (源码) Affero GPLv3 FFTW 离散傅里叶变换 (DFT) 计算库 (SSE/SSE2/AVX/Altivec/ARM Neon)。 (源码) GPL-2.0 CMake KFR 快速、现代、C++17、开源并且跨平台的 DSP/DFT 框架。支持音频重采样、 FIR/IIR 滤波器、二阶滤波器, (SSE, AVX, AVX-512, ARM NEON)。 (源码) GPL-2.0 CMake soundtouch SoundTouch 是一个开源、跨平台的音频处理库，用于更改音频流或音频文件的速度、音调和播放速率。 (源码) LGPL-2.1 Makefile 音频指纹 库名 简述 协议 配置手段 chromaprint (源码) MIT 许可, LGPL 2.1 CMake libmusicbrainz (源码) LGPL-2.1 CMake libofa MusicIP 开源音频指纹库 APL makefile 格式 库名 简述 协议 配置手段 audiofile LGPL-2.1 makefile flac Open Source, BSD 许可, GPL 许可 libsndfile LGPL v2.0 or v3.0 标签 库名 简述 协议 配置手段 id3lib LGPL v2 taglib (源码) LGPL 和 MPL v1.1 CD 库名 简述 协议 配置手段 libkcompactdisc CD 接口库 GPL v2.0 CMake 性能测试 库名 简述 协议 配置手段 benchmark Apache2.0 许可 CMake Celero Apache 许可 CMake gperftools “谷歌性能工具”包含高性能、多线程的 malloc 实现加上评测堆分配和 CPU 利用的工具。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License configure plf::nanotimer 用于性能评测的最低开销、跨平台的简单定时器类。 zlib 许可 通信 库名 简述 协议 配置手段 ACE 异步网络、多路分离、报文发送 Apache Thrift Apache Thrift 软件框架，用于规模可变的跨语言服务开发，将软件栈与代码生成引擎结合，构建有效而无缝地在 C++ 、 Java 、 Python 、 PHP 、 Ruby 、 Erlang 、 Perl 、 Haskell 、 C# 、 Cocoa 、 JavaScript 、 Node.js 、 Smalltalk 、 Ocaml 、 Delphi 及其他语言间工作的服务。 Boost.Asio 异步及同步网络、定时器、序列 I/O BSL-1.0 Boost.Beast 建立于 Boost.Asio 顶上的 HTTP 及 WebSocket 库 BSL-1.0 Breep 基于事件、高层、点对点库，允许用户直接发送和接收对象。 European Union Public License 1.1 CMake C++ REST SDK 异步 HTTP 客户端及监听器、异步 Stream 、 URI 、 JSON MIT 许可 CMake cpp-netlib cpp-netlib ： C++ 网络库 BSL-1.0 CMake cpr 现代 C++ HTTP 请求库 MIT 许可 CMake Crow BSD-3-Clause CMake curlpp CURL 库的 C++ 包装 DumaisLib MIT 许可 Makefile EasyHttp 跨平台的 HTTP 客户端库，专注于可用性和速度，支持 http 响应缓存及更多 MIT 许可 CMake eCAL 高性能进程间通信 Apache2.0 许可 CMake fineftp-server MIT 许可 CMake gRPC gsoap XML 数据绑定、快速 WSDL/SOAP/XML 网络服务、 WS 安全、 JSON/XML-RPC RESTful 服务的 C/C++ 开发工具套 HTTPP 简单、生产就绪的构建在 Boost 上的 HTTP 服务器，及构建在 libcurl 上的客户端。 BSD 2-Clause \u0026ldquo;Simplified\u0026rdquo; License CMake, Makefile IXWebSocket 无依赖的开源 WebSocket + HTTP 库，支持 SSL 和逐条消息 deflate 的 WebSocket 扩展。 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake, Makefile KCP 快速可靠的 ARQ 协议，帮助应用减少网络延迟。 MIT 许可 CMake libashttp 异步 HTTP 客户端库 GNU Lesser General Public License v3.0 libnavajo CeCILL-C FREE SOFTWARE LICENSE AGREEMENT CMake libtins 网络包装制作及嗅探库 nanomsg netif BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake nghttp2 HTTP/2 C 库及工具（服务器、客户端、代理和评测工具） MIT 许可 CMake, configure ngrest 快速而简易的利用 JSON 的 RESTful 网络服务框架 Apache2.0 许可 CMake nng omniORB 最快速、完整而可移植的 CORBA ORB 在 C++ 中的实现 OpenDDS DDS 实现 Paho MQTT CMake PcapPlusPlus 多平台 C++ 网络嗅探和包装分析及制作框架 POCO 网络：加密、 HTTP ； ZIP 文件 rest_rpc 现代、简单、易用的 rpc 框架 CMake restbed 设计以嵌入到宽范围的应用中的 C++ 为框架。 许可协议 CMake restc-cpp 将痛苦从自 C++ 访问 JSON API 带走。 HTTP 客户端，原生 C++ 类到/自 JSON 的序列化，通过 boost::asio coroutines 携程的异步 IO 。 C++14 。 MIT 许可 CMake restful_mapper 于 C++ 中消费 RESTful JSON API 的 ORM CMake, Makefile seastar 用C++11实现的高性能异步编程框架。 Apache2.0 许可 CMake, etc. Silicon 快速而稳健的 Web APIs MIT 许可 CMake sockpp 简单的现代 C++ 套接库 BSD 3-Clause \u0026ldquo;New\u0026rdquo; or \u0026ldquo;Revised\u0026rdquo; License CMake Simple C++ REST library 在你的 C++ 应用中创建 REST API 的非常简单且自成文档的库 stream-client 轻量、唯头文件的、基于 Boost 的客户端 socket/connector/socket pool/resolver Apache2.0 许可 CMake tacopie C++11 TCP 库 MIT 许可 CMake TAO CORBA taox11 基于 C++11 的 CORBA 实现 MIT 许可 Unicomm 异步网络、高层 TCP 交互框架 uvw 现代 C++ 书写的 libuv MIT 许可 CMake wvstreams GPL 许可 zeromq 快速消息队列 并发 库名 简述 协议 配置手段 BlockingCollection C++11 线程安全汇集类，模仿 .Net BlockingCollection。 Boost.Atomic BSL-1.0 Boost.Compute （非官方） OpenCL 的仿 STL 算法及数据结构 BSL-1.0 Boost.Context BSL-1.0 Boost.Interprocess BSL-1.0 Boost.Lockfree BSL-1.0 Boost.MPI BSL-1.0 Boost.Thread BSL-1.0 Cpp-Taskflow 带任务依赖的快速 C++ 并行编程 hipSYCL BSD-2-Clause License CMake HPX 任何规模的并行和分布式应用的通用 C++ 运行时系统 Intel TBB KOKKOS C++ 中的编程模型，用于书写高性能的便携 HPC 应用 libopenmpi libsimdpp MutexGear The MutexGear Library License configure, MSVC OpenMP RaftLib 类似并发行动者的 C++ 流 SObjectizer 通过行动者和出版订阅模型，简化开发并发和事件驱动应用的 C++ 中的小型框架。 subprocess Taskflow Thrust CUDA 的仿 STL 算法及数据结构 VexCL OpenCL 和 CUDA 的 C++ 表达式模板库 ViennaCL 带 OpenMP 、 CUDA 及 OpenCL 后端的线性代数及算法 Xenium 配置 库名 简述 协议 配置手段 Boost.Program_options BSL-1.0 gconfmm libconfig libconfini INI 分析器 XML 库名 简述 协议 配置手段 ai-xml GPDS gSOAP XML 数据绑定 libxml++ pugixml tinyxml tinyxml2 另一 TinyXML ，建设中。 Xerces JSON 库名 简述 协议 配置手段 ArduinoJson ArduinoJson CAJUN jansson Jansson 是编码、解码及操纵 JSON 数据的 C 库。 jeayeson 非常健全的（唯头文件） C++14 JSON 库 jios JSON 输入输出流 (JSON Input Output Streams) MIT 许可 CMake JOST JSON Voorhees C++ 的杀手 JSON json Niels Lohmann JSON json-cpp json11 json11 是 C++11 的轻量 JSON 库，提供 JSON 分析及序列化。 JsonBox jsoncons JSON 与类 JSON 数据结构的唯头文件库，含 JSON Pointer 、 JSON Patch 、 JSONPath 、 CSV 、 MessagePack 、 CBOR 、 BSON 、 UBJSON。 jsoncpp jsonme\u0026ndash; libjson minijson C++ 无 DOM 且免分配的 JSON 分析及序列化 nosjob qjson rapidjson simdjson 每秒解析 GB 级别的 JSON struct_mapping ThorsSerializer JSON/YAML Input Output Streams MIT 许可 Makefile ujson µjson 是小型的 C++11、UTF-8 JSON 库 zoolib meojson json简单库，作者MistEo MIT许可 Cmake, Makefile YAML 库名 简述 协议 配置手段 yaml-cpp TOML 库名 简述 协议 配置手段 toml++ toml11 基于 C++11 的 TOML 解析库 HOCON 库名 简述 协议 配置手段 cpp-hocon Pupplet 开发的 HOCON 格式的 C++ 实现。 CSS 库名 简述 协议 配置手段 mycss CSS 解析器 容器 库名 简述 协议 配置手段 Boost.Bimap BSL-1.0 Boost.Container BSL-1.0 Boost.Fusion BSL-1.0 Boost.Heap BSL-1.0 Boost.Pointer Container BSL-1.0 Boost.Tuple BSL-1.0 Boost.Variant BSL-1.0 cpp-btree btree_map 、 btree_set 、 btree_multimap 、 btree_multiset 。 DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 eggs::variant Eggs.Variant 是 C++11/14 的泛型、线程安全、有区别的联合体。值得注意的是它有很好的 constexpr 支持。 Frozen constexpr 完美基于哈希的冻结集合与映射（ Apache 2.0 ）。 Immer Boost License CMake plf::colony 无序的“类背包”容器，在高度修改场景中性能优于 std:: 容器，同时维护指向未被擦除元素的合法指针，无关乎插入或擦除。 plf::list std::list 实现，为缓存友好牺牲范围切割，导致更快的插入、擦除和迭代。 plf::stack std::stack 容器适配器的随意访问替换容器，在栈环境中有优于 std::vector 和 std::deque 的性能。 ring_span Guy Davidson 与 Arthur O\u0026rsquo;Dwyer 的 ring_span ——即环状缓冲区视图的简化实现。 strict_variant 快速而决不空的 variant ，目标 C++11 。阻止许多不想要的隐式转换。 TdhLists Ygg 高性能容器和数据结构，例如红黑树、区间数和区间映射的侵入式 C++11 实现。 密码学 库名 简述 协议 配置手段 Botan crypto++ gnutls openssl TomCrypt 数据库 库名 简述 协议 配置手段 redis-plus-plus 用C++ 11编写的Redis客户端, 支持Redis Sentinel，Redis Cluster，管道，事务，发布订阅，连接池以及类似于STL的接口 cpp-redis C++11 轻量的 Redis 客户端：异步、线程安全、无依赖、管道化、多平台。 OTL DTL libpqxx lmdb++ LMDB 嵌入式 B+ 树数据库的 C++11 包装。 mongocxx MongoDB 的 C++11 驱动库 mysql++ ODB - C++ Object-Relational Mapping (ORM) Pgfe - PostGres FrontEnd 现代 C++ 客户端 API 到 PostgreSQL QUINCE: QUeries IN C++ Expressions (ORM+EDSL) QxOrm - C++ Qt Object-Relational Mapping (ORM) SOCI sqlpp11 SQLAPI++ EasyQtSql 轻量唯头文件 C++11 库，用 QtSql 快速便捷地进行 SQL 查询 LevelDB 谷歌开发的、能够处理十亿级别规模 Key-Value 型数据持久性存储的C++ 程序库。 嵌入语言绑定 库名 简述 协议 配置手段 ChaiScript ExprTk lua sol2 AngelScript 类似 C++ 的脚本语言。 mozjs muparser PythonQt ScriptCaller 允许程序员调用 Ruby 脚本的唯头文件库。 v8pp 将 C++ 函数和类绑定到 V8 JavaScript引擎中。 嵌入式/实时 库名 简述 协议 配置手段 QP/C++ RTOS 内核，双重 GPL ETL - Embedded Template Library C++03 ，为少资源平台裁剪的可移植模板库 distortos 微控制器的面向对象 C++ RTOS µcuREST 微控制器的 C++11 REST/JSON 服务器框架 文件元数据 库名 简述 协议 配置手段 libkexiv2 exiv2 exempi rarian 金融计算 库名 简述 协议 配置手段 QuantLib - Quantitative finance library DataFrame C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。 游戏引擎架构 库名 简述 协议 配置手段 EntityX Anax EntityPlus EnTT BOX2D 物理引擎 通用多媒体 库名 简述 协议 配置手段 SFML (Simple and Fast Multimedia Library) SDL (Simple DirectMedia Layer) 对音频、键盘、鼠标、操纵杆及图形硬件，经由平台上图形 API （通常为 OpenGL 或 Direct3D ）的跨平台低层访问（ zlib 许可） SIGIL (Sound, Input, and Graphics Integration Library) 文本、形状、输入、音频及 2D 图像的难以置信地简单的跨平台极简库 Cinder openFrameworks 通用 库名 简述 协议 配置手段 Boost 大量通用库的汇集 Boost 许可 GSL Guideline Support Library 实现，为 Bjarne Stroustrup, Herb Sutter 和 Co 在《 C++ 核心方针》中推荐 BDE 来自 Bloomberg L.P. 的 Bloomberg Development Environment 核心库 Apache 许可 Dlib 网络、线程、图形用户界面、数据结构、线性代数、机器学习、 XML 及文本分析、数值优化、贝叶斯网络和大量其他任务 Boost 许可 JUCE 扩展性的成熟跨平台 C++ 工具套 GPL 许可 Loki 设计模式 Reason xml 、 xpath 、正则表达式、线程、接头、 http 、 sql 、日期时间、流、编码与解码、文件系统、压缩 GPL 许可 yomm2 C++17 的开放式多方法 Boost 许可 Folly Facebook 开源库。设计带有构思中的实践性和效率设计的 C++11 组件库。 Abseil Google 设计以补足 C++ 标准库的开源 C++ 库代码汇集。 cxxomfort C++ 特性逆向移植（ C++11 到 C++03 及 C++1y 提案到 C++11/C++03 ）。 libsourcey 高速网络化和多媒体编码的跨平台 C++11 库。 HTTP 、 WebSockets 、 TURN 、 STUN 、 Symple 及更多…… OnPosix 在 POSIX 平台上提供各种抽象（例如线程、网络化、日志、 IPC 等）的 C++ 库。 Ultimate++ 跨平台的迅速应用开发框架 CAF C++ Actor Framework (CAF) 是开源的 C++11 行动者模型实现，特性为轻量而快速的行动者实现、消息的模式匹配、网络不可见消息传递及更多 BSD 许可 cpp-mmf 对 POSIX 或 Windows 封装映射到内存文件的 C++98 库 CommonPP 多用途库，强调在项目中得出度规。 BSD Better Enums 反射性枚举（枚举到字符、迭代等），带 constexpr 支持。 BSD Smart Enum 给你的枚举 \u0026ldquo;to_string\u0026rdquo; 、 \u0026ldquo;from_string\u0026rdquo; 和更多。 Boost 许可 nytl 通用的 C++17 唯头文件模板库。 Boost 许可 SaferCPlusPlus SaferCPlusPlus - 不安全的 C++ 原始工具的安全兼容替换品，包括指针、 int 和 std::vector。 Boost 许可 fcppt Freundlich 的 C++ 工具套 (fcppt) 是聚焦于通过提供更好的类型和函数式编程改进 C++ 代码的库汇集。 bitfield.h 位域结构设施，比基础语言设施更可移植/灵活。 composite_op.h 基础类数据成员自省，繁琐且常常不可重入，但有时有用。 Abstract Intrusive Containers 比 boost::intrusive 更灵活，但非 STL 兼容。 Yato 现代 C++ (14/17) 的跨平台 STL 风格及 STL 兼容库，实现容器、范围、迭代器、类型特性和其他工具；行动者系统；类型安全配置接口 Apache-2.0 Kangaru C++11 与 C++14 的依赖注入容器 MIT 许可 yaal 算法、汇集、任意精度计算、泛型 DSL 文法驱动分析器及更多 CC BY-ND-NC 4.0 CMake gsl-lite C++98 、 C++11 及后续版本的 ISO C++ Guideline 支持库 (GSL) 的单文件唯头文件版本。 nonstd-lite *-lite 仓库的亲属，将 C++11 后特性移植到古代 C++ 环境的迁移路径。 units 编译时唯头文件的量纲分析及单位转换库，建立于 C++14 而无依赖。 GPS 库名 简述 协议 配置手段 gpsd 图形用户界面 库名 简述 协议 配置手段 Dear ImGui 高度优化的不膨胀的图形用户界面库。 FLTK nana 用现代 C++ 风格的 GUI 编程（ Boost 许可） nanogui 最小化的跨平台器件库，适用于 OpenGL 3.x 或更高版本 WxWidgets OWLNext 对 OWL 的，用于在 Windows 上以标准 C++ 书写 GUI 应用的现代更新 tiny file dialogs 单个 C C++ 跨平台文件（无初始化、无 main 循环、 6 种形态的函数调用） CopperSpice 库名 简述 协议 配置手段 CopperSpice CopperSpice 是用于开发跨平台软件应用的 C++ 库集合。它在 LGPL V2.1 许可下发布。它使用现代理念的 C++ 并与 STL 无缝结合。 CopperSpice 派生自 Qt 框架。 CsSignal 独立的 C++ 具线程信号/槽库 CsString 独立的 C++ 具 Unicode 字符串库 libGuarded 独立的 C++ 多线程库，用于管理对共享数据的访问 GTK+ 库名 简述 协议 配置手段 glibmm gtkmm goocanvasmm libglademm libgnomecanvasmm webkitgtk flowcanvas evince Qt 库名 简述 协议 配置手段 Qt qwtplot3d qwt5 技术应用到 Qt Widgets libdbusmenu-qt QuickQanava 直接在 Qt/QML 应用中画图的 C++14 库；项目主页： http://www.qanava.org QuickProperties QObject/QtObject 属性编辑的 C++/QML 库；项目主页： http://www.qanava.org 图形 库名 简述 协议 配置手段 cairomm nux pangomm nanovg 基于openGL/DX/metal的2d绘图库。 bgfx 非常强大的跨平台图形渲染库，支持平台包括 Windows Mac Linux iOS Android Web，渲染后端包括 DX, opengl, metal webgl等。 图像 库名 简述 协议 配置手段 gegl stb.image Adobe/boost GIL 高层通用库，聚焦于 2D 图像上操作的算法。非常有限定 I/O 选项。 GraphicsMagick 读、写、操纵 88 种主要格式的图像。于 2002 年分化自 ImageMagick Skia Graphics Engine Google 从 2005 年起的图形库，用于 Chrome 、 Chrome OS 、 Android 还有 Firefox 和 Sublime Text enwiki:Skia_Graphics_Engine Anti-Grain Evolution 跨平台 2D 光栅化及绘图引擎 打点 库名 简述 协议 配置手段 plotutils 格式 库名 简述 协议 配置手段 libraw openexr qimageblitz imagemagick djvulibre poppler SVG++ 3D 图形 库名 简述 协议 配置手段 Vulkan OpenGL bgfx 跨平台、不知图形 API 、“带来你自己的引擎/框架”风格的制图库。 Ogre3D Diligent Engine 现代跨平台低层 3D 图形库。 GLEW OpenGL 功能加载 GLAD 可定制的轻量库，用于加载 OpenGL 功能 Epoxy GLEM 的现代后继者。在 GL 环境的一些种类间抽象，这使得有时比使用 GLEW 更加单。自 2015 起为 GTK+ 项目所用。 GLFW OpenGL 窗口管理器 GLM 制图用的唯头文件 C++ 数学库 hlsl++ 使用 hlsl 语法的唯头文件 C++ 渲染库。支持 SSE 和 NEON assimp 3D 模型加载 VTK Magnum 游戏和数据可视化的轻量模块化的 C++11/C++14 图形中间件 Irrlicht Horde3D Visionaray C++ 光束追踪模板库 Open CASCADE 3D CAD/CAM/CAE 应用的 SDK OpenSceneGraph 图像处理 库名 简述 协议 配置手段 opencv dlib ITK OTB 国际化 库名 简述 协议 配置手段 IBM ICU gettext spirit-po 快速的唯头文件库，分析 po 文件，并提供类似 GNU libintl 的接口。基于 boost::spirit 。 记录 库名 简述 协议 配置手段 Log4cpp 用于灵活地记录到文件、系统日志、 IDSA 或其他目标的 C++ 类库 (LGPL) Log4cplus 日志 API ，提供日志管理及配置上的线程安全、灵活且有任意粒度的控制。 spdlog 超快的唯头文件 C++ 日志库 plog C++ 的可移植且简单的日志，少于 1000 行代码 (MPL2) Boost.Log glog Google 日志库 log4cxx Apache log4cxx 是 Apache log4j 后的 C++ 模式化记录框架 Pantheios 诊断日志 API 库，提供类型安全、效率、泛型和可扩展性的结合 Backward 打印漂亮的 Python 风格栈追踪，带颜色和源代码片段，特别是在崩溃时（ MIT 许可）。 数学 库名 简述 协议 配置手段 stats++ 先进、广泛的统计软件：数据收集及预处理、统计、机器学习及优化，拥有开放的 C++ 源码。 StatsLib 统计分布函数的模板化唯头文件库。 alglib ArrayFire High Performance Computation Library GNU MP bignum C++ interface BigNumber 创建和计算任意长度整数的 C++ 类 Boost.Multiprecision Boost.Math.Special Functions and Statistical Distributions Boost.Random NTL - A Library for doing Number Theory cpp-measures 处理物理度量的唯头文件 C++11 库 G+Smo 等几何分析的跨平台库 C++ Matrix 高性能且精确（例如极端情况）的矩阵数学库，带表达式模板算术运算符 Exact floating-point arithmetic library RPNX Uniform Smooth Noise N 维均匀分布的平滑噪声函数，以 C++ 实现。 数值计算 库名 简述 协议 配置手段 LibBF 由 Bellard 开发的任意精度数值计算库，拥有一个将圆周率计算到数十亿位的示例程序 线性代数 库名 简述 协议 配置手段 Boost.uBLAS Eigen Armadillo Blitz++ IT++ Dlib - linear algebra tools Blaze ETL DecompLib 唯头文件的 C++11 库，分解向量为正定加权基向量的集合。 优化 库名 简述 协议 配置手段 OptimLib 非线性函数数值优化方法的 C++11 库。 图论 库名 简述 协议 配置手段 Boost.Graph LEMON OGDF - Open Graph Drawing Framework NGraph - a simple (Network) Graph library in C++ GTpo C++14 泛型图拓扑库，带 Protocol Buffer 序列化；项目主页： http://www.qanava.org 数的类库 库名 简述 协议 配置手段 cln Universal 通用数算术的 C++ 模板库，取代 IEEE 浮点（ MIT 许可） 人工智能 库名 简述 协议 配置手段 stats++ liblinear Dlib 机器学习工具 MLPACK 机器学习包 Shogun 大规模机器学习工具箱 FANN 快速人工神经网络库 TensorFlow 面向所有人的开源机器学习框架 Paddle 并行化分布式深度学习库 DLDT OpenVINO™工具包-深度学习部署工具包 TensorRT 用于在 NVIDIA GPU 和深度学习加速器上进行高性能推理的 C++ 库 NCNN 腾讯开发的、针对移动平台进行了优化的高性能神经网络推理框架 OpenPose 实时多人关键点检测库，用于身体，面部，手和脚的检测 ANNetGPGPU 基于GPU（CUDA）的人工神经网络库。 btsk 游戏行为树入门套件。 Evolving Objects 基于模板的 C++ 演化计算库，可帮助您快速随意地编写自己的随机优化算法。 frugally-deep 仅头文件的库，用于在 C++ 中使用Keras模型。 Genann 简单神经网络库。 Recast/Detour 导航网格生成器和浏览器，主要用于游戏。 CNTK 微软认知工具包（CNTK），一种开源的深度学习工具包。 tiny-dnn 基于 C++11 的唯头文件、无依赖的深度学习框架。 Veles 用于快速深度学习应用程序开发的分布式平台。 Kaldi 语音识别工具包。 计算几何 库名 简述 协议 配置手段 CGAL 计算几何算法库 Wykobi 计算几何库 PCL 点云库 自动化理论 库名 简述 协议 配置手段 yasmine - C++11 UML state machine framework 元编程 库名 简述 协议 配置手段 Boost.MPL 原初元编程库，目标为 C++03 ，慢 Boost.Hana 类型与值的新元编程库 Boost.Mp11 Boost.CallableTraits Metal 使用饿元函数， 100% SFINAE 友好 Brigand 使用饿元函数，为最佳性能优化 Meta 使用饿元函数，在 metal 和 brigand 之间，相对于性能妥协 Boost.Metaparse 编译时分析器库，从编译时字符串产生类型、值和元函数 Boost.Proto 构建基于表达式模板的 EDSLs 的库 CoMeta 轻量、唯头文件的 C++14 元编程库 visit_struct 小规模反射库，提供 C++11 的结构体观察器。自容纳， 100-200 行代码，取决于如何计算。 PDF 库名 简述 协议 配置手段 HARU PoDoFo JagPDF 物理与模拟 库名 简述 协议 配置手段 ReactPhysics3D 进行 3D 模拟与游戏的 C++ 物理引擎 ProjectCHRONO 开源多物理模拟引擎 Bullet 游戏、视觉效果、机器人及加固学习的物理模拟 序列化 库名 简述 协议 配置手段 Boost.Serialization libs11n sweet_persist protobuf gSOAP 准确的 XML 序列化 ai-xml 通过添加单个最小的函数到类，在 XML 间序列化及反序列化。在底层使用 libxml++ 。 C++ XML objects YAS (Yet Another Serialization) yaml-cpp cereal (C++11 serialization) jios (JSON serialization) ThorsSerializer (JSON/YAML Input Output Streams) cppcodec 唯头文件库，编码/解码 base64 、 base32 和十六进制，有一致而灵活的 API （ MIT 许可） iguana (universal serialization engine) rpnx-serial 能（反）序列化如 std::map 、 std::vector 等类型的库 二进制序列化 库名 简述 协议 配置手段 UBjsonCpp 基于 C++14 的高性能 UBJson 读写库 binn 旨在紧凑，快速且易于使用的二进制序列化库，自身是同名格式的实现。 bson-cxx BSON 格式的 C++ 实现。 排序 库名 简述 协议 配置手段 Timsort 模板化的稳定排序函数，对于逆序或半排序的数据，性能优于基于快速排序的算法，包括 std::sort 。 (MIT) 终端 库名 简述 协议 配置手段 cwidget replxx readline 和 libedit 的替换品，支持 UTF-8 、语法高亮和提示。 测试 库名 简述 协议 配置手段 Boost.Test cppunit Google Test Catch2 doctest 单元测试和 TDD 使用的最轻量的特性丰富的 C++ 单头文件测试框架 lest 现代的 C++11 原生的单文件唯头文件的轻量单元测试、 TDD 和 BDD 框架（包含 C++98 变体）。 liblittletest 可移植，单个唯头文件的测试框架 ELFspy 杜绝假象和间谍的测试 - 仅 Linux xtd.tunit Windows 、 macOS 、 Linux 、 iOS 和 Android 上的现代 C++17 单元测试库。官方网站 bandit C++11 的对人类友好单元测试 文本 编码 库名 简述 协议 配置手段 uchardet 实现猜字符串编码的功能,和python里的uchardet功能基本一样。 win-iconv Linux 和 Mac 上的字符集编码转换库 iconv 的 Windows 实现，基于 Win32 字符集转换 API 实现。 格式化 库名 简述 协议 配置手段 fmt printf 不好用，ostream 也不好用，format 好用 分析 库名 简述 协议 配置手段 PEGTL 分析表达式文法的模板库 BNFlite 仅单个头文件的轻量文法分析器库 搜索 库名 简述 协议 配置手段 clucene xapian Step Ukkonen 的构建后缀树在线算法， Manber 的构建后缀数组算法。 模板引擎 库名 简述 协议 配置手段 inja 现代 C++ 的模板引擎 版本控制 库名 简述 协议 配置手段 LibGit2 版本控制系统 Git 的核心库。 cpp-semver 语义化版本号的 C++ 操作库。 视频 库名 简述 协议 配置手段 crystalhd mjpegtools libmatroska libVLC gstreamermm Web 库名 简述 协议 配置手段 libmusicbrainz5 liblastfm libkcddb Chromium Embedded QtWebApp Java Servlets 所启发的 HTTP(s) Server ，以 C++ 实现 Wt Tufão libhttpserver cpp-jwt oatpp 用于创建高性能网络服务的轻量零依赖框架 ","date":"2021-12-26T13:23:02+08:00","permalink":"https://okokfun.github.io/post/openlib-c/","title":"OpenLib-c++"},{"content":"看了前面那集 \u0026laquo;苛税猛如虎\u0026raquo; 的观众们, 毫无疑问都明白了一条: 中国政府, 是全世界最有钱的祝福, 它可以从全社会的总裁浮肿抽走近五成的资金 注意, 是净现金, 然后大手大脚的花出去, 没有丝毫的顾虑. 现在, 我们需要追问下一个问题: 财政的钱都花到哪里去了? 好吧, 财政支出主要分两个方向: 公共预算支出, 以及政府性基金支出 我们先来看政府性基金支出, 直接给结论, 这一块的指出严重不透明\n","date":"0001-01-01T00:00:00Z","permalink":"https://okokfun.github.io/post/%E4%BB%8E%E8%B4%A2%E6%94%BF%E6%94%AF%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9C%8B%E4%B8%AD%E5%9B%BD%E6%94%BF%E5%BA%9C%E7%9A%84%E6%B2%BB%E5%9B%BD%E9%80%BB%E8%BE%91/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://okokfun.github.io/post/%E6%A0%87%E7%AD%BE/","title":""}]