<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>第四部分-标准库扩展和修改 - My Blog</title><meta name="Description" content="Hugo theme - LoveIt"><meta property="og:title" content="第四部分-标准库扩展和修改" />
<meta property="og:description" content="第四部分 标准库扩展和修改 这一部分介绍了用C&#43;&#43;17对现有库组件的扩展和修改。
21类型特征扩展 关于类型特征（标准类型函数），C&#43;&#43;17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。
21.1 类型特征的Suffix _v 从C&#43;&#43;17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是
std::is_const&lt;T&gt;::value 你现在可以写:
std::is_const_v&lt;T&gt; // since C&#43;&#43;17 这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:
namespace std { template&lt;typename T&gt; constexpr bool is_const_v = is_const&lt;T&gt;::value; } 通常，这有助于制定布尔条件，你可以在运行时使用:
if (std::is_signed_v&lt;char&gt;) { ... } 但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:
if constexpr (std::is_signed_v&lt;char&gt;) { ... } 或在实例化模板时:
// C&lt;T&gt;类的主要模板 template&lt;typename T, bool = std::is_pointer_v&lt;T&gt;&gt; class C { ... }; // 指针类型的部分特殊化。 template&lt;typename T&gt; class C&lt;T, true&gt; { ... }; 在这里，以C类为例，它为指针类型提供了一个特殊的实现。 但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&lt;&gt;。它产生的是一个原始数组的维度大小:
int a[5][7]; std::cout &lt;&lt; std::extent_v&lt;decltype(a)&gt; &lt;&lt; &#39;\n&#39;; // prints 5 std::cout &lt;&lt; std::extent_v&lt;decltype(a),1&gt; &lt;&lt; &#39;\n&#39;; // prints 7 21." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://okokfun.github.io/posts/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/" /><meta property="og:image" content="https://okokfun.github.io"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-19T00:01:15+00:00" />
<meta property="article:modified_time" content="2022-03-19T00:01:15+00:00" /><meta property="og:site_name" content="My Blog" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://okokfun.github.io"/>

<meta name="twitter:title" content="第四部分-标准库扩展和修改"/>
<meta name="twitter:description" content="第四部分 标准库扩展和修改 这一部分介绍了用C&#43;&#43;17对现有库组件的扩展和修改。
21类型特征扩展 关于类型特征（标准类型函数），C&#43;&#43;17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。
21.1 类型特征的Suffix _v 从C&#43;&#43;17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是
std::is_const&lt;T&gt;::value 你现在可以写:
std::is_const_v&lt;T&gt; // since C&#43;&#43;17 这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:
namespace std { template&lt;typename T&gt; constexpr bool is_const_v = is_const&lt;T&gt;::value; } 通常，这有助于制定布尔条件，你可以在运行时使用:
if (std::is_signed_v&lt;char&gt;) { ... } 但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:
if constexpr (std::is_signed_v&lt;char&gt;) { ... } 或在实例化模板时:
// C&lt;T&gt;类的主要模板 template&lt;typename T, bool = std::is_pointer_v&lt;T&gt;&gt; class C { ... }; // 指针类型的部分特殊化。 template&lt;typename T&gt; class C&lt;T, true&gt; { ... }; 在这里，以C类为例，它为指针类型提供了一个特殊的实现。 但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&lt;&gt;。它产生的是一个原始数组的维度大小:
int a[5][7]; std::cout &lt;&lt; std::extent_v&lt;decltype(a)&gt; &lt;&lt; &#39;\n&#39;; // prints 5 std::cout &lt;&lt; std::extent_v&lt;decltype(a),1&gt; &lt;&lt; &#39;\n&#39;; // prints 7 21."/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://okokfun.github.io/posts/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/" /><link rel="prev" href="https://okokfun.github.io/posts/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/" /><link rel="next" href="https://okokfun.github.io/posts/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "第四部分-标准库扩展和修改",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/okokfun.github.io\/posts\/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9\/"
        },"image": ["https:\/\/okokfun.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "STL, C\u002b\u002b17","wordcount":  3977 ,
        "url": "https:\/\/okokfun.github.io\/posts\/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9\/","datePublished": "2022-03-19T00:01:15+00:00","dateModified": "2022-03-19T00:01:15+00:00","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/okokfun.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Author"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="My Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>My Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/" title="Hello World!"> 文章 </a><a class="menu-item" href="/tags/" title="Hello World!"> 标签 </a><a class="menu-item" href="/categories/" title="Hello World!"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="Select Language">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/posts/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/" selected></option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="My Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span>My Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="Hello World!">文章</a><a class="menu-item" href="/tags/" title="Hello World!">标签</a><a class="menu-item" href="/categories/" title="Hello World!">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="Select Language">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/posts/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/" selected></option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">第四部分-标准库扩展和修改</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Author</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-03-19">2022-03-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;3977 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;19 minutes&nbsp;<span id="/posts/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/" class="leancloud_visitors" data-flag-title="第四部分-标准库扩展和修改">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;views
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#第四部分-标准库扩展和修改">第四部分 标准库扩展和修改</a>
      <ul>
        <li><a href="#21类型特征扩展">21类型特征扩展</a></li>
        <li><a href="#22-并行stl算法">22 并行STL算法</a></li>
        <li><a href="#23--子字符串和子序列搜索">23  子字符串和子序列搜索</a></li>
        <li><a href="#24-其他工具函数和算法">24 其他工具函数和算法</a></li>
        <li><a href="#25--容器扩展">25  容器扩展</a></li>
        <li><a href="#26-多线程和并发">26 多线程和并发</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="第四部分-标准库扩展和修改">第四部分 标准库扩展和修改</h2>
<p>这一部分介绍了用C++17对现有库组件的扩展和修改。</p>
<h3 id="21类型特征扩展">21类型特征扩展</h3>
<p>关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。</p>
<h4 id="211-类型特征的suffix-_v">21.1 类型特征的<code>Suffix _v</code></h4>
<p>从C++17开始，你可以对所有产生数值的类型特征使用后缀<code>_v</code>（因为你可以对所有产生类型的类型特征使用后缀<code>_t</code>）。例如，对于任何类型的T，而不是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>is_const<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value
</span></span></code></pre></div><p>你现在可以写:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>is_const_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// since C++17
</span></span></span></code></pre></div><p>这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> is_const_v <span style="color:#f92672">=</span> is_const<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通常，这有助于制定布尔条件，你可以在运行时使用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>is_signed_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_signed_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>或在实例化模板时:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// C&lt;T&gt;类的主要模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_pointer_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 指针类型的部分特殊化。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">&lt;</span>T, true<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在这里，以C类为例，它为指针类型提供了一个特殊的实现。
但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&lt;&gt;。它产生的是一个原始数组的维度大小:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">5</span>][<span style="color:#ae81ff">7</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>extent_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a)<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// prints 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>extent_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a),<span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// prints 7
</span></span></span></code></pre></div><h4 id="212-新类型特征">21.2 新类型特征</h4>
<p>C++17 引入了几个新的类型特征。
此外， is_literal_type&lt;&gt; 和 result_of&lt;&gt; 自 C++17 起已弃用。
正在建设中的详细说明</p>
<h6 id="is_aggregate">is_aggregate&lt;&gt;</h6>
<p>std::is_aggregate<!-- raw HTML omitted --> 评估 T 是否为聚合类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>complex<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>D<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> s{{<span style="color:#e6db74">&#34;hello&#34;</span>}, {<span style="color:#ae81ff">4.5</span>,<span style="color:#ae81ff">6.7</span>}, <span style="color:#e6db74">&#34;world&#34;</span>}; <span style="color:#75715e">// OK since C++17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_aggregate<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(s)<span style="color:#f92672">&gt;::</span>value; <span style="color:#75715e">// outputs: 1 (true)
</span></span></span></code></pre></div><h4 id="213-stdbool_constant-">21.3 std::bool_constant&lt; &gt;。</h4>
<p>如果特征产生布尔值，它们现在使用别名模板 bool_constant&lt;&gt;：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span> B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> bool_constant <span style="color:#f92672">=</span> integral_constant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, B<span style="color:#f92672">&gt;</span>; <span style="color:#75715e">// since C++17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> true_type <span style="color:#f92672">=</span> bool_constant<span style="color:#f92672">&lt;</span>true<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> false_type <span style="color:#f92672">=</span> bool_constant<span style="color:#f92672">&lt;</span>false<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><table>
<thead>
<tr>
<th>特征</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_aggregate<!-- raw HTML omitted --></td>
<td>是聚合类型</td>
</tr>
<tr>
<td>has_unique_object_representations<!-- raw HTML omitted --></td>
<td>任何两个具有相同值的对象在内存中具有相同的表示</td>
</tr>
<tr>
<td>is_invocable&lt;T,Args&hellip;&gt;</td>
<td>可用作 Args 的可调用对象&hellip;</td>
</tr>
<tr>
<td>is_nothrow_invocable&lt;T,Args&hellip;&gt;</td>
<td>可用作 Args&hellip; 的可调用对象&hellip;无需抛出</td>
</tr>
<tr>
<td>is_invocable_r&lt;RT,T,Args&hellip;&gt;</td>
<td>可用作 Args 的可调用&hellip; 返回 RT</td>
</tr>
<tr>
<td>is_nothrow_invocable_r&lt;RT,T,Args&hellip;&gt;</td>
<td>可用作 Args 的可调用对象&hellip;返回 RT 而不抛出</td>
</tr>
<tr>
<td>invoke_result&lt;T,Args&hellip;&gt;</td>
<td>如果用作 Args 的可调用结果类型&hellip;</td>
</tr>
<tr>
<td>is_swappable<!-- raw HTML omitted --></td>
<td>is_swappable<!-- raw HTML omitted --> 可以为此类型调用 swap()</td>
</tr>
<tr>
<td>is_nothrow_swappable<!-- raw HTML omitted --></td>
<td>可以为此类型调用 swap() 并且该操作不能抛出</td>
</tr>
<tr>
<td>is_swappable_with&lt;T,T2&gt;</td>
<td>可以为这两种具有特定值类别的类型调用 swap()</td>
</tr>
<tr>
<td>is_nothrow_swappable_with&lt;T,T2&gt;</td>
<td>可以为这两种具有特定值类别的类型调用 swap() 并且该操作不能抛出</td>
</tr>
<tr>
<td>conjunction&lt;B&hellip;&gt;</td>
<td>逻辑和布尔特征 B&hellip;</td>
</tr>
<tr>
<td>disjunction&lt;B&hellip; &gt;</td>
<td>逻辑或布尔特征 B&hellip;</td>
</tr>
<tr>
<td>negation<!-- raw HTML omitted --></td>
<td>逻辑不用于布尔特征 B</td>
</tr>
</tbody>
</table>
<p>在C++17之前，std::true_type和std::false_type分别被直接定义为std::integral_constant&lt;bool,true&gt;和std::integral_constant&lt;bool,false&gt;的别名定义。
尽管如此，如果一个特定的属性适用，布尔特性通常继承自std::true_type，如果不适用则继承自std::false_type。比如说:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 主模板：通常 T 不是 void 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">IsVoid</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// void 类型的特化:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">IsVoid</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>true_type {
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>但是现在你可以通过派生自bool_constant&lt;&gt;来定义你自己的类型特质，如果你能够把相应的编译时表达式表述为布尔条件的话。比如说:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">IsLargerThanInt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>bool_constant<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">sizeof</span>(T) <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>))<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>这样你就可以使用这样一个特性，根据一个类型是否大于int来进行编译:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> foo(T x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(IsLargerThanInt<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过添加后缀_v的相应变量模板作为内联变量:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">auto</span> IsLargerThanInt_v <span style="color:#f92672">=</span> IsLargerThanInt<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value;
</span></span></code></pre></div><p>你也可以缩短该特性的用法，如下所示:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> foo(T x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(IsLargerThanInt_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作为另一个例子，我们可以定义一个特质，检查一个类型T的移动构造函数是否保证不抛出，大致如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">IsNothrowMoveConstructibleT</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>bool_constant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">noexcept</span>(T(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()))<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><h4 id="214-stdvoid_t-">21.4 std::void_t&lt; &gt;</h4>
<p>在C++17中，一个小小的，但令人难以置信的有用的定义类型特征的辅助工具被标准化了：std::void_t&lt;&gt;。
它被简单地定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>...<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">using</span> void_t <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是说，它对任何模板参数的变量列表都会产生无效。这很有帮助，我们只想在参数列表中处理类型。
主要的应用是在定义新的类型特征时检查条件的能力。下面的例子演示了这个帮助器的应用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt; // 对于declval&lt;&gt;来说</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt; // 为true_type，false_type，和void_t</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// 主模板:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>, <span style="color:#66d9ef">typename</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>void_t<span style="color:#f92672">&lt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HasVarious</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 部分专业（可能会被SFINAE所取代）:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HasVarious</span><span style="color:#f92672">&lt;</span>T, std<span style="color:#f92672">::</span>void_t<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>().begin()),
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>difference_type,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>iterator<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>true_type {
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><p>在这里，我们定义了一个新的类型特质HasVariousT&lt;&gt;，它检查三件事。</p>
<ul>
<li>
<p>该类型是否有一个成员函数begin()？</p>
</li>
<li>
<p>该类型是否有一个类型成员 difference_type？</p>
</li>
<li>
<p>该类型是否有一个类型成员迭代器？
只有当所有相应的表达式都对一个类型T有效时，才会使用部分专业化。那么它就比主模板更具体，而且由于我们从std::true_type派生出来，对这个特征的值进行检查会得到true。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (HasVarious<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>如果任何一个表达式的结果是无效的代码（即T没有begin()，或者没有类型成员difference_type，或者没有类型成员iterator），部分专业化就会被SFINAE&rsquo;d掉，这意味着由于替换失败不是错误的规则，它被忽略。然后，只有主模板是可用的，它派生自std::false_type，所以对这个特质的值进行检查会产生false。
同样地，你可以使用std::void_t轻松地定义其他特质来检查一个或多个条件，其中一个成员或操作的存在/能力很重要。</p>
<h4 id="215-后记">21.5 后记</h4>
<p>标准类型性状的变量模板最早是由Stephan T. Lavavej在2014年提出的 <a href="https://wg21.link/n3854" target="_blank" rel="noopener noreffer ">https://wg21.link/n3854</a>。它们最终被采纳为图书馆基本原理TS的一部分 的一部分，由Alisdair Meredith在https://wg21.link/p0006r0。</p>
<p>类型特质std::is_aggregate&lt;&gt;是作为美国国家机构的评论引入的，用于C++17的标准化。C++17的标准化而引入的（见https://wg21.link/lwg2911）。</p>
<p>std::bool_constant&lt;&gt;是由袁志豪在https://wg21.link/n4334 中首次提出的。它们最终被采纳为袁志豪在https://wg21.link/n4389 中的提议。</p>
<p>std::void_t_&lt;&gt;是由Walter E. Brown在https://wg21.link/n3911 中提出的，被采用。建设中</p>
<h3 id="22-并行stl算法">22 并行STL算法</h3>
<p>为了从现代多核架构中获益，C++17标准库引入了让STL标准算法使用多线程运行的能力，以并行处理不同的元素。</p>
<p>许多算法通过一个新的第一参数进行了扩展，以指定是否以及如何在并行线程中运行算法（当然，没有这个参数的老方法仍然被支持）。此外，还引入了一些专门支持并行处理的补充算法。</p>
<h6 id="一个简单的计时器助手">一个简单的计时器助手</h6>
<p>在本章的例子中，有时我们需要一个定时器来测量算法的速度。为此，我们使用了一个简单的辅助类，它初始化了一个定时器，并提供了printDiff()来打印消耗的毫秒数并重新初始化定时器:</p>
<p><code>lib/timer.hpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef TIMER_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TIMER_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/********************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* timer to print elapsed time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">********************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Timer</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>time_point last;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Timer()
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> la st{std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now()} {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printDiff</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Timer diff: &#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> now{std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now()};
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>duration<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, std<span style="color:#f92672">::</span>milli<span style="color:#f92672">&gt;</span> diff{now <span style="color:#f92672">-</span> last};
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> msg <span style="color:#f92672">&lt;&lt;</span> diff.count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ms</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        last <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// TIMER_HPP
</span></span></span></code></pre></div><h4 id="221-使用并行算法">22.1 使用并行算法</h4>
<p>让我们从一些例子程序开始，展示让现有算法并行运行和使用新的并行算法的能力。</p>
<h5 id="2211-使用并行的for_each">22.1.1 使用并行的for_each()</h5>
<p>这是并行运行标准算法 for_each() 的第一个非常简单的示例：</p>
<p><code>lib/parforeach.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt; // 对于执行策略</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;timer.hpp&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numElems <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> value; <span style="color:#75715e">// 初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">double</span> sqrt; <span style="color:#75715e">// 并行计算平方根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化没有平方根的 NumElems 值:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(numElems);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>numElems; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.push_back(Data{i <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.37</span>, <span style="color:#ae81ff">0</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 平方根的并行计算:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    for_each(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>             coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>             [](<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>                 val.sqrt <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(val.value);
</span></span><span style="display:flex;"><span>             });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>正如你所看到的，使用并行算法在原则上是非常容易的。</p>
<ul>
<li>包括头文件<!-- raw HTML omitted -->。</li>
<li>按照你通常调用算法的方式来调用算法，并附加一个第一个参数，这个参数通常是简单的std::execution::par。</li>
</ul>
<p>在这种情况下，我们使用标准算法for_each()来计算传递的向量coll中所有元素的成员值的平方根。由于额外的第一个参数std::execution::par，我们要求该算法以并行模式运行:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span>for_each(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>         coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>         [](<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>             val.sqrt <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(val.value);
</span></span><span style="display:flex;"><span>         });
</span></span></code></pre></div><p>像往常一样，coll在这里可以是任何范围。但是请注意，所有的并行算法都要求迭代器至少是前向迭代器（我们在不同的线程中迭代相同的元素，如果迭代器不迭代相同的值，那就没有意义）。
算法并行运行的方式是具体实现的。当然，使用多线程也不一定更快，因为启动和处理多线程也需要时间。</p>
<h6 id="性能优势">性能优势</h6>
<p>为了找到如何、是否以及何时值得并行运行这个算法，让我们把这个例子修改如下。
<code>lib/parforeach.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt; // for the execution policy</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;timer.hpp&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numElems <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> value; <span style="color:#75715e">// 初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">double</span> sqrt; <span style="color:#75715e">// 并行计算平方根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化没有平方根的 NumElems 值:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(numElems);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>numElems; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.push_back(Data{i <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.37</span>, <span style="color:#ae81ff">0</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 平方根的并行计算:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    for_each(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>             coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>             [](<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>                 val.sqrt <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(val.value);
</span></span><span style="display:flex;"><span>             });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关键的修改是。</p>
<ul>
<li>我们可以通过命令行传递我们操作的数值的多少。</li>
<li>我们使用类Timer来测量调用算法的持续时间。</li>
<li>我们在一个循环中进行多次测量，以使持续时间更加成熟。
结果在很大程度上取决于所使用的硬件、C++编译器和C++库。在我的笔记本电脑上（在英特尔i7上使用Visual C++，带有2个核心和超线程），我们得到的结果如下。</li>
<li>在100个元素的情况下，顺序算法要快10倍以上。这是因为启动和管理线程需要太多的时间，对于几个元素来说不值得。</li>
<li>对于10,000个元素，我们接近于收支平衡。</li>
<li>对于1,000,000个元素，并行执行的速度大约是3倍。</li>
</ul>
<p>同样，这也不是一个一般性的证明，在什么地方和什么时候并行算法是值得的。但它表明，即使对于非微不足道的数字运算，也值得使用它们。关键是，它值得用在</p>
<ul>
<li>长操作</li>
<li>许多许多元素
例如，使用并行版本的算法count_if()计算一个ints vector中的偶数元素的数量是不值得的。元素的并行版本是不值得的；即使有1,000,000,000个元素也不值得。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> num <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>count_if(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, <span style="color:#75715e">// execute policy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         coll.cbegin(), coll.cend(), <span style="color:#75715e">// 范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         [](<span style="color:#66d9ef">int</span> elem){ <span style="color:#75715e">//准则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                             <span style="color:#66d9ef">return</span> elem <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                         });
</span></span></code></pre></div><p>事实上，对于本例中具有快速谓词的简单算法，并行运行可能永远不会有回报。每个元素都应该发生一些需要大量时间的事情，并且与其他元素的处理无关。
但你无法预测任何事情，因为何时以及如何使用并行线程，都取决于C++标准库的实现者。事实上，无法控制使用多少线程，实现者可能会决定只在一定数量的元素上使用多线程。
测量! 用你的目标平台上的典型场景。</p>
<h5 id="2212-使用并行的sort">22.1.2 使用并行的sort()</h5>
<p>排序是另一个例子，并行算法可以提供帮助。因为排序标准对每个元素的使用不只一次，你可以节省大量时间。
例如，考虑一下，我们初始化一个字符串的向量如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numElems <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    coll.emplace_back(<span style="color:#e6db74">&#34;id&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i));
</span></span><span style="display:flex;"><span>    coll.emplace_back(<span style="color:#e6db74">&#34;ID&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是说，我们创建一个以 &ldquo;id &ldquo;或 &ldquo;ID &ldquo;开头的元素向量，后面是一个整数:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>id0 ID0 id1 ID1 id2 ID2 id3 ... id99 ID99 id100 ID100 ...
</span></span></code></pre></div><p>我们可以像往常一样按以下顺序对元素进行排序:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(coll.begin(), coll.end());
</span></span></code></pre></div><p>现在也可以通过明确传递一个 &ldquo;顺序 &ldquo;执行策略来实现:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>seq, coll.begin(), coll.end());
</span></span></code></pre></div><p>如果在运行时决定是顺序运行还是并行运行，并且你不想有不同的函数调用，那么将顺序执行作为参数传递会很有用。
要求用并行排序来代替是很容易的:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, coll.begin(), coll.end());
</span></span></code></pre></div><p>请注意，还有另一个并行执行策略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par_seq, coll.begin(), coll.end());
</span></span></code></pre></div><p>我稍后将解释其中的区别。
所以，问题又来了，（什么时候）使用并行排序更好？在我的笔记本电脑上，只有10,000个字符串，你可以看到排序的时间是顺序排序的一半。而且，即使是对1000个字符串进行排序，使用并行执行也略胜一筹。</p>
<h6 id="与其他改进措施相结合">与其他改进措施相结合</h6>
<p>请注意，还有其他的修改可能会给你带来更多或额外的好处。例如，如果我们只按数字排序，使用没有两个前导字符的子串，我们可以在谓词中使用字符串操作，并再次看到并行执行的2倍的改进:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>     coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>     [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> b) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> a.substr(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;</span> b.substr(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>     });
</span></span></code></pre></div><p>然而，substr()对于字符串来说是一个相当昂贵的成员函数，因为它创建并返回一个新的临时字符串。通过使用string_view类，我们甚至在连续执行的情况下，也会比以前好3倍。顺序执行的情况下，我们的速度也会提高3倍:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>     [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> b) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>string_view{a}.substr(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>string_view{b}.substr(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>     });
</span></span></code></pre></div><p>结合使用并行算法，我们的速度提高了多达 10 倍：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>     coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>     [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> b) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>string_view{a}.substr(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>string_view{b}.substr(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>     });
</span></span></code></pre></div><p>与使用字符串的 substr() 成员的顺序执行相比：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>sort(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>     [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> b) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> a.substr(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;</span> b.substr(<span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><h4 id="222-执行策略">22.2 执行策略</h4>
<p>你可以把不同的执行策略作为第一个参数传递给并行STL算法。它们被定义在头文件<!-- raw HTML omitted -->中。表Execution Policies列出了标准化的执行策略。</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::execution::seq</td>
<td>顺序执行</td>
</tr>
<tr>
<td>std::execution::par</td>
<td>并行顺序执行</td>
</tr>
<tr>
<td>std::execution::par_unseq</td>
<td>并行无序列（矢量）执行</td>
</tr>
</tbody>
</table>
<p>让我们详细讨论一下执行策略。</p>
<ul>
<li>使用seq的顺序执行
意味着和非并行算法一样，当前的执行线程按顺序逐个元素执行必要的操作。使用这个策略的行为应该和使用非并行方式调用算法一样，根本不需要传递任何执行策略。然而，对于接受这个参数的并行算法，可能会有额外的限制，比如for_each()不返回任何值，或者所有的迭代器必须至少是前向迭代器。
提供这个策略是为了能够通过传递一个不同的参数而不是使用一个不同的签名来请求顺序执行。但是请注意，采用这种策略的并行算法的行为可能与相应的非并行算法略有不同。</li>
<li>使用par的并行顺序执行
意味着多个线程可能依次执行元素的必要操作。当一个算法开始执行必要的操作时，它在处理其他元素之前完成这一执行。
与par_unseq相比，这可以确保没有问题或死锁发生，因为在处理完一个元素的步骤后，需要在同一个线程对另一个元素执行第一步之前调用另一个步骤。</li>
<li>使用par_unseq的并行无序执行
意味着多个线程可能为多个元素执行必要的操作，但不能保证一个线程执行该元素的所有步骤而不切换到其他 元素。这特别是使矢量执行成为可能，在这种情况下，一个线程可能首先执行多个元素的第一步 在执行下一个步骤之前，一个线程可能首先执行多个元素的执行步骤。</li>
</ul>
<p>并行的无序执行需要编译器/硬件的特别支持，以检测哪里和如何操作可以被矢量化。操作如何被矢量化。</p>
<h4 id="223-异常处理">22.3 异常处理</h4>
<p>所有的并行算法都会调用std::terminate()，如果元素访问函数通过一个未捕获的异常退出。
请注意，如果选择的是顺序执行策略，这也适用。如果不能接受这种情况，使用算法的非并行版本可能是更好的选择。
还要注意的是，并行算法仍有可能被抛出。如果它们不能为并行执行获得临时的内存资源，它们会抛出std::bad_alloc。然而，没有其他 可能会被抛出。</p>
<h4 id="224-不使用并行算法的好处">22.4 不使用并行算法的好处</h4>
<p>有了调用并行算法的能力，以及它们甚至提供了一个顺序执行策略的事实，可能会出现这样的问题：我们是否还需要非并行算法。
然而，除了向后兼容之外，使用非并行算法可能有很大的好处。</p>
<ul>
<li>可以使用输入和输出迭代器。</li>
<li>算法不会在异常情况下terminate()。</li>
<li>算法可以避免由于非故意使用元素而产生的副作用。</li>
<li>算法可能提供额外的功能，例如for_each()返回传递的可调用，以便能够处理其结果状态。</li>
</ul>
<h4 id="225-并行算法的概述">22.5 并行算法的概述</h4>
<p>表Unmodified Parallel STL Algorithms列出了标准化的算法，可以不加任何修改地支持并行处理。
表Modified Parallel STL Algorithms列出了经过一些修改的支持并行处理的标准化算法。
表STL算法无并行化列出了不支持并行处理的算法。
请注意，对于 accumulate() 和 inner_product() ，新的并行算法被提供了宽松的要求。放宽了要求。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>find_end(), adjacent_find()</td>
<td>除了搜索者</td>
</tr>
<tr>
<td>search(), search_n()</td>
<td></td>
</tr>
<tr>
<td>swap_ranges()</td>
<td></td>
</tr>
<tr>
<td>replace(), replace_if()</td>
<td></td>
</tr>
<tr>
<td>fill()</td>
<td></td>
</tr>
<tr>
<td>generate()</td>
<td></td>
</tr>
<tr>
<td>remove(), remove_if()</td>
<td></td>
</tr>
<tr>
<td>unique()</td>
<td></td>
</tr>
<tr>
<td>reverse()</td>
<td></td>
</tr>
<tr>
<td>rotate()</td>
<td></td>
</tr>
<tr>
<td>partition(), stable_partition()</td>
<td></td>
</tr>
<tr>
<td>sort(), stable_sort(), partial_sort()</td>
<td></td>
</tr>
<tr>
<td>is_sorted(), is_sorted_until()</td>
<td></td>
</tr>
<tr>
<td>nth_element()</td>
<td></td>
</tr>
<tr>
<td>inplace_merge()</td>
<td></td>
</tr>
<tr>
<td>is_heap(), is_heap_until()</td>
<td></td>
</tr>
<tr>
<td>min_element(), max_element(), min_max_element()</td>
<td>除了搜索者</td>
</tr>
<tr>
<td>for_each()</td>
<td>前向迭代器和返回类型 void</td>
</tr>
<tr>
<td>all_of(), any_of(), none_of()</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>for_each_n()</td>
<td></td>
</tr>
<tr>
<td>find(), find_if(), find_if_not()</td>
<td></td>
</tr>
<tr>
<td>find_first_of()</td>
<td></td>
</tr>
<tr>
<td>count(), count_if()</td>
<td></td>
</tr>
<tr>
<td>mismatch()</td>
<td></td>
</tr>
<tr>
<td>equal()</td>
<td></td>
</tr>
<tr>
<td>is_partitioned()</td>
<td></td>
</tr>
<tr>
<td>partial_sort_copy()</td>
<td></td>
</tr>
<tr>
<td>includes()</td>
<td></td>
</tr>
<tr>
<td>lexicographical_compare()</td>
<td></td>
</tr>
<tr>
<td>fill_n()</td>
<td></td>
</tr>
<tr>
<td>generate_n()</td>
<td></td>
</tr>
<tr>
<td>reverse_copy()</td>
<td></td>
</tr>
<tr>
<td>rotate_copy()</td>
<td></td>
</tr>
<tr>
<td>copy(), copy_n(), copy_if()</td>
<td></td>
</tr>
<tr>
<td>move()</td>
<td></td>
</tr>
<tr>
<td>transform()</td>
<td></td>
</tr>
<tr>
<td>replace_copy(), replace_copy_if()</td>
<td></td>
</tr>
<tr>
<td>remove_copy(), remove_copy_if()</td>
<td></td>
</tr>
<tr>
<td>unique_copy()</td>
<td></td>
</tr>
<tr>
<td>partition_copy()</td>
<td></td>
</tr>
<tr>
<td>merge()</td>
<td></td>
</tr>
<tr>
<td>set_union(), set_intersection()</td>
<td></td>
</tr>
<tr>
<td>set_difference(), set_symmetric_difference()</td>
<td></td>
</tr>
<tr>
<td>exclusive_scan(), inclusive_scan()</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>accumulate(), inner_product(), partial_sum()</td>
<td>改用 reduce() 和 transform_reduce()</td>
</tr>
<tr>
<td>search() with searcher</td>
<td></td>
</tr>
<tr>
<td>copy_backward() move_backward()</td>
<td></td>
</tr>
<tr>
<td>sample(), shuffle()</td>
<td></td>
</tr>
<tr>
<td>partition_point()</td>
<td></td>
</tr>
<tr>
<td>lower_bound(), upper_bound(), equal_range()</td>
<td></td>
</tr>
<tr>
<td>binary_search()</td>
<td></td>
</tr>
<tr>
<td>is_permutation(), next_permutation(), prev_permutation()</td>
<td></td>
</tr>
<tr>
<td>push_heap(), pop_heap(), make_heap(), sort_heap()</td>
<td>改用 reduce() 和 transform_reduce()</td>
</tr>
</tbody>
</table>
<h4 id="226-并行处理的新算法">22.6 并行处理的新算法</h4>
<p>一些补充算法被引入，以处理自C++98以来可用的标准算法的并行处理。</p>
<h5 id="2261-reduce">22.6.1 reduce()</h5>
<p>例如，reduce()是作为 accumulate()的平行形式引入的，它 &ldquo;累积 &ldquo;所有元素（你可以定义，哪个操作执行 &ldquo;累积&rdquo;）。例如，考虑以下 accumulate() 的用法。</p>
<p><code>lib/accumulate.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // for accumulate()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 1 2 3 4 的 num 个序列创建 coll:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>accumulate(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0L</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;accumulate(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们计算所有元素的总和，输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">10000000</span>
</span></span></code></pre></div><h6 id="换算运算的平行化">换算运算的平行化</h6>
<p>这个程序可以通过改用reduce()来实现并行化:</p>
<p><code>lib/reduce.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // for reduce()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 1 2 3 4 的 num 个序列创建 coll:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>reduce(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>                           coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0L</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;reduce(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在输出相同的情况下，现在的程序可能运行得更快或更慢（取决于是否支持启动多线程，以及所花费的时间是否比我们并行运行算法所节省的时间多）。
这里使用的操作是+，它是换元的，所以加入积分元素的顺序并不重要。</p>
<h6 id="非共轭运算的并行化">非共轭运算的并行化</h6>
<p>然而，对于浮点值来说，顺序很重要，这就证明了以下程序:</p>
<p><code>lib/reducefloat.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 0.1 0.3 0.0001 的 num 个序列创建 coll:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.00001</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>accumulate(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                                <span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;accumulate(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>reduce(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>                            coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                            <span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;reduce(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> (sum1<span style="color:#f92672">==</span>sum2 <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;equal</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;differ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>setprecision(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里我们同时使用 accumulate() 和 reduce() 并比较结果。一个可能的输出是:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: 0.40001
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: 0.40001
</span></span><span style="display:flex;"><span>equal
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: 400.01
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: 400.01
</span></span><span style="display:flex;"><span>differ
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">400010</span>
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: <span style="color:#ae81ff">400010</span>
</span></span><span style="display:flex;"><span>differ
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: 4.0001e+06
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: 4.0001e+06
</span></span><span style="display:flex;"><span>differ
</span></span></code></pre></div><p>虽然结果看起来是一样的，但有时会有差异。这可能是以不同的顺序添加 的顺序不同而造成的。
如果我们改变打印浮点值的精度:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>setprecision(<span style="color:#ae81ff">20</span>);
</span></span></code></pre></div><p>我们可以看到结果值略有不同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>accumulate()<span style="color:#f92672">:</span> <span style="color:#ae81ff">0.40001000000000003221</span>
</span></span><span style="display:flex;"><span>reduce()<span style="color:#f92672">:</span> <span style="color:#ae81ff">0.40001000000000003221</span>
</span></span><span style="display:flex;"><span>equal
</span></span><span style="display:flex;"><span>accumulate()<span style="color:#f92672">:</span> <span style="color:#ae81ff">400.01000000000533419</span>
</span></span><span style="display:flex;"><span>reduce()<span style="color:#f92672">:</span> <span style="color:#ae81ff">400.01000000000010459</span>
</span></span><span style="display:flex;"><span>differ
</span></span><span style="display:flex;"><span>accumulate()<span style="color:#f92672">:</span> <span style="color:#ae81ff">400009.99999085225863</span>
</span></span><span style="display:flex;"><span>reduce()<span style="color:#f92672">:</span> <span style="color:#ae81ff">400009.9999999878346</span>
</span></span><span style="display:flex;"><span>differ
</span></span><span style="display:flex;"><span>accumulate()<span style="color:#f92672">:</span> <span style="color:#ae81ff">4000100.0004483023658</span>
</span></span><span style="display:flex;"><span>reduce()<span style="color:#f92672">:</span> <span style="color:#ae81ff">4000100.0000019222498</span>
</span></span><span style="display:flex;"><span>differ
</span></span></code></pre></div><p>由于没有定义是否、何时以及如何实现并行算法，因此在某些平台上的结果可能看起来是一样的（达到一定数量的元素）。</p>
<h6 id="非关联性操作的并行化">非关联性操作的并行化</h6>
<p>现在让我们改变一下操作，通过总是添加每个值的平方来累积值:</p>
<p><code>lib/accumulate2.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // 对于 accumulate()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 1 2 3 4 的 num 个序列创建 coll：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> squaredSum <span style="color:#f92672">=</span> [] (<span style="color:#66d9ef">auto</span> sum, <span style="color:#66d9ef">auto</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">+</span> val <span style="color:#f92672">*</span> val;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>accumulate(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0L</span>,
</span></span><span style="display:flex;"><span>                               squaredSum);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;accumulate(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这里，我们传递一个lambda，对于每一个值，都要取当前的和，并加上新值的平方:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> squaredSum <span style="color:#f92672">=</span> [] (<span style="color:#66d9ef">auto</span> sum, <span style="color:#66d9ef">auto</span> val) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">+</span> val <span style="color:#f92672">*</span> val;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>使用 accumulate() 输出看起来很好:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">30000</span>
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">30000000</span>
</span></span><span style="display:flex;"><span>accumulate<span style="color:#f92672">()</span>: <span style="color:#ae81ff">300000000</span>
</span></span></code></pre></div><p>但是，让我们使用 reduce() 切换到并行处理：</p>
<p><code>lib/reduce2.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // 对于reduce()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 1 2 3 4 的 num 个序列创建 coll：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> squaredSum <span style="color:#f92672">=</span> [] (<span style="color:#66d9ef">auto</span> sum, <span style="color:#66d9ef">auto</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">+</span> val <span style="color:#f92672">*</span> val;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>reduce(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>                           coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0L</span>,
</span></span><span style="display:flex;"><span>                           squaredSum);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;reduce(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出可能会变成这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: <span style="color:#ae81ff">30000</span>
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: -425251612
</span></span><span style="display:flex;"><span>reduce<span style="color:#f92672">()</span>: <span style="color:#ae81ff">705991074</span>
</span></span></code></pre></div><p>是的，结果有时可能是错误的。问题是，该操作不是关联性的。例如，如果我们对元素1、2和3应用这个操作，我们可能先计算0+1<em>1和2+3</em>3，但当我们把中间的结果结合起来时，我们又把3平方了，基本上是 计算:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>0+1*1<span style="color:#f92672">)</span> + <span style="color:#f92672">(</span>2+3*3<span style="color:#f92672">)</span> * <span style="color:#f92672">(</span>2+3*3<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>但为什么这里的结果有时是正确的呢？嗯，似乎在这个平台上，reduce()只在一定数量的元素中并行运行。而这是完全可以的。因此，使用有足够多元素的测试案例来检测这样的问题。
解决这个问题的方法是使用另一种新的算法，transform_reduce()。它把我们要对每个元素进行的修改（这是我们可以并行化的一件事）和结果的累积分开，只要它是换元的（这是我们可以并行化的另一件事）。</p>
<p><code>lib/transformreduce.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // for transform_reduce()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSum</span>(<span style="color:#66d9ef">long</span> num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用 1 2 3 4 的 num 个序列创建 coll:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    coll.reserve(num <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.insert(coll.end(), {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>transform_reduce(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>                                     coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                                     <span style="color:#ae81ff">0L</span>,
</span></span><span style="display:flex;"><span>                                     std<span style="color:#f92672">::</span>plus{},
</span></span><span style="display:flex;"><span>                                     [] (<span style="color:#66d9ef">auto</span> val) {
</span></span><span style="display:flex;"><span>                                         <span style="color:#66d9ef">return</span> val <span style="color:#f92672">*</span> val;
</span></span><span style="display:flex;"><span>                                     });
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;transform_reduce(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">1000000</span>);
</span></span><span style="display:flex;"><span>    printSum(<span style="color:#ae81ff">10000000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在调用transform_reduce()时，我们传递了</p>
<ul>
<li>执行策略，以便（允许）并行地运行这个程序</li>
<li>要处理的值的范围</li>
<li>0L作为外部累加的初始值</li>
<li>操作+作为外部累加的操作</li>
<li>一个lambda，用于在累加之前处理每个值</li>
</ul>
<p>transform_reduce()可能是迄今为止最重要的并行算法，因为我们经常在合并数值之前修改它们（也称为map reduce原则）。</p>
<h6 id="用于文件系统操作的transform_reduce函数">用于文件系统操作的transform_reduce()函数</h6>
<p>下面是另一个并行运行transform_reduce()的例子:</p>
<p><code>lib/dirsize.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt; // for transform_reduce()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;execution&gt; // 对于执行策略</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;filesystem&gt; // filesystem library</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根目录作为命令行参数被传递:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Usage: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> argv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &lt;path&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path root{argv[<span style="color:#ae81ff">1</span>]};
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在通过的文件树中启动所有文件路径的列表:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path<span style="color:#f92672">&gt;</span> paths;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>recursive_directory_iterator dirpos{root};
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>copy(begin(dirpos), end(dirpos),
</span></span><span style="display:flex;"><span>                  std<span style="color:#f92672">::</span>back_inserter(paths));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> (<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>exception<span style="color:#f92672">&amp;</span> e) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;EXCEPTION: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> e.what() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 累积所有常规文件的大小:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> sz <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>transform_reduce(
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, <span style="color:#75715e">// 并行执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        paths.cbegin(), paths.cend(), <span style="color:#75715e">// range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>uintmax_t{<span style="color:#ae81ff">0</span>}, <span style="color:#75715e">// 初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>plus<span style="color:#f92672">&lt;&gt;</span>(), <span style="color:#75715e">// accumulate ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        [](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path<span style="color:#f92672">&amp;</span> p) { <span style="color:#75715e">// 如果是普通文件，文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> is_regular_file(p) <span style="color:#f92672">?</span> file_size(p)
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>uintmax_t{<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size of all &#34;</span> <span style="color:#f92672">&lt;&lt;</span> paths.size()
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; regular files: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sz <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先，我们递归地收集作为命令行参数的目录中的所有文件系统路径:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path root{argv[<span style="color:#ae81ff">1</span>]};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path<span style="color:#f92672">&gt;</span> paths;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>recursive_directory_iterator dirpos{root};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>copy(begin(dirpos), end(dirpos),
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>back_inserter(paths));
</span></span></code></pre></div><p>请注意，由于我们可能会传递一个无效的路径，可能的（文件系统）异常会被捕获。
然后，我们遍历文件系统路径的集合，积累它们的大小，如果它们是 正常的文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> sz <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>transform_reduce(
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, <span style="color:#75715e">// 并行执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    paths.cbegin(), paths.cend(), <span style="color:#75715e">// range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>uintmax_t{<span style="color:#ae81ff">0</span>}, <span style="color:#75715e">// initial value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>plus<span style="color:#f92672">&lt;&gt;</span>(), <span style="color:#75715e">// accumulate ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    [](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>path<span style="color:#f92672">&amp;</span> p) { <span style="color:#75715e">// 文件大小（如果是常规文件）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">is_regular_file</span>(p) <span style="color:#f92672">?</span> file_size(p)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>uintmax_t{<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    });
</span></span></code></pre></div><p>新的标准算法transform_reduce()的操作方法如下。</p>
<ul>
<li>最后一个参数被应用于每个元素。在这里，对每个路径元素调用传递的lambda，如果它是一个普通文件，则查询其大小。</li>
<li>第二个但也是最后一个参数是合并所有大小的操作。因为我们要累积大小，所以我们使用标准函数对象std::plus&lt;&gt;。</li>
<li>第三个但也是最后一个参数是合并所有大小的操作的初始值。因此，如果路径列表是空的，我们从0开始。我们使用与file_size()的返回值相同的类型，std::uintmax_t。</li>
</ul>
<p>请注意，询问文件的大小是一个相当昂贵的操作，因为它需要一个操作系统调用。由于这个原因，使用一个算法来调用这个转换（从路径到大小），并以任何顺序与多个线程并行，并计算出总和，是非常快的回报。第一次测量显示了一个明显的胜利（程序的速度提高了一倍）。
还要注意的是，你不能把目录迭代器所迭代的路径直接传递给并行的 算法，因为目录迭代器是输入迭代器，而并行算法需要正向的 迭代器。
最后请注意，transform_reduce()被定义在头文件<!-- raw HTML omitted -->中，而不是<!-- raw HTML omitted -->。
(就像 accumulate() 一样，它也算作数字算法。</p>
<h4 id="227-并行算法的详细介绍">22.7 并行算法的详细介绍</h4>
<h4 id="228-后记">22.8 后记</h4>
<p>2012 年，Jared Hoberock Michael Garland Olivier Giroux Vinod Grover、Ujval Kapasi 和 Jaydeep Marathe 在 <a href="https://wg21.link/n3408" target="_blank" rel="noopener noreffer ">https://wg21.link/n3408</a> 中首次提出了并行化 STL 算法。 它成为了一个正式的 beta 标准，即并行 C++ 扩展技术规范（参见 <a href="https://wg21.link/n3850" target="_blank" rel="noopener noreffer ">https://wg21.link/n3850</a>）。 Jared Hoberock、Grant Mercer、Agustin Berge 和 Harmut Kaiser 在 <a href="https://wg21.link/n4276" target="_blank" rel="noopener noreffer ">https://wg21.link/n4276</a> 中添加了其他算法。 通过 <a href="https://wg21.link/p0024r2" target="_blank" rel="noopener noreffer ">https://wg21.link/p0024r2</a>，Jared Hoberock 提出的标准库采用了 C++ 并行扩展技术规范。 JF Bastien 和 Bryce Adelstein Lelbach 在 <a href="https://wg21.link/p0394r4" target="_blank" rel="noopener noreffer ">https://wg21.link/p0394r4</a> 中提出的异常处理被接受。</p>
<h3 id="23--子字符串和子序列搜索">23  子字符串和子序列搜索</h3>
<p>自C++98以来，C++标准库提供了一种搜索算法来寻找一个范围内元素的子序列。然而，存在着不同的搜索算法。例如，通过预先计算关于要搜索的模式的统计数据，这些算法对于特殊的任务，如在一个大文本中寻找子串，可以有明显的表现。
因此，C++17引入了Boyer-Moore和Boyer-Moore-Horspool搜索算法以及使用它们的各种接口。它们特别适用于搜索大文本中的子串，但也可以改进寻找容器或范围中的子序列。</p>
<h4 id="231-使用子串搜索器">23.1 使用子串搜索器</h4>
<p>新的搜索器是专门为搜索大型文本中的字符串（例如，单词或短语）而开发的。
因此，让我们首先演示一下在这种情况下如何使用它们，以及你如何利用它们来获益。</p>
<h5 id="2311-通过search使用搜索器">23.1.1 通过search()使用搜索器</h5>
<p>我们现在有以下选项来搜索一个字符串文本中的子串子:</p>
<ol>
<li>字符串成员 find():</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>size_type idx <span style="color:#f92672">=</span> text.find(sub)<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ol start="2">
<li>算法搜索()。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(text.begin(), text.end(),
</span></span><span style="display:flex;"><span>sub.begin(), sub.end())<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ol start="3">
<li>并行算法 search():</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par,
</span></span><span style="display:flex;"><span>text.begin(), text.end(), sub.begin(), sub.end()<span style="color:#960050;background-color:#1e0010">）。</span>
</span></span></code></pre></div><ol start="4">
<li>使用 default_searcher:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(text.begin(), text.end(),
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>default_searcher{sub.begin(), sub.end()})<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ol start="5">
<li>使用boyer_moore_searcher:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(text.begin(), text.end(),
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher{sub.begin(), sub.end()}<span style="color:#960050;background-color:#1e0010">）。</span>
</span></span></code></pre></div><ol start="6">
<li>使用boyer_moore_horspool_searcher:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(text.begin(), text.end(),
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_horspool_searcher{sub.begin(),
</span></span><span style="display:flex;"><span>sub.end()}<span style="color:#960050;background-color:#1e0010">）。</span>
</span></span></code></pre></div><p>新的搜索器被定义在<!-- raw HTML omitted -->中。
Boyer-Moore和Boyer-Moore-Horspool搜索器是众所周知的算法，在搜索开始前预先计算表格（哈希值），以提高搜索的速度，如果搜索覆盖了相当大的文本和/或子串。使用它们，算法需要随机访问的迭代器（而不是正向迭代器，这对于天真的搜索（）来说已经足够了）。</p>
<p>在lib/searcher1.cpp中，你可以找到一个完整的程序，演示如何使用这些不同的方式来搜索子串。
请注意，所有search()的应用都会产生一个指向匹配子串的第一个字符的迭代器。如果没有，则返回文本的末端。这样我们就可以搜索到一个子串的所有出现，如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bm{sub.begin(), sub.end()};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(text.begin(), text.end(), bm);
</span></span><span style="display:flex;"><span>pos <span style="color:#f92672">!=</span> text.end();
</span></span><span style="display:flex;"><span>pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(pos<span style="color:#f92672">+</span>sub.size(), text.end(), bm)) {
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> sub <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; at index &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pos <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="搜索器的性能">搜索器的性能</h6>
<p>哪一种是搜索子字符串的最佳方法（最快和/或最少的内存）？ 这个问题的一个特殊方面是我们现在也可以在并行模式下使用传统的 search() （使用新的搜索器时这是不可能的）。
答案取决于具体情况：</p>
<ul>
<li>
<p>仅使用（非并行）search() 通常是最慢的，因为对于文本中的每个字符，我们开始找出子字符串是否匹配。</p>
</li>
<li>
<p>使用 default_searcher 应该是等价的，但我看到更糟糕的运行时间高达 3 倍。</p>
</li>
<li>
<p>使用find()可能会更快，但这取决于库中实现的质量。在我所做的测量中，我看到与search()相比，运行时间提高了20%到100倍之间。</p>
</li>
<li>
<p>对于文本和相当大小的子串，boyer_moore_searcher应该是最快的。与search()相比，我看到了50倍甚至100倍的改进。在有大量子串的大文本中，这始终是最快的搜索。</p>
</li>
<li>
<p>boyer_moore__horspool_searcher以空间换时间。它通常比boyer_moore_searcher慢，但不应该使用那么多内存。我看到的改进在不同的平台上确实有很大的不同。在一个平台上，它接近boyer_moore（比search()好50倍，比find()好10倍），而在其他平台上，对search()的改进只有2或3倍，而使用find()则快得多。</p>
</li>
<li>
<p>使用并行的search()与普通的search()相比，我得到了3倍的支持，看起来使用Boyer-Moore搜索器通常还是要快很多。</p>
</li>
</ul>
<p>所以我只能给出一个建议。测量! 在你的目标平台上测试典型场景。
这是值得的，因为你可能会得到100倍的改进（例如，我在一个有1000万个字符的字符串中搜索一个接近结尾的1000个字符的子串）。
<code>lib/searcher1.cpp</code>中的代码还打印了不同搜索选项的测量值，这样你就可以比较你的平台上的数字。</p>
<h5 id="2312-直接使用搜索器">23.1.2 直接使用搜索器</h5>
<p>或者，你可以使用搜索器的函数调用操作，它返回一对开始和结束的一对子序列。
代码看起来如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bm{sub.begin(), sub.end()};
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> begend <span style="color:#f92672">=</span> bm(text.begin(), text.end());
</span></span><span style="display:flex;"><span>     begend.first <span style="color:#f92672">!=</span> text.end();
</span></span><span style="display:flex;"><span>     begend <span style="color:#f92672">=</span> bm(begend.second, text.end())) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> sub <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; at index &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> begend.first <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;-&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> begend.second <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然而，由于你可以使用std::tie()将新的值重新分配给结构化绑定的 std::pair&lt;&gt;，你可以将代码简化如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bm{sub.begin(), sub.end()};
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> [beg, end] <span style="color:#f92672">=</span> bm(text.begin(), text.end());
</span></span><span style="display:flex;"><span>     beg <span style="color:#f92672">!=</span> text.end();
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>tie(beg,end) <span style="color:#f92672">=</span> bm(end, text.end())) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> sub <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; at index &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> beg <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;-&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> end <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只是直接使用搜索器寻找子串的第一次出现，你可以使用如果与 初始化和结构化绑定:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bm{sub.begin(), sub.end()};
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> [beg, end] <span style="color:#f92672">=</span> bm(text.begin(), text.end()); beg <span style="color:#f92672">!=</span> text.end()) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> sub <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; first at index &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> beg <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;-&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> end <span style="color:#f92672">-</span> text.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="232-使用通用子序列搜索器">23.2 使用通用子序列搜索器</h4>
<p>Boyer-Moore 和 Boyer-Moore-Horspool 是作为字符串搜索器开发的。 但是，C++17 采用它们作为通用算法，以便您可以使用它们在容器或范围中查找元素的子序列。
也就是说，您现在可以实现以下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sub{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, ...};
</span></span><span style="display:flex;"><span>pos <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>search(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                  std<span style="color:#f92672">::</span>boyer_moore_searcher{sub.begin(), sub.end()});
</span></span></code></pre></div><p>同样，您还可以使用搜索器的函数调用运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sub{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, ...};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bm{sub.begin(), sub.end()};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> [beg, end] <span style="color:#f92672">=</span> bm(coll.begin(), coll.end());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (beg <span style="color:#f92672">!=</span> coll.end) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found subsequence at &lt;&lt; &#34;</span> beg <span style="color:#f92672">-</span> coll.begin() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了实现这一点，元素必须能够在哈希表中使用（即必须提供一个默认的哈希函数，并且必须支持用==来比较两个元素）。如果不是这种情况，你可以使用谓词（如下所述）。
再说一遍。测量发现你在性能（速度和内存）方面的好处。在尝试一些例子时，我看到了更多不同的因素。例如，使用boyer_moore_searcher可以将搜索的速度再次提高100倍（这又比使用并行算法快多了）。但是使用boyer_moore_horspool_searcher可以使搜索速度提高50倍，但也会慢2倍。
<code>lib/searcher2.cpp</code>中的代码演示了对一个向量中的子序列的不同搜索，还打印了不同搜索选项的测量结果，这样你就可以比较 在你的平台上进行比较。</p>
<h4 id="233-使用搜索器的谓词">23.3 使用搜索器的谓词</h4>
<p>使用搜索时，您可以使用谓词，这可能是必要的，原因有两个：</p>
<ol>
<li>
<p>您想定义自己的方式来比较两个元素。</p>
</li>
<li>
<p>你想提供一个哈希函数，这对于 Boyer-Moore(-Horspool) 搜索器是必需的。
您必须将谓词作为附加参数提供给搜索器的构造函数。 例如，这里我们不区分大小写地搜索子字符串：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bmic{substr.begin(), substr.end(),
</span></span><span style="display:flex;"><span>                             [](<span style="color:#66d9ef">char</span> c){
</span></span><span style="display:flex;"><span>                                 <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>hash<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>{}(std<span style="color:#f92672">::</span>toupper(c));
</span></span><span style="display:flex;"><span>                             },
</span></span><span style="display:flex;"><span>                             [](<span style="color:#66d9ef">char</span> c1, <span style="color:#66d9ef">char</span> c2){
</span></span><span style="display:flex;"><span>                                 <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>toupper(c1)<span style="color:#f92672">==</span>std<span style="color:#f92672">::</span>toupper(c2);
</span></span><span style="display:flex;"><span>                             }
</span></span><span style="display:flex;"><span>                            };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> begend <span style="color:#f92672">=</span> bmic(sub.begin(), sub.end());
</span></span></code></pre></div><p>在散列值之前不要忘记调用 toupper()，否则你违反了散列值对于所有值必须相同的要求，其中 operator== 产生 true。
在这里，如果我们有一个类 Customer 定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>  ...;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  Customer() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>string getID() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> id;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span> (<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c1, <span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c2) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> c1.id <span style="color:#f92672">==</span> c2.id;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>我们可以在Customer vector中搜索客户子序列，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Customer<span style="color:#f92672">&gt;</span> customers;
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Customer<span style="color:#f92672">&gt;</span> sub{...};
</span></span><span style="display:flex;"><span>...;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>boyer_moore_searcher bmcust(sub.begin(), sub.end(),
</span></span><span style="display:flex;"><span>                               [](<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) {
</span></span><span style="display:flex;"><span>                                   <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>hash<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span>{}(c.getID());
</span></span><span style="display:flex;"><span>                               });
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> bmcust(customers.begin(), customers.end());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pos.first <span style="color:#f92672">!=</span> customers.end()) {
</span></span><span style="display:flex;"><span>  ...;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是请注意，使用谓词可能会给使用搜索器带来很大的开销，所以只有当你有大量的元素并搜索一个相当大的子序列时才值得使用它们（例如，在100万个客户的集合中寻找1000个客户的子序列）。
再次强调。要有大的思维，要有大的度量。</p>
<h4 id="234-后记">23.4 后记</h4>
<p>这些搜索最初是由 Marshall Clow 在 <a href="https://wg21.link/n3411" target="_blank" rel="noopener noreffer ">https://wg21.link/n3411</a> 中提出的，将 Boost.Algorithm 作为参考实现。 它们成为第一个图书馆基础 TS 的一部分。 对于 C++17，它们随后与 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1" target="_blank" rel="noopener noreffer ">https://wg21.link/p0220r1</a> 中提出的其他组件一起采用，包括 Marshall Clow 在 <a href="https://wg21.link/p0253R1" target="_blank" rel="noopener noreffer ">https://wg21.link/p0253R1</a> 中提出的接口修复。</p>
<h3 id="24-其他工具函数和算法">24 其他工具函数和算法</h3>
<p>C++17 提供了一些新的实用函数和算法，本章将对其进行介绍。</p>
<h4 id="241-size-empty-and-data">24.1 size(), empty(), and data()</h4>
<p>为了支持通用代码的灵活性，C++标准库提供了三个新的辅助函数：size()、empty()和data()。
正如其他用于泛型代码迭代范围和集合的全局辅助函数std::begin(), std::end(), 和std::advance()一样，这些函数被定义在头文件<!-- raw HTML omitted -->中。</p>
<h5 id="2411-通用的size函数">24.1.1 通用的size()函数</h5>
<p>通用的std::size()函数允许我们询问任何范围的大小，只要它有一个迭代器接口或者是一个原始数组。有了它，你可以写这样的代码:</p>
<p><code>lib/last5.hpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef LAST5_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LAST5_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> printLast5(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> coll)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算大小:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> size{std<span style="color:#f92672">::</span>size(coll)};
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 前进到从最后 5 个元素开始的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; elems: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> pos{std<span style="color:#f92672">::</span>begin(coll)};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>advance(pos, size <span style="color:#f92672">-</span> <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;... &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印剩余元素:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> ( ; pos <span style="color:#f92672">!=</span> std<span style="color:#f92672">::</span>end(coll); <span style="color:#f92672">++</span>pos) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pos <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// LAST5_HPP
</span></span></span></code></pre></div><p>在这里，与</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> size{std<span style="color:#f92672">::</span>size(coll)};
</span></span></code></pre></div><p>我们用传递的集合的大小来初始化 size，它要么映射到 coll.size() 要么映射到传递的原始数组的大小。 因此，如果我们调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>array arr{<span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">55</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector v{<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">8.8</span>, <span style="color:#ae81ff">15.15</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> il{<span style="color:#e6db74">&#34;just&#34;</span>, <span style="color:#e6db74">&#34;five&#34;</span>, <span style="color:#e6db74">&#34;small&#34;</span>, <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>                                      <span style="color:#e6db74">&#34;literals&#34;</span>};
</span></span><span style="display:flex;"><span>printLast5(arr);
</span></span><span style="display:flex;"><span>printLast5(v);
</span></span><span style="display:flex;"><span>printLast5(il);
</span></span></code></pre></div><p>输出是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#ae81ff">9</span> elems: ... <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">22</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">55</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> elems: <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">8.8</span> <span style="color:#ae81ff">15.15</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span> elems: just five small string literal
</span></span></code></pre></div><p>并且因为支持原始 C 数组，我们也可以调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>printLast5(<span style="color:#e6db74">&#34;hello world&#34;</span>);
</span></span></code></pre></div><p>打印:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#ae81ff">12</span> elems: ... o r l d
</span></span></code></pre></div><p>请注意，此函数模板因此替换了使用 countof 或 ARRAYSIZE 定义为类似以下内容的计算数组大小的常用方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define ARRAYSIZE(a) (sizeof(a)/sizeof(*(a)))
</span></span></span></code></pre></div><p>另请注意，您不能将内联定义的初始化列表传递给 last5&lt;&gt;()。 原因是模板参数不能推导出 std::initializer_list()。 为此，您必须使用以下声明重载 last5()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> printLast5(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> coll)
</span></span></code></pre></div><p>最后，请注意此代码不适用于 forward_list&lt;&gt;，因为转发列表没有成员函数 size()。 所以，如果你只想检查集合是否为空，你最好使用std::empty()，这将在后面讨论。</p>
<h5 id="2412-通用的empty函数">24.1.2 通用的empty()函数</h5>
<p>与新的全局 size() 类似，新的通用 std::empty() 允许我们检查容器、原始 C 数组或 std::initializer_list&lt;&gt; 是否为空。
因此，与上面的示例类似，您可以一般地检查传递的集合是否为空：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>empty(coll)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与 std::size() 相比，std::empty() 也适用于前向列表/</p>
<h5 id="2413-通用的data函数">24.1.3 通用的data()函数</h5>
<p>最后，新的通用 std::data() 函数允许我们访问具有 data() 成员和原始数组的容器的原始数据。 容器、原始 C 数组或 std::initializer_list&lt;&gt;。
例如，以下代码每隔一个元素打印一次：</p>
<p><code>lib/data.hpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef DATA_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DATA_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> printData(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> coll)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 每隔一个元素打印一次:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>size_t idx{<span style="color:#ae81ff">0</span>}; idx <span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>size(coll); <span style="color:#f92672">++</span>idx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>data(coll)[idx] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// DATA_HPP
</span></span></span></code></pre></div><p>因此，如果我们调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>array arr{<span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">55</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector v{<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">8.8</span>, <span style="color:#ae81ff">15.15</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> il{<span style="color:#e6db74">&#34;just&#34;</span>, <span style="color:#e6db74">&#34;five&#34;</span>, <span style="color:#e6db74">&#34;small&#34;</span>, <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>                                      <span style="color:#e6db74">&#34;literals&#34;</span>};
</span></span><span style="display:flex;"><span>printData(arr);
</span></span><span style="display:flex;"><span>printData(v);
</span></span><span style="display:flex;"><span>printData(il);
</span></span><span style="display:flex;"><span>printData(<span style="color:#e6db74">&#34;hello world&#34;</span>);
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#ae81ff">27</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">22</span> <span style="color:#ae81ff">55</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">15.15</span>
</span></span><span style="display:flex;"><span>just small literals
</span></span><span style="display:flex;"><span>h l o w r d
</span></span></code></pre></div><h4 id="242-as_const">24.2 as_const()</h4>
<p>新的辅助函数 std::as_const() 将值转换为相应的 const 值，而不使用 static_cast&lt;&gt; 或 add_const_t&lt;&gt; 类型特征。
它允许我们强制为非 const 对象调用函数的 const 重载，以防万一：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>foo(coll); <span style="color:#75715e">// 喜欢非常量重载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>foo(std<span style="color:#f92672">::</span>as_const(coll)); <span style="color:#75715e">// 强制使用 const 重载
</span></span></span></code></pre></div><p>如果 foo() 是一个函数模板，这也将强制将模板实例化为 const 类型而不是原始的非常量类型。</p>
<h5 id="2421-通过常量引用进行捕获">24.2.1 通过常量引用进行捕获</h5>
<p>as_const() 的一种应用是通过 const 引用捕获 lambda 参数的能力。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> coll {<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">42</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> printColl <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>coll <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>as_const(coll)] {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;coll: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> elem : coll) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> elem <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>现在调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>printColl();
</span></span></code></pre></div><p>将打印 coll 的当前状态，而不会有意外修改其值的危险。</p>
<h4 id="243-clamp">24.3 clamp()</h4>
<p>C++17 提供了一个新的实用函数clamp()，它可以在传递的最小值和最大值之间“钳制”一个值。 它是 min() 和 max() 的组合调用。 例如：
<code>lib/clamp.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt; // for sample()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i : {<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>}) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>clamp(i, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">13</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调用clamp(i, 5, 13) 与调用std::min(std::max(i, 5), 13) 的效果相同，因此程序具有以下输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>
</span></span></code></pre></div><p>至于 min() 和 max()，clamp() 要求所有通过 const 引用传递的参数都具有相同的类型 T：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> clamp(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> min, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> max);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>返回值是对传递参数之一的 const 引用。
如果传递不同类型的参数，则可以显式指定模板参数 T：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> d{<span style="color:#ae81ff">4.3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> max{<span style="color:#ae81ff">13</span>};
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>clamp(d, <span style="color:#ae81ff">0</span>, max); <span style="color:#75715e">// 编译时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>clamp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(d, <span style="color:#ae81ff">0</span>, max); <span style="color:#75715e">// OK
</span></span></span></code></pre></div><p>你也可以传递浮点值，只要它们没有 NaN 值。
至于 min() 和 max() 你可以传递一个谓词作为比较操作。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i : {<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>}) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>clamp(i, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">13</span>,
</span></span><span style="display:flex;"><span>                            [] (<span style="color:#66d9ef">auto</span> a, <span style="color:#66d9ef">auto</span> b) {
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>abs(a) <span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>abs(b);
</span></span><span style="display:flex;"><span>                            })
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>具有以下输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span>
</span></span></code></pre></div><p>因为 -7 的绝对值介于 5 和 13 的绝对值之间，所以在这种情况下，clamp() 产生 -7。
没有采用值的初始化列表（如 min() 和 max() 所具有的）的 clamp() 的重载。</p>
<h4 id="244-sample">24.4 sample()</h4>
<p>通过sample()，C++17提供了一种算法，可以从一个给定的数值范围（群体）中提取一个随机子集（样本）。这有时被称为蓄水池采样或选择采样。
考虑一下下面的例子程序。</p>
<p><code>lib/sample1.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt; // for clamp()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt; // for default_random_engine</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化一个包含 10,000 个字符串值的vector:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.push_back(<span style="color:#e6db74">&#34;value&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印此集合的 10 个随机选择的值:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sample(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>           std<span style="color:#f92672">::</span>ostream_iterator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span>{std<span style="color:#f92672">::</span>cout, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>},
</span></span><span style="display:flex;"><span>           <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>           std<span style="color:#f92672">::</span>default_random_engine{});
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在使用大量字符串值（value0、value1、&hellip;）初始化向量后，我们使用 sample() 来提取这些字符串值的随机子集：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 打印此集合的 10 个随机选择的值:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sample(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>       std<span style="color:#f92672">::</span>ostream_iterator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span>{std<span style="color:#f92672">::</span>cout, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>},
</span></span><span style="display:flex;"><span>       <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>       std<span style="color:#f92672">::</span>default_random_engine{});
</span></span></code></pre></div><p>我们通过：</p>
<ul>
<li>我们从中提取值子集的范围的开始和结束，</li>
<li>一个迭代器，用于将提取的值写入（这里是一个 ostream 迭代器将它们写入标准输出）</li>
<li>要提取的值的最大数量（我们可能会提取较少的值，范围太小）</li>
<li>用于计算随机子集的随机引擎</li>
</ul>
<p>结果，我们打印了 coll 的 10 个元素的随机子集。 输出可能是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>value0
</span></span><span style="display:flex;"><span>value488
</span></span><span style="display:flex;"><span>value963
</span></span><span style="display:flex;"><span>value1994
</span></span><span style="display:flex;"><span>value2540
</span></span><span style="display:flex;"><span>value2709
</span></span><span style="display:flex;"><span>value2835
</span></span><span style="display:flex;"><span>value3518
</span></span><span style="display:flex;"><span>value5172
</span></span><span style="display:flex;"><span>value7996
</span></span></code></pre></div><p>如您所见，元素的顺序是稳定的（与它们在 coll 中的顺序相匹配）。 但是，只有在传递范围的迭代器至少是前向迭代器时，才能保证这一点。
算法声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> InputIterator, <span style="color:#66d9ef">typename</span> OutputIterator,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> Distance, <span style="color:#66d9ef">typename</span> UniformRandomBitGenerator<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        OutputIterator sample(InputIterator sourceBeg, InputIterator sourceEnd,
</span></span><span style="display:flex;"><span>                              OutputIterator destBeg,
</span></span><span style="display:flex;"><span>                              Distance num,
</span></span><span style="display:flex;"><span>                              UniformRandomBitGenerator<span style="color:#f92672">&amp;&amp;</span> eng);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它具有以下规范和约束：</p>
<ul>
<li>源范围的迭代器必须至少是输入迭代器，目标范围的迭代器必须至少是输出迭代器。 但是，两者都不可能。 如果源迭代器不是最小前向迭代器，则目标迭代器必须是随机访问迭代器。</li>
<li>像往常一样，目标迭代器会覆盖，如果没有足够的元素可以覆盖并且没有使用插入器，则会导致未定义的行为。</li>
<li>该算法返回最后一个复制元素之后的位置。</li>
<li>目标迭代器不得在传递的源范围内。</li>
<li>num 可以是整数类型。 如果源范围内的元素不足，则提取源范围内的所有元素。</li>
<li>提取元素的顺序是稳定的，除非源范围内的迭代器是纯输入迭代器。</li>
</ul>
<p>这是另一个演示 sample() 用法的示例：</p>
<p><code>lib/sample2.cpp </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt; // for clamp()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt; // for default_random_engine</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// initialize a vector of 10,000 string values:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.push_back(<span style="color:#e6db74">&#34;value&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用随机种子初始化 Mersenne Twister 引擎:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>random_device rd; <span style="color:#75715e">// 随机种子（如果支持）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>mt19937 eng{rd()}; <span style="color:#75715e">// Mersenne twister engine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化目标范围（必须足够大以容纳 10 个元素）:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> subset;
</span></span><span style="display:flex;"><span>    subset.resize(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 10 个随机选择的值从源范围复制到目标范围:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> end <span style="color:#f92672">=</span> sample(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                      subset.begin(),
</span></span><span style="display:flex;"><span>                      <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>                      eng);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印提取的元素（使用返回值作为新的结束）:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    for_each(subset.begin(), end,
</span></span><span style="display:flex;"><span>             [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> s) {
</span></span><span style="display:flex;"><span>                 std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;random elem: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>             });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在再次用大量字符串值（value0，value1，&hellip;）初始化一个vector之后，我们初始化一个用随机种子初始化的随机数引擎：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 用一个随机种子初始化一个Mersenne Twister引擎:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>random_device rd; <span style="color:#75715e">// 随机种子（如果支持）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>mt19937 eng{rd()}; <span style="color:#75715e">// Mersenne Twister引擎 
</span></span></span></code></pre></div><p>和一个目标范围:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 初始化目标范围（必须足够大以容纳 10 个元素）:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> subset;
</span></span><span style="display:flex;"><span>subset.resize(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div><p>sample() 的调用现在将源范围的 10 个元素复制到目标范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 将 10 个随机选择的值从源范围复制到目标范围:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> end <span style="color:#f92672">=</span> sample(coll.begin(), coll.end(),
</span></span><span style="display:flex;"><span>                  subset.begin(),
</span></span><span style="display:flex;"><span>                  <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>                  eng);
</span></span></code></pre></div><p>返回值 end 初始化为包含最后一个随机提取的元素后面的位置，之后可以使用该位置，例如，打印提取的元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 打印提取的元素（使用返回值作为新的结束）：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>for_each(subset.begin(), end,
</span></span><span style="display:flex;"><span>         [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> s) {
</span></span><span style="display:flex;"><span>             std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;random elem: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>         });
</span></span></code></pre></div><h4 id="245-for_each_n">24.5 for_each_n()</h4>
<p>作为并行 STL 算法的一部分，提出了一种新算法 for_each_n()，该算法从 C++17 开始也以传统的非并行形式提供。 与 copy_n()、fill_n() 和 generate_n() 类似，它需要一个整数参数来将传递的可调用对象应用于给定范围的 n 个元素。
例如：
<code>lib/foreachn.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt; // for for_each_n()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化一个包含 10,000 个字符串值的vector:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> coll;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        coll.push_back(std<span style="color:#f92672">::</span>to_string(i));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改前 5 个元素：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    for_each_n(coll.begin(), <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>               [] (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> elem) {
</span></span><span style="display:flex;"><span>                   elem <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;value&#34;</span> <span style="color:#f92672">+</span> elem;
</span></span><span style="display:flex;"><span>               });
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印前 10 个元素：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    for_each_n(coll.begin(), <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>               [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> elem) {
</span></span><span style="display:flex;"><span>                   std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> elem <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>               });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在用大量字符串值（value0、value1、&hellip;）初始化一个vector后，我们首先修改前 5 个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>for_each_n(coll.begin(), <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>           [] (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> elem) {
</span></span><span style="display:flex;"><span>               elem <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;value&#34;</span> <span style="color:#f92672">+</span> elem;
</span></span><span style="display:flex;"><span>           });
</span></span></code></pre></div><p>然后打印前 10 个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>for_each_n(coll.begin(), <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>           [] (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> elem) {
</span></span><span style="display:flex;"><span>               std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> elem <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>           });
</span></span></code></pre></div><p>因此，该程序具有以下输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>value0
</span></span><span style="display:flex;"><span>value1
</span></span><span style="display:flex;"><span>value2
</span></span><span style="display:flex;"><span>value3
</span></span><span style="display:flex;"><span>value4
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>
</span></span></code></pre></div><p>算法声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> InputIterator, <span style="color:#66d9ef">typename</span> Size, <span style="color:#66d9ef">typename</span> Function<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    InputIterator for_each_n(InputIterator first, Size n, Function f);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意以下事项：</p>
<ul>
<li>for_each_n() 的非并行版本保证为每个元素按顺序调用传递的可调用对象。</li>
<li>for_each_n() 算法作为迭代器返回最后处理的元素后面的位置。</li>
<li>由调用者确保给定范围有足够的元素。</li>
<li>传递的可调用对象的任何返回值都将被忽略。</li>
</ul>
<p>该算法也可用作并行 STL 算法，它允许我们将任何函数应用于前 n 个元素，而无需保证任何顺序。</p>
<h4 id="246-后记">24.6 后记</h4>
<p>size()、empty() 和 data() 最早由 Riccardo Marcangelo 在 <a href="https://wg21.link/n4017" target="_blank" rel="noopener noreffer ">https://wg21.link/n4017</a> 中提出。 最终接受的措辞由 Riccardo Marcangelo 在 <a href="https://wg21.link/n4280" target="_blank" rel="noopener noreffer ">https://wg21.link/n4280</a> 中制定。
as_const() 由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a href="https://wg21.link/n4380" target="_blank" rel="noopener noreffer ">https://wg21.link/n4380</a> 中首次提出。 最终接受的措辞由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a href="https://wg21.link/p0007r1" target="_blank" rel="noopener noreffer ">https://wg21.link/p0007r1</a> 中制定。
clamp() 由 Martin Moene 和 Niels Dekker 在 <a href="https://wg21.link/n4536" target="_blank" rel="noopener noreffer ">https://wg21.link/n4536</a> 中首次提出。 最终接受的措辞由 Martin Moene 和 Niels Dekker 在 <a href="https://wg21.link/p002501" target="_blank" rel="noopener noreffer ">https://wg21.link/p002501</a> 中制定。</p>
<p>sample() 由 Walter E. Brown 在 <a href="https://wg21.link/n3842" target="_blank" rel="noopener noreffer ">https://wg21.link/n3842</a> 中首次提出。 最终接受的措辞由 Walter E. Brown 在 <a href="https://wg21.link/n3925" target="_blank" rel="noopener noreffer ">https://wg21.link/n3925</a> 中制定。</p>
<h3 id="25--容器扩展">25  容器扩展</h3>
<p>C++ 标准库的标准容器有一些细微的变化，本章将对此进行描述。</p>
<h4 id="251-支持不完整的容器类型">25.1 支持不完整的容器类型</h4>
<p>由于 C++17 需要 std::vector、std::list 和 std__forward_list 来支持不完整类型。
这样做的主要动机在 Matt Austern 的一篇名为“标准图书馆员：不完整类型的容器”的文章中进行了描述（参见 <a href="http://drdobbs.com/184403814" target="_blank" rel="noopener noreffer ">http://drdobbs.com/184403814</a>）：您现在可以拥有一个类型，它递归地拥有一个成员 其类型的容器。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string value;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> children; <span style="color:#75715e">// 好的，因为 C++17（节点在这里是不完整的类型）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>这也适用于具有私有成员和公共 API 的类。 这是一个完整的例子：</p>
<p><code>lib/incomplete.hpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef NODE_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define NODE_HPP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string value;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> children; <span style="color:#75715e">// 好的，因为 C++17（节点在这里是不完整的类型）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个带值的节点:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node(std<span style="color:#f92672">::</span>string s) <span style="color:#f92672">:</span> value{std<span style="color:#f92672">::</span>move(s)}, children{} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 添加子节点:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(Node n) {
</span></span><span style="display:flex;"><span>        children.push_back(std<span style="color:#f92672">::</span>move(n));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 访问子节点:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span>[](std<span style="color:#f92672">::</span>size_t idx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> children.at(idx);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归打印节点树:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> indent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>string(indent, <span style="color:#e6db74">&#39; &#39;</span>) <span style="color:#f92672">&lt;&lt;</span> value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> n : children) {
</span></span><span style="display:flex;"><span>            n.print(indent<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// NODE_HPP
</span></span></span></code></pre></div><p>您可以使用此类，例如，如下所示：</p>
<p><code>lib/incomplete.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;incomplete.hpp&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建节点树:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node root{<span style="color:#e6db74">&#34;top&#34;</span>};
</span></span><span style="display:flex;"><span>    root.add(Node{<span style="color:#e6db74">&#34;elem1&#34;</span>});
</span></span><span style="display:flex;"><span>    root.add(Node{<span style="color:#e6db74">&#34;elem2&#34;</span>});
</span></span><span style="display:flex;"><span>    root[<span style="color:#ae81ff">0</span>].add(Node{<span style="color:#e6db74">&#34;elem1.1&#34;</span>});
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// print node tree:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    root.print();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该程序具有以下输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>top
</span></span><span style="display:flex;"><span>elem1
</span></span><span style="display:flex;"><span>elem1.1
</span></span><span style="display:flex;"><span>elem2
</span></span></code></pre></div><h4 id="252-节点处理程序">25.2 节点处理程序</h4>
<p>通过引入从关联或无序容器中拼接节点的能力，你可以轻松地：</p>
<ul>
<li>修改键或（无序）maps或maps或（无序）集合。</li>
<li>在（无序） sets 和 maps中使用移动语义，以及</li>
<li>在（无序）sets 和 maps之间移动元素。</li>
</ul>
<p>例如，在定义和初始化一个map后，如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> m{{<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#34;mango&#34;</span>},
</span></span><span style="display:flex;"><span>                             {<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;papaya&#34;</span>},
</span></span><span style="display:flex;"><span>                             {<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#34;guava&#34;</span>}};
</span></span></code></pre></div><p>您可以使用键 2 修改元素，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> nh <span style="color:#f92672">=</span> m.extract(<span style="color:#ae81ff">2</span>); <span style="color:#75715e">// nh 的类型为 decltype(m)::node_type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>nh.key() <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>m.insert(std<span style="color:#f92672">::</span>move(nh));
</span></span></code></pre></div><p>代码将键为 2 的元素的节点从容器中取出，修改键，然后将其移回，如图 25.1 中所述。
请注意，不使用内存（取消）分配，并且对元素的指针和引用保持有效。 但是，在元素保存在节点句柄中时使用指针和引用会导致未定义的行为。</p>
<p>节点句柄的类型是 container::node_type。 它为会员提供</p>
<ul>
<li>所有（无序）集合类型的value()</li>
<li>所有（无序）map类型的成员 key() 和 mapped()</li>
</ul>
<p>您还可以使用节点句柄将元素从一个容器移动到另一个容器。 容器甚至可以通过以下方式有所不同：</p>
<ul>
<li>一个支持重复，而另一个不支持（例如，您可以将元素从多地图移动到地图）</li>
<li>比较函数和散列函数可能不同</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png"
        data-srcset="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png, https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png 1.5x, https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png"
        title="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png" /> )</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>multimap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> src {{<span style="color:#ae81ff">1.1</span>,<span style="color:#e6db74">&#34;one&#34;</span>},
</span></span><span style="display:flex;"><span>                                        {<span style="color:#ae81ff">2.2</span>,<span style="color:#e6db74">&#34;two&#34;</span>},
</span></span><span style="display:flex;"><span>                                        {<span style="color:#ae81ff">3.3</span>,<span style="color:#e6db74">&#34;three&#34;</span>}};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> dst {{<span style="color:#ae81ff">3.3</span>,<span style="color:#e6db74">&#34;old data&#34;</span>}};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一些元素从 multimap src 移动到 map dst:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dst.insert(src.extract(src.find(<span style="color:#ae81ff">1.1</span>))); <span style="color:#75715e">// 使用迭代器拼接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dst.insert(src.extract(<span style="color:#ae81ff">2.2</span>)); <span style="color:#75715e">// 使用键拼接
</span></span></span></code></pre></div><p>请注意， insert() 函数返回一个包含三个元素的结构（按以下顺序）：</p>
<ul>
<li>如果无法插入，则为现有元素的迭代器位置。</li>
<li>插入一个布尔值，表示插入是否成功。</li>
<li>如果无法插入，则带有节点句柄的 mode_type 节点。</li>
</ul>
<p>即，关键信息是插入的第二个成员。 使用结构化绑定，您可以按如下方式使用返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> [pos,done,node] <span style="color:#f92672">=</span> dst.insert(src.extract(<span style="color:#ae81ff">3.3</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>done) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;insert() of node handle failed:&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; tried to insert key &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> node.key()
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; with value &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> node.mapped()
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; but key exists with value &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> pos<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="253-后记">25.3 后记</h4>
<p>容器对不完整类型的支持首先是由 Matt Austern 在 <a href="http://drdobbs.com/184403814" target="_blank" rel="noopener noreffer ">http://drdobbs.com/184403814</a> 中讨论的，最初是由袁志豪在 <a href="https://wg21.link/n3890" target="_blank" rel="noopener noreffer ">https://wg21.link/n3890</a> 中提出的。 最终接受的措辞由袁志豪在 <a href="https://wg21.link/n4510" target="_blank" rel="noopener noreffer ">https://wg21.link/n4510</a> 中制定。</p>
<p>节点句柄首先由 Alan Talbot 间接提出，请求拼接操作作为库问题 <a href="https://wg21.link/lwg839" target="_blank" rel="noopener noreffer ">https://wg21.link/lwg839</a> 和 Alisdair Meredith 请求对节点元素的移动支持作为库问题 <a href="https://wg21.link/lwg1041" target="_blank" rel="noopener noreffer ">https://wg21.link/lwg1041</a>。 最终接受的措辞由 Alan Talbot、Jonathan Wakely、Howard Hinnant 和 James Dennett 在 <a href="https://wg21.link/p0083r3" target="_blank" rel="noopener noreffer ">https://wg21.link/p0083r3</a> 中制定。 最终，Howard E. Hinnant 在 <a href="https://wg21.link/p0508r0" target="_blank" rel="noopener noreffer ">https://wg21.link/p0508r0</a> 中稍微澄清了 API。</p>
<h3 id="26-多线程和并发">26 多线程和并发</h3>
<p>在多线程和并发领域引入了一些小的扩展和改进。</p>
<h4 id="261-补充的互斥和锁">26.1 补充的互斥和锁</h4>
<h5 id="2611-stdscoped_lock">26.1.1 std::scoped_lock</h5>
<p>C++11 引入了一个简单的 std::lock_guard 来以一种简单的 RAII 风格的方式来锁定互斥锁：</p>
<ul>
<li>构造函数锁</li>
<li>析构函数解锁（可能由异常引起）</li>
</ul>
<p>不幸的是，这没有标准化为可变参数模板，以便能够通过单个声明锁定多个互斥锁。
std::scoped_lock&lt;&gt; 弥补了这一差距。 它允许我们锁定一个或多个互斥锁。 互斥锁可能有不同的互斥锁类型。
例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> allIssues;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex allIssuesMx;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> openIssues;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>timed_mutex openIssuesMx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// lock both issue lists:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>scoped_lock lg(allIssuesMx, openIssuesMx)
</span></span><span style="display:flex;"><span>    ...; <span style="color:#75715e">// 操作 allIssues 和 openIssues
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>请注意，由于类模板参数推导，您在声明 lg 时不必指定互斥锁的类型。
此示例用法等价于以下代码，从 C++11 开始可以调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 锁定两个问题清单:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>lock(allIssuesMx, openIssuesMx); <span style="color:#75715e">// 避免死锁的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lg1(allIssuesMx, std<span style="color:#f92672">::</span>adopt_lock);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lg2(openIssuesMx, std<span style="color:#f92672">::</span>adopt_lock);
</span></span><span style="display:flex;"><span>	... <span style="color:#75715e">// 同时操作allIssues和openIssues
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>因此，如果传递了多个互斥锁，则 scoped_lock 的构造函数使用可变参数便利函数 lock(&hellip;)，它保证调用不会导致死锁（标准注释：“死锁避免算法，例如 因为必须使用try-and-back-off，但没有指定具体算法以避免过度约束实现”）。
如果只将一个互斥锁传递给 scoped_lock 的构造函数，它只会锁定互斥锁。 因此，在具有单个构造函数参数的 scoped_lock 中，其作用类似于 lock_guard）。 然后它甚至定义了没有为多个互斥锁定义的成员 mutex_type。1 因此，您可以将 lock_guard 的所有用法替换为 scoped_lock。
如果没有传递互斥体，则锁守卫不起作用。
请注意，您还可以采用多个锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 锁定两个问题清单:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>lock(allIssuesMx, openIssuesMx); <span style="color:#75715e">// 注意：使用的死锁避免算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>scoped_lock lg(std<span style="color:#f92672">::</span>adopt_lock, allIssuesMx, openIssuesMx);
</span></span><span style="display:flex;"><span>	... <span style="color:#75715e">// 同时操作allIssues和openIssues
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>然而，请注意，采用锁的构造函数现在在前面有 adopt_lock 参数。</p>
<h5 id="2612-stdshared_mutex">26.1.2 std::shared_mutex</h5>
<p>C++14添加了shared_timed_mutex来支持读/写锁，即多个线程同时读取一个值，而不时地有线程可能会更新这个值。因为在一些平台上，不支持定时锁的mutex可以更有效地实现，现在引入了shared_mutex类型（就像自C++11以来，除了std::timed_mutex之外，还有std::mutex存在）。
shared_mutex定义在头文件&lt;shared_mutex&gt;中，支持以下操作。</p>
<ul>
<li>对于独占锁：lock(), try_lock(), unlock()</li>
<li>对于共享的读访问：lock_shared(), try_lock_shared(), unlock_shared()</li>
<li>native_handle()</li>
</ul>
<p>也就是说，与shared_times_mutex不同，它不支持try_lock_for()、try_lock_until()。try_lock_shared_for(), and try_lock_shared_until()。</p>
<h6 id="使用-shared_mutex">使用 shared_mutex</h6>
<p>使用shared_mutex的方法如下。假设你有一个共享vector，它通常被多个线程读取，但不时地被修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;shared_mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> v; <span style="color:#75715e">// 共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>shared_mutex vMutex; <span style="color:#75715e">// 控制对 v 的访问（C++14 中的 shared_timed_mutex）
</span></span></span></code></pre></div><p>要进行共享读取访问（以便多个读取器不会相互阻塞），请使用 shared_lock，它是共享读取访问的锁保护（在 C++14 中引入）。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>shared_lock sl(vMutex); v.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    ... <span style="color:#75715e">// （共享）对vector v 元素的读取访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>只有在排他性的写访问中，你才会使用排他性的锁防护，这可能是一个简单的lock_guard或scoped_lock（如刚刚介绍的），或者是一个复杂的unique_lock。比如说:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>scoped_lock sl(vMutex);
</span></span><span style="display:flex;"><span>    ... <span style="color:#75715e">// 对vector 的独占写读访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="262-原子的-is_always_lock_free">26.2 原子的 is_always_lock_free()</h4>
<p>你现在可以通过一个C++库的功能来检查一个特定的原子类型是否总是可以在没有锁的情况下使用不加锁。比如说：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>is_always_lock_free) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果该值为真，那么对于相应的原子类型的任何对象来说，is_lock_free()产生真:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(atomic<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>is_always_lock_free) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static_assert</span>(atomic<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>().is_lock_free()); <span style="color:#75715e">// 从未失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>如果有的话，这个值与相应的宏的值相匹配，在C++17之前必须使用。
例如，如果且仅当ATOMIC_INT_LOCK_FREE产生2（代表 &ldquo;总是&rdquo;），那么std::atomic<!-- raw HTML omitted -->::is_always_lock_free()产生true。:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>is_always_lock_free) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ATOMIC_INT_LOCK_FREE == 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ATOMIC_INT_LOCK_FREE == 0 || ATOMIC_INT_LOCK_FREE == 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>用静态成员代替宏的原因是为了有更多的类型安全，并支持在棘手的通用代码中使用这种检查（例如，使用SFINAE）。
请记住，std::atomic&lt;&gt;也可以用于琐碎的可复制类型。因此，你也可以检查，如果你自己的结构在原子上使用，是否需要锁。比如说：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">auto</span> SZ<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> set;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> values[SZ];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> average;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span>(std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;&gt;::</span>is_always_lock_free) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="263-缓存线的大小">26.3 缓存线的大小</h4>
<p>有时对于一个程序来说，处理缓存线的大小是很重要的。</p>
<ul>
<li>一方面，不同线程访问的不同对象不属于同一个缓存线，这对并发性很重要。否则，当不同的线程同时访问时，同样数量的内存必须在它们之间进行同步。</li>
<li>另一方面，你的目标可能是将多个对象放在同一个缓存线中，这样访问第一个对象就可以直接访问其他对象，而不是将它们加载到缓存中。</li>
</ul>
<p>为此，C++标准库在头文件<!-- raw HTML omitted -->中引入了两个内联变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> std {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">constexpr</span> size_t hardware_destructive_interference_size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">constexpr</span> size_t hardware_constructive_interference_size;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这些对象有以下执行定义的值。</p>
<ul>
<li>hardware_destructive_interference_size是推荐的两个可能被不同线程同时访问的对象之间的最小偏移量，以避免因为同一L1缓存线受到影响而导致性能下降。</li>
<li>hardware_constructive_interference_size是推荐的两个对象放在同一L1缓存行内的最大连续内存大小。</li>
</ul>
<p>这两个值只是提示，因为理想的值可能取决于具体的架构。这些常数是编译器在处理生成的代码所支持的各种平台时所能提供的最佳值。所以，如果你知道的更多，请使用特定的值，但对于支持多种平台的代码来说，使用这些值比任何假定的固定尺寸要好。
这些值至少都是alignof(std::max_align_t)。通常情况下，值是相同的。然而，从语义上讲，它们代表了使用不同对象的不同目的，所以你应该使用它们 相应地使用它们，</p>
<p>如下所示:</p>
<ul>
<li>如果你想通过不同的线程访问两个不同的（原子）对象。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">alignas</span>(std<span style="color:#f92672">::</span>hardware_destructive_interference_size) <span style="color:#66d9ef">int</span> valueForOneThread;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">alignas</span>(std<span style="color:#f92672">::</span>hardware_destructive_interference_size) <span style="color:#66d9ef">int</span> valueForAnotherThread;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>如果你想通过同一个线程访问两个不同的（原子）对象。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> valueForOneThread;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> valueForTheSameThread;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 仔细检查，由于共享缓存线，我们有最好的性能。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static_assert</span>(<span style="color:#66d9ef">sizeof</span>(Data) <span style="color:#f92672">&lt;=</span> std<span style="color:#f92672">::</span>hardware_constructive_interference_size);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 确保对象被正确对齐。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">alignas</span>(<span style="color:#66d9ef">sizeof</span>(Data)) Data myDataForAThread;
</span></span></code></pre></div><h4 id="264-后记">26.4 后记</h4>
<p>scoped_locks 最初是由 Mike Spertus 在 <a href="https://wg21.link/n4470" target="_blank" rel="noopener noreffer ">https://wg21.link/n4470</a> 中将 lock_guard 修改为可变参数，被接受为 <a href="https://wg21.link/p0156r0" target="_blank" rel="noopener noreffer ">https://wg21.link/p0156r0</a>。然而，因为这被证明是 ABI 破坏，新名称 scoped_lock 由 Mike Spertus 用 <a href="https://wg21.link/p0156r2" target="_blank" rel="noopener noreffer ">https://wg21.link/p0156r2</a> 引入并最终被接受。 Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 后来通过 <a href="https://wg21.link/p0739r0" target="_blank" rel="noopener noreffer ">https://wg21.link/p0739r0</a> 将构造函数的顺序更改为针对 C++17 的缺陷：</p>
<p>shared_mutex 最初是由 Howard Hinnant 在 <a href="https://wg21.link/n2406" target="_blank" rel="noopener noreffer ">https://wg21.link/n2406</a> 中与 C++11 的所有其他互斥体一起提出的。然而，要让 C++ 标准化委员会相信所有提议的互斥锁都是有用的，需要时间。因此，最终接受的措辞是由 Gor Nishanov 在 <a href="https://wg21.link/n4508" target="_blank" rel="noopener noreffer ">https://wg21.link/n4508</a> 中为 C++17 制定的。</p>
<p>std::atomic&lt;&gt; 静态成员 std::is_always_lock_free 由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a href="https://wg21.link/n4509" target="_blank" rel="noopener noreffer ">https://wg21.link/n4509</a> 中首次提出。最终接受的措辞也是由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a href="https://wg21.link/p0152r1" target="_blank" rel="noopener noreffer ">https://wg21.link/p0152r1</a> 中制定的。</p>
<p>JF Bastien 和 Olivier Giroux 在 <a href="https://wg21.link/n4523" target="_blank" rel="noopener noreffer ">https://wg21.link/n4523</a> 中首次提出了硬件干扰（缓存线）大小。最终接受的措辞也是由 JF Bastien 和 Olivier Giroux 在 <a href="https://wg21.link/p0154r1" target="_blank" rel="noopener noreffer ">https://wg21.link/p0154r1</a> 中制定的。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-03-19</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/stl/">STL</a>,&nbsp;<a href="/tags/c&#43;&#43;17/">C&#43;&#43;17</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/" class="prev" rel="prev" title="第二部分-模板特性"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>第二部分-模板特性</a>
            <a href="/posts/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7-/" class="next" rel="next" title="第五部分-专业工具">第五部分-专业工具<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.115.4">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.5.0/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"en","pageSize":10,"placeholder":"Your comment ...","recordIP":true,"serverURLs":"https://leancloud.hugoloveit.com","visitor":true}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"","algoliaIndex":"","algoliaSearchKey":"","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
