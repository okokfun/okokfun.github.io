<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Thread - Tag - My Blog</title>
        <link>https://okokfun.github.io/tags/thread/</link>
        <description>Thread - Tag - My Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Feb 2022 21:27:50 &#43;0000</lastBuildDate><atom:link href="https://okokfun.github.io/tags/thread/" rel="self" type="application/rss+xml" /><item>
    <title>è®©C&#43;&#43;ç¨‹åºæ›´å¿«çš„è¿è¡Œ</title>
    <link>https://okokfun.github.io/posts/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</link>
    <pubDate>Sun, 06 Feb 2022 21:27:50 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</guid>
    <description><![CDATA[è§†é¢‘ç”±upç¥ç»å…ƒçŒ« ç¥ç»å…ƒçŒ«çš„ä¸ªäººç©ºé—´_å“”å“©å“”å“©_bilibili ç¿»è¯‘è‡ª youtube.com/cherno å¹¶å‘å¸ƒåˆ°ğŸ‘‰ ã€79ã€‘ã€Cherno C++ã€‘ã€ä¸­å­—ã€‘å¦‚ä½•è®©C++è¿è¡Œå¾—æ›´å¿«_å“”å“©å“”å“©_bilibili å¹¶ç”±æˆ‘æ•´ç†ã€‚
é€šè¿‡ç¼–ç æ–¹å¼åˆ©ç”¨å¤šæ ¸æˆ–å¤šå¤„ç†å™¨ ,åˆ©ç”¨è¿™äº›çº¿ç¨‹ï¼Œä¸åªæ˜¯è®©ä½ çš„ç¨‹åºé¡ºåºæ‰§è¡Œä¸€æ¡æ¡æŒ‡ä»¤ï¼Œè€Œæ˜¯æŠŠä¸€äº›ä¸œè¥¿ï¼Œæ¨è¿Ÿåˆ°ä¸åŒçš„çº¿ç¨‹ï¼Œç”šè‡³ä¸æ˜¯æ¨è¿Ÿï¼ŒäºŒåæŠŠä¸œè¥¿åˆ†æ´¾åˆ°ä¸åŒçš„çº¿ç¨‹ï¼Œè®©è®¡ç®—æœºæ›´å¿«åœ°å¤„ç†è¿™äº›ä¸œè¥¿ã€‚
æ¯ä¸€ä¸ªèµ„æºï¼Œæ¯ä¸€ä¸ªçº¹ç†æ¨¡å‹ï¼Œä»–ä»¬é€šå¸¸ç‹¬ç«‹äºå½¼æ­¤ï¼Œæ„å‘³ç€è¿™æ˜¯è‰¯å¥½çš„å¤šçº¿ç¨‹å€™é€‰åœºæ™¯ã€‚
static std::mutex s_MeshesMutex; static void LoadMesh(std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard&lt;std::mutex&gt; lock(s_MeshesMutex); meshes.push_back(mesh); } void EditLayer::LoadMeshes() { std::ifstream stream(&#34;src/Models.txt&#34;); std::string line; std::vector&lt;std::string&gt; meshFilepaths; while (std::getline(stream, line)) meshFilepaths.push_back(line); #define ASYNC 1 #id ASYNC for (const auto&amp; file : meshFilepaths) // std::launch::asyncå‘ŠçŸ¥stdåº“åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å¤„ç†ã€‚ // æˆ‘ä»¬éœ€è¦ä¿ç•™std::asyncçš„è¿”å›å€¼ï¼Œå¦‚æœä¸ä¿ç•™çš„è¯ï¼Œå› ä¸ºå®ƒä¼šè¢«C++æ ‡å‡†åº“æ‘§æ¯ï¼Œåœ¨æ‘§æ¯æ—¶ï¼Œæ ‡å‡†åº“éœ€è¦ç¡®ä¿è¿‡ç¨‹å®é™…å·²è¢«å®Œæˆï¼Œè¿™åŸºæœ¬ä¸æ˜¯å¹¶è¡Œäº†ï¼Œæ‰€ä»¥éœ€è¦åˆ›å»ºä¸€ä¸ªstd::futureçš„å‘é‡ã€‚ m_Futures.push_back(std::async(std::launch::async, LoadMesh, &amp;m_Meshes, file)); #else for (const auto&amp; file : meshFilepaths) m_Meshes.push_back(Mesh::Load(file)); } std::vector&lt;std::future&lt;void&gt; m_Meshes; é€šè¿‡æŠŠä»»åŠ¡åˆ†æ´¾çš„ä¸åŒçš„çº¿ç¨‹ï¼Œèµ„æºåŠ è½½é€Ÿåº¦ç”±6.]]></description>
</item>
<item>
    <title>çº¿ç¨‹æ”¯æŒåº“</title>
    <link>https://okokfun.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/</link>
    <pubDate>Sat, 15 Jan 2022 17:13:05 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/</guid>
    <description><![CDATA[æ­¤æ–‡æ¥è‡ªäºğŸ‘‰çº¿ç¨‹æ”¯æŒåº“ - cppreference.com
çº¿ç¨‹æ”¯æŒåº“ thread(C++11) std::thread ç±»ä¸æ”¯æŒå‡½æ•° stop_token(C++20) std::jthread çš„åœæ­¢è®°å· mutex(C++11) äº’æ–¥å…ƒä»¶ shared_mutex(C++14) å…±äº«äº’æ–¥å…ƒä»¶ future(C++11) å¼‚æ­¥è®¡ç®—å…ƒä»¶ condition_variable(C++11) çº¿ç¨‹ç­‰å¾…æ¡ä»¶ semaphore(C++20) ä¿¡å·é‡ latch(C++20) é—© barrier(C++20) å±éšœ #include &lt;thread&gt; std::thread threadç±» è¡¨ç¤ºå•ä¸ªæ‰§è¡Œçº¿ç¨‹ã€‚
#include &lt;iostream&gt; #include &lt;thread&gt; int main() { std::thread th1; } std:ğŸ§µ:id thread::idç±» æ˜¯è½»é‡çš„å¯é¢‘ç¹å¤åˆ¶ç±»ï¼Œå®ƒä½œä¸º std::thread å¯¹è±¡çš„å”¯ä¸€æ ‡è¯†ç¬¦å·¥ä½œã€‚
#include &lt;iostream&gt; #include &lt;thread&gt; typedef unsigned long long ULL; std::string getThreadIdOfString(const std:ğŸ§µ:id &amp; id) { std::stringstream sin; sin &lt;&lt; id; return sin.str(); } ULL getThreadIdOfULL(const std:ğŸ§µ:id &amp; id) { return std::stoull(getThreadIdOfString(id)); } int main() { std:ğŸ§µ:id id = std::this_thread::get_id(); std::cout &lt;&lt; &#34;cout ----- id : &#34; &lt;&lt; id &lt;&lt; std::endl; std::cout &lt;&lt; &#34;getThreadIdOfString ----- id : &#34; &lt;&lt; getThreadIdOfString(id) &lt;&lt; std::endl; std::cout &lt;&lt; &#34;getThreadIdOfULL ----- id : &#34; &lt;&lt; getThreadIdOfULL(id) &lt;&lt; std::endl; return 0; } std:ğŸ§µ:hardware_concurrency() è¿”å›å¤„ç†å™¨æ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°ã€‚]]></description>
</item>
</channel>
</rss>
