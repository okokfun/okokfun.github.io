<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on My Blog</title>
    <link>https://okokfun.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 31 Jan 2022 18:56:20 +0000</lastBuildDate><atom:link href="https://okokfun.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式准则</title>
      <link>https://okokfun.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/</link>
      <pubDate>Mon, 31 Jan 2022 18:56:20 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/</guid>
      <description>最终目的：高内聚，低耦合 1. 开放封闭原则 (OCP,Open For Extension, Closed For Modification Principle) 😎类的改动是通过增加代码进行的，而不是修改源代码。
2. 单一职责原则 (SRP,Single Responsibility Principle) 类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。
3. 依赖倒置原则 (DIP,Dependence Inversion Principle) 😎依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。
4. 接口隔离原则 (ISP,Interface Segegation Principle) 不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。
5. 里氏替换原则 (LSP, Liskov Substitution Principle) 任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。
6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle) 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。 如果使用对象组合，就降低了这种依赖关系。
7. 迪米特法则(LOD,Law of Demeter) 😎一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。(黑盒原理)</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-行为模式</title>
      <link>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 03 Jan 2022 15:48:22 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。
适用场景:
当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。
当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。
观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。
当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。
订阅列表是动态的， 因此订阅者可随时加入或离开该列表。
/** * Observer Design Pattern * * Intent: Lets you define a subscription mechanism to notify multiple objects * about any events that happen to the object they&amp;#39;re observing. * * Note that there&amp;#39;s a lot of different terms with similar meaning associated * with this pattern.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-结构型模式</title>
      <link>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 03 Jan 2022 15:07:58 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
代理模式 解释
对真正要被访问的产品或类加以控制，并可以进行一些控制，把访问产品与代理进行映射，访问代理就相当于访问产品
适用场景：
使用代理模式的方式多种多样， 我们来看看最常见的几种。
延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。
你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。
访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。
代理可仅在客户端凭据满足要求时将请求传递给服务对象。
本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。
在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。
缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。
代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。
智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。
代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。
代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。
class Subject { public: virtual void Request() const = 0; }; /** * The RealSubject contains some core business logic. Usually, RealSubjects are * capable of doing some useful work which may also be very slow or sensitive - * e.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;设计模式-创建型模式</title>
      <link>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 27 Dec 2021 13:48:06 +0000</pubDate>
      
      <guid>https://okokfun.github.io/post/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>推荐看👉常用设计模式有哪些？ (refactoringguru.cn)
设计模式描述：
用特定的套路解决现实问题，每一个设计模式对应一个法子
分类 根据意图或目的分类
创建型模式: 提供创建对象机制，增加已有的代码灵活性和可复用性 结构型模式: 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 行为模式: 负责对象间的高效沟通和职责委派。 创建型模式 simple_factory_pattern(简单工厂) Factory Method(工厂方法) 在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
要解决的问题：
当增加一个新类，和其他类低耦合
解决方案:
增加一个子类的抽象类，所有的子类继承于抽象类，并且写父类的实现
#include &amp;lt;iostream&amp;gt; class product { public: virtual ~product() {} }; class phone : public product { public: phone() { std::cout &amp;lt;&amp;lt; &amp;#34;make phone&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class tv : public product { public: tv() { std::cout &amp;lt;&amp;lt; &amp;#34;make tv&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class factory { public: virtual ~factory() {} virtual product* make_product() = 0; }; class phone_factory : public factory { public: virtual product* make_product() { return new phone(); } }; class tv_factory : public factory { public: virtual product* make_product() { return new tv(); } }; int main() { factory* factory1 = new phone_factory(); product* product1 = factory1-&amp;gt;make_product(); factory* factory2 = new tv_factory(); product* product2 = factory2-&amp;gt;make_product(); delete factory1; delete product1; delete factory2; delete product2; return 0; } Abstract Factory(抽象工厂模式) 随着业务的发展，更多的类需要创建，比如美国工厂，欧洲工厂，亚洲工厂，南美工厂，每个地区工厂又需要创建各自的产品</description>
    </item>
    
  </channel>
</rss>
