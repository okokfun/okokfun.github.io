<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Digital on My Blog</title>
    <link>https://okokfun.github.io/tags/digital/</link>
    <description>Recent content in Digital on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 21 Jul 2023 22:33:48 +0800</lastBuildDate><atom:link href="https://okokfun.github.io/tags/digital/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>12.7 PMOS、NMOS和E2CMOS</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-7pmosnmos%E5%92%8Ce2cmos/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-7pmosnmos%E5%92%8Ce2cmos/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.6 发射极耦合逻辑-ECL电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:24 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-6%E5%8F%91%E5%B0%84%E6%9E%81%E8%80%A6%E5%90%88%E9%80%BB%E8%BE%91-ecl%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.5 CMOS和TTL性能的比较</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 21 Jul 2023 22:33:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-5cmos%E5%92%8Cttl%E6%80%A7%E8%83%BD%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.4 TTL在实际使用中的注意事项</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-4ttl%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.3 TTL电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-3ttl%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-3ttl%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.2 CMOS电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-2cmos%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:24 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-2cmos%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>12.1 基本操作特性和参数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 21 Jul 2023 22:32:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/12-1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%E5%92%8C%E5%8F%82%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.4 数字信号处理基础</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-4%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.3 数—模转换方法</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:38 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-3%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.2 模—数转换方法</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-2%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>11.1 模拟信号转换为数字信号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:31:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/11-1%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.8 磁和光存储</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-8%E7%A3%81%E5%92%8C%E5%85%89%E5%AD%98%E5%82%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.7 特殊类型的存储器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.6 存储器扩展</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-6%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.5 闪存</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-5%E9%97%AA%E5%AD%98/</link>
      <pubDate>Fri, 21 Jul 2023 22:30:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-5%E9%97%AA%E5%AD%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.4 可编程ROM[PROM和EPROM]</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/</link>
      <pubDate>Fri, 21 Jul 2023 22:29:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-4%E5%8F%AF%E7%BC%96%E7%A8%8Brom-prom%E5%92%8Ceprom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.3 只读存储器-ROM</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/</link>
      <pubDate>Fri, 21 Jul 2023 22:28:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-3%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-rom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.2 随机存储器-RAM</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/</link>
      <pubDate>Fri, 21 Jul 2023 22:28:08 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-2%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-ram/</guid>
      <description></description>
    </item>
    
    <item>
      <title>10.1 半导体存储器基础</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 21 Jul 2023 22:27:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/10-1%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.9 关联标注的逻辑符号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:27:02 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-9%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.8 移位寄存器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-8%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.7 移位寄存器计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:39 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-7%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.6 双向移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:26 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-6%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.5 并行输入/并行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:26:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-5%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.4 并行输入/串行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:25:20 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-4%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.3 串行输入/并行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:25:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-3%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E5%B9%B6%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.2 串行输入/串行输出移位寄存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-2%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5-%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%87%BA%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.1 基本移位寄存器的功能</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/9-1%E5%9F%BA%E6%9C%AC%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.8 关联标注的逻辑符号</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Fri, 21 Jul 2023 22:24:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-8%E5%85%B3%E8%81%94%E6%A0%87%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.7 计数器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-7%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.6 计数器译码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-6%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AF%91%E7%A0%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.5 级联计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:23:18 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-5%E7%BA%A7%E8%81%94%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.4 同步计数器的设计</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 21 Jul 2023 22:22:10 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-4%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.3 加/减同步计数器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:58 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-3%E5%8A%A0-%E5%87%8F%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.2 同步计数器运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-2%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>8.1 异步计数器运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/8-1%E5%BC%82%E6%AD%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.6 非稳态多谐振荡器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:21:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-6%E9%9D%9E%E7%A8%B3%E6%80%81%E5%A4%9A%E8%B0%90%E6%8C%AF%E8%8D%A1%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.5 单稳态触发器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:48 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-5%E5%8D%95%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.4 触发器应用</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:19 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BA%94%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.3 触发器运算特性</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 21 Jul 2023 22:20:05 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-3%E8%A7%A6%E5%8F%91%E5%99%A8%E8%BF%90%E7%AE%97%E7%89%B9%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.2 边沿触发器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:19:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-2%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7.1 锁存器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-1%E9%94%81%E5%AD%98%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:19:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/7-1%E9%94%81%E5%AD%98%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.10 奇偶发生器/校验器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:55 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-10%E5%A5%87%E5%81%B6%E5%8F%91%E7%94%9F%E5%99%A8-%E6%A0%A1%E9%AA%8C%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.9 多路分配器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-9%E5%A4%9A%E8%B7%AF%E5%88%86%E9%85%8D%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.8 多路复用器-数据选择器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:18:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8-%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.7 代码转换器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:58 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-7%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.6 编码器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-6%E7%BC%96%E7%A0%81%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:47 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-6%E7%BC%96%E7%A0%81%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.5 译码器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-5%E8%AF%91%E7%A0%81%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:28 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-5%E8%AF%91%E7%A0%81%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.4 比较器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-4%E6%AF%94%E8%BE%83%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:17:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-4%E6%AF%94%E8%BE%83%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.3 异步进位与超前进位加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:16:29 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-3%E5%BC%82%E6%AD%A5%E8%BF%9B%E4%BD%8D%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.2 并行二进制加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:16:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-2%E5%B9%B6%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>6.1 基本加法器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/</link>
      <pubDate>Fri, 21 Jul 2023 22:15:49 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/6-1%E5%9F%BA%E6%9C%AC%E5%8A%A0%E6%B3%95%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.5 具有脉冲波形输入的逻辑电路运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 21 Jul 2023 22:15:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-5%E5%85%B7%E6%9C%89%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%BF%90%E7%AE%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.4 使用与非门和或非门的组合逻辑</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-4%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.3 与非门和或非门的通用特性</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-3%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%92%8C%E6%88%96%E9%9D%9E%E9%97%A8%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.2 组合逻辑电路的实现</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 21 Jul 2023 22:14:09 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-2%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.1 基本组合逻辑电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 21 Jul 2023 22:13:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/5-1%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.10 5变量的卡诺图</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/</link>
      <pubDate>Fri, 14 Jul 2023 19:07:46 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-10-5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%A1%E8%AF%BA%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.9 卡诺图乘积项之和的最小化</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/</link>
      <pubDate>Fri, 14 Jul 2023 19:07:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-9%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B9%98%E7%A7%AF%E9%A1%B9%E4%B9%8B%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.8 卡诺图</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:40 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-8%E5%8D%A1%E8%AF%BA%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.7 布尔表达式和真值表</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:31 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-7%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%9C%9F%E5%80%BC%E8%A1%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.6 布尔表达式的标准形式</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:22 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-6%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.5 使用布尔代数进行化简</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/</link>
      <pubDate>Fri, 14 Jul 2023 19:06:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-5%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8C%96%E7%AE%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.4 逻辑电路的布尔分析</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-4%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B8%83%E5%B0%94%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.3 狄摩根定理</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:42 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-3%E7%8B%84%E6%91%A9%E6%A0%B9%E5%AE%9A%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.2 布尔代数的定律和法则</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-2%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E5%AE%9A%E5%BE%8B%E5%92%8C%E6%B3%95%E5%88%99/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.1 布尔运算和表达式</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:21 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4-1%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.7 固定功能逻辑</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-7%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91/</guid>
      <description>3.7.1 逻辑系列 数字逻辑电路的三个系列是 CMOS(互补金属氧化物半导体)、双极型和 BiCMOS(双CMOS)。这三种电路器件实现内部逻辑功能的类型不同。CMOS 是由场效应管(FET)来实现，双极型(也称为TTL，即晶体管-晶体管逻辑)逻辑使用双极型晶体管来实现，而 BiCMOS 是前面两种的组合。这些逻辑器件系列的基本逻辑功能相同，但是工作参数不同，例如开关速度(传输时间)、功率损耗和抗干扰能力。CMOS 与门和双极型或 BiCMOS 与门的逻辑功能相同。对于所有其他功能的逻辑器件也一样。
CMOS 在这些逻辑系列中，CMOS占有主导地位，双极型显然要被淘汰，BiCMOS 具有的逻辑功能类型也有限。在 CMOS 系列中，按不同的使用电压、功率损耗、开关速度和一些其他参数分为许多种类。表3.14列出了更多的常用 CMOS 逻辑电路,按各种器件的电路运行和优化的直流工作电压进行区分。 $$ 表3.14 ~~~CMOS逻辑器件的种类 $$
名称 描述 $V_{CC}$ AC 高级CMOS 5.0 V ACT 具有双极型兼容输入的高级CMOS 5.0 V AHC 高级高速CMOS 5.0 V AHCT 具有双极型兼容输入的高级高速CMO 5.0 V ALVC 高级低电压CMOS 3.3 V AUC 高级超低电压CMOS 1.8 V AUP 高级超低功耗CMOS 3.3 V AVC 高级甚低电压CMOS 2.5 V CD4000 标准CMOS 5.0 V FCT 快速CMOS技术 5.0 V HC 高速CMOS 5.0 V HCT 具有双极型兼容输入的高速CMOS 5.</description>
    </item>
    
    <item>
      <title>3.6 异或门和同或门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:05:01 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-6%E5%BC%82%E6%88%96%E9%97%A8%E5%92%8C%E5%90%8C%E6%88%96%E9%97%A8/</guid>
      <description>3.6.1 异或门 异或门(XOR)的标准符号如图3.42所示。异或门只有两个输入。异或门的运算功能为模-2加法(第2章介绍过)。只有当两个输入处于相反的逻辑电平时，异或门的输出才是高电平。根据输入 A 和输入 B 及输出 X，它的运算可以做如下表述:
对于异或门来说，如果输入 A 是低电平而输入 B 是高电平，或者输入 A 是高电平而输入 B 是低电平，那么输出 X 就是高电平; 如果 A 和 B 都是高电平或者都是低电平，那么输出 X 为低电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~(b)具有异或门的矩形轮廓 $$ $$ 图3.42~~~~异或门的标准逻辑符号 $$
◇ 对于异或门来说,相反的两个输入产生高电平输出。 异或门的所有 4 个可能的输入组合及输出结果如图3.43所示。高电平是有效或者是确定电平，只有当两个输入相反时才会输出高电平。异或门的运算总结在表3.11中。 $$ 图3.43~~~异或门的所有输入逻辑电平和相应的输出电平。打开文件F03-43检验异或门操作 $$
$$ 表3.11~~~异或门的真值表 $$
输入A 输入B 输出X 0 0 0 0 1 1 1 0 1 1 1 0 3.6.2 同或门 同或门(XNOR)的标准符号如图3.45所示。和异或门相似，同或门也只有两个输入。同或门符号输出位置上的小圆圈指示它的输出和异或门的输出是相反的。当两个输人逻辑电平相反时，同或门的输出就是低电平。这个运算可以做如下表述(A 和 B 是输入,X 是输出):
对于同或门来说，如果输入 A 是低电平而输入 B 是高电平，或者 A 是高电平，B 是低电平，输出 X 就是低电平;如果输入 A 和输入 B 都是高电平或者都是低电平，输出 X 就是高电平。 $$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)长方形轮廓 $$ $$ 图3.</description>
    </item>
    
    <item>
      <title>3.5 或非门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-5%E6%88%96%E9%9D%9E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:51 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-5%E6%88%96%E9%9D%9E%E9%97%A8/</guid>
      <description>◇ 除了输出反相之外，或非门和或门相同。 术语或非(NOR)是非-或(NOT-OR)的缩写，意指具有反相(反码)输出的或运算。2输入或非门和与之等价的或门后面再加反相器的标准逻辑符号，如图3.34(a)所示。图3.34(b)给出了矩形轮廓符号。
$$ (a)特殊形状，2输入或非门和等价的非-或门~~~~~~~~~~~~~~~~~~(b)矩形轮廓,具有极性指示的2输入或非门 $$ $$ 图3.34~~~标准或非门逻辑符号(ANSI/IEEE标准91-1984) $$
3.5.1 或非门的运算 当任何一个输入为高电平时，或非门就输出一个低电平。只有当所有的输入是低电平时，输出才是高电平。对于 2 输入或非门的情况，如图3.34所示，输人被标为 A 和 B，输出被标记为 X，该运算可以做如下表述:
对于 2 输入或非门，如果输入 A 或 B 为高电平，或者 A 和 B 都是高电平，输出 X 就是低电平; 如果 A 和 B 都是低电平，输出X就是高电平。
这个运算产生和或门相反的输出电平。在或非门中，低电平输出是有效的或者是确定的输出电平，由输出的小圆圈所表示。图3.35说明了2输入或非门的运算，包括所有可能的4种输入组合,而表3.9是2输入或非门的真值表。 $$ 图3.35~~~2输人或非门的操作。打开文件F03-35检验或非门操作 $$
$$ 表3.9~~~2输入或非门的真值表 $$
输入A 输入B 输出X 0 0 1 0 1 0 1 0 0 1 1 0 1=高电平, 0=低电平
3.5.2 波形输入的运算 下面的两个例子给出了具有脉冲波形输人的或非门运算。和其他类型的门一样，只要遵循真值表就可以确定输出波形和输入的正确时间关系。
或非门的非-与等价运算 或非门和与非门相似，但具有其运算的另一个方面，也就是固有的逻辑函数功能。表3.9给出了只有当所有的输入都是低电平时，才会产生高电平输出。从这一点来说，或非门可以用做需要所有的低电平输入来产生高电平输出的与运算。或非门的这个功能称为非-与。这里术语“非”意指低电平输入有效或低电平为确定状态。
对非-与运算的 2 输入或非门来说，如果输入 A 和 B 都是低电平时, 输出 X 就是高电平。</description>
    </item>
    
    <item>
      <title>3.4 与非门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:42 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-4%E4%B8%8E%E9%9D%9E%E9%97%A8/</guid>
      <description>◇ 除了输出被反相之外，与非门和与门是一样的。 词汇与非(NAND)是非-与(NOT-AND)的缩写，意思是具有反码(反相)输出的与函数。2输入的与非门的标准逻辑符号和一个与门其后再加一个反相器的电路图等价，如图3.26(a)所示，其中符号=的意思是恒等于。图3.26(b)给出了矩形轮廓符号。
$$ (a)特殊形状，2输入与非门及等价的与门+非门~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)矩形轮廓，具有极性指示 $$
$$ 图3.26~~~标准与非门逻辑符号(ANSI/IEEE标准91-1984) $$
3.4.1与非门的运算 只有所有的输入都是高电平时，与非门才会输出其低电平。当任何一个输入为低电平时，输出就是高电平。2输人与非门的一个具体例子如图3.26所示，其中输人被标为 A 和 B,输出被标为 X,该运算可以进行如下表述:
对于一个2输入与非门，当输入 A 和 B 都是高电平时，输出X就是低电平; 当输入 A 或 B 为低电平，或者 A 和 B 都是低电平时,输出 X 就是高电平。
注意，这个运算和与门输出电平的运算是相反的。在一个与非门中，低电平(0)是有双蚁确定的输出电平，由输出的小圆圈所表示。图3.27说明了 2 输入与非门的所有 4 种可能组合，而表3.7是把 2 输入与非门的所有逻辑运算汇总后的真值表。
$$ 图3.27~~~2输入与非门的运算。打开文件F03-27检验与非门操作 $$
$$ 表3.7~~~2输入与非门的真值表 $$
输入A 输入B 输出X 0 0 0 0 1 0 1 0 0 1 1 1 1=高电平,0=低电平
3.4.2波形输入的运算 现在来看与非门的波形运算。从真值表可以知道，仅当所有的输人为高电平时，输出才是低电平。
与非门的非-或等价运算 与非门运算的内在特性是这样的: 一个或者多个低电平输人产生一个高电平输出。表3.7给出了当任何一个输入 A 和 B 是低电平(0)时，输出就是高电平(1)。从这个观点来看，与非门可用于需要一个或者多个低电平输入并且产生高电平输出的或运算。与非门运算的这个功能称为非-或运算。术语“非”在上下文中意思是当输入为低电平时，输人就被定义为处于有效或者确定状态。</description>
    </item>
    
    <item>
      <title>3.3 或门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-3%E6%88%96%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:34 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-3%E6%88%96%E9%97%A8/</guid>
      <description>◇ 或门可以具有多于两个的输入。 或门(OR gate)具有两个或者更多的输入及一个输出，如图3.18所示的标准逻辑符号给出了具有两个输人的或门。或门可以具有多于一个的任意输入。虽然同时给出了特殊形状和矩形轮廓符号，但是本书使用的是特殊形状符号。
$$ (a)特殊形状~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(b)具有OR(≥1)限定符号的矩形轮廓 $$ $$ 图3.18 ~~~或门的标准逻辑符号，图中给出了两个输入的或门(ANSI/IEEE标准91-1984) $$
3.3.1 或门的运算 ◇ 有一个以上的输入是高电平时，或门的输出就是高电平。 当任意一个输人为高电平时，或门的输出就为高电平。当且仅当所有的输入是低电平时，输出才会是低电平。所以，或门用来判断它的输入是否有一个或者多个高电平,有高电平输入时，输出一个高电平以表明条件满足。图3.18中2输人或门的输入被标以A和B，输出则被标以X，或门的运算可以做如下表述:
对于一个 2 输入或门来说，如果输入 A 和输入 B 中有一个是高电平，或者两者都为高电平,输出 X 就为高电平; 仅当 A 和 B 都是低电平时，X 为低电平。
高电平是或门的有效或者肯定输出电位。图3.19给出了2输人或门的所有 4 种可能输人组合的输人和输出结果。
$$ 图3.19 ~~~2输人或门的所有可能逻辑电位。打开文件F03-19检验或门操作 $$
3.3.2 或门真值表 表3.5描述了2输入或门的运算。这个真值表可以扩展到任意个数的输入;但是不管有多少输入，当有一个或者多个输入是高电平时，输出就是高电平。 $$ 表3.5~~~2输入或门的真值表 $$
输入 输入 输出 0 0 0 0 1 1 1 0 1 1 1 1 1=高电平,0=低电平
3.3.3波形输入的运算 现在观察具有波形输入的或门运算，并请记住它的逻辑运算。再有，分析具有脉冲波形的或门运算的关键是涉及的所有波形的时间关系。例如，在图3.20 中，在时间间隔 $t_1$ 期间，A 和 B 都是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_2$ 期间,输入A是低电平0，但是输入 B 是高电平 1，所以输出 X 为高电平 1。在时间间隔 $t_3$ 期间,两个输入都是低电平 0,所以输出 X 为低电平 0。在时间间隔 $t_4$ 期间，两个输人都是高电平 1，所以输出 X 为高电平 1。</description>
    </item>
    
    <item>
      <title>3.2 与门</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-2%E4%B8%8E%E9%97%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-2%E4%B8%8E%E9%97%A8/</guid>
      <description>名词“门&amp;quot;用以描述运行基本逻辑运算的电路。与门(AND gate)由两个或者更多的输入和一个输出组成，由图3.8中的标准逻辑符号所表示。输入位于左边，而输出位于每个符号的右边。图中给出具有两个输入的与门;但是，与门可以有大于两个的任意输入。虽然给出了特殊形状符号和矩形轮廓符号，但是本书主要使用图3.8(a)中的特殊形状符号。
(a)特殊形状_____________________________(b)具有与(&amp;amp;)限定符号的矩形轮廓
$$ 图3.8~~~与门的标准逻辑符号，给出了两个输入(ANSI/IEEE标准91-1984) $$
3.2.1与门的运算 ◇ 与门可以具有多于两个的输入。 当且仅当与门所有的输人都是高电平时，才会输出高电平。当任何一个输入为低电平时，输出就是低电平。所以，与门的基本用途即判断若干条件是否同时为真，为真时所有的输入是高电平,并且在输出产生高电平以表示所有的条件都为真。图3.8中的2输入与门的输入被标记为 A 和 B，而输出被标记为 X。与门运算可以表述为
对于 2 输入与门，当输入 A 和 B 都是高电平时，输出 X 为高电平;当 A 或 B 是低电平，或者 A 和 B 都是低电平时, X 就是低电平。
图3.9给出了一个 2 输人与门，同时列出了所有 4 种可能的输入组合，以及每个与门相对应的输出。
$$ 图3.92~~~输入与门的所有可能逻辑电平。打开文件 F03-09检验与门操作 $$
3.2.2与门真值表 ◇ 对于一个与门来说，输入都是高电平时才会产生高电平输出 $$ 表3.2 ~~~2输入与门的真值表 $$ 输入 输入 输出 A B X 0 0 0 0 1 0 1 0 0 1 1 1 1 = 高电平,0 = 低电平</description>
    </item>
    
    <item>
      <title>3.1 反相器</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/</link>
      <pubDate>Fri, 14 Jul 2023 19:04:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3-1%E5%8F%8D%E7%9B%B8%E5%99%A8/</guid>
      <description>反相器的标准逻辑符号如图3.1所示,(a)图给出了特殊形状符号,(b)图给出了矩形轮廓符号.在这本书中,一般使用特殊形状符号;但是,矩形轮廓符号常常出现在许多工业出版物中,所以也应该熟悉它们.(逻辑门符号依据 ANSI/IEEE 标准 91-1984.)
3.1.1 否定和极性指示 $$ (a)具有否定指示的特殊形状符号~~~~~~~~~~(b)具有极性指示的矩形轮廓符号 $$ 否定指示是一个小圆圈(o),当其出现在任何逻辑元件的输入或者输出位置时,为反相或者为反码,如图3.1(a)的反相器所示.一般情况下,输入位于逻辑符号的左侧而输出位于右侧.当出现在输人位置时,小圆圈就表示 0 电平有效或者是确定的输入状态,而这个输入称为低电平有效输人.当出现在输出位置时,该小圆圈就指明0有效或者是确定的输出状态,而这个输出称为低电平有效输出.当输人或者输出没有小圆圈时,就表示1是有效的或者是确定的状态,而这个输入或输出称为高电平有效.
极性或者电平指示是一个&amp;quot;三角形&amp;quot;(◣),当其出现在任何逻辑元件的输人或者输出位置时,表示反相,如图3.1(b)所示.当其出现在输入位置时,就表示低电平是有效的或者是确定的输人状态.当其出现在输出位置时,就表示低电平是有效的或者是确定的输出状态.
两种指示(小圆圈或三角形)都可以用在特殊形状符号和矩形轮廓符号中.图3.1(a)给出的是本书后面主要使用的反相器.注意反相或极性指示的不同放置并不意味着反相器运算方式的改变.
3.1.2 反相器真值表 当反相器的输入是高电平时，它的输出就是低电平。当反相器的输入是低电平时，它的输出就是高电平。这种运算总结于表3.1中，表中以电平和对应的位值给出了每个可能的输入和与之对应的输出。这样的表称为真值表。 $$ 表3.1~~~反相器真值表 $$
输入 输出 低(0) 高(1) 高(1) 低(0) 3.1.3 反相器运算 图3.2给出了反相器脉冲输入和相应的输出，其中 $t_1$ 和 $t_2$ 指明了在输人和输出波形上相对应的点。
当输入为低电平时，输出就是高电平; 当输入是高电平时,输出就是低电平，因此产生反相的输出脉冲。
$$ 图3.2~~~具有脉冲输入的反相运算。打开文件FO3-02检验反相操作 $$
3.1.4 时序图 ◇ 时序图给出了两个或者更多的波形在时间上的相互关系。 回顾第1章我们知道，基本上时序图是基于时间的、准确显示两个或者更多波形相互之间关系的图形。例如，图3.2中输出脉冲和输人脉冲的时间关系，可以用一个时序图把两个脉冲对准,从而使得这些脉冲边沿的发生以正确的时间关系展现出来。输入脉冲的上升沿和输出脉冲的下降沿在相同的时间出现(理想状态)。类似地,输入脉冲的下降沿和输出脉冲的上升沿在相同的时间出现(理想状态)。这种时序关系如图3.3所示。实际上，从输入的变化到输出的变化有一个非常小的延迟。时序图在说明具有多个脉冲的数字波形之间的时间关系时特别有用。
$$ 图3.3~~~在图3.2条件下的时序图 $$
3.1.5 反相器的逻辑表达式 ◇ 布尔代数使用变量和运算符来描述逻辑电路。 在布尔代数(它是逻辑电路的数学基础并且将在第4章得到全面的介绍)中，变量可以由多个字母表示，但是通常由一个或两个字母表示。接近字母表中开始位置的通常表示输人，而接近结束位置的通常表示输出。变量的反码由字母上方的横杠来表示。变量可取的值是 1 或者 0。如果一个变量是 1，它的反码就是 0，反之亦然。
反相器(非门电路)的运算可以用下面的方式表示: 如果输入变量为 A,输出变量为 X，那么 $$ X=\overline{A} $$ 这个表达式说明输出是输入的反码,所以如果 A=0，那么 X =1; 而如果 A=1，那么 X =0。图3.</description>
    </item>
    
    <item>
      <title>2.12 错误检测码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:59 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-12%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E7%A0%81/</guid>
      <description>2.12.1错误检测的奇偶校验法 ◇ 奇偶校验位给出一个数中1的个数是奇数还是偶数. 许多系统都使用一个奇偶校验位,作为位错误检测的手段.任意的多位数组都包含奇数个 1或偶数个 1.将一个奇偶校验位附加到多位数组中,使得这组数中 1 的个数总是偶数或者总是奇数.一个偶校验位使得 1 的总数为偶数,而奇校验位使得 1 的总数为奇数.
一个给定的系统运行于偶校验或者奇校验,而不是同时运行于两者.例如,如果某系统运行于偶校验,则对于所接收的每一个多位数组都做一个检查,以确保这个多位数组中 1 的总数是偶数.如果有奇数个 1,就有一个错误发生了.
作为对奇偶校验位怎样附加到编码中的一个说明,表2.7列出了每个BCD码的偶校验和奇校验的奇偶校验位.每个BCD码的校验位处于P列上. $$ 表2.7~~带奇偶校验位的 ~BCD ~码 $$ $$偶校验$$
校验位 P BCD 0 0000 1 0001 1 0010 0 0011 1 0100 0 0101 0 0110 1 0111 1 1000 0 1001 $$奇校验$$
校验位 P BCD 1 0000 0 0001 0 0010 1 0011 0 0100 1 0101 1 0110 0 0111 0 1000 1 1001 奇偶校验位可以附加到码的开头或者结尾,这取决于系统的设计.</description>
    </item>
    
    <item>
      <title>2.11 数字编码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:50 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-11%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</guid>
      <description>2.11.1格雷码 格雷(Gray)码是无权码,并不是算术编码;也就是没有赋予不同位的特足的权.恰雷俏的重要特征是,从一个码字到下一个接续码字仅有一位发生了变化.这个特征在许多应用程序中是非常重要的,例如对于轴位编码器,在两个相邻顺序数之间,错误敏感度随着位数改变数目的增加而增加.
◇ 格雷码的一位改变的特征减小了出错概率. 表2.6列出了十进制数 0~15 所对应的 4 位格雷码,表中给出了二进制数以做参照.和二进制数相似,格雷码可以拥有任意的位数.注意两个相邻的格雷码字之间的一位变化.例如,从十进制数 3 到十进制数 4,格雷码从 0010 变为 0110,而二进制编码从 0011 变为 0100 改变了 3 个位.格雷码中唯一的位改变是从右数的第 3 位,其他位保持不变. $$ 表2.6 ~~~4位格雷码 $$
10进制 2进制 格雷码 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 二进制数到格雷码的转换 二进制数和格雷码之间的转换有时很有用.</description>
    </item>
    
    <item>
      <title>2.10 二—十进制编码-BCD</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:37 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-10%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81-bcd/</guid>
      <description>2.10.1 8421 BCD码 ◇ 在 BCD码中,每个十进制数都由 4 位二进制编码表示. 8421 码是 BCD(二-十进制编码)码的一种类型.二-十进制编码的意思是,每一个十进制数,从 0~9,都由 4 位二进制编码表示.名称 8421 表明了 4 个位的二进制权($2^3,~2^2,~2^1,~2^0$).这种编码的主要优点是,8421 编码数和我们熟悉的十进制数之间很容易转换.只要记住 10 个十进制数的二进制组合,如表2.5所示.8421 码是主要的 BCD 码,所以当我们提及 BCD 码时,总是指 8421 码,除非有特殊的说明.
$$ 表2.5~~10进制/BCD转换 $$
10进制 0 1 2 3 4 5 6 7 8 9 BCD 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 无效码 应当认识到,使用4个位可以表示 16 个数(从0000 到1111),但是在 8421 码中,在这 16 个数中只使用了 10 个数.未使用的编码组合为 1010,1011,1100,1101,1110,1111,它们在 8421 BCD 码中是无效的.
为了以 BCD 码表示任意十进制数,只要将每个十进制数位用相应的 4 位编码替代就可以了,如例2.</description>
    </item>
    
    <item>
      <title>2.9 八进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:11 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-9%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>八进制数字系统由8个数位组成,它们是
$$ 0，~1,~2，~3,~4，~5,~6，~7 $$
要计大于 7 的数，则从另一列重新开始:
$$ 10,~11 ，~12，~13，~14，~15~，16，~17，~20，~21 ,… $$
八进制数字系统的基是 8。 八进制计数和十进制计数比较相似，不同的是没有使用数字 8 和 9。为了区别八进制数和十进制数或者十六进制数，我们使用下标 8 来表示八进制数。例如，八进制 $15_8$ 等于十进制数 $13_{10}$ 和十六进制数D。有时会看到八进制数后面跟随“o”或者“Q”。
2.9.1 八进制数到十进制数的转换 由于八进制数的基是 8,因此每一个相继的数位都是 8 的递增幂，从最右边 $8^0$ 开始, 计算八进制数的相应十进制数的数值，可以通过把每一个数字都乘以其相应的权，并把所得到的积加起来。下面展示了 $2374_8$ 的转换过程。
2.9.2 十进制数到八进制数的转换 把十进制数转换为八进制数的方法，即重复除以 8 的方法，这和十进制数到二进制数或十六进制数的转换方法相似。为了给出这个过程，我们把十进制数 359 转换为八进制数，以 8 为除数的每一次相继相除都会产生一个余数，而这个余数就会成为相应八进制数的数位。所产生的第一个余数是最低有效数(LSD)。 2.9.3 八进制数到二进制数的转换 ◇ 八进制是表示二进制数的简洁方法，但是并没有十六进制数常用。 因为每一个八进制数位都可以由一个 3 位二进制数来表示，所以八进制数转换为二进制数很容易。每一个八进制数位由 3 位二进制数表示，如表2.4所示。 $$ 表2.4 ~~~8进制/2进制转换 $$
8进制 0 1 2 3 4 5 6 7 2进制 000 001 010 011 100 101 110 111 为了把八进制数转换为二进制数，只要用相应的 3 位二进制数替换每个八进制数位就可以了。这个过程如例2.</description>
    </item>
    
    <item>
      <title>2.8 十六进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:03:03 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>◇ 十六进制数字系统由数字 0~9 和字母 A~F 组成.
十六讲制数字系统的基是 16,也就是它由 16 个数字和字母共同组成.大多数的数字系统都能成组处理二进制数,即多个4位的组合,这样使用十六进制非常方便,因为每一个十六进制数位就代表了一个 4 位二进制数(如表2.3所示).
10 个数字和 6 个字母字符构成了十六进制数字系统.使用字母 A,B,C, D,E,F 表示数字,初看起来很奇怪,但是请记住任何一种数字系统都是有序符号的集合而已.如果已经理解这些符号表示哪些数,一旦习惯了它们的使用方式,这些符号本身就不重要了.我们将使用下标 16 来指明十六进制数以避免和十进制数相混淆.有时可能会看到十六进制数后面跟随一个&amp;quot;h &amp;ldquo;.
$$ 表2.3 $$
10进制数 2进制数 16进制数 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 2.</description>
    </item>
    
    <item>
      <title>2.7 带符号数的算术运算</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:52 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-7%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</guid>
      <description>2.7.1 加法 加法中的两个数就是加数和被加数,结果是和.当两个带符号二进制数相加时,有以下4种情况.
两个数都是正的. 正数的数值大于负数的数值. 负数的数值大于正数的数值. 两个数都是负的. 这里使用 8 位带符号数,每次给出一种情况作为例子,也给出相应的十进制数作为对照
◇ 两个正数相加产生一个正数.
两个数都是正的:
和是正的,因而是二进制原码(非补码).
◇ 正数和负数相加产生一个正数.
正数的数值大于负数的数值:
最后的进位被舍去.和是正的,因而是二进制原码(非补码).
◇ 一个正数加上一个较大的负数或者两个负数相加时,生成一个补码形式的负数.
负数的数值大于正数的数值:
和是负的,所以是补码形式.
两个数都是负的:
最后的进位被舍去.和是负的,所以是补码形式.
在计算机中,负数是以补码形式保存的,所以正如所见,加法过程是很简单: 将两个数加起来,并舍去最后的任何进位.
溢出条件 当两个数加在一起,而表示和所需的位数超出了这两个数的位数,这时就会发生溢出,并由一个错误符号位指明.溢出仅发生在两个都是正数或者两个都是负数的情况下.如果相加结果得到的符号位和相加的两个数的符号不同,就表明发生了溢出.下面的 8 位数例子将说明这种情况.
在这个例子中,和 183 需要 8 个数值位.由于数中只有 7 个数值位(有一位是符号位),这时进位就会进人符号位,从而产生溢出指示.
一次加两个数 现在让我们看看数字串相加的情况,即一次加两个数.可以这样操作,首先将前两个数相加,然后两数之和加第三个数,然后再在此和的基础上加第四个数,以此类推.这就是计算机中数字串的相加方法.一次加两个数的方法如例2.19所示.
2.7.2 减法 ◇ 减法是将减数符号改变后的加法.
减法是加法的一个特例.例如,从　＋9(被减数)中减去　＋6(减数)就相当于　+9　加上　-6.基本上,减法运算是改变减数的符号然后加上被减数的运算.减法的结果称为差.
正二进制数或者负二进制数的符号通过求此数的补码而改变.
例如,求取正数　00000100 (+4)的补码时,就会得到　11111100,这就是　–4,权和的计算如下: $$ -128~+64~+32~+16~+8~+4=-4 $$ 作为另一个例子,当取负数 11101101 (-19)的补码时,就会得到 00010011,这就是＋19,权和的计算如下: $$ 16~+2~+1~=~19 $$
◇ 当用补码的方法进行二进制减法时,重要的是两个数要有相同的位数.
由于减法仅仅是减数符号改变后的加法,所以该过程有如下的表述方式:
要将两个带符号数相减,取减数的补码然后相加即可.舍去最后的任何进位.
2.7.3 乘法 乘法中的数分别是被乘数,乘数及积.</description>
    </item>
    
    <item>
      <title>2.6 带符号数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:43 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-6%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>2.6.1 符号位 二进制符号数的最左边就是符号位,指出这个数是正数还是负数.符号位 0 表示正数,1 表示负数.
2.6.2 符号数值的形式 当以符号数值的形式表示带符号二进制数时,最左边的一位是符号位,其余的都是数值位.数值位对于正数和负数来说都是二进制原码(非补码).例如,十进制数＋25表示为符号数值的形式就是一个 8 位带符号二进制数,使用符号数值的形式为
十进制数-25表示为 $$ 10011001 $$ 注意 ＋25 和 –25 之间的唯一区别是符号位,因为对于正数和负数来说,数值位都是二进制原码.
在符号数值的形式中,负数和其相应的正数具有相同的数值位,但其符号位为 1 而不是 0.
2.6.3 反码形式 以反码形式表示正数的方法和以符号数值形式表示正数的方法是一致的.但是,负数却是其相应正数的反码.例如,使用 8 位数字,十进制数 -25 可以表示为 +25(00011001) 的反码 $$ 11100110 $$ 在反码形式中,负数就是其相应正数的反码.
2.6.4 补码形式 正数的补码形式表示方法和符号数值与反码形式的表示方法是一致的.负数是相应正数的补码.再次使用 8 位数字,把十进制数 -25 表示为 +25(000011001) 的补码.按位取反再加 1,得到 $$ -25 =11100111 $$ 在补码形式中,负数是相应正数的补码.
2.6.5 带符号数的十进制值 符号数值 在符号数值的形式中,正数和负数的十进制值,是由所有数值位为 1 的相应权加起来得到的,不考虑那些为 0 的位.符号通过检查符号位来确定.
反码 在反码形式中,正数的十进制值是由所有为 1 的数值位相应的权加起来得到的,而不要考虑为 0 的位置.负数的十进制值是通过给符号位的权赋以负值,并把所有为 1 的数值位相应的权加起来再加上 1 得到的.</description>
    </item>
    
    <item>
      <title>2.5 二进制数的反码和补码</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:15 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</guid>
      <description>2.5.1 求二进制数的反码 ◇ 改变数中的每一位以得到反码.
二进制数的反码可以通过把所有的 1 变为 0 及把所有的 0 变为 1 而得到,如下所示:
利用数字电路求二进制数反码的最简单方法是使用并行反相器(&amp;ldquo;非&amp;quot;电路),如图2.1所示,用以变换8位二进制数.
2.5.2 求二进制数的补码 ◇ 反码加 1 就可以得到补码.
二进制数的补码是通过在反码的最低有效位(LSB)上加1而获得的. $$ 补码=反码+1 $$
◇ 改变最低有效1左边的全部位求得补码.
求二进制数补码的另一种替代方法如下所示:
从右边的最低有效位开始,写下它们实际的位,包括第一个 1. 剩下的位求反码. 使用反相器和加法器可以实现二进制负数的补码,如图2.2所示.该图说明了怎样把一个8位数转换为它的补码;首先每一个位取反(取得反码),然后使用加法器电路把反码加1. $$ 图2.2~~~ 获得二进制负数补码的例子 $$ 为了把反码或者补码变回二进制原码(非补码),可以应用和前面描述的一样的过程.为了从反码回到二进制数原码,可以反转所有的位.为了从补码回到二进制数原码,可以先取得补码的反码,然后在最低有效位上加 1.</description>
    </item>
    
    <item>
      <title>2.4 二进制算术</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/</link>
      <pubDate>Fri, 14 Jul 2023 19:02:06 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-4%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%9C%AF/</guid>
      <description>2.4.1 二进制加法 ◇ 在二进制中,1+1 = 10,而不是2.
二进制数(位)加法的 4 条基本规则如下:
0+0=0 和为0. 进位是0 0+1=1 和为1. 进位是0 1+0=1 和为1. 进位是0 1+1=10 和为10. 进位是1 注意: 前三条规则产生单个的位,而在第4条规则中,两个1相加生成二进制的2(10).二进制数在相加时,最后一种情况在低位的和为0,而在左边的高位产生了进位1,如下面的加法运算 11+1 所示:
在最右列中,1+1=0,因而在此列的左侧一列,即中间一列产生进位1.在中间一列中,1+1+0=0,因而在此列的左侧一列中产生进位1.在最左列中,1+0+0 =1.
当存在进位1时,就会遇到三个位进行加法的情况(两个数中的位和一个进位).这种情况如下所示: 2.4.2 二进制减法 ◇ 在二进制中,10 - 1 =1,而不是9.
二进制数(位)减法的4条基本规则如下:
0-0=0 1-1=0 1-0=1 10-1=1 0-1 产生借位1 进行减法运算时,有时必须从左边一列中借位.在二进制中,仅当0减去1时才需要借位.在这种情况下﹐从左边一列借来1,被减的列就会出现10,这时必须使用上面列出的4条基本规则中的最后一条.例2.8和例2.9说明了二进制减法,同时也给出了相应的十进制减法.
2.4.3 二进制乘法 ◇ 两位的二进制乘法和十进制数О和1的乘法相同.
位相乘的4条基本规则如下:
0 * 0 = 0 1 * 1 = 0 1 * 0 = 1 10 * 1 = 1 ~~ 0 - 1 产生借位1 二进制乘法和十进制乘法的运算方法是一样的.</description>
    </item>
    
    <item>
      <title>2.3 十进制数到二进制数的转换</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:56 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-3%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>2.3.1 权和的方法 ◇ 如果要把一个已知的十进制数转换为二进制数,只要求出二进制数的权,全部权加起来就是十进制数.
想要得到一个给定十进制数的二进制数,只要确定二进制数权的和,它们等于相应的十进制数.记住二进制权的简单方法是最低位为1,也就是$2^0$,任何一个权乘以2,就会得到下一个更高位的权,因此7个二进制权的序列就是64,32,16,8,4,2,l,这和上一节学到的一样.例如,十进制数9就可以由二进制权的和表示如下: $$ 9=8+1或者9=2^3＋2^0 $$ 把1放在适当的权的位置上,即 $2^3$ 和 $2^0$,把0放在 $2^2$ 和 $2^1$ 的位置上,就确定了十进制数9.
2^3 2^2 2^1 2^0 1 0 0 1 十进制数9的二进制数表达
2.3.2 重复除以2的方法 ◇要得到一个给定十进制数的二进制数,可以用2除这个十进制数直至商为0,每次余数的全部便构成了二进制数.
将十进制整数转换为二进制数的系统方法是重复除以2的过程.例如,把十进制数12转换为二进制数,首先12除以2.然后把每次得到的商都除以2,直到商为0.每次相除所得到的余数就构成了二进制数.第一个得到的余数是二进制数中的最低有效位(ISB),最后一个产生的余数是最高有效位(MSB).将十进制数12转换为二进制数的过程由下列步骤给出. 2.3.3 十进制小数转换为二进制数 例2.5和例2.6给出了整数的转换,现在来看小数的转换.记住小数二进制权的一个简单的方法是最高有效权是0.5,也就是$2^{-1}$,任何一个权除以2,就得到次低位的权;因此4个小数的二进制权的序列就是0.5, 0.25, 0.125,0.0625.
权和 权和的方法可以应用于十进制小数,如以下的例子所示: $$ 0.625= 0.5 +0.125 = 2^{-1} + 2^{-3} =0.101 $$
在$2^{-1}$位置上有一个1,在 $2^{-2}$ 位置上有一个0,而在$2^{-3}$位置上有一个1.
重复乘2 正如所见,可以用重复除以 2 的方法把十进制整数转换为二进制数.二进制小数则可以用重复乘2的方法转换得到.例如,把十进制小数 0.3125 转换为二进制数,首先把 0.3125 乘以 2,然后把每次乘积的小数部分乘以 2,直到乘积的小数部分为 0,或者达到了所需要的小数位数. 由相乘产生的进位数字或者进位,就生成了二进制数. 所产生的第一个进位是最高有效位(MSB),最后一个进位是最低有效位(LSB).该过程如下所示: </description>
    </item>
    
    <item>
      <title>2.2 二进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:45 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>2.2.1 二进制计数 ◇ 二进制数字系统有两个数字(位).
下面学习二进制系统的计数方法.首先看一下十进制系统的计数方法.在用完数字之前,从О开始,依次计数到9.然后从另一个数位开始(左边),继续从10计数到99.此时已经用完了两位数字的所有组合,所以需要第三个数位,从100计数到999.
二进制数在计数时,也会发生类似的情况,只是这时只有两个数字,称为位(比特).开始计数:0,1.此时,已经使用了两个数字,所以加入另一个数位继续计数:10,11.至此,已经使用了两个数字的所有组合,所以需要第3个数位.使用3个数位,可以继续计数:100,101,110,111.还要继续下去,就需要第4个数位,以此类推.从0到15的二进制计数方法如表2.1所示.注意在每一列中1和0的交替规律.
◇ 二进制数字系统的基为2.
如表2.1所示,从О计数到15需要4个数位.一般来说,对于 n 个数位,可以计数到2^n-1. $$最大十进制数=2^n-1$$ 例如,若有5个数位(n =5),就可以从0计数到31. $$2^5-1= 32-1 = 31$$ 若有6个数位(n =6),就可以从О计数到63. $$2^6-1=64-1 =63$$
◇ 一个数中位的值由它在此数的位置确定.
10进制数字 2进制数字 0 0 0 0 0 1 0 0 0 1 2 0 0 1 0 3 0 0 1 1 4 0 1 0 0 5 0 1 0 1 6 0 1 1 0 7 0 1 1 1 8 1 0 0 0 9 1 0 0 1 10 1 0 1 0 11 1 0 1 1 12 1 1 0 0 13 1 1 0 1 14 1 1 1 0 15 1 1 1 1 2.</description>
    </item>
    
    <item>
      <title>2.1 十进制数</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:36 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2-1%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>十进制数字系统有10个数字.
在十进制数字系统中,10个数字中的每一个数字(从0到9)都表示某个数量.这10个符号(数字)并没有限制仅仅表示10个不同的数字量,因为可以在数字量相应的位置上分别使用这10个不同数字来表示这个数字量的大小.这10个数字的每一个最多可以从0到9表示10个数字.如果想要表示一个比9大的数字量,可以使用两个或者更多的数字位,而每一个数字所处的位置表示了这一位的大小.例如,想要表示23这个数字量,可以使用(根据它们在该数字量中相应的位置)数字2表示20这个数字量,用数字3表示3这个数字量,如下所示. 十进制数字系统的基为10.
十进制数中每一个数字所在的位置表示了这一位的大小,称之为权.整数的权是10的正次幂,从右向左递增,开始于 $10^0$= 1. $$ &amp;hellip;10^5\ 10^4\ 10^3\ 10^2\ 10^1\ 10^0 $$ 对于小数,权是10的负次幂,从左向右递减,开始于$10^{-1}$. $$ 10^2\ 10^1\ 10^0.10^{-1}\ 10^{-2}\ 10^{-3}&amp;hellip;\ \\ \\ 个-小数点 $$
数字的值取决于它在数中的位置.
十进制数的值等于每个数字乘以相应位置上的权之后的和.</description>
    </item>
    
    <item>
      <title>1.3 固定功能的集成电路</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:23 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-3%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</guid>
      <description>单片集成电路(IC)是一个完全由单个小型的硅芯片组成的电子电路.组成电路的所有元件-晶体管,二极管,电阻和电容是单个芯片的一部分.固定功能的逻辑和可编程的逻辑是数字集成电路的两大类型.在固定逻辑功能的芯片中,逻辑功能已由开发商写入,不能改变. $$ 图1.15一个固定功能集成芯片封装类型的剖面图(双引线封装),给出了芯片的内部连接输入/输出引脚的封装部分 $$ 图1.15给出了一个固定功能集成芯片封装类型的剖面图,其中露出了封装内部的芯片电路,标出了芯片连接封装引脚用以连接外部的各种电路.
1.3.1 集成电路封装 $$ (a)双引线封装(DIP) $$ 集成电路封装以它们安装在印制电路板(PCB)上的方法来分类,例如对穿孔封装和表面贴装等类型.对穿孔封装类型的引脚通过穿孔插入印制电路板,以便可以和另一边的导体焊接.最为普通的对穿孔封装是双引线封装(DIP),如图1.16( a)所示.
另一种集成电路封装的类型是使用表面贴装技术(SMT).表面贴装相对于对穿孔封装节省空间.通过印制电路板的孔对于表面贴装技术是多余的.表面贴装的引脚直接焊接在印制电路板一面的导体上,留出另一面用于附加的电路.其次,对于有相同引脚数的电路,表面贴装与双引线封装相比尺寸更小,因为表面贴装的引脚分布更紧凑.一个表面贴装的例子就是小轮廓集成电路(SOIC),如图1.16(b)所示.
$$(b)小轮廓集成电路(SOIC)$$ $$图1.16对穿孔和表面贴装芯片的例子.相同引脚数的 DIP比 SOIC的尺寸大, DIP大约为0.785英寸①长 , SOIC大约为0.385英寸长$$
在一种尺寸范围内可用的表面贴装技术的不同类型,取决于引脚数(越复杂的电路和引线配置需要更多的引脚).图1.17给出了几种类型的例子.如图所见,收缩小轮廓封装( SSOP )的引脚形成鸥翼式形状.带引线的塑料芯片载体( PLCC )的引脚在封装下以J形翻转.无引线陶瓷芯片( LCC )具有金属接触面,焊接在它的陶瓷体上.薄型四侧引脚扁平封装( LQFP )也具有鸥翼式形状的引脚.片状刻度封装( CSP )和精密间距球形网格阵列( FBGA )的引脚嵌入在封装的底部相互接触. $$ 图1.17SMT封装配置,(e)和(f)给出的是底视图 $$
1.3.2 引脚编号 所有集成电路的封装都具有一个标准形式的引脚编号.双引线封装(DIP)和收缩小轮廓封装(SSOP)的引脚都具有一定的编号排列方式,如图1.18( a)的16个引脚封装的芯片所示.观察芯片封装的顶部,引脚1有一个标识,可以是一个小圆点,一个缺口或是一个斜角边.小圆点总是紧靠着引脚1.同样,缺口方向朝上,引脚1总是在左上角的位置,如图所示.从引脚1开始,逐步向下引脚编号递增,然后跨越芯片在另一边编号向上递增.最大的引脚编号总是在缺口的右边小圆点对面的位置. $$ 图1.18集成电路封装引脚的标准类型.给出的是顶视图 $$ 带引线的塑料芯片载体(PLCC)封装和无引线陶瓷芯片(LCC)封装在全部的4个边上都具有引脚.引脚1由一个小圆点标记,或由其他的索引标记,它处于一边的中心位置.引脚的编号沿逆时针递增,图中看到的是封装顶部的视图.最大的引脚编号总是处于引脚1的右边.图1.18(b)给出了20个引脚的PLCC封装芯片的引脚分布.</description>
    </item>
    
    <item>
      <title>1.2 二进制数,逻辑电平和数字波形</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/</link>
      <pubDate>Fri, 14 Jul 2023 19:01:12 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E5%92%8C%E6%95%B0%E5%AD%97%E6%B3%A2%E5%BD%A2/</guid>
      <description>1.2.1 二进制数 二进制系统中的两个数——1和0,称为位(比特,bit),是二进制数(binary digit)的缩写.在数字电路中,使用两个不同的电压电平表示这两个位.一般情况下,高电压用1来表示,低电压用0来表示.这称为正逻辑,本书将都使用正逻辑. $$ 高电压(H)=1低电压(L)=0 $$ 在另一种系统中,1表示低电压,0表示高电压,这称为负逻辑. 一组位(一些1和0的组合)称为码,用来表示数字,字母,符号,指令及任何给定应用中的对象.
1.2.2 逻辑电平 用来表示1和0的电压称为逻辑电平.理想情况下,一个电平表示高电压,另一个电平表示低电压.在实际的数字电路中,这个高电压可以是指定的最小值和最大值之间的任意值.同样,低电压也可以是指定的最小值和最大值之间的任意值.在指定的高电平范围和低电平范围之间是不能有重叠的.
图1.5给出了数字电路中高电平和低电平的通常范围.变量 $V_{H(max)}$ 表示高电平的最大值,变量 $V_{H(min)}$ 表示高电平的最小值.$V_{L(max)}$ 表示低电平的最大值,$V_{L(min)}$ 表示低电平的最小值.在正常的工作情况下,$V_{L(max)}$ 和 $V_{H(min)}$ 之间的电压值是不可以出现的.对于一个给定的电路,在此范围内的电压既可以是高电平,也可以是低电平.例如,在CMOS 数字电路中,高电平值在2~3.3 V,低电平压值在0~0.8 V,也就是说,如果使用2.5 V,电路将把它看成是高电平或二进制1.如果使用0.5 V,那么就是低电平或二进制0.对于这种类型的电路,0.8~2 V的电平值是不可以出现的.
1.2.3 数字波形 数字波形由两种不同的电平值组合而成,它们在高,低电平或状态之间不断地变化.图1.6(a)给出一个正向脉冲,是在电压(或电流)从低电平变到高电平,再从高电平变回到低电平时产生的.图1.6(b)给出一个反向脉冲,是在电压从高电平变到低电平,再从低电平变回到高电平时产生的.数字波形由这一系列的脉冲组成. 脉冲 如图1.6所示,脉冲有两个边沿:在t时刻首先出现的为前沿,在t,时刻随后出现的为后沿.对于一个正向脉冲,前沿是上升沿,后沿是下降沿.图1.6所示的脉冲是理想状态下的脉冲,因为假设上升沿和下降沿的变化是没有时间范围的(瞬间).实际情况是,这些变化是有时间范围的,尽管大多数的数字波形可以假定为理想脉冲.
图1.7给出了一个非理想的脉冲.实际上,所有脉冲或多或少都存在这些非理想的特性.通常,杂散电感和电容效应会产生超调量和振荡.杂散电容和电路电阻会产生下调量,形成时间常数不大的RC电路. $$ 图1.7非理想脉冲的特性 $$
从低电平到高电平所需的时间称为上升时间t,,从高电平到低电平所需的时间称为下降时间t.在实际运用中,通常测量的上升时间是从脉冲幅度(相对于基线的高度)的10%处到脉冲幅度的90%处的时间宽度,测量的下降时间则是从幅度的90%处到幅度的10%处的时间宽度.如图1.7所示,上升时间和下降时间不包括脉冲顶部和底部的10% ,因为这部分区域的波形是非线性的.脉冲的宽度tw就是脉冲的持续时间,通常把上升沿和下降沿幅度50%处的时间间隔定义为脉冲宽度,如图1.7所示.
波形特性 在数字系统里,遇到的大多数波形都是由一系列的脉冲组成的,有时称为脉冲序列,它们可以分为周期的和非周期的.周期波形就是在一个固定的时间间隔里不断重复自身,这个时间间隔称为周期( $T$ ).频率( $f$ )是重复的速率,测量单位是赫兹( $Hz$ ).而一个非周期性脉冲波形则不会在一个固定的时间间隔里重复,它可能由脉冲宽度不确定的脉冲组成,也有可能由时间间隔不确定的脉冲组成,图1.8给出两种波形的例子.
$$ (a)周期(方波) $$ $$ (b)非周期 $$ 脉冲(数字)波形的频率(f)就是其周期(T)的倒数,它们之间的关系如下所示: $$ (1.1) f = \frac{1}{T} $$ $$ (1.2) T = \frac{1}{f} $$ 周期数字波形的一个重要特性就是它的占空比,它是脉冲宽度( $t_w$ )和周期( $T$ )的比值,可以用百分比来表示 $$ (1.</description>
    </item>
    
    <item>
      <title>1.1 数字量与模拟量</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/</link>
      <pubDate>Fri, 14 Jul 2023 18:57:32 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1-1%E6%95%B0%E5%AD%97%E9%87%8F%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%87%8F/</guid>
      <description>模拟量具有连续的数值,数字量具有离散的数值.自然界中大多数可以测量的事物都以模拟量的形式出现.例如,空气温度在一个连续的范围内变化.在给定的一天里,温度不会立即从70°F下上升到71°F;这中间经历无数个温度值.如果绘制一个典型的夏季温度图,将会得到一个平滑和连续的曲线(类似于图1.1的曲线).其他模拟量的例子是时间,压力,距离和声音.
相对于一个连续的温度图,假设每小时测量一次温度.现在有一个24小时内每隔一小时采样测量到的离散温度值,如图1.2所示,这样就可以有效地将模拟量转换成数字量的形式,即用一个个数字码对应于每个采样到的温度值.注意,图1.2本身并不是模拟量的数字表示.
数字量的优点,在电学应用方面,数字量表示法和模拟量表示法相比有一定的优势.其,数字数据和模拟数据相比,前者在处理和传输方面更有效,更可靠.其二,数字数据在需要保存时,更显示了它的优越性.例如,转换成数字形式的音乐,要比相对应的模拟形式更简洁,复制时更精确,更清晰.噪声(不需要的电压波动)几乎不会影响数字数据,但会影响模拟信号.
1.1.1 模拟电子系统 扩音系统用于把声音放大,从而让更多的听众听到,这是模拟电子应用的一个简单例子.图1.3的基本图示给出了自然界中的模拟量,即声波,它由麦克风接收,并将其转换为较弱的模拟电压,称为声频信号.这个电压随着声波的音量大小和频率变化而连续变化,随即加到线性放大器的输入中.放大器的输出,也就是放大的输入电压,随即传人扬声器.扬声器将放大的音频信号再变回声波,而这时的声波音量比话简接收到的原始声波的音量大很多.</description>
    </item>
    
    <item>
      <title>数字电子技术</title>
      <link>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 12 Jul 2023 21:20:25 +0800</pubDate>
      
      <guid>https://okokfun.github.io/post/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</guid>
      <description>第1章 基本概念 1.1 数字量与模拟量 1.2 二进制数、逻辑电平和数字波形 1.3 固定功能的集成电路 关键词 判断题 自测题 习题 答案
第2章 数字系统、运算和编码 2.1 十进制数 2.2 二进制数 2.3 十进制数到二进制数的转换 2.4 二进制算术 2.5 二进制数的反码和补码 2.6 带符号数 2.7 带符号数的算术运算 2.8 十六进制数 2.9 八进制数 2.10 二—十进制编码(BCD) 2.11 数字编码 2.12 错误检测码 关键词 判断题 自测题 习题 答案
第3章 逻辑门 3.1 反相器 3.2 与门 3.3 或门 3.4 与非门 3.5 或非门 3.6 异或门和同或门 3.7 固定功能逻辑 关键词 判断题 自测题 习题 答案
第4章 布尔代数和逻辑化简 4.1 布尔运算和表达式 4.</description>
    </item>
    
  </channel>
</rss>
