<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43;11 - Tag - My Blog</title>
        <link>https://okokfun.github.io/tags/c&#43;&#43;11/</link>
        <description>C&#43;&#43;11 - Tag - My Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Feb 2022 21:27:50 &#43;0000</lastBuildDate><atom:link href="https://okokfun.github.io/tags/c&#43;&#43;11/" rel="self" type="application/rss+xml" /><item>
    <title>ËÆ©C&#43;&#43;Á®ãÂ∫èÊõ¥Âø´ÁöÑËøêË°å</title>
    <link>https://okokfun.github.io/posts/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</link>
    <pubDate>Sun, 06 Feb 2022 21:27:50 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/%E8%AE%A9c-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</guid>
    <description><![CDATA[ËßÜÈ¢ëÁî±upÁ•ûÁªèÂÖÉÁå´ Á•ûÁªèÂÖÉÁå´ÁöÑ‰∏™‰∫∫Á©∫Èó¥_ÂìîÂì©ÂìîÂì©_bilibili ÁøªËØëËá™ youtube.com/cherno Âπ∂ÂèëÂ∏ÉÂà∞üëâ „Äê79„Äë„ÄêCherno C++„Äë„Äê‰∏≠Â≠ó„ÄëÂ¶Ç‰ΩïËÆ©C++ËøêË°åÂæóÊõ¥Âø´_ÂìîÂì©ÂìîÂì©_bilibili Âπ∂Áî±ÊàëÊï¥ÁêÜ„ÄÇ
ÈÄöËøáÁºñÁ†ÅÊñπÂºèÂà©Áî®Â§öÊ†∏ÊàñÂ§öÂ§ÑÁêÜÂô® ,Âà©Áî®Ëøô‰∫õÁ∫øÁ®ãÔºå‰∏çÂè™ÊòØËÆ©‰Ω†ÁöÑÁ®ãÂ∫èÈ°∫Â∫èÊâßË°å‰∏ÄÊù°Êù°Êåá‰ª§ÔºåËÄåÊòØÊää‰∏Ä‰∫õ‰∏úË•øÔºåÊé®ËøüÂà∞‰∏çÂêåÁöÑÁ∫øÁ®ãÔºåÁîöËá≥‰∏çÊòØÊé®ËøüÔºå‰∫åÂçÅÊää‰∏úË•øÂàÜÊ¥æÂà∞‰∏çÂêåÁöÑÁ∫øÁ®ãÔºåËÆ©ËÆ°ÁÆóÊú∫Êõ¥Âø´Âú∞Â§ÑÁêÜËøô‰∫õ‰∏úË•ø„ÄÇ
ÊØè‰∏Ä‰∏™ËµÑÊ∫êÔºåÊØè‰∏Ä‰∏™Á∫πÁêÜÊ®°ÂûãÔºå‰ªñ‰ª¨ÈÄöÂ∏∏Áã¨Á´ã‰∫éÂΩºÊ≠§ÔºåÊÑèÂë≥ÁùÄËøôÊòØËâØÂ•ΩÁöÑÂ§öÁ∫øÁ®ãÂÄôÈÄâÂú∫ÊôØ„ÄÇ
static std::mutex s_MeshesMutex; static void LoadMesh(std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard&lt;std::mutex&gt; lock(s_MeshesMutex); meshes.push_back(mesh); } void EditLayer::LoadMeshes() { std::ifstream stream(&#34;src/Models.txt&#34;); std::string line; std::vector&lt;std::string&gt; meshFilepaths; while (std::getline(stream, line)) meshFilepaths.push_back(line); #define ASYNC 1 #id ASYNC for (const auto&amp; file : meshFilepaths) // std::launch::asyncÂëäÁü•stdÂ∫ìÂàõÂª∫‰∏Ä‰∏™Á∫øÁ®ãÂ§ÑÁêÜ„ÄÇ // Êàë‰ª¨ÈúÄË¶Å‰øùÁïôstd::asyncÁöÑËøîÂõûÂÄºÔºåÂ¶ÇÊûú‰∏ç‰øùÁïôÁöÑËØùÔºåÂõ†‰∏∫ÂÆÉ‰ºöË¢´C++Ê†áÂáÜÂ∫ìÊëßÊØÅÔºåÂú®ÊëßÊØÅÊó∂ÔºåÊ†áÂáÜÂ∫ìÈúÄË¶ÅÁ°Æ‰øùËøáÁ®ãÂÆûÈôÖÂ∑≤Ë¢´ÂÆåÊàêÔºåËøôÂü∫Êú¨‰∏çÊòØÂπ∂Ë°å‰∫ÜÔºåÊâÄ‰ª•ÈúÄË¶ÅÂàõÂª∫‰∏Ä‰∏™std::futureÁöÑÂêëÈáè„ÄÇ m_Futures.push_back(std::async(std::launch::async, LoadMesh, &amp;m_Meshes, file)); #else for (const auto&amp; file : meshFilepaths) m_Meshes.push_back(Mesh::Load(file)); } std::vector&lt;std::future&lt;void&gt; m_Meshes; ÈÄöËøáÊää‰ªªÂä°ÂàÜÊ¥æÁöÑ‰∏çÂêåÁöÑÁ∫øÁ®ãÔºåËµÑÊ∫êÂä†ËΩΩÈÄüÂ∫¶Áî±6.]]></description>
</item>
<item>
    <title>C&#43;&#43;ÂÖÉÁªÑ‰∏éÂØπÁªÑ</title>
    <link>https://okokfun.github.io/posts/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/</link>
    <pubDate>Sat, 29 Jan 2022 17:41:10 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/c-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/</guid>
    <description><![CDATA[Êù•Ëá™‰∫éüëâ tuple - C++ Reference (cplusplus.com) Âπ∂Êï¥ÁêÜ
‰∏Ä‰∏™ÂÖÉÁªÑstd::tupleÊòØ‰∏Ä‰∏™ËÉΩÂ§üÂÆπÁ∫≥ ÂÖÉÁ¥†ÈõÜÂêà ÁöÑÂØπË±°„ÄÇÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÂèØ‰ª•ÊòØ ‰∏çÂêåÁöÑÁ±ªÂûã„ÄÇ
std::make_pair()ÂèØ‰ª•ÊûÑÂª∫‰∏Ä‰∏™ÈÖçÂØπÂØπË±°ÔºåÂÖ∂Á¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ËÆæÁΩÆ‰∏∫xÔºåÁ¨¨‰∫å‰∏™ÂÖÉÁ¥†ËÆæÁΩÆ‰∏∫yÔºåÂπ∂ËøîÂõû„ÄÇ
std::tieÂèØ‰ª•ÁªëÂÆöstd::tuple&lt;T,T,T,...&gt;ÁöÑÂÆû‰æãÔºåÂπ∂ÂàÜÂà´ÁªôËøô‰∫õÂÖÉÁ¥†Ëµ∑Âà´Âêç
std::tuple ÊâÄÂú®Â§¥Êñá‰ª∂ &lt;tuple&gt;
‰æãÂ≠êÔºö
// tuple example #include &lt;iostream&gt; // std::cout #include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignore int main () { std::tuple&lt;int,char&gt; foo (10,&#39;x&#39;); auto bar = std::make_tuple (&#34;test&#34;, 3.1, 14, &#39;y&#39;); std::cout &lt;&lt; &#34;bar has &#34;&lt;&lt;std::tuple_size&lt;decltype(bar)&gt;::value &lt;&lt; elements&lt;&lt; &#39;\n&#39;; std::tuple_element&lt;0,decltype(bar)&gt;::type first = std::get&lt;0&gt;(bar); std::cout &lt;&lt; &#34;bar contains: &#34; &lt;&lt; first &lt;&lt; &#39;\n&#39;; std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; &#34;foo contains: &#34;; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; &#39; &#39;; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; &#39;\n&#39;; return 0; } Á≠îÊ°àÔºö]]></description>
</item>
<item>
    <title>C&#43;&#43;Êñ∞ÁâπÊÄß</title>
    <link>https://okokfun.github.io/posts/c-%E6%96%B0%E7%89%B9%E6%80%A7/</link>
    <pubDate>Mon, 24 Jan 2022 17:02:47 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/c-%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
    <description><![CDATA[1. Variadic Templates Êï∞Èáè‰∏çÂÆöÁöÑÊ®°ÊùøÂèÇÊï∞
...‰ª£Ë°®‰ªªÊÑè‰∏™Êï∞ÊçÆ
void print(){} template &lt;typename T, typename... Types&gt; void print(const T&amp; firstArg, const Types&amp;...args) { std::cout &lt;&lt; firstArg &lt;&lt; &#39;\n&#39;; print(args...); } void print(const T&amp; firstArg, const Types&amp;...args){}‰∏≠...‰ª£Ë°®‰ªªÊÑè‰∏™Êï∞ÊçÆÔºåTypes‰ªªÊÑèÁ±ªÂûãÁöÑÊï∞ÊçÆ,
Ë°®Á§∫Êé•Âèó‰ªªÊÑè‰∏™‰ªªÊÑèÁ±ªÂûãÁöÑÊï∞ÊçÆ
‰æãÂ≠êÔºö
#include &lt;iostream&gt; #include &lt;bitset&gt; void print() {} template &lt;typename T, typename... Types&gt; void print(const T &amp;firstArg, const Types &amp;...args) { std::cout &lt;&lt; firstArg &lt;&lt; &#39;\n&#39;; print(args...); } int main(int argc, char *argv[]) { print(7.5, &#34;hello&#34;, std::bitset&lt;16&gt;(377), 42); return 0; } ÁªìÊûúÔºö]]></description>
</item>
<item>
    <title>C&#43;&#43;Á∫øÁ®ãÊ±†</title>
    <link>https://okokfun.github.io/posts/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
    <pubDate>Fri, 24 Dec 2021 17:01:29 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
    <description><![CDATA[C++Á∫øÁ®ãÊ±† ‰ªªÂä°Á±ª #pragma once #include &lt;mutex&gt; #include &lt;queue&gt; // ÂÆö‰πâ‰ªªÂä°ÁªìÊûÑ‰Ωì using callback = void (*)(void *); struct Task { Task() { this-&gt;function = nullptr; this-&gt;arg = nullptr; } Task(callback f, void *arg) { this-&gt;function = f; this-&gt;arg = arg; } callback function; void *arg; }; class TaskQueue { public: TaskQueue(); ~TaskQueue(); // Ê∑ªÂä†‰ªªÂä° void addTask(Task task); void addTask(callback f, void *arg); // ÂèñÂá∫‰∏Ä‰∏™‰ªªÂä° Task getTask(); // Âà§Êñ≠ÈòüÂàó‰ªªÂä°ÊòØÂê¶‰∏∫Á©∫ inline bool empty() { return m_taskQ.]]></description>
</item>
</channel>
</rss>
