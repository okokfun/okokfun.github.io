<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Template - Tag - My Blog</title>
        <link>https://okokfun.github.io/tags/template/</link>
        <description>Template - Tag - My Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 19 Mar 2022 00:01:14 &#43;0000</lastBuildDate><atom:link href="https://okokfun.github.io/tags/template/" rel="self" type="application/rss+xml" /><item>
    <title>第二部分-模板特性</title>
    <link>https://okokfun.github.io/posts/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/</link>
    <pubDate>Sat, 19 Mar 2022 00:01:14 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/</guid>
    <description><![CDATA[第二部分: 模板特性 9 类模板参数推导 C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：
std::complex&lt;double&gt; c{5.1,3.3}; 也不能忽略第二次的std::mutex：
std::mutex mx; std::lock_guard&lt;std::mutex&gt; lg(mx); C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。
比如：
你可以这样声明： std::complex c{5.1,3.3}; // 好的：推断出 std::complex&lt;double&gt; 你可以这样实现： std::mutex mx; std::lock_guard lg{mx}; // OK: 推断出 std::lock_guard&lt;std_mutex&gt; 你甚至可以让容器推导其元素的类型： std::vector v1 {1, 2, 3} // OK: 推断出 std::vector&lt;int&gt; std::vector v2 {&#34;hello&#34;, &#34;world&#34;}; // OK: 推断出 std::vector&lt;const char*&gt; 9.1 类模板参数推导的使用 只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：
std::complex c1{1.1, 2.2}; // 推断出 std::complex&lt;double&gt; std::complex c2(2.2, 3.3); // 推断出 std::complex&lt;double&gt; std::complex c3 = 3.3; // 推断出 std::complex&lt;double&gt; std::complex c4 = {4.]]></description>
</item>
<item>
    <title>模板</title>
    <link>https://okokfun.github.io/posts/%E6%A8%A1%E6%9D%BF/</link>
    <pubDate>Sun, 23 Jan 2022 19:49:07 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/%E6%A8%A1%E6%9D%BF/</guid>
    <description><![CDATA[本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用
1 模板 1.1 模板的概念 模板就是建立通用的模具，大大提高复用性
模板的特点：
模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板
C++提供两种模板机制:函数模板和类模板
1.2.1 函数模板语法 函数模板作用：
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。
语法：
template&lt;typename T&gt; 函数声明或定义 解释：
template &mdash; 声明创建模板
typename &mdash; 表面其后面的符号是一种数据类型，可以用class代替
T &mdash; 通用的数据类型，名称可以替换，通常为大写字母
示例：
//交换整型函数 void swapInt(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp; } //交换浮点型函数 void swapDouble(double&amp; a, double&amp; b) { double temp = a; a = b; b = temp; } //利用模板提供通用的交换函数 template&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &#34;a = &#34; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &#34;b = &#34; &lt;&lt; b &lt;&lt; endl; } int main() { test01(); system(&#34;pause&#34;); return 0; } 总结：]]></description>
</item>
</channel>
</rss>
