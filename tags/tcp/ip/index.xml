<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>TCP/IP - Tag - My Blog</title>
        <link>https://okokfun.github.io/tags/tcp/ip/</link>
        <description>TCP/IP - Tag - My Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://okokfun.github.io/tags/tcp/ip/" rel="self" type="application/rss+xml" /><item>
    <title>cpr请求库</title>
    <link>https://okokfun.github.io/posts/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/</link>
    <pubDate>Thu, 13 Jan 2022 20:43:31 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/cpr-http%E8%AF%B7%E6%B1%82%E5%BA%93/</guid>
    <description><![CDATA[本文介绍的HTTP库👉libcpr/cpr: C++ Requests: Curl for People, a spiritual port of Python Requests. (github.com)
HttpServer Url Url url{server-&gt;GetBaseUrl() + &#34;/hello.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/basic.json&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/error.html&#34;}; Url url{&#34;http://bad_host/&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/basic_cookies.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/empty_cookies.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/check_cookies.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/v1_cookies.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/check_v1_cookies.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/basic_auth.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/bearer_token.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/digest_auth.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/header_reflect.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/temporary_redirect.html&#34;}; Url url{server-&gt;GetBaseUrl() + &#34;/permanent_redirect.]]></description>
</item>
<item>
    <title>Socket_Cpp库的使用</title>
    <link>https://okokfun.github.io/posts/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
    <pubDate>Thu, 13 Jan 2022 20:28:16 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://okokfun.github.io/posts/socket_cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
    <description><![CDATA[传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
此库是一个简单的TCP库👉sockpp
TCP TCP Clien IPV4:tcp_clien sockpp::socket_initializer sockpp环境初始化 sockpp::tcp_connector conn({host, port}) // 初始化一个连接器，并尝试连接到{host, port} !conn.read_timeout(seconds(5)) // 读超时 conn.address() // 连接成功打印地址 conn.connect(sockpp::inet_address(&#34;localhost&#34;, port)) // 链接{localhost, port} sockpp::inet_address(host, port) // 返回一个默认的端口号和地址 conn.clone() // clone一个sockpp::tcp_socket conn.last_error_str() // 返回根据平台各自的错误字符串 conn.last_error() conn.write(s) // 通过coon把字符串s写过去 conn.write_n(buf, n) // 从buf中取n个字节的数据并通过tcp写过去 conn.read(buf, sizeof(buf))) // 读sizeof(buf)个字节到buf中，并返回读到的字节数 conn.read_n() // conn.address() // 服务器的地址 conn.peer_address() conn.shutdown(SHUT_WR) 例子- 单线程
#include &lt;iostream&gt; #include &lt;string&gt; #include &#34;sockpp/tcp_connector.h&#34; #include &#34;sockpp/version.h&#34; using namespace std; using namespace std::chrono; int main(int argc, char* argv[]) { cout &lt;&lt; &#34;Sample TCP echo client for &#39;sockpp&#39; &#34; &lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; &#39;\n&#39; &lt;&lt; endl; string host = (argc &gt; 1) ?]]></description>
</item>
</channel>
</rss>
